var CalendarPreferences = CalendarPreferences || {};
if (!CalendarPreferences.controller) CalendarPreferences.controller = {};
if (!CalendarPreferences.store) CalendarPreferences.store = {};
if (!CalendarPreferences.view) CalendarPreferences.view = {};
var Ext = Ext || {};
if (!Ext.Toolbar) Ext.Toolbar = {};
if (!Ext.app) Ext.app = {};
if (!Ext.app.domain) Ext.app.domain = {};
if (!Ext.button) Ext.button = {};
if (!Ext.container) Ext.container = {};
if (!Ext.core) Ext.core = {};
if (!Ext.data) Ext.data = {};
if (!Ext.data.association) Ext.data.association = {};
if (!Ext.data.flash) Ext.data.flash = {};
if (!Ext.data.proxy) Ext.data.proxy = {};
if (!Ext.data.reader) Ext.data.reader = {};
if (!Ext.data.writer) Ext.data.writer = {};
if (!Ext.dd) Ext.dd = {};
if (!Ext.dom) Ext.dom = {};
if (!Ext.draw) Ext.draw = {};
if (!Ext.form) Ext.form = {};
if (!Ext.form.Action) Ext.form.Action = {};
if (!Ext.form.action) Ext.form.action = {};
if (!Ext.form.field) Ext.form.field = {};
if (!Ext.fx) Ext.fx = {};
if (!Ext.fx.target) Ext.fx.target = {};
if (!Ext.grid) Ext.grid = {};
if (!Ext.grid.column) Ext.grid.column = {};
if (!Ext.grid.header) Ext.grid.header = {};
if (!Ext.grid.locking) Ext.grid.locking = {};
if (!Ext.grid.plugin) Ext.grid.plugin = {};
if (!Ext.layout) Ext.layout = {};
if (!Ext.layout.boxOverflow) Ext.layout.boxOverflow = {};
if (!Ext.layout.component) Ext.layout.component = {};
if (!Ext.layout.component.field) Ext.layout.component.field = {};
if (!Ext.layout.container) Ext.layout.container = {};
if (!Ext.layout.container.border) Ext.layout.container.border = {};
if (!Ext.layout.container.boxOverflow) Ext.layout.container.boxOverflow = {};
if (!Ext.list) Ext.list = {};
if (!Ext.menu) Ext.menu = {};
if (!Ext.panel) Ext.panel = {};
if (!Ext.perf) Ext.perf = {};
if (!Ext.resizer) Ext.resizer = {};
if (!Ext.selection) Ext.selection = {};
if (!Ext.state) Ext.state = {};
if (!Ext.tip) Ext.tip = {};
if (!Ext.toolbar) Ext.toolbar = {};
if (!Ext.util) Ext.util = {};
if (!Ext.ux) Ext.ux = {};
if (!Ext.ux.form) Ext.ux.form = {};
if (!Ext.ux.form.field) Ext.ux.form.field = {};
if (!Ext.ux.layout) Ext.ux.layout = {};
if (!Ext.ux.layout.component) Ext.ux.layout.component = {};
if (!Ext.ux.layout.component.field) Ext.ux.layout.component.field = {};
if (!Ext.view) Ext.view = {};
if (!Ext.window) Ext.window = {};
var Override = Override || {};
var Sch = Sch || {};
if (!Sch.locale) Sch.locale = {};
if (!Sch.mixin) Sch.mixin = {};
if (!Sch.model) Sch.model = {};
if (!Sch.util) Sch.util = {};
var Sdc = Sdc || {};
if (!Sdc.controller) Sdc.controller = {};
if (!Sdc.data) Sdc.data = {};
if (!Sdc.data.mixin) Sdc.data.mixin = {};
if (!Sdc.locale) Sdc.locale = {};
if (!Sdc.model) Sdc.model = {};
if (!Sdc.util) Sdc.util = {};
if (!Sdc.ux) Sdc.ux = {};
/* 
 * Helper code for compiler optimization
 */

//@tag compiler-helpers



(function(ExtCmd) {
  var baseStaticMembers = [], enumerables = ['constructor', 'toString', 'valueOf', 'toLocaleString'], enumerablesMap = {}, enumerablesObj = {}, enumerablesMask = 0, baseStaticMember, Base, ClassManager, applyConfig, thunk = function() {
  var i, mask;
  Base = Ext.Base;
  ClassManager = Ext.ClassManager;
  for (i = enumerables.length; i-- > 0; ) 
    {
      mask = (1 << i);
      enumerablesObj[enumerablesMap[mask] = enumerables[i]] = mask;
    }
  for (i in enumerablesObj) 
    {
      enumerablesMask |= enumerablesObj[i];
    }
  enumerablesMask = ~enumerablesMask;
  Function.prototype.$isFunction = 1;
  applyConfig = Ext.Class.getPreprocessor('config').fn;
  for (baseStaticMember in Base) 
    {
      if (Base.hasOwnProperty(baseStaticMember)) 
      {
        baseStaticMembers.push(baseStaticMember);
      }
    }
  ExtCmd.derive = derive;
  return derive.apply(this, arguments);
}, onBeforeCreated = function(cls, data, hooks) {
  var enumerableMembers = hooks.enumerableMembers, proto = cls.prototype, member, fn, which, val;
  if (!data) 
  {
    return;
  }
  for (member in data) 
    {
      val = data[member];
      if (val && val.$isFunction && !val.$isClass && val !== Ext.emptyFn && val !== Ext.identityFn) 
      {
        proto[member] = fn = val;
        fn.$owner = cls;
        fn.$name = member;
      } else {
        proto[member] = val;
      }
    }
  for (which = 1; enumerableMembers; which <<= 1) 
    {
      if (enumerableMembers & which) 
      {
        enumerableMembers &= ~which;
        member = enumerablesMap[which];
        proto[member] = fn = data[member];
        fn.$owner = cls;
        fn.$name = member;
      }
    }
}, makeShim = function(base) {
  var cls = function ctor() {
  return base.apply(this, arguments) || null;
}, i, name;
  cls.prototype = Ext.Object.chain(base.prototype);
  for (i = baseStaticMembers.length; i-- > 0; ) 
    {
      name = baseStaticMembers[i];
      cls[name] = Base[name];
    }
  return cls;
}, derive = function(className, base, data, enumerableMembers, xtypes, xtypesChain, xtypeMap, aliases, mixins, names, createdFn) {
  var cls = function ctor() {
  return this.constructor.apply(this, arguments) || null;
}, ret = cls, hooks = {enumerableMembers: enumerableMembers & enumerablesMask, onCreated: createdFn, onBeforeCreated: onBeforeCreated, aliases: aliases}, alternates = data.alternateClassName || [], global = Ext.global, alias, alternate, i, ln, n, ns, name, nameToAlternates, proto, statics, staticMember, targetName, fn, val;
  for (i = baseStaticMembers.length; i-- > 0; ) 
    {
      name = baseStaticMembers[i];
      cls[name] = Base[name];
    }
  if (data.$isFunction) 
  {
    data = data(cls);
  }
  hooks.data = data;
  statics = data.statics , data.$className = className;
  if ('$className' in data) 
  {
    cls.$className = data.$className;
  }
  cls.extend(base);
  proto = cls.prototype;
  cls.xtype = data.xtype = xtypes[0];
  if (xtypes) 
  {
    proto.xtypes = xtypes;
  }
  proto.xtypesChain = xtypesChain;
  proto.xtypesMap = xtypeMap;
  data.alias = aliases;
  ret.triggerExtended(cls, data, hooks);
  if (data.onClassExtended) 
  {
    cls.onExtended(data.onClassExtended, cls);
    delete data.onClassExtended;
  }
  if (statics) 
  {
    for (staticMember in statics) 
      {
        if (statics.hasOwnProperty(staticMember)) 
        {
          val = statics[staticMember];
          if (val && val.$isFunction && !val.$isClass && val !== Ext.emptyFn && val !== Ext.identityFn) 
          {
            cls[staticMember] = fn = val;
            fn.$owner = cls;
            fn.$name = staticMember;
          }
          cls[staticMember] = val;
        }
      }
  }
  delete data.statics;
  if (data.inheritableStatics) 
  {
    cls.addInheritableStatics(data.inheritableStatics);
  }
  if (proto.onClassExtended) 
  {
    ret.onExtended(proto.onClassExtended, ret);
    delete proto.onClassExtended;
  }
  if (data.config) 
  {
    applyConfig(cls, data);
  }
  hooks.onBeforeCreated(cls, hooks.data, hooks);
  for (i = 0 , n = mixins && mixins.length; i < n; ++i) 
    {
      cls.mixin.apply(cls, mixins[i]);
    }
  for (i = 0 , n = aliases.length; i < n; i++) 
    {
      alias = aliases[i];
      ClassManager.setAlias(cls, alias);
    }
  if (data.singleton) 
  {
    ret = new cls();
  }
  if (!(alternates instanceof Array)) 
  {
    alternates = [alternates];
  }
  for (i = 0 , ln = alternates.length; i < ln; i++) 
    {
      alternate = alternates[i];
      ClassManager.classes[alternate] = ret;
      targetName = ClassManager.getName(ret);
      nameToAlternates = ClassManager.maps.nameToAlternates;
      if (targetName && targetName !== alternate) 
      {
        ClassManager.maps.alternateToName[alternate] = targetName;
        alternates = nameToAlternates[targetName] || (nameToAlternates[targetName] = []);
        alternates.push(alternate);
      }
    }
  for (i = 0 , n = names.length; i < n; i += 2) 
    {
      ns = names[i];
      if (!ns) 
      {
        ns = global;
      }
      ns[names[i + 1]] = ret;
    }
  ClassManager.classes[className] = ret;
  targetName = ClassManager.getName(ret);
  nameToAlternates = ClassManager.maps.nameToAlternates;
  if (targetName && targetName !== className) 
  {
    ClassManager.maps.alternateToName[className] = targetName;
    alternates = nameToAlternates[targetName] || (nameToAlternates[targetName] = []);
    alternates.push(className);
  }
  delete proto.alternateClassName;
  if (hooks.onCreated) 
  {
    hooks.onCreated.call(ret, ret);
  }
  if (className) 
  {
    ClassManager.triggerCreated(className);
  }
  return ret;
};
  ExtCmd.derive = thunk;
}(Ext.cmd = {}));

/* 
 * Helper code for compiler optimization
 */

//@tag compiler-helpers



/* 
 * Helper code for compiler optimization
 */

//@tag compiler-helpers



var Ext = Ext || {};
Ext._startTime = new Date().getTime();
(function() {
  var global = this, objectPrototype = Object.prototype, toString = objectPrototype.toString, enumerables = true, enumerablesTest = {toString: 1}, emptyFn = function() {
}, callOverrideParent = function() {
  var method = callOverrideParent.caller.caller;
  return method.$owner.prototype[method.$name].apply(this, arguments);
}, i, nonWhitespaceRe = /\S/, ExtApp, iterableRe = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/;
  Ext.global = global;
  for (i in enumerablesTest) 
    {
      enumerables = null;
    }
  if (enumerables) 
  {
    enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'constructor'];
  }
  Ext.enumerables = enumerables;
  Ext.apply = function(object, config, defaults) {
  if (defaults) 
  {
    Ext.apply(object, defaults);
  }
  if (object && config && typeof config === 'object') 
  {
    var i, j, k;
    for (i in config) 
      {
        object[i] = config[i];
      }
    if (enumerables) 
    {
      for (j = enumerables.length; j--; ) 
        {
          k = enumerables[j];
          if (config.hasOwnProperty(k)) 
          {
            object[k] = config[k];
          }
        }
    }
  }
  return object;
};
  Ext.buildSettings = Ext.apply({baseCSSPrefix: 'x-'}, Ext.buildSettings || {});
  Ext.apply(Ext, {name: Ext.sandboxName || 'Ext', emptyFn: emptyFn, identityFn: function(o) {
  return o;
}, emptyString: new String(), baseCSSPrefix: Ext.buildSettings.baseCSSPrefix, applyIf: function(object, config) {
  var property;
  if (object) 
  {
    for (property in config) 
      {
        if (object[property] === undefined) 
        {
          object[property] = config[property];
        }
      }
  }
  return object;
}, iterate: function(object, fn, scope) {
  if (Ext.isEmpty(object)) 
  {
    return;
  }
  if (scope === undefined) 
  {
    scope = object;
  }
  if (Ext.isIterable(object)) 
  {
    Ext.Array.each.call(Ext.Array, object, fn, scope);
  } else {
    Ext.Object.each.call(Ext.Object, object, fn, scope);
  }
}});
  Ext.apply(Ext, {extend: (function() {
  var objectConstructor = objectPrototype.constructor, inlineOverrides = function(o) {
  for (var m in o) 
    {
      if (!o.hasOwnProperty(m)) 
      {
        continue;
      }
      this[m] = o[m];
    }
};
  return function(subclass, superclass, overrides) {
  if (Ext.isObject(superclass)) 
  {
    overrides = superclass;
    superclass = subclass;
    subclass = overrides.constructor !== objectConstructor ? overrides.constructor : function() {
  superclass.apply(this, arguments);
};
  }
  var F = function() {
}, subclassProto, superclassProto = superclass.prototype;
  F.prototype = superclassProto;
  subclassProto = subclass.prototype = new F();
  subclassProto.constructor = subclass;
  subclass.superclass = superclassProto;
  if (superclassProto.constructor === objectConstructor) 
  {
    superclassProto.constructor = superclass;
  }
  subclass.override = function(overrides) {
  Ext.override(subclass, overrides);
};
  subclassProto.override = inlineOverrides;
  subclassProto.proto = subclassProto;
  subclass.override(overrides);
  subclass.extend = function(o) {
  return Ext.extend(subclass, o);
};
  return subclass;
};
}()), override: function(target, overrides) {
  if (target.$isClass) 
  {
    target.override(overrides);
  } else if (typeof target == 'function') 
  {
    Ext.apply(target.prototype, overrides);
  } else {
    var owner = target.self, name, value;
    if (owner && owner.$isClass) 
    {
      for (name in overrides) 
        {
          if (overrides.hasOwnProperty(name)) 
          {
            value = overrides[name];
            if (typeof value == 'function') 
            {
              value.$name = name;
              value.$owner = owner;
              value.$previous = target.hasOwnProperty(name) ? target[name] : callOverrideParent;
            }
            target[name] = value;
          }
        }
    } else {
      Ext.apply(target, overrides);
    }
  }
  return target;
}});
  Ext.apply(Ext, {valueFrom: function(value, defaultValue, allowBlank) {
  return Ext.isEmpty(value, allowBlank) ? defaultValue : value;
}, typeOf: function(value) {
  var type, typeToString;
  if (value === null) 
  {
    return 'null';
  }
  type = typeof value;
  if (type === 'undefined' || type === 'string' || type === 'number' || type === 'boolean') 
  {
    return type;
  }
  typeToString = toString.call(value);
  switch (typeToString) {
    case '[object Array]':
      return 'array';
    case '[object Date]':
      return 'date';
    case '[object Boolean]':
      return 'boolean';
    case '[object Number]':
      return 'number';
    case '[object RegExp]':
      return 'regexp';
  }
  if (type === 'function') 
  {
    return 'function';
  }
  if (type === 'object') 
  {
    if (value.nodeType !== undefined) 
    {
      if (value.nodeType === 3) 
      {
        return (nonWhitespaceRe).test(value.nodeValue) ? 'textnode' : 'whitespace';
      } else {
        return 'element';
      }
    }
    return 'object';
  }
}, coerce: function(from, to) {
  var fromType = Ext.typeOf(from), toType = Ext.typeOf(to), isString = typeof from === 'string';
  if (fromType !== toType) 
  {
    switch (toType) {
      case 'string':
        return String(from);
      case 'number':
        return Number(from);
      case 'boolean':
        return isString && (!from || from === 'false') ? false : Boolean(from);
      case 'null':
        return isString && (!from || from === 'null') ? null : from;
      case 'undefined':
        return isString && (!from || from === 'undefined') ? undefined : from;
      case 'date':
        return isString && isNaN(from) ? Ext.Date.parse(from, Ext.Date.defaultFormat) : Date(Number(from));
    }
  }
  return from;
}, isEmpty: function(value, allowEmptyString) {
  return (value === null) || (value === undefined) || (!allowEmptyString ? value === '' : false) || (Ext.isArray(value) && value.length === 0);
}, isArray: ('isArray' in Array) ? Array.isArray : function(value) {
  return toString.call(value) === '[object Array]';
}, isDate: function(value) {
  return toString.call(value) === '[object Date]';
}, isObject: (toString.call(null) === '[object Object]') ? function(value) {
  return value !== null && value !== undefined && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;
} : function(value) {
  return toString.call(value) === '[object Object]';
}, isSimpleObject: function(value) {
  return value instanceof Object && value.constructor === Object;
}, isPrimitive: function(value) {
  var type = typeof value;
  return type === 'string' || type === 'number' || type === 'boolean';
}, isFunction: (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') ? function(value) {
  return !!value && toString.call(value) === '[object Function]';
} : function(value) {
  return !!value && typeof value === 'function';
}, isNumber: function(value) {
  return typeof value === 'number' && isFinite(value);
}, isNumeric: function(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
}, isString: function(value) {
  return typeof value === 'string';
}, isBoolean: function(value) {
  return typeof value === 'boolean';
}, isElement: function(value) {
  return value ? value.nodeType === 1 : false;
}, isTextNode: function(value) {
  return value ? value.nodeName === "#text" : false;
}, isDefined: function(value) {
  return typeof value !== 'undefined';
}, isIterable: function(value) {
  if (!value || typeof value.length !== 'number' || typeof value === 'string' || Ext.isFunction(value)) 
  {
    return false;
  }
  if (!value.propertyIsEnumerable) 
  {
    return !!value.item;
  }
  if (value.hasOwnProperty('length') && !value.propertyIsEnumerable('length')) 
  {
    return true;
  }
  return iterableRe.test(toString.call(value));
}});
  Ext.apply(Ext, {clone: function(item) {
  var type, i, j, k, clone, key;
  if (item === null || item === undefined) 
  {
    return item;
  }
  if (item.nodeType && item.cloneNode) 
  {
    return item.cloneNode(true);
  }
  type = toString.call(item);
  if (type === '[object Date]') 
  {
    return new Date(item.getTime());
  }
  if (type === '[object Array]') 
  {
    i = item.length;
    clone = [];
    while (i--) 
      {
        clone[i] = Ext.clone(item[i]);
      }
  } else if (type === '[object Object]' && item.constructor === Object) 
  {
    clone = {};
    for (key in item) 
      {
        clone[key] = Ext.clone(item[key]);
      }
    if (enumerables) 
    {
      for (j = enumerables.length; j--; ) 
        {
          k = enumerables[j];
          if (item.hasOwnProperty(k)) 
          {
            clone[k] = item[k];
          }
        }
    }
  }
  return clone || item;
}, getUniqueGlobalNamespace: function() {
  var uniqueGlobalNamespace = this.uniqueGlobalNamespace, i;
  if (uniqueGlobalNamespace === undefined) 
  {
    i = 0;
    do {
      uniqueGlobalNamespace = 'ExtBox' + (++i);
    } while (Ext.global[uniqueGlobalNamespace] !== undefined);
    Ext.global[uniqueGlobalNamespace] = Ext;
    this.uniqueGlobalNamespace = uniqueGlobalNamespace;
  }
  return uniqueGlobalNamespace;
}, functionFactoryCache: {}, cacheableFunctionFactory: function() {
  var me = this, args = Array.prototype.slice.call(arguments), cache = me.functionFactoryCache, idx, fn, ln;
  if (Ext.isSandboxed) 
  {
    ln = args.length;
    if (ln > 0) 
    {
      ln--;
      args[ln] = 'var Ext=window.' + Ext.name + ';' + args[ln];
    }
  }
  idx = args.join('');
  fn = cache[idx];
  if (!fn) 
  {
    fn = Function.prototype.constructor.apply(Function.prototype, args);
    cache[idx] = fn;
  }
  return fn;
}, functionFactory: function() {
  var me = this, args = Array.prototype.slice.call(arguments), ln;
  if (Ext.isSandboxed) 
  {
    ln = args.length;
    if (ln > 0) 
    {
      ln--;
      args[ln] = 'var Ext=window.' + Ext.name + ';' + args[ln];
    }
  }
  return Function.prototype.constructor.apply(Function.prototype, args);
}, Logger: {verbose: emptyFn, log: emptyFn, info: emptyFn, warn: emptyFn, error: function(message) {
  throw new Error(message);
}, deprecate: emptyFn}});
  Ext.type = Ext.typeOf;
  ExtApp = Ext.app;
  if (!ExtApp) 
  {
    ExtApp = Ext.app = {};
  }
  Ext.apply(ExtApp, {namespaces: {}, collectNamespaces: function(paths) {
  var namespaces = Ext.app.namespaces, path;
  for (path in paths) 
    {
      if (paths.hasOwnProperty(path)) 
      {
        namespaces[path] = true;
      }
    }
}, addNamespaces: function(ns) {
  var namespaces = Ext.app.namespaces, i, l;
  if (!Ext.isArray(ns)) 
  {
    ns = [ns];
  }
  for (i = 0 , l = ns.length; i < l; i++) 
    {
      namespaces[ns[i]] = true;
    }
}, clearNamespaces: function() {
  Ext.app.namespaces = {};
}, getNamespace: function(className) {
  var namespaces = Ext.app.namespaces, deepestPrefix = '', prefix;
  for (prefix in namespaces) 
    {
      if (namespaces.hasOwnProperty(prefix) && prefix.length > deepestPrefix.length && (prefix + '.' === className.substring(0, prefix.length + 1))) 
      {
        deepestPrefix = prefix;
      }
    }
  return deepestPrefix === '' ? undefined : deepestPrefix;
}});
}());
Ext.globalEval = Ext.global.execScript ? function(code) {
  execScript(code);
} : function($$code) {
  (function() {
  var Ext = this.Ext;
  eval($$code);
}());
};

(function() {
  var version = '4.2.3.1477', checkVerTemp = [''], endOfVersionRe = /([^\d\.])/, notDigitsRe = /[^\d]/g, plusMinusRe = /[\-+]/g, stripRe = /\s/g, underscoreRe = /_/g, Version;
  Ext.Version = Version = Ext.extend(Object, {isVersion: true, padModes: {'~': NaN, '^': Infinity}, release: '', constructor: function(version, defaultMode) {
  var me = this, padModes = me.padModes, ch, i, pad, parts, release, releaseStartIndex, ver;
  if (version.isVersion) 
  {
    return version;
  }
  me.version = ver = String(version).toLowerCase().replace(underscoreRe, '.').replace(plusMinusRe, '');
  ch = ver.charAt(0);
  if (ch in padModes) 
  {
    ver = ver.substring(1);
    pad = padModes[ch];
  } else {
    pad = defaultMode ? padModes[defaultMode] : 0;
  }
  me.pad = pad;
  releaseStartIndex = ver.search(endOfVersionRe);
  me.shortVersion = ver;
  if (releaseStartIndex !== -1) 
  {
    me.release = release = ver.substr(releaseStartIndex, version.length);
    me.shortVersion = ver.substr(0, releaseStartIndex);
    release = Version.releaseValueMap[release] || release;
  }
  me.releaseValue = release || pad;
  me.shortVersion = me.shortVersion.replace(notDigitsRe, '');
  me.parts = parts = ver.split('.');
  for (i = parts.length; i--; ) 
    {
      parts[i] = parseInt(parts[i], 10);
    }
  if (pad === Infinity) 
  {
    parts.push(pad);
  }
  me.major = parts[0] || pad;
  me.minor = parts[1] || pad;
  me.patch = parts[2] || pad;
  me.build = parts[3] || pad;
  return me;
}, compareTo: function(other) {
  var me = this, lhsPad = me.pad, lhsParts = me.parts, lhsLength = lhsParts.length, rhsVersion = other.isVersion ? other : new Version(other), rhsPad = rhsVersion.pad, rhsParts = rhsVersion.parts, rhsLength = rhsParts.length, length = Math.max(lhsLength, rhsLength), i, lhs, rhs;
  for (i = 0; i < length; i++) 
    {
      lhs = (i < lhsLength) ? lhsParts[i] : lhsPad;
      rhs = (i < rhsLength) ? rhsParts[i] : rhsPad;
      if (lhs < rhs) 
      {
        return -1;
      }
      if (lhs > rhs) 
      {
        return 1;
      }
    }
  lhs = me.releaseValue;
  rhs = rhsVersion.releaseValue;
  if (lhs < rhs) 
  {
    return -1;
  }
  if (lhs > rhs) 
  {
    return 1;
  }
  return 0;
}, toString: function() {
  return this.version;
}, valueOf: function() {
  return this.version;
}, getMajor: function() {
  return this.major;
}, getMinor: function() {
  return this.minor;
}, getPatch: function() {
  return this.patch;
}, getBuild: function() {
  return this.build;
}, getRelease: function() {
  return this.release;
}, getReleaseValue: function() {
  return this.releaseValue;
}, isGreaterThan: function(target) {
  return this.compareTo(target) > 0;
}, isGreaterThanOrEqual: function(target) {
  return this.compareTo(target) >= 0;
}, isLessThan: function(target) {
  return this.compareTo(target) < 0;
}, isLessThanOrEqual: function(target) {
  return this.compareTo(target) <= 0;
}, equals: function(target) {
  return this.compareTo(target) === 0;
}, match: function(target) {
  target = String(target);
  return this.version.substr(0, target.length) === target;
}, toArray: function() {
  var me = this;
  return [me.getMajor(), me.getMinor(), me.getPatch(), me.getBuild(), me.getRelease()];
}, getShortVersion: function() {
  return this.shortVersion;
}, gt: function(target) {
  return this.compareTo(target) > 0;
}, lt: function(target) {
  return this.compareTo(target) < 0;
}, gtEq: function(target) {
  return this.compareTo(target) >= 0;
}, ltEq: function(target) {
  return this.compareTo(target) <= 0;
}});
  Ext.apply(Version, {releaseValueMap: {dev: -6, alpha: -5, a: -5, beta: -4, b: -4, rc: -3, '#': -2, p: -1, pl: -1}, getComponentValue: function(value) {
  return !value ? 0 : (isNaN(value) ? this.releaseValueMap[value] || value : parseInt(value, 10));
}, compare: function(current, target) {
  var ver = current.isVersion ? current : new Version(current);
  return ver.compareTo(target);
}});
  Ext.apply(Ext, {versions: {}, lastRegisteredVersion: null, setVersion: function(packageName, version) {
  Ext.lastRegisteredVersion = Ext.versions[packageName] = new Version(version);
  return this;
}, getVersion: function(packageName) {
  if (packageName === undefined) 
  {
    return Ext.lastRegisteredVersion;
  }
  return Ext.versions[packageName];
}, checkVersion: function(specs, matchAll) {
  var isArray = Ext.isArray(specs), compat = isArray ? specs : checkVerTemp, length = compat.length, versions = Ext.versions, frameworkVer = versions.ext || versions.touch, i, index, matches, minVer, maxVer, spec, range, ver;
  if (!isArray) 
  {
    checkVerTemp[0] = specs;
  }
  for (i = 0; i < length; ++i) 
    {
      if (!Ext.isString(spec = compat[i])) 
      {
        matches = Ext.checkVersion(spec.and || spec.or, !spec.or);
        if (spec.not) 
        {
          matches = !matches;
        }
      } else {
        if (spec.indexOf(' ') >= 0) 
        {
          spec = spec.replace(stripRe, '');
        }
        index = spec.indexOf('@');
        if (index < 0) 
        {
          range = spec;
          ver = frameworkVer;
        } else {
          if (!(ver = versions[spec.substring(0, index)])) 
          {
            if (matchAll) 
            {
              return false;
            }
            continue;
          }
          range = spec.substring(index + 1);
        }
        index = range.indexOf('-');
        if (index < 0) 
        {
          if (range.charAt(index = range.length - 1) === '+') 
          {
            minVer = range.substring(0, index);
            maxVer = null;
          } else {
            minVer = maxVer = range;
          }
        } else if (index > 0) 
        {
          minVer = range.substring(0, index);
          maxVer = range.substring(index + 1);
        } else {
          minVer = null;
          maxVer = range.substring(index + 1);
        }
        matches = true;
        if (minVer) 
        {
          minVer = new Version(minVer, '~');
          matches = minVer.ltEq(ver);
        }
        if (matches && maxVer) 
        {
          maxVer = new Version(maxVer, '~');
          matches = maxVer.gtEq(ver);
        }
      }
      if (matches) 
      {
        if (!matchAll) 
        {
          return true;
        }
      } else if (matchAll) 
      {
        return false;
      }
    }
  return !!matchAll;
}, deprecate: function(packageName, since, closure, scope) {
  if (Version.compare(Ext.getVersion(packageName), since) < 1) 
  {
    closure.call(scope);
  }
}});
  Ext.setVersion('core', version);
}());

Ext.String = (function() {
  var trimRegex = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g, escapeRe = /('|\\)/g, formatRe = /\{\d+\}/, escapeRegexRe = /([-.*+?\^${}()|\[\]\/\\])/g, basicTrimRe = /^\s+|\s+$/g, whitespaceRe = /\s+/, varReplace = /(^[^a-z]*|[^\w])/gi, charToEntity, entityToChar, charToEntityRegex, entityToCharRegex, htmlEncodeReplaceFn = function(match, capture) {
  return charToEntity[capture];
}, htmlDecodeReplaceFn = function(match, capture) {
  return (capture in entityToChar) ? entityToChar[capture] : String.fromCharCode(parseInt(capture.substr(2), 10));
}, boundsCheck = function(s, other) {
  if (s === null || s === undefined || other === null || other === undefined) 
  {
    return false;
  }
  return other.length <= s.length;
}, formatTplConfig = {useFormat: false, compiled: true, stringFormat: true}, formatFns = {}, generateFormatFn = function(format) {
  if (formatRe.test(format)) 
  {
    format = new Ext.Template(format, formatTplConfig);
    return function() {
  return format.apply(arguments);
};
  } else {
    return function() {
  return format;
};
  }
};
  return {insert: function(s, value, index) {
  if (!s) 
  {
    return value;
  }
  if (!value) 
  {
    return s;
  }
  var len = s.length;
  if (!index && index !== 0) 
  {
    index = len;
  }
  if (index < 0) 
  {
    index *= -1;
    if (index >= len) 
    {
      index = 0;
    } else {
      index = len - index;
    }
  }
  if (index === 0) 
  {
    s = value + s;
  } else if (index >= s.length) 
  {
    s += value;
  } else {
    s = s.substr(0, index) + value + s.substr(index);
  }
  return s;
}, startsWith: function(s, start, ignoreCase) {
  var result = boundsCheck(s, start);
  if (result) 
  {
    if (ignoreCase) 
    {
      s = s.toLowerCase();
      start = start.toLowerCase();
    }
    result = s.lastIndexOf(start, 0) === 0;
  }
  return result;
}, endsWith: function(s, end, ignoreCase) {
  var result = boundsCheck(s, end);
  if (result) 
  {
    if (ignoreCase) 
    {
      s = s.toLowerCase();
      end = end.toLowerCase();
    }
    result = s.indexOf(end, s.length - end.length) !== -1;
  }
  return result;
}, createVarName: function(s) {
  return s.replace(varReplace, '');
}, htmlEncode: function(value) {
  return (!value) ? value : String(value).replace(charToEntityRegex, htmlEncodeReplaceFn);
}, htmlDecode: function(value) {
  return (!value) ? value : String(value).replace(entityToCharRegex, htmlDecodeReplaceFn);
}, hasHtmlCharacters: function(s) {
  return charToEntityRegex.test(s);
}, addCharacterEntities: function(newEntities) {
  var charKeys = [], entityKeys = [], key, echar;
  for (key in newEntities) 
    {
      echar = newEntities[key];
      entityToChar[key] = echar;
      charToEntity[echar] = key;
      charKeys.push(echar);
      entityKeys.push(key);
    }
  charToEntityRegex = new RegExp('(' + charKeys.join('|') + ')', 'g');
  entityToCharRegex = new RegExp('(' + entityKeys.join('|') + '|&#[0-9]{1,5};' + ')', 'g');
}, resetCharacterEntities: function() {
  charToEntity = {};
  entityToChar = {};
  this.addCharacterEntities({'&amp;': '&', '&gt;': '>', '&lt;': '<', '&quot;': '"', '&#39;': "'"});
}, urlAppend: function(url, string) {
  if (!Ext.isEmpty(string)) 
  {
    return url + (url.indexOf('?') === -1 ? '?' : '&') + string;
  }
  return url;
}, trim: function(string) {
  return string.replace(trimRegex, "");
}, capitalize: function(string) {
  return string.charAt(0).toUpperCase() + string.substr(1);
}, uncapitalize: function(string) {
  return string.charAt(0).toLowerCase() + string.substr(1);
}, ellipsis: function(value, length, word) {
  if (value && value.length > length) 
  {
    if (word) 
    {
      var vs = value.substr(0, length - 2), index = Math.max(vs.lastIndexOf(' '), vs.lastIndexOf('.'), vs.lastIndexOf('!'), vs.lastIndexOf('?'));
      if (index !== -1 && index >= (length - 15)) 
      {
        return vs.substr(0, index) + "...";
      }
    }
    return value.substr(0, length - 3) + "...";
  }
  return value;
}, escapeRegex: function(string) {
  return string.replace(escapeRegexRe, "\\$1");
}, escape: function(string) {
  return string.replace(escapeRe, "\\$1");
}, toggle: function(string, value, other) {
  return string === value ? other : value;
}, leftPad: function(string, size, character) {
  var result = String(string);
  character = character || " ";
  while (result.length < size) 
    {
      result = character + result;
    }
  return result;
}, format: function(format) {
  var formatFn = formatFns[format] || (formatFns[format] = generateFormatFn(format));
  return formatFn.apply(this, arguments);
}, repeat: function(pattern, count, sep) {
  if (count < 1) 
  {
    count = 0;
  }
  for (var buf = [], i = count; i--; ) 
    {
      buf.push(pattern);
    }
  return buf.join(sep || '');
}, splitWords: function(words) {
  if (words && typeof words == 'string') 
  {
    return words.replace(basicTrimRe, '').split(whitespaceRe);
  }
  return words || [];
}};
}());
Ext.String.resetCharacterEntities();
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;

Ext.Number = new function() {
  var me = this, isToFixedBroken = (0.9).toFixed() !== '1', math = Math;
  Ext.apply(this, {constrain: function(number, min, max) {
  var x = parseFloat(number);
  return (x < min) ? min : ((x > max) ? max : x);
}, snap: function(value, increment, minValue, maxValue) {
  var m;
  if (value === undefined || value < minValue) 
  {
    return minValue || 0;
  }
  if (increment) 
  {
    m = value % increment;
    if (m !== 0) 
    {
      value -= m;
      if (m * 2 >= increment) 
      {
        value += increment;
      } else if (m * 2 < -increment) 
      {
        value -= increment;
      }
    }
  }
  return me.constrain(value, minValue, maxValue);
}, snapInRange: function(value, increment, minValue, maxValue) {
  var tween;
  minValue = (minValue || 0);
  if (value === undefined || value < minValue) 
  {
    return minValue;
  }
  if (increment && (tween = ((value - minValue) % increment))) 
  {
    value -= tween;
    tween *= 2;
    if (tween >= increment) 
    {
      value += increment;
    }
  }
  if (maxValue !== undefined) 
  {
    if (value > (maxValue = me.snapInRange(maxValue, increment, minValue))) 
    {
      value = maxValue;
    }
  }
  return value;
}, toFixed: isToFixedBroken ? function(value, precision) {
  precision = precision || 0;
  var pow = math.pow(10, precision);
  return (math.round(value * pow) / pow).toFixed(precision);
} : function(value, precision) {
  return value.toFixed(precision);
}, from: function(value, defaultValue) {
  if (isFinite(value)) 
  {
    value = parseFloat(value);
  }
  return !isNaN(value) ? value : defaultValue;
}, randomInt: function(from, to) {
  return math.floor(math.random() * (to - from + 1) + from);
}, correctFloat: function(n) {
  return parseFloat(n.toPrecision(14));
}});
  Ext.num = function() {
  return me.from.apply(this, arguments);
};
}();

(function() {
  var arrayPrototype = Array.prototype, slice = arrayPrototype.slice, supportsSplice = (function() {
  var array = [], lengthBefore, j = 20;
  if (!array.splice) 
  {
    return false;
  }
  while (j--) 
    {
      array.push("A");
    }
  array.splice(15, 0, "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F", "F");
  lengthBefore = array.length;
  array.splice(13, 0, "XXX");
  if (lengthBefore + 1 != array.length) 
  {
    return false;
  }
  return true;
}()), supportsForEach = 'forEach' in arrayPrototype, supportsMap = 'map' in arrayPrototype, supportsIndexOf = 'indexOf' in arrayPrototype, supportsEvery = 'every' in arrayPrototype, supportsSome = 'some' in arrayPrototype, supportsFilter = 'filter' in arrayPrototype, supportsSort = (function() {
  var a = [1, 2, 3, 4, 5].sort(function() {
  return 0;
});
  return a[0] === 1 && a[1] === 2 && a[2] === 3 && a[3] === 4 && a[4] === 5;
}()), supportsSliceOnNodeList = true, ExtArray, erase, replace, splice;
  try {
    if (typeof document !== 'undefined') 
    {
      slice.call(document.getElementsByTagName('body'));
    }
  }  catch (e) {
  supportsSliceOnNodeList = false;
}
  function fixArrayIndex(array, index) {
    return (index < 0) ? Math.max(0, array.length + index) : Math.min(array.length, index);
  }
  function replaceSim(array, index, removeCount, insert) {
    var add = insert ? insert.length : 0, length = array.length, pos = fixArrayIndex(array, index), remove, tailOldPos, tailNewPos, tailCount, lengthAfterRemove, i;
    if (pos === length) 
    {
      if (add) 
      {
        array.push.apply(array, insert);
      }
    } else {
      remove = Math.min(removeCount, length - pos);
      tailOldPos = pos + remove;
      tailNewPos = tailOldPos + add - remove;
      tailCount = length - tailOldPos;
      lengthAfterRemove = length - remove;
      if (tailNewPos < tailOldPos) 
      {
        for (i = 0; i < tailCount; ++i) 
          {
            array[tailNewPos + i] = array[tailOldPos + i];
          }
      } else if (tailNewPos > tailOldPos) 
      {
        for (i = tailCount; i--; ) 
          {
            array[tailNewPos + i] = array[tailOldPos + i];
          }
      }
      if (add && pos === lengthAfterRemove) 
      {
        array.length = lengthAfterRemove;
        array.push.apply(array, insert);
      } else {
        array.length = lengthAfterRemove + add;
        for (i = 0; i < add; ++i) 
          {
            array[pos + i] = insert[i];
          }
      }
    }
    return array;
  }
  function replaceNative(array, index, removeCount, insert) {
    if (insert && insert.length) 
    {
      if (index === 0 && !removeCount) 
      {
        array.unshift.apply(array, insert);
      } else if (index < array.length) 
      {
        array.splice.apply(array, [index, removeCount].concat(insert));
      } else {
        array.push.apply(array, insert);
      }
    } else {
      array.splice(index, removeCount);
    }
    return array;
  }
  function eraseSim(array, index, removeCount) {
    return replaceSim(array, index, removeCount);
  }
  function eraseNative(array, index, removeCount) {
    array.splice(index, removeCount);
    return array;
  }
  function spliceSim(array, index, removeCount) {
    var pos = fixArrayIndex(array, index), removed = array.slice(index, fixArrayIndex(array, pos + removeCount));
    if (arguments.length < 4) 
    {
      replaceSim(array, pos, removeCount);
    } else {
      replaceSim(array, pos, removeCount, slice.call(arguments, 3));
    }
    return removed;
  }
  function spliceNative(array) {
    return array.splice.apply(array, slice.call(arguments, 1));
  }
  erase = supportsSplice ? eraseNative : eraseSim;
  replace = supportsSplice ? replaceNative : replaceSim;
  splice = supportsSplice ? spliceNative : spliceSim;
  ExtArray = Ext.Array = {each: function(array, fn, scope, reverse) {
  array = ExtArray.from(array);
  var i, ln = array.length;
  if (reverse !== true) 
  {
    for (i = 0; i < ln; i++) 
      {
        if (fn.call(scope || array[i], array[i], i, array) === false) 
        {
          return i;
        }
      }
  } else {
    for (i = ln - 1; i > -1; i--) 
      {
        if (fn.call(scope || array[i], array[i], i, array) === false) 
        {
          return i;
        }
      }
  }
  return true;
}, forEach: supportsForEach ? function(array, fn, scope) {
  array.forEach(fn, scope);
} : function(array, fn, scope) {
  var i = 0, ln = array.length;
  for (; i < ln; i++) 
    {
      fn.call(scope, array[i], i, array);
    }
}, indexOf: supportsIndexOf ? function(array, item, from) {
  return arrayPrototype.indexOf.call(array, item, from);
} : function(array, item, from) {
  var i, length = array.length;
  for (i = (from < 0) ? Math.max(0, length + from) : from || 0; i < length; i++) 
    {
      if (array[i] === item) 
      {
        return i;
      }
    }
  return -1;
}, contains: supportsIndexOf ? function(array, item) {
  return arrayPrototype.indexOf.call(array, item) !== -1;
} : function(array, item) {
  var i, ln;
  for (i = 0 , ln = array.length; i < ln; i++) 
    {
      if (array[i] === item) 
      {
        return true;
      }
    }
  return false;
}, toArray: function(iterable, start, end) {
  if (!iterable || !iterable.length) 
  {
    return [];
  }
  if (typeof iterable === 'string') 
  {
    iterable = iterable.split('');
  }
  if (supportsSliceOnNodeList) 
  {
    return slice.call(iterable, start || 0, end || iterable.length);
  }
  var array = [], i;
  start = start || 0;
  end = end ? ((end < 0) ? iterable.length + end : end) : iterable.length;
  for (i = start; i < end; i++) 
    {
      array.push(iterable[i]);
    }
  return array;
}, pluck: function(array, propertyName) {
  var ret = [], i, ln, item;
  for (i = 0 , ln = array.length; i < ln; i++) 
    {
      item = array[i];
      ret.push(item[propertyName]);
    }
  return ret;
}, map: supportsMap ? function(array, fn, scope) {
  return array.map(fn, scope);
} : function(array, fn, scope) {
  var results = [], i = 0, len = array.length;
  for (; i < len; i++) 
    {
      results[i] = fn.call(scope, array[i], i, array);
    }
  return results;
}, every: supportsEvery ? function(array, fn, scope) {
  return array.every(fn, scope);
} : function(array, fn, scope) {
  var i = 0, ln = array.length;
  for (; i < ln; ++i) 
    {
      if (!fn.call(scope, array[i], i, array)) 
      {
        return false;
      }
    }
  return true;
}, some: supportsSome ? function(array, fn, scope) {
  return array.some(fn, scope);
} : function(array, fn, scope) {
  var i = 0, ln = array.length;
  for (; i < ln; ++i) 
    {
      if (fn.call(scope, array[i], i, array)) 
      {
        return true;
      }
    }
  return false;
}, equals: function(array1, array2) {
  var len1 = array1.length, len2 = array2.length, i;
  if (array1 === array2) 
  {
    return true;
  }
  if (len1 !== len2) 
  {
    return false;
  }
  for (i = 0; i < len1; ++i) 
    {
      if (array1[i] !== array2[i]) 
      {
        return false;
      }
    }
  return true;
}, clean: function(array) {
  var results = [], i = 0, ln = array.length, item;
  for (; i < ln; i++) 
    {
      item = array[i];
      if (!Ext.isEmpty(item)) 
      {
        results.push(item);
      }
    }
  return results;
}, unique: function(array) {
  var clone = [], i = 0, ln = array.length, item;
  for (; i < ln; i++) 
    {
      item = array[i];
      if (ExtArray.indexOf(clone, item) === -1) 
      {
        clone.push(item);
      }
    }
  return clone;
}, filter: supportsFilter ? function(array, fn, scope) {
  return array.filter(fn, scope);
} : function(array, fn, scope) {
  var results = [], i = 0, ln = array.length;
  for (; i < ln; i++) 
    {
      if (fn.call(scope, array[i], i, array)) 
      {
        results.push(array[i]);
      }
    }
  return results;
}, findBy: function(array, fn, scope) {
  var i = 0, len = array.length;
  for (; i < len; i++) 
    {
      if (fn.call(scope || array, array[i], i)) 
      {
        return array[i];
      }
    }
  return null;
}, from: function(value, newReference) {
  if (value === undefined || value === null) 
  {
    return [];
  }
  if (Ext.isArray(value)) 
  {
    return (newReference) ? slice.call(value) : value;
  }
  var type = typeof value;
  if (value && value.length !== undefined && type !== 'string' && (type !== 'function' || !value.apply)) 
  {
    return ExtArray.toArray(value);
  }
  return [value];
}, remove: function(array, item) {
  var index = ExtArray.indexOf(array, item);
  if (index !== -1) 
  {
    erase(array, index, 1);
  }
  return array;
}, include: function(array, item) {
  if (!ExtArray.contains(array, item)) 
  {
    array.push(item);
  }
}, clone: function(array) {
  return slice.call(array);
}, merge: function() {
  var args = slice.call(arguments), array = [], i, ln;
  for (i = 0 , ln = args.length; i < ln; i++) 
    {
      array = array.concat(args[i]);
    }
  return ExtArray.unique(array);
}, intersect: function() {
  var intersection = [], arrays = slice.call(arguments), arraysLength, array, arrayLength, minArray, minArrayIndex, minArrayCandidate, minArrayLength, element, elementCandidate, elementCount, i, j, k;
  if (!arrays.length) 
  {
    return intersection;
  }
  arraysLength = arrays.length;
  for (i = minArrayIndex = 0; i < arraysLength; i++) 
    {
      minArrayCandidate = arrays[i];
      if (!minArray || minArrayCandidate.length < minArray.length) 
      {
        minArray = minArrayCandidate;
        minArrayIndex = i;
      }
    }
  minArray = ExtArray.unique(minArray);
  erase(arrays, minArrayIndex, 1);
  minArrayLength = minArray.length;
  arraysLength = arrays.length;
  for (i = 0; i < minArrayLength; i++) 
    {
      element = minArray[i];
      elementCount = 0;
      for (j = 0; j < arraysLength; j++) 
        {
          array = arrays[j];
          arrayLength = array.length;
          for (k = 0; k < arrayLength; k++) 
            {
              elementCandidate = array[k];
              if (element === elementCandidate) 
              {
                elementCount++;
                break;
              }
            }
        }
      if (elementCount === arraysLength) 
      {
        intersection.push(element);
      }
    }
  return intersection;
}, difference: function(arrayA, arrayB) {
  var clone = slice.call(arrayA), ln = clone.length, i, j, lnB;
  for (i = 0 , lnB = arrayB.length; i < lnB; i++) 
    {
      for (j = 0; j < ln; j++) 
        {
          if (clone[j] === arrayB[i]) 
          {
            erase(clone, j, 1);
            j--;
            ln--;
          }
        }
    }
  return clone;
}, slice: ([1, 2].slice(1, undefined).length ? function(array, begin, end) {
  return slice.call(array, begin, end);
} : function(array, begin, end) {
  if (typeof begin === 'undefined') 
  {
    return slice.call(array);
  }
  if (typeof end === 'undefined') 
  {
    return slice.call(array, begin);
  }
  return slice.call(array, begin, end);
}), sort: supportsSort ? function(array, sortFn) {
  if (sortFn) 
  {
    return array.sort(sortFn);
  } else {
    return array.sort();
  }
} : function(array, sortFn) {
  var length = array.length, i = 0, comparison, j, min, tmp;
  for (; i < length; i++) 
    {
      min = i;
      for (j = i + 1; j < length; j++) 
        {
          if (sortFn) 
          {
            comparison = sortFn(array[j], array[min]);
            if (comparison < 0) 
            {
              min = j;
            }
          } else if (array[j] < array[min]) 
          {
            min = j;
          }
        }
      if (min !== i) 
      {
        tmp = array[i];
        array[i] = array[min];
        array[min] = tmp;
      }
    }
  return array;
}, flatten: function(array) {
  var worker = [];
  function rFlatten(a) {
    var i, ln, v;
    for (i = 0 , ln = a.length; i < ln; i++) 
      {
        v = a[i];
        if (Ext.isArray(v)) 
        {
          rFlatten(v);
        } else {
          worker.push(v);
        }
      }
    return worker;
  }
  return rFlatten(array);
}, min: function(array, comparisonFn) {
  var min = array[0], i, ln, item;
  for (i = 0 , ln = array.length; i < ln; i++) 
    {
      item = array[i];
      if (comparisonFn) 
      {
        if (comparisonFn(min, item) === 1) 
        {
          min = item;
        }
      } else {
        if (item < min) 
        {
          min = item;
        }
      }
    }
  return min;
}, max: function(array, comparisonFn) {
  var max = array[0], i, ln, item;
  for (i = 0 , ln = array.length; i < ln; i++) 
    {
      item = array[i];
      if (comparisonFn) 
      {
        if (comparisonFn(max, item) === -1) 
        {
          max = item;
        }
      } else {
        if (item > max) 
        {
          max = item;
        }
      }
    }
  return max;
}, mean: function(array) {
  return array.length > 0 ? ExtArray.sum(array) / array.length : undefined;
}, sum: function(array) {
  var sum = 0, i, ln, item;
  for (i = 0 , ln = array.length; i < ln; i++) 
    {
      item = array[i];
      sum += item;
    }
  return sum;
}, toMap: function(array, getKey, scope) {
  var map = {}, i = array.length;
  if (!getKey) 
  {
    while (i--) 
      {
        map[array[i]] = i + 1;
      }
  } else if (typeof getKey == 'string') 
  {
    while (i--) 
      {
        map[array[i][getKey]] = i + 1;
      }
  } else {
    while (i--) 
      {
        map[getKey.call(scope, array[i])] = i + 1;
      }
  }
  return map;
}, toValueMap: function(array, getKey, scope) {
  var map = {}, i = array.length;
  if (!getKey) 
  {
    while (i--) 
      {
        map[array[i]] = array[i];
      }
  } else if (typeof getKey == 'string') 
  {
    while (i--) 
      {
        map[array[i][getKey]] = array[i];
      }
  } else {
    while (i--) 
      {
        map[getKey.call(scope, array[i])] = array[i];
      }
  }
  return map;
}, erase: erase, insert: function(array, index, items) {
  return replace(array, index, 0, items);
}, replace: replace, splice: splice, push: function(array) {
  var len = arguments.length, i = 1, newItem;
  if (array === undefined) 
  {
    array = [];
  } else if (!Ext.isArray(array)) 
  {
    array = [array];
  }
  for (; i < len; i++) 
    {
      newItem = arguments[i];
      Array.prototype.push[Ext.isIterable(newItem) ? 'apply' : 'call'](array, newItem);
    }
  return array;
}};
  Ext.each = ExtArray.each;
  ExtArray.union = ExtArray.merge;
  Ext.min = ExtArray.min;
  Ext.max = ExtArray.max;
  Ext.sum = ExtArray.sum;
  Ext.mean = ExtArray.mean;
  Ext.flatten = ExtArray.flatten;
  Ext.clean = ExtArray.clean;
  Ext.unique = ExtArray.unique;
  Ext.pluck = ExtArray.pluck;
  Ext.toArray = function() {
  return ExtArray.toArray.apply(ExtArray, arguments);
};
}());

Ext.Function = {flexSetter: function(fn) {
  return function(a, b) {
  var k, i;
  if (a === null) 
  {
    return this;
  }
  if (typeof a !== 'string') 
  {
    for (k in a) 
      {
        if (a.hasOwnProperty(k)) 
        {
          fn.call(this, k, a[k]);
        }
      }
    if (Ext.enumerables) 
    {
      for (i = Ext.enumerables.length; i--; ) 
        {
          k = Ext.enumerables[i];
          if (a.hasOwnProperty(k)) 
          {
            fn.call(this, k, a[k]);
          }
        }
    }
  } else {
    fn.call(this, a, b);
  }
  return this;
};
}, bind: function(fn, scope, args, appendArgs) {
  if (arguments.length === 2) 
  {
    return function() {
  return fn.apply(scope, arguments);
};
  }
  var method = fn, slice = Array.prototype.slice;
  return function() {
  var callArgs = args || arguments;
  if (appendArgs === true) 
  {
    callArgs = slice.call(arguments, 0);
    callArgs = callArgs.concat(args);
  } else if (typeof appendArgs == 'number') 
  {
    callArgs = slice.call(arguments, 0);
    Ext.Array.insert(callArgs, appendArgs, args);
  }
  return method.apply(scope || Ext.global, callArgs);
};
}, pass: function(fn, args, scope) {
  if (!Ext.isArray(args)) 
  {
    if (Ext.isIterable(args)) 
    {
      args = Ext.Array.clone(args);
    } else {
      args = args !== undefined ? [args] : [];
    }
  }
  return function() {
  var fnArgs = [].concat(args);
  fnArgs.push.apply(fnArgs, arguments);
  return fn.apply(scope || this, fnArgs);
};
}, alias: function(object, methodName) {
  return function() {
  return object[methodName].apply(object, arguments);
};
}, clone: function(method) {
  return function() {
  return method.apply(this, arguments);
};
}, createInterceptor: function(origFn, newFn, scope, returnValue) {
  var method = origFn;
  if (!Ext.isFunction(newFn)) 
  {
    return origFn;
  } else {
    returnValue = Ext.isDefined(returnValue) ? returnValue : null;
    return function() {
  var me = this, args = arguments;
  newFn.target = me;
  newFn.method = origFn;
  return (newFn.apply(scope || me || Ext.global, args) !== false) ? origFn.apply(me || Ext.global, args) : returnValue;
};
  }
}, createDelayed: function(fn, delay, scope, args, appendArgs) {
  if (scope || args) 
  {
    fn = Ext.Function.bind(fn, scope, args, appendArgs);
  }
  return function() {
  var me = this, args = Array.prototype.slice.call(arguments);
  setTimeout(function() {
  fn.apply(me, args);
}, delay);
};
}, defer: function(fn, millis, scope, args, appendArgs) {
  fn = Ext.Function.bind(fn, scope, args, appendArgs);
  if (millis > 0) 
  {
    return setTimeout(Ext.supports.TimeoutActualLateness ? function() {
  fn();
} : fn, millis);
  }
  fn();
  return 0;
}, createSequence: function(originalFn, newFn, scope) {
  if (!newFn) 
  {
    return originalFn;
  } else {
    return function() {
  var result = originalFn.apply(this, arguments);
  newFn.apply(scope || this, arguments);
  return result;
};
  }
}, createBuffered: function(fn, buffer, scope, args) {
  var timerId;
  return function() {
  var callArgs = args || Array.prototype.slice.call(arguments, 0), me = scope || this;
  if (timerId) 
  {
    clearTimeout(timerId);
  }
  timerId = setTimeout(function() {
  fn.apply(me, callArgs);
}, buffer);
};
}, createThrottled: function(fn, interval, scope) {
  var lastCallTime, elapsed, lastArgs, timer, execute = function() {
  fn.apply(scope || this, lastArgs);
  lastCallTime = Ext.Date.now();
};
  return function() {
  elapsed = Ext.Date.now() - lastCallTime;
  lastArgs = arguments;
  clearTimeout(timer);
  if (!lastCallTime || (elapsed >= interval)) 
  {
    execute();
  } else {
    timer = setTimeout(execute, interval - elapsed);
  }
};
}, interceptBefore: function(object, methodName, fn, scope) {
  var method = object[methodName] || Ext.emptyFn;
  return (object[methodName] = function() {
  var ret = fn.apply(scope || this, arguments);
  method.apply(this, arguments);
  return ret;
});
}, interceptAfter: function(object, methodName, fn, scope) {
  var method = object[methodName] || Ext.emptyFn;
  return (object[methodName] = function() {
  method.apply(this, arguments);
  return fn.apply(scope || this, arguments);
});
}};
Ext.defer = Ext.Function.alias(Ext.Function, 'defer');
Ext.pass = Ext.Function.alias(Ext.Function, 'pass');
Ext.bind = Ext.Function.alias(Ext.Function, 'bind');

(function() {
  var TemplateClass = function() {
}, ExtObject = Ext.Object = {chain: Object.create || function(object) {
  TemplateClass.prototype = object;
  var result = new TemplateClass();
  TemplateClass.prototype = null;
  return result;
}, clear: function(object) {
  var keys = ExtObject.getKeys(object), n = keys.length;
  while (n--) 
    {
      delete object[keys[n]];
    }
  return object;
}, toQueryObjects: function(name, value, recursive) {
  var self = ExtObject.toQueryObjects, objects = [], i, ln;
  if (Ext.isArray(value)) 
  {
    for (i = 0 , ln = value.length; i < ln; i++) 
      {
        if (recursive) 
        {
          objects = objects.concat(self(name + '[' + i + ']', value[i], true));
        } else {
          objects.push({name: name, value: value[i]});
        }
      }
  } else if (Ext.isObject(value)) 
  {
    for (i in value) 
      {
        if (value.hasOwnProperty(i)) 
        {
          if (recursive) 
          {
            objects = objects.concat(self(name + '[' + i + ']', value[i], true));
          } else {
            objects.push({name: name, value: value[i]});
          }
        }
      }
  } else {
    objects.push({name: name, value: value});
  }
  return objects;
}, toQueryString: function(object, recursive) {
  var paramObjects = [], params = [], i, j, ln, paramObject, value;
  for (i in object) 
    {
      if (object.hasOwnProperty(i)) 
      {
        paramObjects = paramObjects.concat(ExtObject.toQueryObjects(i, object[i], recursive));
      }
    }
  for (j = 0 , ln = paramObjects.length; j < ln; j++) 
    {
      paramObject = paramObjects[j];
      value = paramObject.value;
      if (Ext.isEmpty(value)) 
      {
        value = '';
      } else if (Ext.isDate(value)) 
      {
        value = Ext.Date.toString(value);
      }
      params.push(encodeURIComponent(paramObject.name) + '=' + encodeURIComponent(String(value)));
    }
  return params.join('&');
}, fromQueryString: function(queryString, recursive) {
  var parts = queryString.replace(/^\?/, '').split('&'), object = {}, temp, components, name, value, i, ln, part, j, subLn, matchedKeys, matchedName, keys, key, nextKey;
  for (i = 0 , ln = parts.length; i < ln; i++) 
    {
      part = parts[i];
      if (part.length > 0) 
      {
        components = part.split('=');
        name = decodeURIComponent(components[0]);
        value = (components[1] !== undefined) ? decodeURIComponent(components[1]) : '';
        if (!recursive) 
        {
          if (object.hasOwnProperty(name)) 
          {
            if (!Ext.isArray(object[name])) 
            {
              object[name] = [object[name]];
            }
            object[name].push(value);
          } else {
            object[name] = value;
          }
        } else {
          matchedKeys = name.match(/(\[):?([^\]]*)\]/g);
          matchedName = name.match(/^([^\[]+)/);
          name = matchedName[0];
          keys = [];
          if (matchedKeys === null) 
          {
            object[name] = value;
            continue;
          }
          for (j = 0 , subLn = matchedKeys.length; j < subLn; j++) 
            {
              key = matchedKeys[j];
              key = (key.length === 2) ? '' : key.substring(1, key.length - 1);
              keys.push(key);
            }
          keys.unshift(name);
          temp = object;
          for (j = 0 , subLn = keys.length; j < subLn; j++) 
            {
              key = keys[j];
              if (j === subLn - 1) 
              {
                if (Ext.isArray(temp) && key === '') 
                {
                  temp.push(value);
                } else {
                  temp[key] = value;
                }
              } else {
                if (temp[key] === undefined || typeof temp[key] === 'string') 
                {
                  nextKey = keys[j + 1];
                  temp[key] = (Ext.isNumeric(nextKey) || nextKey === '') ? [] : {};
                }
                temp = temp[key];
              }
            }
        }
      }
    }
  return object;
}, each: function(object, fn, scope) {
  for (var property in object) 
    {
      if (object.hasOwnProperty(property)) 
      {
        if (fn.call(scope || object, property, object[property], object) === false) 
        {
          return;
        }
      }
    }
}, merge: function(destination) {
  var i = 1, ln = arguments.length, mergeFn = ExtObject.merge, cloneFn = Ext.clone, object, key, value, sourceKey;
  for (; i < ln; i++) 
    {
      object = arguments[i];
      for (key in object) 
        {
          value = object[key];
          if (value && value.constructor === Object) 
          {
            sourceKey = destination[key];
            if (sourceKey && sourceKey.constructor === Object) 
            {
              mergeFn(sourceKey, value);
            } else {
              destination[key] = cloneFn(value);
            }
          } else {
            destination[key] = value;
          }
        }
    }
  return destination;
}, mergeIf: function(destination) {
  var i = 1, ln = arguments.length, cloneFn = Ext.clone, object, key, value;
  for (; i < ln; i++) 
    {
      object = arguments[i];
      for (key in object) 
        {
          if (!(key in destination)) 
          {
            value = object[key];
            if (value && value.constructor === Object) 
            {
              destination[key] = cloneFn(value);
            } else {
              destination[key] = value;
            }
          }
        }
    }
  return destination;
}, getKey: function(object, value) {
  for (var property in object) 
    {
      if (object.hasOwnProperty(property) && object[property] === value) 
      {
        return property;
      }
    }
  return null;
}, getValues: function(object) {
  var values = [], property;
  for (property in object) 
    {
      if (object.hasOwnProperty(property)) 
      {
        values.push(object[property]);
      }
    }
  return values;
}, getKeys: (typeof Object.keys == 'function') ? function(object) {
  if (!object) 
  {
    return [];
  }
  return Object.keys(object);
} : function(object) {
  var keys = [], property;
  for (property in object) 
    {
      if (object.hasOwnProperty(property)) 
      {
        keys.push(property);
      }
    }
  return keys;
}, getSize: function(object) {
  var size = 0, property;
  for (property in object) 
    {
      if (object.hasOwnProperty(property)) 
      {
        size++;
      }
    }
  return size;
}, isEmpty: function(object) {
  for (var key in object) 
    {
      if (object.hasOwnProperty(key)) 
      {
        return false;
      }
    }
  return true;
}, equals: (function() {
  var check = function(o1, o2) {
  var key;
  for (key in o1) 
    {
      if (o1.hasOwnProperty(key)) 
      {
        if (o1[key] !== o2[key]) 
        {
          return false;
        }
      }
    }
  return true;
};
  return function(object1, object2) {
  if (object1 === object2) 
  {
    return true;
  }
  if (object1 && object2) 
  {
    return check(object1, object2) && check(object2, object1);
  } else if (!object1 && !object2) 
  {
    return object1 === object2;
  } else {
    return false;
  }
};
})(), classify: function(object) {
  var prototype = object, objectProperties = [], propertyClassesMap = {}, objectClass = function() {
  var i = 0, ln = objectProperties.length, property;
  for (; i < ln; i++) 
    {
      property = objectProperties[i];
      this[property] = new propertyClassesMap[property]();
    }
}, key, value;
  for (key in object) 
    {
      if (object.hasOwnProperty(key)) 
      {
        value = object[key];
        if (value && value.constructor === Object) 
        {
          objectProperties.push(key);
          propertyClassesMap[key] = ExtObject.classify(value);
        }
      }
    }
  objectClass.prototype = prototype;
  return objectClass;
}};
  Ext.merge = Ext.Object.merge;
  Ext.mergeIf = Ext.Object.mergeIf;
  Ext.urlEncode = function() {
  var args = Ext.Array.from(arguments), prefix = '';
  if ((typeof args[1] === 'string')) 
  {
    prefix = args[1] + '&';
    args[1] = false;
  }
  return prefix + ExtObject.toQueryString.apply(ExtObject, args);
};
  Ext.urlDecode = function() {
  return ExtObject.fromQueryString.apply(ExtObject, arguments);
};
}());

Ext.Date = new function() {
  var utilDate = this, stripEscapeRe = /(\\.)/g, hourInfoRe = /([gGhHisucUOPZ]|MS)/, dateInfoRe = /([djzmnYycU]|MS)/, slashRe = /\\/gi, numberTokenRe = /\{(\d+)\}/g, MSFormatRe = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/'), code = ["var me = this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,", "def = me.defaults,", "from = Ext.Number.from,", "results = String(input).match(me.parseRegexes[{0}]);", "if(results){", "{1}", "if(u != null){", "v = new Date(u * 1000);", "}else{", "dt = me.clearTime(new Date);", "y = from(y, from(def.y, dt.getFullYear()));", "m = from(m, from(def.m - 1, dt.getMonth()));", "dayMatched = d !== undefined;", "d = from(d, from(def.d, dt.getDate()));", "if (!dayMatched) {", "dt.setDate(1);", "dt.setMonth(m);", "dt.setFullYear(y);", "daysInMonth = me.getDaysInMonth(dt);", "if (d > daysInMonth) {", "d = daysInMonth;", "}", "}", "h  = from(h, from(def.h, dt.getHours()));", "i  = from(i, from(def.i, dt.getMinutes()));", "s  = from(s, from(def.s, dt.getSeconds()));", "ms = from(ms, from(def.ms, dt.getMilliseconds()));", "if(z >= 0 && y >= 0){", "v = me.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);", "v = !strict? v : (strict === true && (z <= 364 || (me.isLeapYear(v) && z <= 365))? me.add(v, me.DAY, z) : null);", "}else if(strict === true && !me.isValid(y, m + 1, d, h, i, s, ms)){", "v = null;", "}else{", "if (W) {", "year = y || (new Date()).getFullYear();", "jan4 = new Date(year, 0, 4, 0, 0, 0);", "d = jan4.getDay();", "week1monday = new Date(jan4.getTime() - ((d === 0 ? 6 : d - 1) * 86400000));", "v = Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000 + 43200000)));", "} else {", "v = me.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);", "}", "}", "}", "}", "if(v){", "if(zz != null){", "v = me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);", "}else if(o){", "v = me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));", "}", "}", "return v;"].join('\n');
  function xf(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(numberTokenRe, function(m, i) {
  return args[i];
});
  }
  Ext.apply(utilDate, {now: Date.now || function() {
  return +new Date();
}, toString: function(date) {
  var pad = Ext.String.leftPad;
  return date.getFullYear() + "-" + pad(date.getMonth() + 1, 2, '0') + "-" + pad(date.getDate(), 2, '0') + "T" + pad(date.getHours(), 2, '0') + ":" + pad(date.getMinutes(), 2, '0') + ":" + pad(date.getSeconds(), 2, '0');
}, getElapsed: function(dateA, dateB) {
  return Math.abs(dateA - (dateB || utilDate.now()));
}, useStrict: false, formatCodeToRegex: function(character, currentGroup) {
  var p = utilDate.parseCodes[character];
  if (p) 
  {
    p = typeof p == 'function' ? p() : p;
    utilDate.parseCodes[character] = p;
  }
  return p ? Ext.applyIf({c: p.c ? xf(p.c, currentGroup || "{0}") : p.c}, p) : {g: 0, c: null, s: Ext.String.escapeRegex(character)};
}, parseFunctions: {"MS": function(input, strict) {
  var r = (input || '').match(MSFormatRe);
  return r ? new Date(((r[1] || '') + r[2]) * 1) : null;
}, "time": function(input, strict) {
  var num = parseInt(input, 10);
  if (num || num === 0) 
  {
    return new Date(num);
  }
  return null;
}, "timestamp": function(input, strict) {
  var num = parseInt(input, 10);
  if (num || num === 0) 
  {
    return new Date(num * 1000);
  }
  return null;
}}, parseRegexes: [], formatFunctions: {"MS": function() {
  return '\\/Date(' + this.getTime() + ')\\/';
}, "time": function() {
  return this.getTime().toString();
}, "timestamp": function() {
  return utilDate.format(this, 'U');
}}, y2kYear: 50, MILLI: "ms", SECOND: "s", MINUTE: "mi", HOUR: "h", DAY: "d", MONTH: "mo", YEAR: "y", defaults: {}, dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthNumbers: {January: 0, Jan: 0, February: 1, Feb: 1, March: 2, Mar: 2, April: 3, Apr: 3, May: 4, June: 5, Jun: 5, July: 6, Jul: 6, August: 7, Aug: 7, September: 8, Sep: 8, October: 9, Oct: 9, November: 10, Nov: 10, December: 11, Dec: 11}, defaultFormat: "m/d/Y", getShortMonthName: function(month) {
  return Ext.Date.monthNames[month].substring(0, 3);
}, getShortDayName: function(day) {
  return Ext.Date.dayNames[day].substring(0, 3);
}, getMonthNumber: function(name) {
  return Ext.Date.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
}, formatContainsHourInfo: function(format) {
  return hourInfoRe.test(format.replace(stripEscapeRe, ''));
}, formatContainsDateInfo: function(format) {
  return dateInfoRe.test(format.replace(stripEscapeRe, ''));
}, unescapeFormat: function(format) {
  return format.replace(slashRe, '');
}, formatCodes: {d: "Ext.String.leftPad(this.getDate(), 2, '0')", D: "Ext.Date.getShortDayName(this.getDay())", j: "this.getDate()", l: "Ext.Date.dayNames[this.getDay()]", N: "(this.getDay() ? this.getDay() : 7)", S: "Ext.Date.getSuffix(this)", w: "this.getDay()", z: "Ext.Date.getDayOfYear(this)", W: "Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')", F: "Ext.Date.monthNames[this.getMonth()]", m: "Ext.String.leftPad(this.getMonth() + 1, 2, '0')", M: "Ext.Date.getShortMonthName(this.getMonth())", n: "(this.getMonth() + 1)", t: "Ext.Date.getDaysInMonth(this)", L: "(Ext.Date.isLeapYear(this) ? 1 : 0)", o: "(this.getFullYear() + (Ext.Date.getWeekOfYear(this) == 1 && this.getMonth() > 0 ? +1 : (Ext.Date.getWeekOfYear(this) >= 52 && this.getMonth() < 11 ? -1 : 0)))", Y: "Ext.String.leftPad(this.getFullYear(), 4, '0')", y: "('' + this.getFullYear()).substring(2, 4)", a: "(this.getHours() < 12 ? 'am' : 'pm')", A: "(this.getHours() < 12 ? 'AM' : 'PM')", g: "((this.getHours() % 12) ? this.getHours() % 12 : 12)", G: "this.getHours()", h: "Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')", H: "Ext.String.leftPad(this.getHours(), 2, '0')", i: "Ext.String.leftPad(this.getMinutes(), 2, '0')", s: "Ext.String.leftPad(this.getSeconds(), 2, '0')", u: "Ext.String.leftPad(this.getMilliseconds(), 3, '0')", O: "Ext.Date.getGMTOffset(this)", P: "Ext.Date.getGMTOffset(this, true)", T: "Ext.Date.getTimezone(this)", Z: "(this.getTimezoneOffset() * -60)", c: function() {
  var c, code, i, l, e;
  for (c = "Y-m-dTH:i:sP" , code = [] , i = 0 , l = c.length; i < l; ++i) 
    {
      e = c.charAt(i);
      code.push(e == "T" ? "'T'" : utilDate.getFormatCode(e));
    }
  return code.join(" + ");
}, U: "Math.round(this.getTime() / 1000)"}, isValid: function(y, m, d, h, i, s, ms) {
  h = h || 0;
  i = i || 0;
  s = s || 0;
  ms = ms || 0;
  var dt = utilDate.add(new Date(y < 100 ? 100 : y, m - 1, d, h, i, s, ms), utilDate.YEAR, y < 100 ? y - 100 : 0);
  return y == dt.getFullYear() && m == dt.getMonth() + 1 && d == dt.getDate() && h == dt.getHours() && i == dt.getMinutes() && s == dt.getSeconds() && ms == dt.getMilliseconds();
}, parse: function(input, format, strict) {
  var p = utilDate.parseFunctions;
  if (p[format] == null) 
  {
    utilDate.createParser(format);
  }
  return p[format].call(utilDate, input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
}, parseDate: function(input, format, strict) {
  return utilDate.parse(input, format, strict);
}, getFormatCode: function(character) {
  var f = utilDate.formatCodes[character];
  if (f) 
  {
    f = typeof f == 'function' ? f() : f;
    utilDate.formatCodes[character] = f;
  }
  return f || ("'" + Ext.String.escape(character) + "'");
}, createFormat: function(format) {
  var code = [], special = false, ch = '', i;
  for (i = 0; i < format.length; ++i) 
    {
      ch = format.charAt(i);
      if (!special && ch == "\\") 
      {
        special = true;
      } else if (special) 
      {
        special = false;
        code.push("'" + Ext.String.escape(ch) + "'");
      } else {
        code.push(utilDate.getFormatCode(ch));
      }
    }
  utilDate.formatFunctions[format] = Ext.functionFactory("return " + code.join('+'));
}, createParser: function(format) {
  var regexNum = utilDate.parseRegexes.length, currentGroup = 1, calc = [], regex = [], special = false, ch = "", i = 0, len = format.length, atEnd = [], obj;
  for (; i < len; ++i) 
    {
      ch = format.charAt(i);
      if (!special && ch == "\\") 
      {
        special = true;
      } else if (special) 
      {
        special = false;
        regex.push(Ext.String.escape(ch));
      } else {
        obj = utilDate.formatCodeToRegex(ch, currentGroup);
        currentGroup += obj.g;
        regex.push(obj.s);
        if (obj.g && obj.c) 
        {
          if (obj.calcAtEnd) 
          {
            atEnd.push(obj.c);
          } else {
            calc.push(obj.c);
          }
        }
      }
    }
  calc = calc.concat(atEnd);
  utilDate.parseRegexes[regexNum] = new RegExp("^" + regex.join('') + "$", 'i');
  utilDate.parseFunctions[format] = Ext.functionFactory("input", "strict", xf(code, regexNum, calc.join('')));
}, parseCodes: {d: {g: 1, c: "d = parseInt(results[{0}], 10);\n", s: "(3[0-1]|[1-2][0-9]|0[1-9])"}, j: {g: 1, c: "d = parseInt(results[{0}], 10);\n", s: "(3[0-1]|[1-2][0-9]|[1-9])"}, D: function() {
  for (var a = [], i = 0; i < 7; a.push(utilDate.getShortDayName(i)) , ++i) 
    ;
  return {g: 0, c: null, s: "(?:" + a.join("|") + ")"};
}, l: function() {
  return {g: 0, c: null, s: "(?:" + utilDate.dayNames.join("|") + ")"};
}, N: {g: 0, c: null, s: "[1-7]"}, S: {g: 0, c: null, s: "(?:st|nd|rd|th)"}, w: {g: 0, c: null, s: "[0-6]"}, z: {g: 1, c: "z = parseInt(results[{0}], 10);\n", s: "(\\d{1,3})"}, W: {g: 1, c: "W = parseInt(results[{0}], 10);\n", s: "(\\d{2})"}, F: function() {
  return {g: 1, c: "m = parseInt(me.getMonthNumber(results[{0}]), 10);\n", s: "(" + utilDate.monthNames.join("|") + ")"};
}, M: function() {
  for (var a = [], i = 0; i < 12; a.push(utilDate.getShortMonthName(i)) , ++i) 
    ;
  return Ext.applyIf({s: "(" + a.join("|") + ")"}, utilDate.formatCodeToRegex("F"));
}, m: {g: 1, c: "m = parseInt(results[{0}], 10) - 1;\n", s: "(1[0-2]|0[1-9])"}, n: {g: 1, c: "m = parseInt(results[{0}], 10) - 1;\n", s: "(1[0-2]|[1-9])"}, t: {g: 0, c: null, s: "(?:\\d{2})"}, L: {g: 0, c: null, s: "(?:1|0)"}, o: {g: 1, c: "y = parseInt(results[{0}], 10);\n", s: "(\\d{4})"}, Y: {g: 1, c: "y = parseInt(results[{0}], 10);\n", s: "(\\d{4})"}, y: {g: 1, c: "var ty = parseInt(results[{0}], 10);\n" + "y = ty > me.y2kYear ? 1900 + ty : 2000 + ty;\n", s: "(\\d{1,2})"}, a: {g: 1, c: "if (/(am)/i.test(results[{0}])) {\n" + "if (!h || h == 12) { h = 0; }\n" + "} else { if (!h || h < 12) { h = (h || 0) + 12; }}", s: "(am|pm|AM|PM)", calcAtEnd: true}, A: {g: 1, c: "if (/(am)/i.test(results[{0}])) {\n" + "if (!h || h == 12) { h = 0; }\n" + "} else { if (!h || h < 12) { h = (h || 0) + 12; }}", s: "(AM|PM|am|pm)", calcAtEnd: true}, g: {g: 1, c: "h = parseInt(results[{0}], 10);\n", s: "(1[0-2]|[0-9])"}, G: {g: 1, c: "h = parseInt(results[{0}], 10);\n", s: "(2[0-3]|1[0-9]|[0-9])"}, h: {g: 1, c: "h = parseInt(results[{0}], 10);\n", s: "(1[0-2]|0[1-9])"}, H: {g: 1, c: "h = parseInt(results[{0}], 10);\n", s: "(2[0-3]|[0-1][0-9])"}, i: {g: 1, c: "i = parseInt(results[{0}], 10);\n", s: "([0-5][0-9])"}, s: {g: 1, c: "s = parseInt(results[{0}], 10);\n", s: "([0-5][0-9])"}, u: {g: 1, c: "ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n", s: "(\\d+)"}, O: {g: 1, c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", "mn = o.substring(3,5) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"), s: "([+-]\\d{4})"}, P: {g: 1, c: ["o = results[{0}];", "var sn = o.substring(0,1),", "hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", "mn = o.substring(4,6) % 60;", "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join("\n"), s: "([+-]\\d{2}:\\d{2})"}, T: {g: 0, c: null, s: "[A-Z]{1,5}"}, Z: {g: 1, c: "zz = results[{0}] * 1;\n" + "zz = (-43200 <= zz && zz <= 50400)? zz : null;\n", s: "([+-]?\\d{1,5})"}, c: function() {
  var calc = [], arr = [utilDate.formatCodeToRegex("Y", 1), utilDate.formatCodeToRegex("m", 2), utilDate.formatCodeToRegex("d", 3), utilDate.formatCodeToRegex("H", 4), utilDate.formatCodeToRegex("i", 5), utilDate.formatCodeToRegex("s", 6), {c: "ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"}, {c: ["if(results[8]) {", "if(results[8] == 'Z'){", "zz = 0;", "}else if (results[8].indexOf(':') > -1){", utilDate.formatCodeToRegex("P", 8).c, "}else{", utilDate.formatCodeToRegex("O", 8).c, "}", "}"].join('\n')}], i, l;
  for (i = 0 , l = arr.length; i < l; ++i) 
    {
      calc.push(arr[i].c);
    }
  return {g: 1, c: calc.join(""), s: [arr[0].s, "(?:", "-", arr[1].s, "(?:", "-", arr[2].s, "(?:", "(?:T| )?", arr[3].s, ":", arr[4].s, "(?::", arr[5].s, ")?", "(?:(?:\\.|,)(\\d+))?", "(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", ")?", ")?", ")?"].join("")};
}, U: {g: 1, c: "u = parseInt(results[{0}], 10);\n", s: "(-?\\d+)"}}, dateFormat: function(date, format) {
  return utilDate.format(date, format);
}, isEqual: function(date1, date2) {
  if (date1 && date2) 
  {
    return (date1.getTime() === date2.getTime());
  }
  return !(date1 || date2);
}, format: function(date, format) {
  var formatFunctions = utilDate.formatFunctions;
  if (!Ext.isDate(date)) 
  {
    return '';
  }
  if (formatFunctions[format] == null) 
  {
    utilDate.createFormat(format);
  }
  return formatFunctions[format].call(date) + '';
}, getTimezone: function(date) {
  return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, "$1$2").replace(/[^A-Z]/g, "");
}, getGMTOffset: function(date, colon) {
  var offset = date.getTimezoneOffset();
  return (offset > 0 ? "-" : "+") + Ext.String.leftPad(Math.floor(Math.abs(offset) / 60), 2, "0") + (colon ? ":" : "") + Ext.String.leftPad(Math.abs(offset % 60), 2, "0");
}, getDayOfYear: function(date) {
  var num = 0, d = Ext.Date.clone(date), m = date.getMonth(), i;
  for (i = 0 , d.setDate(1) , d.setMonth(0); i < m; d.setMonth(++i)) 
    {
      num += utilDate.getDaysInMonth(d);
    }
  return num + date.getDate() - 1;
}, getWeekOfYear: (function() {
  var ms1d = 86400000, ms7d = 7 * ms1d;
  return function(date) {
  var DC3 = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d, AWN = Math.floor(DC3 / 7), Wyr = new Date(AWN * ms7d).getUTCFullYear();
  return AWN - Math.floor(Date.UTC(Wyr, 0, 7) / ms7d) + 1;
};
}()), isLeapYear: function(date) {
  var year = date.getFullYear();
  return !!((year & 3) == 0 && (year % 100 || (year % 400 == 0 && year)));
}, getFirstDayOfMonth: function(date) {
  var day = (date.getDay() - (date.getDate() - 1)) % 7;
  return (day < 0) ? (day + 7) : day;
}, getLastDayOfMonth: function(date) {
  return utilDate.getLastDateOfMonth(date).getDay();
}, getFirstDateOfMonth: function(date) {
  return new Date(date.getFullYear(), date.getMonth(), 1);
}, getLastDateOfMonth: function(date) {
  return new Date(date.getFullYear(), date.getMonth(), utilDate.getDaysInMonth(date));
}, getDaysInMonth: (function() {
  var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  return function(date) {
  var m = date.getMonth();
  return m == 1 && utilDate.isLeapYear(date) ? 29 : daysInMonth[m];
};
}()), getSuffix: function(date) {
  switch (date.getDate()) {
    case 1:
    case 21:
    case 31:
      return "st";
    case 2:
    case 22:
      return "nd";
    case 3:
    case 23:
      return "rd";
    default:
      return "th";
  }
}, clone: function(date) {
  return new Date(date.getTime());
}, isDST: function(date) {
  return new Date(date.getFullYear(), 0, 1).getTimezoneOffset() != date.getTimezoneOffset();
}, clearTime: function(date, clone) {
  if (clone) 
  {
    return Ext.Date.clearTime(Ext.Date.clone(date));
  }
  var d = date.getDate(), hr, c;
  date.setHours(0);
  date.setMinutes(0);
  date.setSeconds(0);
  date.setMilliseconds(0);
  if (date.getDate() != d) 
  {
    for (hr = 1 , c = utilDate.add(date, Ext.Date.HOUR, hr); c.getDate() != d; hr++ , c = utilDate.add(date, Ext.Date.HOUR, hr)) 
      ;
    date.setDate(d);
    date.setHours(c.getHours());
  }
  return date;
}, add: function(date, interval, value) {
  var d = Ext.Date.clone(date), Date = Ext.Date, day, decimalValue, base = 0;
  if (!interval || value === 0) 
  {
    return d;
  }
  decimalValue = value - parseInt(value, 10);
  value = parseInt(value, 10);
  if (value) 
  {
    switch (interval.toLowerCase()) {
      case Ext.Date.MILLI:
        d.setTime(d.getTime() + value);
        break;
      case Ext.Date.SECOND:
        d.setTime(d.getTime() + value * 1000);
        break;
      case Ext.Date.MINUTE:
        d.setTime(d.getTime() + value * 60 * 1000);
        break;
      case Ext.Date.HOUR:
        d.setTime(d.getTime() + value * 60 * 60 * 1000);
        break;
      case Ext.Date.DAY:
        d.setDate(d.getDate() + value);
        break;
      case Ext.Date.MONTH:
        day = date.getDate();
        if (day > 28) 
        {
          day = Math.min(day, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(date), Ext.Date.MONTH, value)).getDate());
        }
        d.setDate(day);
        d.setMonth(date.getMonth() + value);
        break;
      case Ext.Date.YEAR:
        day = date.getDate();
        if (day > 28) 
        {
          day = Math.min(day, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(date), Ext.Date.YEAR, value)).getDate());
        }
        d.setDate(day);
        d.setFullYear(date.getFullYear() + value);
        break;
    }
  }
  if (decimalValue) 
  {
    switch (interval.toLowerCase()) {
      case Ext.Date.MILLI:
        base = 1;
        break;
      case Ext.Date.SECOND:
        base = 1000;
        break;
      case Ext.Date.MINUTE:
        base = 1000 * 60;
        break;
      case Ext.Date.HOUR:
        base = 1000 * 60 * 60;
        break;
      case Ext.Date.DAY:
        base = 1000 * 60 * 60 * 24;
        break;
      case Ext.Date.MONTH:
        day = utilDate.getDaysInMonth(d);
        base = 1000 * 60 * 60 * 24 * day;
        break;
      case Ext.Date.YEAR:
        day = (utilDate.isLeapYear(d) ? 366 : 365);
        base = 1000 * 60 * 60 * 24 * day;
        break;
    }
    if (base) 
    {
      d.setTime(d.getTime() + base * decimalValue);
    }
  }
  return d;
}, subtract: function(date, interval, value) {
  return utilDate.add(date, interval, -value);
}, between: function(date, start, end) {
  var t = date.getTime();
  return start.getTime() <= t && t <= end.getTime();
}, compat: function() {
  var nativeDate = window.Date, p, statics = ['useStrict', 'formatCodeToRegex', 'parseFunctions', 'parseRegexes', 'formatFunctions', 'y2kYear', 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'MONTH', 'YEAR', 'defaults', 'dayNames', 'monthNames', 'monthNumbers', 'getShortMonthName', 'getShortDayName', 'getMonthNumber', 'formatCodes', 'isValid', 'parseDate', 'getFormatCode', 'createFormat', 'createParser', 'parseCodes'], proto = ['dateFormat', 'format', 'getTimezone', 'getGMTOffset', 'getDayOfYear', 'getWeekOfYear', 'isLeapYear', 'getFirstDayOfMonth', 'getLastDayOfMonth', 'getDaysInMonth', 'getSuffix', 'clone', 'isDST', 'clearTime', 'add', 'between'], sLen = statics.length, pLen = proto.length, stat, prot, s;
  for (s = 0; s < sLen; s++) 
    {
      stat = statics[s];
      nativeDate[stat] = utilDate[stat];
    }
  for (p = 0; p < pLen; p++) 
    {
      prot = proto[p];
      nativeDate.prototype[prot] = function() {
  var args = Array.prototype.slice.call(arguments);
  args.unshift(this);
  return utilDate[prot].apply(utilDate, args);
};
    }
}});
}();

(function(flexSetter) {
  var noArgs = [], Base = function() {
}, hookFunctionFactory = function(hookFunction, underriddenFunction, methodName, owningClass) {
  var result = function() {
  var result = this.callParent(arguments);
  hookFunction.apply(this, arguments);
  return result;
};
  result.$name = methodName;
  result.$owner = owningClass;
  if (underriddenFunction) 
  {
    result.$previous = underriddenFunction.$previous;
    underriddenFunction.$previous = result;
  }
  return result;
};
  Ext.apply(Base, {$className: 'Ext.Base', $isClass: true, create: function() {
  return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
}, extend: function(parent) {
  var parentPrototype = parent.prototype, basePrototype, prototype, i, ln, name, statics;
  prototype = this.prototype = Ext.Object.chain(parentPrototype);
  prototype.self = this;
  this.superclass = prototype.superclass = parentPrototype;
  if (!parent.$isClass) 
  {
    basePrototype = Ext.Base.prototype;
    for (i in basePrototype) 
      {
        if (i in prototype) 
        {
          prototype[i] = basePrototype[i];
        }
      }
  }
  statics = parentPrototype.$inheritableStatics;
  if (statics) 
  {
    for (i = 0 , ln = statics.length; i < ln; i++) 
      {
        name = statics[i];
        if (!this.hasOwnProperty(name)) 
        {
          this[name] = parent[name];
        }
      }
  }
  if (parent.$onExtended) 
  {
    this.$onExtended = parent.$onExtended.slice();
  }
  prototype.config = new prototype.configClass();
  prototype.initConfigList = prototype.initConfigList.slice();
  prototype.initConfigMap = Ext.clone(prototype.initConfigMap);
  prototype.configMap = Ext.Object.chain(prototype.configMap);
}, $onExtended: [], triggerExtended: function() {
  var callbacks = this.$onExtended, ln = callbacks.length, i, callback;
  if (ln > 0) 
  {
    for (i = 0; i < ln; i++) 
      {
        callback = callbacks[i];
        callback.fn.apply(callback.scope || this, arguments);
      }
  }
}, onExtended: function(fn, scope) {
  this.$onExtended.push({fn: fn, scope: scope});
  return this;
}, addConfig: function(config, fullMerge) {
  var prototype = this.prototype, configNameCache = Ext.Class.configNameCache, hasConfig = prototype.configMap, initConfigList = prototype.initConfigList, initConfigMap = prototype.initConfigMap, defaultConfig = prototype.config, initializedName, name, value;
  for (name in config) 
    {
      if (config.hasOwnProperty(name)) 
      {
        if (!hasConfig[name]) 
        {
          hasConfig[name] = true;
        }
        value = config[name];
        initializedName = configNameCache[name].initialized;
        if (!initConfigMap[name] && value !== null && !prototype[initializedName]) 
        {
          initConfigMap[name] = true;
          initConfigList.push(name);
        }
      }
    }
  if (fullMerge) 
  {
    Ext.merge(defaultConfig, config);
  } else {
    Ext.mergeIf(defaultConfig, config);
  }
  prototype.configClass = Ext.Object.classify(defaultConfig);
}, addStatics: function(members) {
  var member, name;
  for (name in members) 
    {
      if (members.hasOwnProperty(name)) 
      {
        member = members[name];
        if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) 
        {
          member.$owner = this;
          member.$name = name;
        }
        this[name] = member;
      }
    }
  return this;
}, addInheritableStatics: function(members) {
  var inheritableStatics, hasInheritableStatics, prototype = this.prototype, name, member;
  inheritableStatics = prototype.$inheritableStatics;
  hasInheritableStatics = prototype.$hasInheritableStatics;
  if (!inheritableStatics) 
  {
    inheritableStatics = prototype.$inheritableStatics = [];
    hasInheritableStatics = prototype.$hasInheritableStatics = {};
  }
  for (name in members) 
    {
      if (members.hasOwnProperty(name)) 
      {
        member = members[name];
        this[name] = member;
        if (!hasInheritableStatics[name]) 
        {
          hasInheritableStatics[name] = true;
          inheritableStatics.push(name);
        }
      }
    }
  return this;
}, addMembers: function(members) {
  var prototype = this.prototype, enumerables = Ext.enumerables, names = [], i, ln, name, member;
  for (name in members) 
    {
      names.push(name);
    }
  if (enumerables) 
  {
    names.push.apply(names, enumerables);
  }
  for (i = 0 , ln = names.length; i < ln; i++) 
    {
      name = names[i];
      if (members.hasOwnProperty(name)) 
      {
        member = members[name];
        if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) 
        {
          member.$owner = this;
          member.$name = name;
        }
        prototype[name] = member;
      }
    }
  return this;
}, addMember: function(name, member) {
  if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) 
  {
    member.$owner = this;
    member.$name = name;
  }
  this.prototype[name] = member;
  return this;
}, implement: function() {
  this.addMembers.apply(this, arguments);
}, borrow: function(fromClass, members) {
  var prototype = this.prototype, fromPrototype = fromClass.prototype, i, ln, name, fn, toBorrow;
  members = Ext.Array.from(members);
  for (i = 0 , ln = members.length; i < ln; i++) 
    {
      name = members[i];
      toBorrow = fromPrototype[name];
      if (typeof toBorrow == 'function') 
      {
        fn = Ext.Function.clone(toBorrow);
        fn.$owner = this;
        fn.$name = name;
        prototype[name] = fn;
      } else {
        prototype[name] = toBorrow;
      }
    }
  return this;
}, override: function(members) {
  var me = this, enumerables = Ext.enumerables, target = me.prototype, cloneFunction = Ext.Function.clone, name, index, member, statics, names, previous;
  if (arguments.length === 2) 
  {
    name = members;
    members = {};
    members[name] = arguments[1];
    enumerables = null;
  }
  do {
    names = [];
    statics = null;
    for (name in members) 
      {
        if (name == 'statics') 
        {
          statics = members[name];
        } else if (name == 'inheritableStatics') 
        {
          me.addInheritableStatics(members[name]);
        } else if (name == 'config') 
        {
          me.addConfig(members[name], true);
        } else {
          names.push(name);
        }
      }
    if (enumerables) 
    {
      names.push.apply(names, enumerables);
    }
    for (index = names.length; index--; ) 
      {
        name = names[index];
        if (members.hasOwnProperty(name)) 
        {
          member = members[name];
          if (typeof member == 'function' && !member.$className && member !== Ext.emptyFn && member !== Ext.identityFn) 
          {
            if (typeof member.$owner != 'undefined') 
            {
              member = cloneFunction(member);
            }
            member.$owner = me;
            member.$name = name;
            previous = target.hasOwnProperty(name) && target[name];
            if (previous) 
            {
              member.$previous = previous;
            }
          }
          target[name] = member;
        }
      }
    target = me;
    members = statics;
  } while (members);
  return this;
}, callParent: function(args) {
  var method;
  return (method = this.callParent.caller) && (method.$previous || ((method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name])).apply(this, args || noArgs);
}, callSuper: function(args) {
  var method;
  return (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
}, mixin: function(name, mixinClass) {
  var me = this, mixin = mixinClass.prototype, prototype = me.prototype, key, statics, i, ln, staticName, mixinValue, hookKey, hookFunction;
  if (typeof mixin.onClassMixedIn != 'undefined') 
  {
    mixin.onClassMixedIn.call(mixinClass, me);
  }
  if (!prototype.hasOwnProperty('mixins')) 
  {
    if ('mixins' in prototype) 
    {
      prototype.mixins = Ext.Object.chain(prototype.mixins);
    } else {
      prototype.mixins = {};
    }
  }
  for (key in mixin) 
    {
      mixinValue = mixin[key];
      if (key === 'mixins') 
      {
        Ext.merge(prototype.mixins, mixinValue);
      } else if (key === 'xhooks') 
      {
        for (hookKey in mixinValue) 
          {
            hookFunction = mixinValue[hookKey];
            hookFunction.$previous = Ext.emptyFn;
            if (prototype.hasOwnProperty(hookKey)) 
            {
              hookFunctionFactory(hookFunction, prototype[hookKey], hookKey, me);
            } else {
              prototype[hookKey] = hookFunctionFactory(hookFunction, null, hookKey, me);
            }
          }
      } else if (!(key === 'mixinId' || key === 'config') && (prototype[key] === undefined)) 
      {
        prototype[key] = mixinValue;
      }
    }
  statics = mixin.$inheritableStatics;
  if (statics) 
  {
    for (i = 0 , ln = statics.length; i < ln; i++) 
      {
        staticName = statics[i];
        if (!me.hasOwnProperty(staticName)) 
        {
          me[staticName] = mixinClass[staticName];
        }
      }
  }
  if ('config' in mixin) 
  {
    me.addConfig(mixin.config, false);
  }
  prototype.mixins[name] = mixin;
  return me;
}, getName: function() {
  return Ext.getClassName(this);
}, createAlias: flexSetter(function(alias, origin) {
  this.override(alias, function() {
  return this[origin].apply(this, arguments);
});
}), addXtype: function(xtype) {
  var prototype = this.prototype, xtypesMap = prototype.xtypesMap, xtypes = prototype.xtypes, xtypesChain = prototype.xtypesChain;
  if (!prototype.hasOwnProperty('xtypesMap')) 
  {
    xtypesMap = prototype.xtypesMap = Ext.merge({}, prototype.xtypesMap || {});
    xtypes = prototype.xtypes = prototype.xtypes ? [].concat(prototype.xtypes) : [];
    xtypesChain = prototype.xtypesChain = prototype.xtypesChain ? [].concat(prototype.xtypesChain) : [];
    prototype.xtype = xtype;
  }
  if (!xtypesMap[xtype]) 
  {
    xtypesMap[xtype] = true;
    xtypes.push(xtype);
    xtypesChain.push(xtype);
    Ext.ClassManager.setAlias(this, 'widget.' + xtype);
  }
  return this;
}});
  Base.implement({isInstance: true, $className: 'Ext.Base', configClass: Ext.emptyFn, initConfigList: [], configMap: {}, initConfigMap: {}, statics: function() {
  var method = this.statics.caller, self = this.self;
  if (!method) 
  {
    return self;
  }
  return method.$owner;
}, callParent: function(args) {
  var method, superMethod = (method = this.callParent.caller) && (method.$previous || ((method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]));
  return superMethod.apply(this, args || noArgs);
}, callSuper: function(args) {
  var method, superMethod = (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
  return superMethod.apply(this, args || noArgs);
}, self: Base, constructor: function() {
  return this;
}, initConfig: function(config) {
  var instanceConfig = config, configNameCache = Ext.Class.configNameCache, defaultConfig = new this.configClass(), defaultConfigList = this.initConfigList, hasConfig = this.configMap, nameMap, i, ln, name, initializedName;
  this.initConfig = Ext.emptyFn;
  this.initialConfig = instanceConfig || {};
  this.config = config = (instanceConfig) ? Ext.merge(defaultConfig, config) : defaultConfig;
  if (instanceConfig) 
  {
    defaultConfigList = defaultConfigList.slice();
    for (name in instanceConfig) 
      {
        if (hasConfig[name]) 
        {
          if (instanceConfig[name] !== null) 
          {
            defaultConfigList.push(name);
            this[configNameCache[name].initialized] = false;
          }
        }
      }
  }
  for (i = 0 , ln = defaultConfigList.length; i < ln; i++) 
    {
      name = defaultConfigList[i];
      nameMap = configNameCache[name];
      initializedName = nameMap.initialized;
      if (!this[initializedName]) 
      {
        this[initializedName] = true;
        this[nameMap.set].call(this, config[name]);
      }
    }
  return this;
}, hasConfig: function(name) {
  return Boolean(this.configMap[name]);
}, setConfig: function(config, applyIfNotSet) {
  if (!config) 
  {
    return this;
  }
  var configNameCache = Ext.Class.configNameCache, currentConfig = this.config, hasConfig = this.configMap, initialConfig = this.initialConfig, name, value;
  applyIfNotSet = Boolean(applyIfNotSet);
  for (name in config) 
    {
      if (applyIfNotSet && initialConfig.hasOwnProperty(name)) 
      {
        continue;
      }
      value = config[name];
      currentConfig[name] = value;
      if (hasConfig[name]) 
      {
        this[configNameCache[name].set](value);
      }
    }
  return this;
}, getConfig: function(name) {
  var configNameCache = Ext.Class.configNameCache;
  return this[configNameCache[name].get]();
}, getInitialConfig: function(name) {
  var config = this.config;
  if (!name) 
  {
    return config;
  } else {
    return config[name];
  }
}, onConfigUpdate: function(names, callback, scope) {
  var self = this.self, i, ln, name, updaterName, updater, newUpdater;
  names = Ext.Array.from(names);
  scope = scope || this;
  for (i = 0 , ln = names.length; i < ln; i++) 
    {
      name = names[i];
      updaterName = 'update' + Ext.String.capitalize(name);
      updater = this[updaterName] || Ext.emptyFn;
      newUpdater = function() {
  updater.apply(this, arguments);
  scope[callback].apply(scope, arguments);
};
      newUpdater.$name = updaterName;
      newUpdater.$owner = self;
      this[updaterName] = newUpdater;
    }
}, destroy: function() {
  this.destroy = Ext.emptyFn;
}});
  Base.prototype.callOverridden = Base.prototype.callParent;
  Ext.Base = Base;
}(Ext.Function.flexSetter));

(function() {
  var ExtClass, Base = Ext.Base, baseStaticMembers = [], baseStaticMember, baseStaticMemberLength;
  for (baseStaticMember in Base) 
    {
      if (Base.hasOwnProperty(baseStaticMember)) 
      {
        baseStaticMembers.push(baseStaticMember);
      }
    }
  baseStaticMemberLength = baseStaticMembers.length;
  function makeCtor(className) {
    function constructor() {
      return this.constructor.apply(this, arguments) || null;
    }
    return constructor;
  }
  Ext.Class = ExtClass = function(Class, data, onCreated) {
  if (typeof Class != 'function') 
  {
    onCreated = data;
    data = Class;
    Class = null;
  }
  if (!data) 
  {
    data = {};
  }
  Class = ExtClass.create(Class, data);
  ExtClass.process(Class, data, onCreated);
  return Class;
};
  Ext.apply(ExtClass, {onBeforeCreated: function(Class, data, hooks) {
  Class.addMembers(data);
  hooks.onCreated.call(Class, Class);
}, create: function(Class, data) {
  var name, i;
  if (!Class) 
  {
    Class = makeCtor();
  }
  for (i = 0; i < baseStaticMemberLength; i++) 
    {
      name = baseStaticMembers[i];
      Class[name] = Base[name];
    }
  return Class;
}, process: function(Class, data, onCreated) {
  var preprocessorStack = data.preprocessors || ExtClass.defaultPreprocessors, registeredPreprocessors = this.preprocessors, hooks = {onBeforeCreated: this.onBeforeCreated}, preprocessors = [], preprocessor, preprocessorsProperties, i, ln, j, subLn, preprocessorProperty;
  delete data.preprocessors;
  for (i = 0 , ln = preprocessorStack.length; i < ln; i++) 
    {
      preprocessor = preprocessorStack[i];
      if (typeof preprocessor == 'string') 
      {
        preprocessor = registeredPreprocessors[preprocessor];
        preprocessorsProperties = preprocessor.properties;
        if (preprocessorsProperties === true) 
        {
          preprocessors.push(preprocessor.fn);
        } else if (preprocessorsProperties) 
        {
          for (j = 0 , subLn = preprocessorsProperties.length; j < subLn; j++) 
            {
              preprocessorProperty = preprocessorsProperties[j];
              if (data.hasOwnProperty(preprocessorProperty)) 
              {
                preprocessors.push(preprocessor.fn);
                break;
              }
            }
        }
      } else {
        preprocessors.push(preprocessor);
      }
    }
  hooks.onCreated = onCreated ? onCreated : Ext.emptyFn;
  hooks.preprocessors = preprocessors;
  this.doProcess(Class, data, hooks);
}, doProcess: function(Class, data, hooks) {
  var me = this, preprocessors = hooks.preprocessors, preprocessor = preprocessors.shift(), doProcess = me.doProcess;
  for (; preprocessor; preprocessor = preprocessors.shift()) 
    {
      if (preprocessor.call(me, Class, data, hooks, doProcess) === false) 
      {
        return;
      }
    }
  hooks.onBeforeCreated.apply(me, arguments);
}, preprocessors: {}, registerPreprocessor: function(name, fn, properties, position, relativeTo) {
  if (!position) 
  {
    position = 'last';
  }
  if (!properties) 
  {
    properties = [name];
  }
  this.preprocessors[name] = {name: name, properties: properties || false, fn: fn};
  this.setDefaultPreprocessorPosition(name, position, relativeTo);
  return this;
}, getPreprocessor: function(name) {
  return this.preprocessors[name];
}, getPreprocessors: function() {
  return this.preprocessors;
}, defaultPreprocessors: [], getDefaultPreprocessors: function() {
  return this.defaultPreprocessors;
}, setDefaultPreprocessors: function(preprocessors) {
  this.defaultPreprocessors = Ext.Array.from(preprocessors);
  return this;
}, setDefaultPreprocessorPosition: function(name, offset, relativeName) {
  var defaultPreprocessors = this.defaultPreprocessors, index;
  if (typeof offset == 'string') 
  {
    if (offset === 'first') 
    {
      defaultPreprocessors.unshift(name);
      return this;
    } else if (offset === 'last') 
    {
      defaultPreprocessors.push(name);
      return this;
    }
    offset = (offset === 'after') ? 1 : -1;
  }
  index = Ext.Array.indexOf(defaultPreprocessors, relativeName);
  if (index !== -1) 
  {
    Ext.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
  }
  return this;
}, configNameCache: {}, getConfigNameMap: function(name) {
  var cache = this.configNameCache, map = cache[name], capitalizedName;
  if (!map) 
  {
    capitalizedName = name.charAt(0).toUpperCase() + name.substr(1);
    map = cache[name] = {internal: name, initialized: '_is' + capitalizedName + 'Initialized', apply: 'apply' + capitalizedName, update: 'update' + capitalizedName, 'set': 'set' + capitalizedName, 'get': 'get' + capitalizedName, doSet: 'doSet' + capitalizedName, changeEvent: name.toLowerCase() + 'change'};
  }
  return map;
}});
  ExtClass.registerPreprocessor('extend', function(Class, data, hooks) {
  var Base = Ext.Base, basePrototype = Base.prototype, extend = data.extend, Parent, parentPrototype, i;
  delete data.extend;
  if (extend && extend !== Object) 
  {
    Parent = extend;
  } else {
    Parent = Base;
  }
  parentPrototype = Parent.prototype;
  if (!Parent.$isClass) 
  {
    for (i in basePrototype) 
      {
        if (!parentPrototype[i]) 
        {
          parentPrototype[i] = basePrototype[i];
        }
      }
  }
  Class.extend(Parent);
  Class.triggerExtended.apply(Class, arguments);
  if (data.onClassExtended) 
  {
    Class.onExtended(data.onClassExtended, Class);
    delete data.onClassExtended;
  }
}, true);
  ExtClass.registerPreprocessor('statics', function(Class, data) {
  Class.addStatics(data.statics);
  delete data.statics;
});
  ExtClass.registerPreprocessor('inheritableStatics', function(Class, data) {
  Class.addInheritableStatics(data.inheritableStatics);
  delete data.inheritableStatics;
});
  ExtClass.registerPreprocessor('config', function(Class, data) {
  var config = data.config, prototype = Class.prototype;
  delete data.config;
  Ext.Object.each(config, function(name, value) {
  var nameMap = ExtClass.getConfigNameMap(name), internalName = nameMap.internal, initializedName = nameMap.initialized, applyName = nameMap.apply, updateName = nameMap.update, setName = nameMap.set, getName = nameMap.get, hasOwnSetter = (setName in prototype) || data.hasOwnProperty(setName), hasOwnApplier = (applyName in prototype) || data.hasOwnProperty(applyName), hasOwnUpdater = (updateName in prototype) || data.hasOwnProperty(updateName), optimizedGetter, customGetter;
  if (value === null || (!hasOwnSetter && !hasOwnApplier && !hasOwnUpdater)) 
  {
    prototype[internalName] = value;
    prototype[initializedName] = true;
  } else {
    prototype[initializedName] = false;
  }
  if (!hasOwnSetter) 
  {
    data[setName] = function(value) {
  var oldValue = this[internalName], applier = this[applyName], updater = this[updateName];
  if (!this[initializedName]) 
  {
    this[initializedName] = true;
  }
  if (applier) 
  {
    value = applier.call(this, value, oldValue);
  }
  if (typeof value != 'undefined') 
  {
    this[internalName] = value;
    if (updater && value !== oldValue) 
    {
      updater.call(this, value, oldValue);
    }
  }
  return this;
};
  }
  if (!(getName in prototype) || data.hasOwnProperty(getName)) 
  {
    customGetter = data[getName] || false;
    if (customGetter) 
    {
      optimizedGetter = function() {
  return customGetter.apply(this, arguments);
};
    } else {
      optimizedGetter = function() {
  return this[internalName];
};
    }
    data[getName] = function() {
  var currentGetter;
  if (!this[initializedName]) 
  {
    this[initializedName] = true;
    this[setName](this.config[name]);
  }
  currentGetter = this[getName];
  if ('$previous' in currentGetter) 
  {
    currentGetter.$previous = optimizedGetter;
  } else {
    this[getName] = optimizedGetter;
  }
  return optimizedGetter.apply(this, arguments);
};
  }
});
  Class.addConfig(config, true);
});
  ExtClass.registerPreprocessor('mixins', function(Class, data, hooks) {
  var mixins = data.mixins, name, mixin, i, ln;
  delete data.mixins;
  Ext.Function.interceptBefore(hooks, 'onCreated', function() {
  if (mixins instanceof Array) 
  {
    for (i = 0 , ln = mixins.length; i < ln; i++) 
      {
        mixin = mixins[i];
        name = mixin.prototype.mixinId || mixin.$className;
        Class.mixin(name, mixin);
      }
  } else {
    for (var mixinName in mixins) 
      {
        if (mixins.hasOwnProperty(mixinName)) 
        {
          Class.mixin(mixinName, mixins[mixinName]);
        }
      }
  }
});
});
  Ext.extend = function(Class, Parent, members) {
  if (arguments.length === 2 && Ext.isObject(Parent)) 
  {
    members = Parent;
    Parent = Class;
    Class = null;
  }
  var cls;
  if (!Parent) 
  {
    throw new Error("[Ext.extend] Attempting to extend from a class which has not been loaded on the page.");
  }
  members.extend = Parent;
  members.preprocessors = ['extend', 'statics', 'inheritableStatics', 'mixins', 'config'];
  if (Class) 
  {
    cls = new ExtClass(Class, members);
    cls.prototype.constructor = Class;
  } else {
    cls = new ExtClass(members);
  }
  cls.prototype.override = function(o) {
  for (var m in o) 
    {
      if (o.hasOwnProperty(m)) 
      {
        this[m] = o[m];
      }
    }
};
  return cls;
};
}());

(function(Class, alias, arraySlice, arrayFrom, global) {
  function makeCtor() {
    function constructor() {
      return this.constructor.apply(this, arguments) || null;
    }
    return constructor;
  }
  var Manager = Ext.ClassManager = {classes: {}, existCache: {}, namespaceRewrites: [{from: 'Ext.', to: Ext}], maps: {alternateToName: {}, aliasToName: {}, nameToAliases: {}, nameToAlternates: {}}, enableNamespaceParseCache: true, namespaceParseCache: {}, instantiators: [], isCreated: function(className) {
  var existCache = this.existCache, i, ln, part, root, parts;
  if (this.classes[className] || existCache[className]) 
  {
    return true;
  }
  root = global;
  parts = this.parseNamespace(className);
  for (i = 0 , ln = parts.length; i < ln; i++) 
    {
      part = parts[i];
      if (typeof part != 'string') 
      {
        root = part;
      } else {
        if (!root || !root[part]) 
        {
          return false;
        }
        root = root[part];
      }
    }
  existCache[className] = true;
  this.triggerCreated(className);
  return true;
}, createdListeners: [], nameCreatedListeners: {}, triggerCreated: function(className) {
  var listeners = this.createdListeners, nameListeners = this.nameCreatedListeners, alternateNames = this.maps.nameToAlternates[className], names = [className], i, ln, j, subLn, listener, name;
  for (i = 0 , ln = listeners.length; i < ln; i++) 
    {
      listener = listeners[i];
      listener.fn.call(listener.scope, className);
    }
  if (alternateNames) 
  {
    names.push.apply(names, alternateNames);
  }
  for (i = 0 , ln = names.length; i < ln; i++) 
    {
      name = names[i];
      listeners = nameListeners[name];
      if (listeners) 
      {
        for (j = 0 , subLn = listeners.length; j < subLn; j++) 
          {
            listener = listeners[j];
            listener.fn.call(listener.scope, name);
          }
        delete nameListeners[name];
      }
    }
}, onCreated: function(fn, scope, className) {
  var listeners = this.createdListeners, nameListeners = this.nameCreatedListeners, listener = {fn: fn, scope: scope};
  if (className) 
  {
    if (this.isCreated(className)) 
    {
      fn.call(scope, className);
      return;
    }
    if (!nameListeners[className]) 
    {
      nameListeners[className] = [];
    }
    nameListeners[className].push(listener);
  } else {
    listeners.push(listener);
  }
}, parseNamespace: function(namespace) {
  var cache = this.namespaceParseCache, parts, rewrites, root, name, rewrite, from, to, i, ln;
  if (this.enableNamespaceParseCache) 
  {
    if (cache.hasOwnProperty(namespace)) 
    {
      return cache[namespace];
    }
  }
  parts = [];
  rewrites = this.namespaceRewrites;
  root = global;
  name = namespace;
  for (i = 0 , ln = rewrites.length; i < ln; i++) 
    {
      rewrite = rewrites[i];
      from = rewrite.from;
      to = rewrite.to;
      if (name === from || name.substring(0, from.length) === from) 
      {
        name = name.substring(from.length);
        if (typeof to != 'string') 
        {
          root = to;
        } else {
          parts = parts.concat(to.split('.'));
        }
        break;
      }
    }
  parts.push(root);
  parts = parts.concat(name.split('.'));
  if (this.enableNamespaceParseCache) 
  {
    cache[namespace] = parts;
  }
  return parts;
}, setNamespace: function(name, value) {
  var root = global, parts = this.parseNamespace(name), ln = parts.length - 1, leaf = parts[ln], i, part;
  for (i = 0; i < ln; i++) 
    {
      part = parts[i];
      if (typeof part != 'string') 
      {
        root = part;
      } else {
        if (!root[part]) 
        {
          root[part] = {};
        }
        root = root[part];
      }
    }
  root[leaf] = value;
  return root[leaf];
}, createNamespaces: function() {
  var root = global, parts, part, i, j, ln, subLn;
  for (i = 0 , ln = arguments.length; i < ln; i++) 
    {
      parts = this.parseNamespace(arguments[i]);
      for (j = 0 , subLn = parts.length; j < subLn; j++) 
        {
          part = parts[j];
          if (typeof part != 'string') 
          {
            root = part;
          } else {
            if (!root[part]) 
            {
              root[part] = {};
            }
            root = root[part];
          }
        }
    }
  return root;
}, set: function(name, value) {
  var me = this, maps = me.maps, nameToAlternates = maps.nameToAlternates, targetName = me.getName(value), alternates;
  me.classes[name] = me.setNamespace(name, value);
  if (targetName && targetName !== name) 
  {
    maps.alternateToName[name] = targetName;
    alternates = nameToAlternates[targetName] || (nameToAlternates[targetName] = []);
    alternates.push(name);
  }
  return this;
}, get: function(name) {
  var classes = this.classes, root, parts, part, i, ln;
  if (classes[name]) 
  {
    return classes[name];
  }
  root = global;
  parts = this.parseNamespace(name);
  for (i = 0 , ln = parts.length; i < ln; i++) 
    {
      part = parts[i];
      if (typeof part != 'string') 
      {
        root = part;
      } else {
        if (!root || !root[part]) 
        {
          return null;
        }
        root = root[part];
      }
    }
  return root;
}, setAlias: function(cls, alias) {
  var aliasToNameMap = this.maps.aliasToName, nameToAliasesMap = this.maps.nameToAliases, className;
  if (typeof cls == 'string') 
  {
    className = cls;
  } else {
    className = this.getName(cls);
  }
  if (alias && aliasToNameMap[alias] !== className) 
  {
    aliasToNameMap[alias] = className;
  }
  if (!nameToAliasesMap[className]) 
  {
    nameToAliasesMap[className] = [];
  }
  if (alias) 
  {
    Ext.Array.include(nameToAliasesMap[className], alias);
  }
  return this;
}, addNameAliasMappings: function(aliases) {
  var aliasToNameMap = this.maps.aliasToName, nameToAliasesMap = this.maps.nameToAliases, className, aliasList, alias, i;
  for (className in aliases) 
    {
      aliasList = nameToAliasesMap[className] || (nameToAliasesMap[className] = []);
      for (i = 0; i < aliases[className].length; i++) 
        {
          alias = aliases[className][i];
          if (!aliasToNameMap[alias]) 
          {
            aliasToNameMap[alias] = className;
            aliasList.push(alias);
          }
        }
    }
  return this;
}, addNameAlternateMappings: function(alternates) {
  var alternateToName = this.maps.alternateToName, nameToAlternates = this.maps.nameToAlternates, className, aliasList, alternate, i;
  for (className in alternates) 
    {
      aliasList = nameToAlternates[className] || (nameToAlternates[className] = []);
      for (i = 0; i < alternates[className].length; i++) 
        {
          alternate = alternates[className][i];
          if (!alternateToName[alternate]) 
          {
            alternateToName[alternate] = className;
            aliasList.push(alternate);
          }
        }
    }
  return this;
}, getByAlias: function(alias) {
  return this.get(this.getNameByAlias(alias));
}, getNameByAlias: function(alias) {
  return this.maps.aliasToName[alias] || '';
}, getNameByAlternate: function(alternate) {
  return this.maps.alternateToName[alternate] || '';
}, getAliasesByName: function(name) {
  return this.maps.nameToAliases[name] || [];
}, getName: function(object) {
  return object && object.$className || '';
}, getClass: function(object) {
  return object && object.self || null;
}, create: function(className, data, createdFn) {
  var ctor = makeCtor();
  if (typeof data == 'function') 
  {
    data = data(ctor);
  }
  data.$className = className;
  return new Class(ctor, data, function() {
  var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors, registeredPostprocessors = Manager.postprocessors, postprocessors = [], postprocessor, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;
  delete data.postprocessors;
  for (i = 0 , ln = postprocessorStack.length; i < ln; i++) 
    {
      postprocessor = postprocessorStack[i];
      if (typeof postprocessor == 'string') 
      {
        postprocessor = registeredPostprocessors[postprocessor];
        postprocessorProperties = postprocessor.properties;
        if (postprocessorProperties === true) 
        {
          postprocessors.push(postprocessor.fn);
        } else if (postprocessorProperties) 
        {
          for (j = 0 , subLn = postprocessorProperties.length; j < subLn; j++) 
            {
              postprocessorProperty = postprocessorProperties[j];
              if (data.hasOwnProperty(postprocessorProperty)) 
              {
                postprocessors.push(postprocessor.fn);
                break;
              }
            }
        }
      } else {
        postprocessors.push(postprocessor);
      }
    }
  data.postprocessors = postprocessors;
  data.createdFn = createdFn;
  Manager.processCreate(className, this, data);
});
}, processCreate: function(className, cls, clsData) {
  var me = this, postprocessor = clsData.postprocessors.shift(), createdFn = clsData.createdFn;
  if (!postprocessor) 
  {
    if (className) 
    {
      me.set(className, cls);
    }
    if (createdFn) 
    {
      createdFn.call(cls, cls);
    }
    if (className) 
    {
      me.triggerCreated(className);
    }
    return;
  }
  if (postprocessor.call(me, className, cls, clsData, me.processCreate) !== false) 
  {
    me.processCreate(className, cls, clsData);
  }
}, createOverride: function(className, data, createdFn) {
  var me = this, overriddenClassName = data.override, requires = data.requires, uses = data.uses, compat = data.compatibility, classReady = function() {
  var cls, temp;
  if (requires) 
  {
    temp = requires;
    requires = null;
    Ext.Loader.require(temp, classReady);
  } else {
    cls = me.get(overriddenClassName);
    delete data.override;
    delete data.compatibility;
    delete data.requires;
    delete data.uses;
    Ext.override(cls, data);
    me.triggerCreated(className);
    if (uses) 
    {
      Ext.Loader.addUsedClasses(uses);
    }
    if (createdFn) 
    {
      createdFn.call(cls);
    }
  }
};
  me.existCache[className] = true;
  if (!compat || Ext.checkVersion(compat)) 
  {
    me.onCreated(classReady, me, overriddenClassName);
  }
  return me;
}, instantiateByAlias: function() {
  var alias = arguments[0], args = arraySlice.call(arguments), className = this.getNameByAlias(alias);
  if (!className) 
  {
    className = this.maps.aliasToName[alias];
    Ext.syncRequire(className);
  }
  args[0] = className;
  return this.instantiate.apply(this, args);
}, instantiate: function() {
  var name = arguments[0], nameType = typeof name, args = arraySlice.call(arguments, 1), alias = name, possibleName, cls;
  if (nameType != 'function') 
  {
    if (nameType != 'string' && args.length === 0) 
    {
      args = [name];
      name = name.xclass;
    }
    cls = this.get(name);
  } else {
    cls = name;
  }
  if (!cls) 
  {
    possibleName = this.getNameByAlias(name);
    if (possibleName) 
    {
      name = possibleName;
      cls = this.get(name);
    }
  }
  if (!cls) 
  {
    possibleName = this.getNameByAlternate(name);
    if (possibleName) 
    {
      name = possibleName;
      cls = this.get(name);
    }
  }
  if (!cls) 
  {
    Ext.syncRequire(name);
    cls = this.get(name);
  }
  return this.getInstantiator(args.length)(cls, args);
}, dynInstantiate: function(name, args) {
  args = arrayFrom(args, true);
  args.unshift(name);
  return this.instantiate.apply(this, args);
}, getInstantiator: function(length) {
  var instantiators = this.instantiators, instantiator, i, args;
  instantiator = instantiators[length];
  if (!instantiator) 
  {
    i = length;
    args = [];
    for (i = 0; i < length; i++) 
      {
        args.push('a[' + i + ']');
      }
    instantiator = instantiators[length] = new Function('c', 'a', 'return new c(' + args.join(',') + ')');
  }
  return instantiator;
}, postprocessors: {}, defaultPostprocessors: [], registerPostprocessor: function(name, fn, properties, position, relativeTo) {
  if (!position) 
  {
    position = 'last';
  }
  if (!properties) 
  {
    properties = [name];
  }
  this.postprocessors[name] = {name: name, properties: properties || false, fn: fn};
  this.setDefaultPostprocessorPosition(name, position, relativeTo);
  return this;
}, setDefaultPostprocessors: function(postprocessors) {
  this.defaultPostprocessors = arrayFrom(postprocessors);
  return this;
}, setDefaultPostprocessorPosition: function(name, offset, relativeName) {
  var defaultPostprocessors = this.defaultPostprocessors, index;
  if (typeof offset == 'string') 
  {
    if (offset === 'first') 
    {
      defaultPostprocessors.unshift(name);
      return this;
    } else if (offset === 'last') 
    {
      defaultPostprocessors.push(name);
      return this;
    }
    offset = (offset === 'after') ? 1 : -1;
  }
  index = Ext.Array.indexOf(defaultPostprocessors, relativeName);
  if (index !== -1) 
  {
    Ext.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
  }
  return this;
}, getNamesByExpression: function(expression) {
  var nameToAliasesMap = this.maps.nameToAliases, names = [], name, alias, aliases, possibleName, regex, i, ln;
  if (expression.indexOf('*') !== -1) 
  {
    expression = expression.replace(/\*/g, '(.*?)');
    regex = new RegExp('^' + expression + '$');
    for (name in nameToAliasesMap) 
      {
        if (nameToAliasesMap.hasOwnProperty(name)) 
        {
          aliases = nameToAliasesMap[name];
          if (name.search(regex) !== -1) 
          {
            names.push(name);
          } else {
            for (i = 0 , ln = aliases.length; i < ln; i++) 
              {
                alias = aliases[i];
                if (alias.search(regex) !== -1) 
                {
                  names.push(name);
                  break;
                }
              }
          }
        }
      }
  } else {
    possibleName = this.getNameByAlias(expression);
    if (possibleName) 
    {
      names.push(possibleName);
    } else {
      possibleName = this.getNameByAlternate(expression);
      if (possibleName) 
      {
        names.push(possibleName);
      } else {
        names.push(expression);
      }
    }
  }
  return names;
}};
  Manager.registerPostprocessor('alias', function(name, cls, data) {
  var aliases = data.alias, i, ln;
  for (i = 0 , ln = aliases.length; i < ln; i++) 
    {
      alias = aliases[i];
      this.setAlias(cls, alias);
    }
}, ['xtype', 'alias']);
  Manager.registerPostprocessor('singleton', function(name, cls, data, fn) {
  if (data.singleton) 
  {
    fn.call(this, name, new cls(), data);
  } else {
    return true;
  }
  return false;
});
  Manager.registerPostprocessor('alternateClassName', function(name, cls, data) {
  var alternates = data.alternateClassName, i, ln, alternate;
  if (!(alternates instanceof Array)) 
  {
    alternates = [alternates];
  }
  for (i = 0 , ln = alternates.length; i < ln; i++) 
    {
      alternate = alternates[i];
      this.set(alternate, cls);
    }
});
  Ext.apply(Ext, {create: alias(Manager, 'instantiate'), widget: function(name, config) {
  var xtype = name, alias, className, T, load;
  if (typeof xtype != 'string') 
  {
    config = name;
    xtype = config.xtype;
  } else {
    config = config || {};
  }
  if (config.isComponent) 
  {
    return config;
  }
  alias = 'widget.' + xtype;
  className = Manager.getNameByAlias(alias);
  if (!className) 
  {
    load = true;
  }
  T = Manager.get(className);
  if (load || !T) 
  {
    return Manager.instantiateByAlias(alias, config);
  }
  return new T(config);
}, createByAlias: alias(Manager, 'instantiateByAlias'), define: function(className, data, createdFn) {
  if (data.override) 
  {
    return Manager.createOverride.apply(Manager, arguments);
  }
  return Manager.create.apply(Manager, arguments);
}, undefine: function(className) {
  var classes = Manager.classes, maps = Manager.maps, aliasToName = maps.aliasToName, nameToAliases = maps.nameToAliases, alternateToName = maps.alternateToName, nameToAlternates = maps.nameToAlternates, aliases = nameToAliases[className], alternates = nameToAlternates[className], parts, partCount, namespace, i;
  delete Manager.namespaceParseCache[className];
  delete nameToAliases[className];
  delete nameToAlternates[className];
  delete classes[className];
  if (aliases) 
  {
    for (i = aliases.length; i--; ) 
      {
        delete aliasToName[aliases[i]];
      }
  }
  if (alternates) 
  {
    for (i = alternates.length; i--; ) 
      {
        delete alternateToName[alternates[i]];
      }
  }
  parts = Manager.parseNamespace(className);
  partCount = parts.length - 1;
  namespace = parts[0];
  for (i = 1; i < partCount; i++) 
    {
      namespace = namespace[parts[i]];
      if (!namespace) 
      {
        return;
      }
    }
  try {
    delete namespace[parts[partCount]];
  }  catch (e) {
  namespace[parts[partCount]] = undefined;
}
}, getClassName: alias(Manager, 'getName'), getDisplayName: function(object) {
  if (object) 
  {
    if (object.displayName) 
    {
      return object.displayName;
    }
    if (object.$name && object.$class) 
    {
      return Ext.getClassName(object.$class) + '#' + object.$name;
    }
    if (object.$className) 
    {
      return object.$className;
    }
  }
  return 'Anonymous';
}, getClass: alias(Manager, 'getClass'), namespace: alias(Manager, 'createNamespaces')});
  Ext.createWidget = Ext.widget;
  Ext.ns = Ext.namespace;
  Class.registerPreprocessor('className', function(cls, data) {
  if ('$className' in data) 
  {
    cls.$className = data.$className;
  }
}, true, 'first');
  Class.registerPreprocessor('alias', function(cls, data) {
  var prototype = cls.prototype, xtypes = arrayFrom(data.xtype), aliases = arrayFrom(data.alias), widgetPrefix = 'widget.', widgetPrefixLength = widgetPrefix.length, xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []), xtypesMap = Ext.merge({}, prototype.xtypesMap || {}), i, ln, alias, xtype;
  for (i = 0 , ln = aliases.length; i < ln; i++) 
    {
      alias = aliases[i];
      if (alias.substring(0, widgetPrefixLength) === widgetPrefix) 
      {
        xtype = alias.substring(widgetPrefixLength);
        Ext.Array.include(xtypes, xtype);
      }
    }
  cls.xtype = data.xtype = xtypes[0];
  data.xtypes = xtypes;
  for (i = 0 , ln = xtypes.length; i < ln; i++) 
    {
      xtype = xtypes[i];
      if (!xtypesMap[xtype]) 
      {
        xtypesMap[xtype] = true;
        xtypesChain.push(xtype);
      }
    }
  data.xtypesChain = xtypesChain;
  data.xtypesMap = xtypesMap;
  Ext.Function.interceptAfter(data, 'onClassCreated', function() {
  var mixins = prototype.mixins, key, mixin;
  for (key in mixins) 
    {
      if (mixins.hasOwnProperty(key)) 
      {
        mixin = mixins[key];
        xtypes = mixin.xtypes;
        if (xtypes) 
        {
          for (i = 0 , ln = xtypes.length; i < ln; i++) 
            {
              xtype = xtypes[i];
              if (!xtypesMap[xtype]) 
              {
                xtypesMap[xtype] = true;
                xtypesChain.push(xtype);
              }
            }
        }
      }
    }
});
  for (i = 0 , ln = xtypes.length; i < ln; i++) 
    {
      xtype = xtypes[i];
      Ext.Array.include(aliases, widgetPrefix + xtype);
    }
  data.alias = aliases;
}, ['xtype', 'alias']);
}(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global));
if (Ext._alternatesMetadata) 
{
  Ext.ClassManager.addNameAlternateMappings(Ext._alternatesMetadata);
  Ext._alternatesMetadata = null;
}
if (Ext._aliasMetadata) 
{
  Ext.ClassManager.addNameAliasMappings(Ext._aliasMetadata);
  Ext._aliasMetadata = null;
}

Ext.Loader = new function() {
  var Loader = this, Manager = Ext.ClassManager, Class = Ext.Class, flexSetter = Ext.Function.flexSetter, alias = Ext.Function.alias, pass = Ext.Function.pass, defer = Ext.Function.defer, arrayErase = Ext.Array.erase, dependencyProperties = ['extend', 'mixins', 'requires'], isInHistory = {}, history = [], slashDotSlashRe = /\/\.\//g, dotRe = /\./g, setPathCount = 0;
  Ext.apply(Loader, {isInHistory: isInHistory, history: history, config: {enabled: false, scriptChainDelay: false, disableCaching: true, disableCachingParam: '_dc', garbageCollect: false, paths: {'Ext': '.'}, preserveScripts: true, scriptCharset: undefined}, setConfig: function(name, value) {
  if (Ext.isObject(name) && arguments.length === 1) 
  {
    Ext.merge(Loader.config, name);
    if ('paths' in name) 
    {
      Ext.app.collectNamespaces(name.paths);
    }
  } else {
    Loader.config[name] = (Ext.isObject(value)) ? Ext.merge(Loader.config[name], value) : value;
    if (name === 'paths') 
    {
      Ext.app.collectNamespaces(value);
    }
  }
  return Loader;
}, getConfig: function(name) {
  if (name) 
  {
    return Loader.config[name];
  }
  return Loader.config;
}, setPath: flexSetter(function(name, path) {
  Loader.config.paths[name] = path;
  Ext.app.namespaces[name] = true;
  setPathCount++;
  return Loader;
}), addClassPathMappings: function(paths) {
  var name;
  if (setPathCount == 0) 
  {
    Loader.config.paths = paths;
  } else {
    for (name in paths) 
      {
        Loader.config.paths[name] = paths[name];
      }
  }
  setPathCount++;
  return Loader;
}, getPath: function(className) {
  var path = '', paths = Loader.config.paths, prefix = Loader.getPrefix(className);
  if (prefix.length > 0) 
  {
    if (prefix === className) 
    {
      return paths[prefix];
    }
    path = paths[prefix];
    className = className.substring(prefix.length + 1);
  }
  if (path.length > 0) 
  {
    path += '/';
  }
  return path.replace(slashDotSlashRe, '/') + className.replace(dotRe, "/") + '.js';
}, getPrefix: function(className) {
  var paths = Loader.config.paths, prefix, deepestPrefix = '';
  if (paths.hasOwnProperty(className)) 
  {
    return className;
  }
  for (prefix in paths) 
    {
      if (paths.hasOwnProperty(prefix) && prefix + '.' === className.substring(0, prefix.length + 1)) 
      {
        if (prefix.length > deepestPrefix.length) 
        {
          deepestPrefix = prefix;
        }
      }
    }
  return deepestPrefix;
}, isAClassNameWithAKnownPrefix: function(className) {
  var prefix = Loader.getPrefix(className);
  return prefix !== '' && prefix !== className;
}, require: function(expressions, fn, scope, excludes) {
  if (fn) 
  {
    fn.call(scope);
  }
}, syncRequire: function() {
}, exclude: function(excludes) {
  return {require: function(expressions, fn, scope) {
  return Loader.require(expressions, fn, scope, excludes);
}, syncRequire: function(expressions, fn, scope) {
  return Loader.syncRequire(expressions, fn, scope, excludes);
}};
}, onReady: function(fn, scope, withDomReady, options) {
  var oldFn;
  if (withDomReady !== false && Ext.onDocumentReady) 
  {
    oldFn = fn;
    fn = function() {
  Ext.onDocumentReady(oldFn, scope, options);
};
  }
  fn.call(scope);
}});
  var queue = [], isClassFileLoaded = {}, isFileLoaded = {}, inFlight = {}, classNameToFilePathMap = {}, scriptElements = {}, readyListeners = [], usedClasses = [], requiresMap = {}, comparePriority = function(listenerA, listenerB) {
  return listenerB.priority - listenerA.priority;
};
  Ext.apply(Loader, {documentHead: typeof document != 'undefined' && (document.head || document.getElementsByTagName('head')[0]), isLoading: false, queue: queue, isClassFileLoaded: isClassFileLoaded, isFileLoaded: isFileLoaded, readyListeners: readyListeners, optionalRequires: usedClasses, requiresMap: requiresMap, numPendingFiles: 0, numLoadedFiles: 0, hasFileLoadError: false, classNameToFilePathMap: classNameToFilePathMap, scriptsLoading: 0, syncModeEnabled: false, scriptElements: scriptElements, refreshQueue: function() {
  var ln = queue.length, i, item, j, requires;
  if (!ln && !Loader.scriptsLoading) 
  {
    return Loader.triggerReady();
  }
  for (i = 0; i < ln; i++) 
    {
      item = queue[i];
      if (item) 
      {
        requires = item.requires;
        for (j = 0; j < requires.length; ) 
          {
            if (Manager.isCreated(requires[j])) 
            {
              arrayErase(requires, j, 1);
            } else {
              j++;
            }
          }
        if (item.requires.length === 0) 
        {
          arrayErase(queue, i, 1);
          item.callback.call(item.scope);
          Loader.refreshQueue();
          break;
        }
      }
    }
  return Loader;
}, injectScriptElement: function(url, onLoad, onError, scope, charset) {
  var script = document.createElement('script'), dispatched = false, config = Loader.config, onLoadFn = function() {
  if (!dispatched) 
  {
    dispatched = true;
    script.onload = script.onreadystatechange = script.onerror = null;
    if (typeof config.scriptChainDelay == 'number') 
    {
      defer(onLoad, config.scriptChainDelay, scope);
    } else {
      onLoad.call(scope);
    }
    Loader.cleanupScriptElement(script, config.preserveScripts === false, config.garbageCollect);
  }
}, onErrorFn = function(arg) {
  defer(onError, 1, scope);
  Loader.cleanupScriptElement(script, config.preserveScripts === false, config.garbageCollect);
};
  script.type = 'text/javascript';
  script.onerror = onErrorFn;
  charset = charset || config.scriptCharset;
  if (charset) 
  {
    script.charset = charset;
  }
  if ('addEventListener' in script) 
  {
    script.onload = onLoadFn;
  } else if ('readyState' in script) 
  {
    script.onreadystatechange = function() {
  if (this.readyState == 'loaded' || this.readyState == 'complete') 
  {
    onLoadFn();
  }
};
  } else {
    script.onload = onLoadFn;
  }
  script.src = url;
  (Loader.documentHead || document.getElementsByTagName('head')[0]).appendChild(script);
  return script;
}, removeScriptElement: function(url) {
  if (scriptElements[url]) 
  {
    Loader.cleanupScriptElement(scriptElements[url], true, !!Loader.getConfig('garbageCollect'));
    delete scriptElements[url];
  }
  return Loader;
}, cleanupScriptElement: function(script, remove, collect) {
  var prop;
  script.onload = script.onreadystatechange = script.onerror = null;
  if (remove) 
  {
    Ext.removeNode(script);
    if (collect) 
    {
      for (prop in script) 
        {
          try {
            if (prop != 'src') 
            {
              script[prop] = null;
            }
            delete script[prop];
          }          catch (cleanEx) {
}
        }
    }
  }
  return Loader;
}, loadScript: function(options) {
  var config = Loader.getConfig(), isString = typeof options == 'string', url = isString ? options : options.url, onError = !isString && options.onError, onLoad = !isString && options.onLoad, scope = !isString && options.scope, onScriptError = function() {
  Loader.numPendingFiles--;
  Loader.scriptsLoading--;
  if (onError) 
  {
    onError.call(scope, "Failed loading '" + url + "', please verify that the file exists");
  }
  if (Loader.numPendingFiles + Loader.scriptsLoading === 0) 
  {
    Loader.refreshQueue();
  }
}, onScriptLoad = function() {
  Loader.numPendingFiles--;
  Loader.scriptsLoading--;
  if (onLoad) 
  {
    onLoad.call(scope);
  }
  if (Loader.numPendingFiles + Loader.scriptsLoading === 0) 
  {
    Loader.refreshQueue();
  }
}, src;
  Loader.isLoading = true;
  Loader.numPendingFiles++;
  Loader.scriptsLoading++;
  src = config.disableCaching ? (url + (url.indexOf('?') === -1 ? '?' : '&') + config.disableCachingParam + '=' + Ext.Date.now()) : url;
  scriptElements[url] = Loader.injectScriptElement(src, onScriptLoad, onScriptError);
}, loadScriptFile: function(url, onLoad, onError, scope, synchronous) {
  var config = Loader.getConfig(), noCacheUrl = url + (config.disableCaching ? ('?' + config.disableCachingParam + '=' + Ext.Date.now()) : ''), isCrossOriginRestricted = false, xhr, status, onScriptError, debugSourceURL = "";
  scope = scope || Loader;
  Loader.isLoading = true;
  if (!synchronous) 
  {
    onScriptError = function() {
};
    scriptElements[url] = Loader.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);
  } else {
    if (typeof XMLHttpRequest != 'undefined') 
    {
      xhr = new XMLHttpRequest();
    } else {
      xhr = new ActiveXObject('Microsoft.XMLHTTP');
    }
    try {
      xhr.open('GET', noCacheUrl, false);
      xhr.send(null);
    }    catch (e) {
  isCrossOriginRestricted = true;
}
    status = (xhr.status === 1223) ? 204 : (xhr.status === 0 && ((self.location || {}).protocol == 'file:' || (self.location || {}).protocol == 'ionp:')) ? 200 : xhr.status;
    isCrossOriginRestricted = isCrossOriginRestricted || (status === 0);
    if (isCrossOriginRestricted) 
    {
    } else if ((status >= 200 && status < 300) || (status === 304)) 
    {
      if (!Ext.isIE) 
      {
        debugSourceURL = "\n//@ sourceURL=" + url;
      }
      Ext.globalEval(xhr.responseText + debugSourceURL);
      onLoad.call(scope);
    } else {
    }
    xhr = null;
  }
}, syncRequire: function() {
  var syncModeEnabled = Loader.syncModeEnabled;
  if (!syncModeEnabled) 
  {
    Loader.syncModeEnabled = true;
  }
  Loader.require.apply(Loader, arguments);
  if (!syncModeEnabled) 
  {
    Loader.syncModeEnabled = false;
  }
  Loader.refreshQueue();
}, require: function(expressions, fn, scope, excludes) {
  var excluded = {}, included = {}, excludedClassNames = [], possibleClassNames = [], classNames = [], references = [], callback, syncModeEnabled, filePath, expression, exclude, className, possibleClassName, i, j, ln, subLn;
  if (excludes) 
  {
    excludes = (typeof excludes === 'string') ? [excludes] : excludes;
    for (i = 0 , ln = excludes.length; i < ln; i++) 
      {
        exclude = excludes[i];
        if (typeof exclude == 'string' && exclude.length > 0) 
        {
          excludedClassNames = Manager.getNamesByExpression(exclude);
          for (j = 0 , subLn = excludedClassNames.length; j < subLn; j++) 
            {
              excluded[excludedClassNames[j]] = true;
            }
        }
      }
  }
  expressions = (typeof expressions === 'string') ? [expressions] : (expressions ? expressions : []);
  if (fn) 
  {
    if (fn.length > 0) 
    {
      callback = function() {
  var classes = [], i, ln;
  for (i = 0 , ln = references.length; i < ln; i++) 
    {
      classes.push(Manager.get(references[i]));
    }
  return fn.apply(this, classes);
};
    } else {
      callback = fn;
    }
  } else {
    callback = Ext.emptyFn;
  }
  scope = scope || Ext.global;
  for (i = 0 , ln = expressions.length; i < ln; i++) 
    {
      expression = expressions[i];
      if (typeof expression == 'string' && expression.length > 0) 
      {
        possibleClassNames = Manager.getNamesByExpression(expression);
        subLn = possibleClassNames.length;
        for (j = 0; j < subLn; j++) 
          {
            possibleClassName = possibleClassNames[j];
            if (excluded[possibleClassName] !== true) 
            {
              references.push(possibleClassName);
              if (!Manager.isCreated(possibleClassName) && !included[possibleClassName]) 
              {
                included[possibleClassName] = true;
                classNames.push(possibleClassName);
              }
            }
          }
      }
    }
  if (classNames.length > 0) 
  {
    if (!Loader.config.enabled) 
    {
      throw new Error("Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. " + "Missing required class" + ((classNames.length > 1) ? "es" : "") + ": " + classNames.join(', '));
    }
  } else {
    callback.call(scope);
    return Loader;
  }
  syncModeEnabled = Loader.syncModeEnabled;
  if (!syncModeEnabled) 
  {
    queue.push({requires: classNames.slice(), callback: callback, scope: scope});
  }
  ln = classNames.length;
  for (i = 0; i < ln; i++) 
    {
      className = classNames[i];
      filePath = Loader.getPath(className);
      if (syncModeEnabled && isClassFileLoaded.hasOwnProperty(className)) 
      {
        if (!isClassFileLoaded[className]) 
        {
          Loader.numPendingFiles--;
          Loader.removeScriptElement(filePath);
          delete isClassFileLoaded[className];
        }
      }
      if (!isClassFileLoaded.hasOwnProperty(className)) 
      {
        if (Loader.isFileLoaded[filePath] || inFlight[filePath]) 
        {
          isClassFileLoaded[className] = true;
        } else {
          inFlight[filePath] = true;
          isClassFileLoaded[className] = false;
          Loader.numPendingFiles++;
          Loader.loadScriptFile(filePath, pass(Loader.onFileLoaded, [className, filePath], Loader), pass(Loader.onFileLoadError, [className, filePath], Loader), Loader, syncModeEnabled);
        }
        classNameToFilePathMap[className] = filePath;
      }
    }
  if (syncModeEnabled) 
  {
    callback.call(scope);
    if (ln === 1) 
    {
      return Manager.get(className);
    }
  }
  return Loader;
}, onFileLoaded: function(className, filePath) {
  var loaded = isClassFileLoaded[className];
  Loader.numLoadedFiles++;
  isClassFileLoaded[className] = true;
  isFileLoaded[filePath] = true;
  delete inFlight[filePath];
  if (!loaded) 
  {
    Loader.numPendingFiles--;
  }
  if (Loader.numPendingFiles === 0) 
  {
    Loader.refreshQueue();
  }
}, onFileLoadError: function(className, filePath, errorMessage, isSynchronous) {
  Loader.numPendingFiles--;
  Loader.hasFileLoadError = true;
}, addUsedClasses: function(classes) {
  var cls, i, ln;
  if (classes) 
  {
    classes = (typeof classes == 'string') ? [classes] : classes;
    for (i = 0 , ln = classes.length; i < ln; i++) 
      {
        cls = classes[i];
        if (typeof cls == 'string' && !Ext.Array.contains(usedClasses, cls)) 
        {
          usedClasses.push(cls);
        }
      }
  }
  return Loader;
}, triggerReady: function() {
  var listener, refClasses = usedClasses;
  if (Loader.isLoading) 
  {
    Loader.isLoading = false;
    if (refClasses.length !== 0) 
    {
      refClasses = refClasses.slice();
      usedClasses.length = 0;
      Loader.require(refClasses, Loader.triggerReady, Loader);
      return Loader;
    }
  }
  Ext.Array.sort(readyListeners, comparePriority);
  while (readyListeners.length && !Loader.isLoading) 
    {
      listener = readyListeners.shift();
      listener.fn.call(listener.scope);
    }
  return Loader;
}, onReady: function(fn, scope, withDomReady, options) {
  var oldFn;
  if (withDomReady !== false && Ext.onDocumentReady) 
  {
    oldFn = fn;
    fn = function() {
  Ext.onDocumentReady(oldFn, scope, options);
};
  }
  if (!Loader.isLoading) 
  {
    fn.call(scope);
  } else {
    readyListeners.push({fn: fn, scope: scope, priority: (options && options.priority) || 0});
  }
}, historyPush: function(className) {
  if (className && isClassFileLoaded.hasOwnProperty(className) && !isInHistory[className]) 
  {
    isInHistory[className] = true;
    history.push(className);
  }
  return Loader;
}});
  Ext.disableCacheBuster = function(disable, path) {
  var date = new Date();
  date.setTime(date.getTime() + (disable ? 10 * 365 : -1) * 24 * 60 * 60 * 1000);
  date = date.toGMTString();
  document.cookie = 'ext-cache=1; expires=' + date + '; path=' + (path || '/');
};
  Ext.require = alias(Loader, 'require');
  Ext.syncRequire = alias(Loader, 'syncRequire');
  Ext.exclude = alias(Loader, 'exclude');
  Ext.onReady = function(fn, scope, options) {
  Loader.onReady(fn, scope, true, options);
};
  Class.registerPreprocessor('loader', function(cls, data, hooks, continueFn) {
  var me = this, dependencies = [], dependency, className = Manager.getName(cls), i, j, ln, subLn, value, propertyName, propertyValue, requiredMap, requiredDep;
  for (i = 0 , ln = dependencyProperties.length; i < ln; i++) 
    {
      propertyName = dependencyProperties[i];
      if (data.hasOwnProperty(propertyName)) 
      {
        propertyValue = data[propertyName];
        if (typeof propertyValue == 'string') 
        {
          dependencies.push(propertyValue);
        } else if (propertyValue instanceof Array) 
        {
          for (j = 0 , subLn = propertyValue.length; j < subLn; j++) 
            {
              value = propertyValue[j];
              if (typeof value == 'string') 
              {
                dependencies.push(value);
              }
            }
        } else if (typeof propertyValue != 'function') 
        {
          for (j in propertyValue) 
            {
              if (propertyValue.hasOwnProperty(j)) 
              {
                value = propertyValue[j];
                if (typeof value == 'string') 
                {
                  dependencies.push(value);
                }
              }
            }
        }
      }
    }
  if (dependencies.length === 0) 
  {
    return;
  }
  Loader.require(dependencies, function() {
  for (i = 0 , ln = dependencyProperties.length; i < ln; i++) 
    {
      propertyName = dependencyProperties[i];
      if (data.hasOwnProperty(propertyName)) 
      {
        propertyValue = data[propertyName];
        if (typeof propertyValue == 'string') 
        {
          data[propertyName] = Manager.get(propertyValue);
        } else if (propertyValue instanceof Array) 
        {
          for (j = 0 , subLn = propertyValue.length; j < subLn; j++) 
            {
              value = propertyValue[j];
              if (typeof value == 'string') 
              {
                data[propertyName][j] = Manager.get(value);
              }
            }
        } else if (typeof propertyValue != 'function') 
        {
          for (var k in propertyValue) 
            {
              if (propertyValue.hasOwnProperty(k)) 
              {
                value = propertyValue[k];
                if (typeof value == 'string') 
                {
                  data[propertyName][k] = Manager.get(value);
                }
              }
            }
        }
      }
    }
  continueFn.call(me, cls, data, hooks);
});
  return false;
}, true, 'after', 'className');
  Manager.registerPostprocessor('uses', function(name, cls, data) {
  var uses = data.uses;
  if (uses) 
  {
    Loader.addUsedClasses(uses);
  }
});
  Manager.onCreated(Loader.historyPush);
}();
if (Ext._classPathMetadata) 
{
  Ext.Loader.addClassPathMappings(Ext._classPathMetadata);
  Ext._classPathMetadata = null;
}
(function() {
  var scripts = document.getElementsByTagName('script'), currentScript = scripts[scripts.length - 1], src = currentScript.src, path = src.substring(0, src.lastIndexOf('/') + 1), Loader = Ext.Loader;
  Loader.setConfig({enabled: true, disableCaching: true, paths: {'Ext': path + 'src'}});
})();
Ext._endTime = new Date().getTime();
if (Ext._beforereadyhandler) 
{
  Ext._beforereadyhandler();
}

Ext.Error = Ext.extend(Error, {statics: {ignore: false, raise: function(err) {
  err = err || {};
  if (Ext.isString(err)) 
  {
    err = {msg: err};
  }
  var method = this.raise.caller, msg;
  if (method) 
  {
    if (method.$name) 
    {
      err.sourceMethod = method.$name;
    }
    if (method.$owner) 
    {
      err.sourceClass = method.$owner.$className;
    }
  }
  if (Ext.Error.handle(err) !== true) 
  {
    msg = Ext.Error.prototype.toString.call(err);
    Ext.log({msg: msg, level: 'error', dump: err, stack: true});
    throw new Ext.Error(err);
  }
}, handle: function() {
  return Ext.Error.ignore;
}}, name: 'Ext.Error', constructor: function(config) {
  if (Ext.isString(config)) 
  {
    config = {msg: config};
  }
  var me = this;
  Ext.apply(me, config);
  me.message = me.message || me.msg;
}, toString: function() {
  var me = this, className = me.sourceClass ? me.sourceClass : '', methodName = me.sourceMethod ? '.' + me.sourceMethod + '(): ' : '', msg = me.msg || '(No description provided)';
  return className + methodName + msg;
}});
Ext.deprecated = function(suggestion) {
  return Ext.emptyFn;
};

Ext.JSON = (new (function() {
  var me = this, encodingFunction, decodingFunction, useNative = null, useHasOwn = !!{}.hasOwnProperty, isNative = function() {
  if (useNative === null) 
  {
    useNative = Ext.USE_NATIVE_JSON && window.JSON && JSON.toString() == '[object JSON]';
  }
  return useNative;
}, pad = function(n) {
  return n < 10 ? "0" + n : n;
}, doDecode = function(json) {
  return eval("(" + json + ')');
}, doEncode = function(o, newline) {
  if (o === null || o === undefined) 
  {
    return "null";
  } else if (Ext.isDate(o)) 
  {
    return Ext.JSON.encodeDate(o);
  } else if (Ext.isString(o)) 
  {
    return Ext.JSON.encodeString(o);
  } else if (typeof o == "number") 
  {
    return isFinite(o) ? String(o) : "null";
  } else if (Ext.isBoolean(o)) 
  {
    return String(o);
  } else if (o.toJSON) 
  {
    return o.toJSON();
  } else if (Ext.isArray(o)) 
  {
    return encodeArray(o, newline);
  } else if (Ext.isObject(o)) 
  {
    return encodeObject(o, newline);
  } else if (typeof o === "function") 
  {
    return "null";
  }
  return 'undefined';
}, m = {"\b": '\\b', "\t": '\\t', "\n": '\\n', "\f": '\\f', "\r": '\\r', '"': '\\"', "\\": '\\\\', '\v': '\\u000b'}, charToReplace = /[\\\"\x00-\x1f\x7f-\uffff]/g, encodeString = function(s) {
  return '"' + s.replace(charToReplace, function(a) {
  var c = m[a];
  return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
}) + '"';
}, encodeArray = function(o, newline) {
  var a = ["[", ""], len = o.length, i;
  for (i = 0; i < len; i += 1) 
    {
      a.push(Ext.JSON.encodeValue(o[i]), ',');
    }
  a[a.length - 1] = ']';
  return a.join("");
}, encodeObject = function(o, newline) {
  var a = ["{", ""], i, val;
  for (i in o) 
    {
      val = o[i];
      if (!useHasOwn || o.hasOwnProperty(i)) 
      {
        if (typeof val === 'function' || val === undefined) 
        {
          continue;
        }
        a.push(Ext.JSON.encodeValue(i), ":", Ext.JSON.encodeValue(val), ',');
      }
    }
  a[a.length - 1] = '}';
  return a.join("");
};
  me.encodeString = encodeString;
  me.encodeValue = doEncode;
  me.encodeDate = function(o) {
  return '"' + o.getFullYear() + "-" + pad(o.getMonth() + 1) + "-" + pad(o.getDate()) + "T" + pad(o.getHours()) + ":" + pad(o.getMinutes()) + ":" + pad(o.getSeconds()) + '"';
};
  me.encode = function(o) {
  if (!encodingFunction) 
  {
    encodingFunction = isNative() ? JSON.stringify : me.encodeValue;
  }
  return encodingFunction(o);
};
  me.decode = function(json, safe) {
  if (!decodingFunction) 
  {
    decodingFunction = isNative() ? JSON.parse : doDecode;
  }
  try {
    return decodingFunction(json);
  }  catch (e) {
  if (safe === true) 
  {
    return null;
  }
  Ext.Error.raise({sourceClass: "Ext.JSON", sourceMethod: "decode", msg: "You're trying to decode an invalid JSON String: " + json});
}
};
})());
Ext.encode = Ext.JSON.encode;
Ext.decode = Ext.JSON.decode;

Ext.apply(Ext, {userAgent: navigator.userAgent.toLowerCase(), cache: {}, idSeed: 1000, windowId: 'ext-window', documentId: 'ext-document', isReady: false, enableGarbageCollector: true, enableListenerCollection: true, rootHierarchyState: {}, addCacheEntry: function(id, el, dom) {
  dom = dom || el.dom;
  var cache = Ext.cache, key = id || (el && el.id) || dom.id, entry = cache[key] || (cache[key] = {data: {}, events: {}, dom: dom, skipGarbageCollection: !!(dom.getElementById || dom.navigator)});
  if (el) 
  {
    el.$cache = entry;
    entry.el = el;
  }
  return entry;
}, updateCacheEntry: function(cacheItem, dom) {
  var oldDom = cacheItem.dom;
  if (dom !== oldDom) 
  {
    Ext.EventManager.removeAll(oldDom);
  }
  cacheItem.dom = dom;
  if (cacheItem.el) 
  {
    cacheItem.el.dom = dom;
  }
  return cacheItem;
}, id: function(el, prefix) {
  var me = this, sandboxPrefix = '';
  el = Ext.getDom(el, true) || {};
  if (el === document) 
  {
    el.id = me.documentId;
  } else if (el === window) 
  {
    el.id = me.windowId;
  }
  if (!el.id) 
  {
    if (me.isSandboxed) 
    {
      sandboxPrefix = Ext.sandboxName.toLowerCase() + '-';
    }
    el.id = sandboxPrefix + (prefix || "ext-gen") + (++Ext.idSeed);
  }
  return el.id;
}, escapeId: (function() {
  var validIdRe = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i, escapeRx = /([\W]{1})/g, leadingNumRx = /^(\d)/g, escapeFn = function(match, capture) {
  return "\\" + capture;
}, numEscapeFn = function(match, capture) {
  return '\\00' + capture.charCodeAt(0).toString(16) + ' ';
};
  return function(id) {
  return validIdRe.test(id) ? id : id.replace(escapeRx, escapeFn).replace(leadingNumRx, numEscapeFn);
};
}()), getBody: (function() {
  var body;
  return function() {
  return body || (body = Ext.get(document.body));
};
}()), getHead: (function() {
  var head;
  return function() {
  return head || (head = Ext.get(document.getElementsByTagName("head")[0]));
};
}()), getDoc: (function() {
  var doc;
  return function() {
  return doc || (doc = Ext.get(document));
};
}()), getOrientation: function() {
  return window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
}, destroy: function() {
  var ln = arguments.length, i, arg;
  for (i = 0; i < ln; i++) 
    {
      arg = arguments[i];
      if (arg) 
      {
        if (Ext.isArray(arg)) 
        {
          this.destroy.apply(this, arg);
        } else if (arg.isStore) 
        {
          arg.destroyStore();
        } else if (Ext.isFunction(arg.destroy)) 
        {
          arg.destroy();
        } else if (arg.dom) 
        {
          arg.remove();
        }
      }
    }
}, callback: function(callback, scope, args, delay) {
  var fn, ret;
  if (Ext.isFunction(callback)) 
  {
    fn = callback;
  } else if (scope && Ext.isString(callback)) 
  {
    fn = scope[callback];
  }
  if (fn) 
  {
    args = args || [];
    scope = scope || window;
    if (delay) 
    {
      Ext.defer(fn, delay, scope, args);
    } else {
      ret = fn.apply(scope, args);
    }
  }
  return ret;
}, resolveMethod: function(fn, scope) {
  if (Ext.isFunction(fn)) 
  {
    return fn;
  }
  return scope[fn];
}, htmlEncode: function(value) {
  return Ext.String.htmlEncode(value);
}, htmlDecode: function(value) {
  return Ext.String.htmlDecode(value);
}, urlAppend: function(url, s) {
  return Ext.String.urlAppend(url, s);
}, splitAndUnescape: (function() {
  var cache = {};
  return function(origin, delimiter) {
  if (!origin) 
  {
    return [];
  } else if (!delimiter) 
  {
    return [origin];
  }
  var replaceRe = cache[delimiter] || (cache[delimiter] = new RegExp('\\\\' + delimiter, 'g')), result = [], parts, part;
  parts = origin.split(delimiter);
  while ((part = parts.shift()) !== undefined) 
    {
      while (part.charAt(part.length - 1) === '\\' && parts.length > 0) 
        {
          part = part + delimiter + parts.shift();
        }
      part = part.replace(replaceRe, delimiter);
      result.push(part);
    }
  return result;
};
})()});
Ext.ns = Ext.namespace;
window.undefined = window.undefined;
(function() {
  var check = function(regex) {
  return regex.test(Ext.userAgent);
}, isStrict = document.compatMode == "CSS1Compat", version = function(is, regex) {
  var m;
  return (is && (m = regex.exec(Ext.userAgent))) ? parseFloat(m[1]) : 0;
}, docMode = document.documentMode, isOpera = check(/opera/), isOpera10_5 = isOpera && check(/version\/10\.5/), isChrome = check(/\bchrome\b/), isWebKit = check(/webkit/), isSafari = !isChrome && check(/safari/), isSafari2 = isSafari && check(/applewebkit\/4/), isSafari3 = isSafari && check(/version\/3/), isSafari4 = isSafari && check(/version\/4/), isSafari5_0 = isSafari && check(/version\/5\.0/), isSafari5 = isSafari && check(/version\/5/), isIE = !isOpera && (check(/msie/) || check(/trident/)), isIE7 = isIE && ((check(/msie 7/) && docMode != 8 && docMode != 9 && docMode != 10) || docMode == 7), isIE8 = isIE && ((check(/msie 8/) && docMode != 7 && docMode != 9 && docMode != 10) || docMode == 8), isIE9 = isIE && ((check(/msie 9/) && docMode != 7 && docMode != 8 && docMode != 10) || docMode == 9), isIE10 = isIE && ((check(/msie 10/) && docMode != 7 && docMode != 8 && docMode != 9) || docMode == 10), isIE11 = isIE && ((check(/trident\/7\.0/) && docMode != 7 && docMode != 8 && docMode != 9 && docMode != 10) || docMode == 11), isIE6 = isIE && check(/msie 6/), isGecko = !isWebKit && !isIE && check(/gecko/), isGecko3 = isGecko && check(/rv:1\.9/), isGecko4 = isGecko && check(/rv:2\.0/), isGecko5 = isGecko && check(/rv:5\./), isGecko10 = isGecko && check(/rv:10\./), isFF3_0 = isGecko3 && check(/rv:1\.9\.0/), isFF3_5 = isGecko3 && check(/rv:1\.9\.1/), isFF3_6 = isGecko3 && check(/rv:1\.9\.2/), isWindows = check(/windows|win32/), isMac = check(/macintosh|mac os x/), isLinux = check(/linux/), scrollbarSize = null, chromeVersion = version(true, /\bchrome\/(\d+\.\d+)/), firefoxVersion = version(true, /\bfirefox\/(\d+\.\d+)/), ieVersion = version(isIE, /msie (\d+\.\d+)/), operaVersion = version(isOpera, /version\/(\d+\.\d+)/), safariVersion = version(isSafari, /version\/(\d+\.\d+)/), webKitVersion = version(isWebKit, /webkit\/(\d+\.\d+)/), isSecure = /^https/i.test(window.location.protocol), nullLog;
  try {
    document.execCommand("BackgroundImageCache", false, true);
  }  catch (e) {
}
  nullLog = function() {
};
  nullLog.info = nullLog.warn = nullLog.error = Ext.emptyFn;
  Ext.setVersion('ext', '4.2.3.1477');
  Ext.setVersion('extjs', '4.2.3.1477');
  Ext.apply(Ext, {SSL_SECURE_URL: isSecure && isIE ? 'javascript:\'\'' : 'about:blank', plainTableCls: Ext.buildSettings.baseCSSPrefix + 'table-plain', plainListCls: Ext.buildSettings.baseCSSPrefix + 'list-plain', enableNestedListenerRemoval: false, USE_NATIVE_JSON: false, getDom: function(el, strict) {
  if (!el || !document) 
  {
    return null;
  }
  if (el.dom) 
  {
    return el.dom;
  } else {
    if (typeof el == 'string') 
    {
      var e = Ext.getElementById(el);
      if (e && isIE && strict) 
      {
        if (el == e.getAttribute('id')) 
        {
          return e;
        } else {
          return null;
        }
      }
      return e;
    } else {
      return el;
    }
  }
}, removeNode: isIE6 || isIE7 || isIE8 ? (function() {
  var d;
  return function(n) {
  if (n && n.tagName.toUpperCase() != 'BODY') 
  {
        (Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(n) : Ext.EventManager.removeAll(n);
    var cache = Ext.cache, id = n.id;
    if (cache[id]) 
    {
      delete cache[id].dom;
      delete cache[id];
    }
    if (isIE8 && n.parentNode) 
    {
      n.parentNode.removeChild(n);
    }
    d = d || document.createElement('div');
    d.appendChild(n);
    d.innerHTML = '';
  }
};
}()) : function(n) {
  if (n && n.parentNode && n.tagName.toUpperCase() != 'BODY') 
  {
        (Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(n) : Ext.EventManager.removeAll(n);
    var cache = Ext.cache, id = n.id;
    if (cache[id]) 
    {
      delete cache[id].dom;
      delete cache[id];
    }
    n.parentNode.removeChild(n);
  }
}, isStrict: isStrict, isIEQuirks: isIE && (!isStrict && (isIE6 || isIE7 || isIE8 || isIE9)), isOpera: isOpera, isOpera10_5: isOpera10_5, isWebKit: isWebKit, isChrome: isChrome, isSafari: isSafari, isSafari3: isSafari3, isSafari4: isSafari4, isSafari5: isSafari5, isSafari5_0: isSafari5_0, isSafari2: isSafari2, isIE: isIE, isIE6: isIE6, isIE7: isIE7, isIE7m: isIE6 || isIE7, isIE7p: isIE && !isIE6, isIE8: isIE8, isIE8m: isIE6 || isIE7 || isIE8, isIE8p: isIE && !(isIE6 || isIE7), isIE9: isIE9, isIE9m: isIE6 || isIE7 || isIE8 || isIE9, isIE9p: isIE && !(isIE6 || isIE7 || isIE8), isIE10: isIE10, isIE10m: isIE6 || isIE7 || isIE8 || isIE9 || isIE10, isIE10p: isIE && !(isIE6 || isIE7 || isIE8 || isIE9), isIE11: isIE11, isIE11m: isIE6 || isIE7 || isIE8 || isIE9 || isIE10 || isIE11, isIE11p: isIE && !(isIE6 || isIE7 || isIE8 || isIE9 || isIE10), isGecko: isGecko, isGecko3: isGecko3, isGecko4: isGecko4, isGecko5: isGecko5, isGecko10: isGecko10, isFF3_0: isFF3_0, isFF3_5: isFF3_5, isFF3_6: isFF3_6, isFF4: 4 <= firefoxVersion && firefoxVersion < 5, isFF5: 5 <= firefoxVersion && firefoxVersion < 6, isFF10: 10 <= firefoxVersion && firefoxVersion < 11, isLinux: isLinux, isWindows: isWindows, isMac: isMac, chromeVersion: chromeVersion, firefoxVersion: firefoxVersion, ieVersion: ieVersion, operaVersion: operaVersion, safariVersion: safariVersion, webKitVersion: webKitVersion, isSecure: isSecure, BLANK_IMAGE_URL: (isIE6 || isIE7) ? '/' + '/www.sencha.com/s.gif' : 'data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==', value: function(v, defaultValue, allowBlank) {
  return Ext.isEmpty(v, allowBlank) ? defaultValue : v;
}, escapeRe: function(s) {
  return s.replace(/([-.*+?\^${}()|\[\]\/\\])/g, "\\$1");
}, addBehaviors: function(o) {
  if (!Ext.isReady) 
  {
    Ext.onReady(function() {
  Ext.addBehaviors(o);
});
  } else {
    var cache = {}, parts, b, s;
    for (b in o) 
      {
        if ((parts = b.split('@'))[1]) 
        {
          s = parts[0];
          if (!cache[s]) 
          {
            cache[s] = Ext.select(s);
          }
          cache[s].on(parts[1], o[b]);
        }
      }
    cache = null;
  }
}, getScrollbarSize: function(force) {
  if (!Ext.isReady) 
  {
    return {};
  }
  if (force || !scrollbarSize) 
  {
    var db = document.body, div = document.createElement('div');
    div.style.width = div.style.height = '100px';
    div.style.overflow = 'scroll';
    div.style.position = 'absolute';
    db.appendChild(div);
    scrollbarSize = {width: div.offsetWidth - div.clientWidth, height: div.offsetHeight - div.clientHeight};
    db.removeChild(div);
  }
  return scrollbarSize;
}, getScrollBarWidth: function(force) {
  var size = Ext.getScrollbarSize(force);
  return size.width + 2;
}, copyTo: function(dest, source, names, usePrototypeKeys) {
  if (typeof names == 'string') 
  {
    names = names.split(/[,;\s]/);
  }
  var n, nLen = names ? names.length : 0, name;
  for (n = 0; n < nLen; n++) 
    {
      name = names[n];
      if (usePrototypeKeys || source.hasOwnProperty(name)) 
      {
        dest[name] = source[name];
      }
    }
  return dest;
}, destroyMembers: function(o) {
  for (var i = 1, a = arguments, len = a.length; i < len; i++) 
    {
      Ext.destroy(o[a[i]]);
      delete o[a[i]];
    }
}, log: nullLog, partition: function(arr, truth) {
  var ret = [[], []], a, v, aLen = arr.length;
  for (a = 0; a < aLen; a++) 
    {
      v = arr[a];
      ret[(truth && truth(v, a, arr)) || (!truth && v) ? 0 : 1].push(v);
    }
  return ret;
}, invoke: function(arr, methodName) {
  var ret = [], args = Array.prototype.slice.call(arguments, 2), a, v, aLen = arr.length;
  for (a = 0; a < aLen; a++) 
    {
      v = arr[a];
      if (v && typeof v[methodName] == 'function') 
      {
        ret.push(v[methodName].apply(v, args));
      } else {
        ret.push(undefined);
      }
    }
  return ret;
}, zip: function() {
  var parts = Ext.partition(arguments, function(val) {
  return typeof val != 'function';
}), arrs = parts[0], fn = parts[1][0], len = Ext.max(Ext.pluck(arrs, "length")), ret = [], i, j, aLen;
  for (i = 0; i < len; i++) 
    {
      ret[i] = [];
      if (fn) 
      {
        ret[i] = fn.apply(fn, Ext.pluck(arrs, i));
      } else {
        for (j = 0 , aLen = arrs.length; j < aLen; j++) 
          {
            ret[i].push(arrs[j][i]);
          }
      }
    }
  return ret;
}, toSentence: function(items, connector) {
  var length = items.length, head, tail;
  if (length <= 1) 
  {
    return items[0];
  } else {
    head = items.slice(0, length - 1);
    tail = items[length - 1];
    return Ext.util.Format.format("{0} {1} {2}", head.join(", "), connector || 'and', tail);
  }
}, setGlyphFontFamily: function(fontFamily) {
  Ext._glyphFontFamily = fontFamily;
}, useShims: isIE6});
}());
Ext.application = function(config) {
  var App, paths, ns, createApp = function() {
  Ext.onReady(function() {
  Ext.app.Application.instance = new App();
});
};
  if (typeof config === "string") 
  {
    Ext.require(config, function() {
  App = Ext.ClassManager.get(config);
  createApp();
});
  } else {
    Ext.Loader.setPath(config.name, config.appFolder || 'app');
    if (paths = config.paths) 
    {
      for (ns in paths) 
        {
          if (paths.hasOwnProperty(ns)) 
          {
            Ext.Loader.setPath(ns, paths[ns]);
          }
        }
    }
    config['paths processed'] = true;
    Ext.define(config.name + ".$application", Ext.apply({extend: 'Ext.app.Application'}, config), function() {
  App = this;
  createApp();
});
  }
};

(function() {
  Ext.ns('Ext.util');
  var UtilFormat = Ext.util.Format = {}, stripTagsRE = /<\/?[^>]+>/gi, stripScriptsRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, nl2brRe = /\r?\n/g, hashRe = /#+$/, formatPattern = /[\d,\.#]+/, formatCleanRe = /[^\d\.#]/g, I18NFormatCleanRe, lastDecimalSeparator, formatFns = {};
  Ext.apply(UtilFormat, {thousandSeparator: ',', decimalSeparator: '.', currencyPrecision: 2, currencySign: '$', currencyAtEnd: false, undef: function(value) {
  return value !== undefined ? value : "";
}, defaultValue: function(value, defaultValue) {
  return value !== undefined && value !== '' ? value : defaultValue;
}, substr: 'ab'.substr(-1) != 'b' ? function(value, start, length) {
  var str = String(value);
  return (start < 0) ? str.substr(Math.max(str.length + start, 0), length) : str.substr(start, length);
} : function(value, start, length) {
  return String(value).substr(start, length);
}, lowercase: function(value) {
  return String(value).toLowerCase();
}, uppercase: function(value) {
  return String(value).toUpperCase();
}, usMoney: function(v) {
  return UtilFormat.currency(v, '$', 2);
}, currency: function(v, currencySign, decimals, end) {
  var negativeSign = '', format = ",0", i = 0;
  v = v - 0;
  if (v < 0) 
  {
    v = -v;
    negativeSign = '-';
  }
  decimals = Ext.isDefined(decimals) ? decimals : UtilFormat.currencyPrecision;
  format += (decimals > 0 ? '.' : '');
  for (; i < decimals; i++) 
    {
      format += '0';
    }
  v = UtilFormat.number(v, format);
  if ((end || UtilFormat.currencyAtEnd) === true) 
  {
    return Ext.String.format("{0}{1}{2}", negativeSign, v, currencySign || UtilFormat.currencySign);
  } else {
    return Ext.String.format("{0}{1}{2}", negativeSign, currencySign || UtilFormat.currencySign, v);
  }
}, date: function(v, format) {
  if (!v) 
  {
    return "";
  }
  if (!Ext.isDate(v)) 
  {
    v = new Date(Date.parse(v));
  }
  return Ext.Date.dateFormat(v, format || Ext.Date.defaultFormat);
}, dateRenderer: function(format) {
  return function(v) {
  return UtilFormat.date(v, format);
};
}, stripTags: function(v) {
  return !v ? v : String(v).replace(stripTagsRE, "");
}, stripScripts: function(v) {
  return !v ? v : String(v).replace(stripScriptsRe, "");
}, fileSize: (function() {
  var byteLimit = 1024, kbLimit = 1048576, mbLimit = 1073741824;
  return function(size) {
  var out;
  if (size < byteLimit) 
  {
    if (size === 1) 
    {
      out = '1 byte';
    } else {
      out = size + ' bytes';
    }
  } else if (size < kbLimit) 
  {
    out = (Math.round(((size * 10) / byteLimit)) / 10) + ' KB';
  } else if (size < mbLimit) 
  {
    out = (Math.round(((size * 10) / kbLimit)) / 10) + ' MB';
  } else {
    out = (Math.round(((size * 10) / mbLimit)) / 10) + ' GB';
  }
  return out;
};
})(), math: (function() {
  var fns = {};
  return function(v, a) {
  if (!fns[a]) 
  {
    fns[a] = Ext.functionFactory('v', 'return v ' + a + ';');
  }
  return fns[a](v);
};
}()), round: function(value, precision) {
  var result = Number(value);
  if (typeof precision == 'number') 
  {
    precision = Math.pow(10, precision);
    result = Math.round(value * precision) / precision;
  }
  return result;
}, number: function(v, formatString) {
  if (!formatString) 
  {
    return v;
  }
  var formatFn = formatFns[formatString];
  if (!formatFn) 
  {
    var originalFormatString = formatString, comma = UtilFormat.thousandSeparator, decimalSeparator = UtilFormat.decimalSeparator, precision = 0, trimPart = '', hasComma, splitFormat, extraChars, multiplier, trimTrailingZeroes, code, len;
    if (formatString.substr(formatString.length - 2) == '/i') 
    {
      if (!I18NFormatCleanRe || lastDecimalSeparator !== decimalSeparator) 
      {
        I18NFormatCleanRe = new RegExp('[^\\d\\' + decimalSeparator + ']', 'g');
        lastDecimalSeparator = decimalSeparator;
      }
      formatString = formatString.substr(0, formatString.length - 2);
      hasComma = formatString.indexOf(comma) !== -1;
      splitFormat = formatString.replace(I18NFormatCleanRe, '').split(decimalSeparator);
    } else {
      hasComma = formatString.indexOf(',') != -1;
      splitFormat = formatString.replace(formatCleanRe, '').split('.');
    }
    extraChars = formatString.replace(formatPattern, '');
    if (splitFormat.length > 2) 
    {
    } else if (splitFormat.length === 2) 
    {
      precision = splitFormat[1].length;
      trimTrailingZeroes = splitFormat[1].match(hashRe);
      if (trimTrailingZeroes) 
      {
        len = trimTrailingZeroes[0].length;
        trimPart = 'trailingZeroes=new RegExp(Ext.String.escapeRegex(utilFormat.decimalSeparator) + "*0{0,' + len + '}$")';
      }
    }
    code = ['var utilFormat=Ext.util.Format,extNumber=Ext.Number,neg,absVal,fnum,parts' + (hasComma ? ',thousandSeparator,thousands=[],j,n,i' : '') + (extraChars ? ',formatString="' + formatString + '",formatPattern=/[\\d,\\.#]+/' : '') + ',trailingZeroes;' + 'return function(v){' + 'if(typeof v!=="number"&&isNaN(v=extNumber.from(v,NaN)))return"";' + 'neg=v<0;', 'absVal=Math.abs(v);', 'fnum=Ext.Number.toFixed(absVal, ' + precision + ');', trimPart, ';'];
    if (hasComma) 
    {
      if (precision) 
      {
        code[code.length] = 'parts=fnum.split(".");';
        code[code.length] = 'fnum=parts[0];';
      }
      code[code.length] = 'if(absVal>=1000) {';
      code[code.length] = 'thousandSeparator=utilFormat.thousandSeparator;' + 'thousands.length=0;' + 'j=fnum.length;' + 'n=fnum.length%3||3;' + 'for(i=0;i<j;i+=n){' + 'if(i!==0){' + 'n=3;' + '}' + 'thousands[thousands.length]=fnum.substr(i,n);' + '}' + 'fnum=thousands.join(thousandSeparator);' + '}';
      if (precision) 
      {
        code[code.length] = 'fnum += utilFormat.decimalSeparator+parts[1];';
      }
    } else if (precision) 
    {
      code[code.length] = 'if(utilFormat.decimalSeparator!=="."){' + 'parts=fnum.split(".");' + 'fnum=parts[0]+utilFormat.decimalSeparator+parts[1];' + '}';
    }
    code[code.length] = 'if(neg&&fnum!=="' + (precision ? '0.' + Ext.String.repeat('0', precision) : '0') + '")fnum="-"+fnum;';
    if (trimTrailingZeroes) 
    {
      code[code.length] = 'fnum=fnum.replace(trailingZeroes,"");';
    }
    code[code.length] = 'return ';
    if (extraChars) 
    {
      code[code.length] = 'formatString.replace(formatPattern, fnum);';
    } else {
      code[code.length] = 'fnum;';
    }
    code[code.length] = '};';
    formatFn = formatFns[originalFormatString] = Ext.functionFactory('Ext', code.join(''))(Ext);
  }
  return formatFn(v);
}, numberRenderer: function(format) {
  return function(v) {
  return UtilFormat.number(v, format);
};
}, attributes: function(attributes) {
  if (typeof attributes === 'object') 
  {
    var result = [], name;
    for (name in attributes) 
      {
        if (attributes.hasOwnProperty(name)) 
        {
          result.push(name, '="', name === 'style' ? Ext.DomHelper.generateStyles(attributes[name], null, true) : Ext.htmlEncode(attributes[name]), '"');
        }
      }
    attributes = result.join('');
  }
  return attributes || '';
}, plural: function(v, s, p) {
  return v + ' ' + (v == 1 ? s : (p ? p : s + 's'));
}, nl2br: function(v) {
  return Ext.isEmpty(v) ? '' : v.replace(nl2brRe, '<br/>');
}, capitalize: Ext.String.capitalize, ellipsis: Ext.String.ellipsis, format: Ext.String.format, htmlDecode: Ext.String.htmlDecode, htmlEncode: Ext.String.htmlEncode, leftPad: Ext.String.leftPad, trim: Ext.String.trim, parseBox: function(box) {
  box = box || 0;
  if (typeof box === 'number') 
  {
    return {top: box, right: box, bottom: box, left: box};
  }
  var parts = box.split(' '), ln = parts.length;
  if (ln == 1) 
  {
    parts[1] = parts[2] = parts[3] = parts[0];
  } else if (ln == 2) 
  {
    parts[2] = parts[0];
    parts[3] = parts[1];
  } else if (ln == 3) 
  {
    parts[3] = parts[1];
  }
  return {top: parseInt(parts[0], 10) || 0, right: parseInt(parts[1], 10) || 0, bottom: parseInt(parts[2], 10) || 0, left: parseInt(parts[3], 10) || 0};
}, escapeRegex: function(s) {
  return s.replace(/([\-.*+?\^${}()|\[\]\/\\])/g, "\\$1");
}});
}());

(Ext.cmd.derive('Ext.util.TaskRunner', Ext.Base, {interval: 10, timerId: null, constructor: function(interval) {
  var me = this;
  if (typeof interval == 'number') 
  {
    me.interval = interval;
  } else if (interval) 
  {
    Ext.apply(me, interval);
  }
  me.tasks = [];
  me.timerFn = Ext.Function.bind(me.onTick, me);
}, newTask: function(config) {
  var task = new Ext.util.TaskRunner.Task(config);
  task.manager = this;
  return task;
}, start: function(task) {
  var me = this, now = Ext.Date.now();
  if (!task.pending) 
  {
    me.tasks.push(task);
    task.pending = true;
  }
  task.stopped = false;
  task.taskStartTime = now;
  task.taskRunTime = task.fireOnStart !== false ? 0 : task.taskStartTime;
  task.taskRunCount = 0;
  if (!me.firing) 
  {
    if (task.fireOnStart !== false) 
    {
      me.startTimer(0, now);
    } else {
      me.startTimer(task.interval, now);
    }
  }
  return task;
}, stop: function(task) {
  if (!task.stopped) 
  {
    task.stopped = true;
    if (task.onStop) 
    {
      task.onStop.call(task.scope || task, task);
    }
  }
  return task;
}, stopAll: function() {
  Ext.each(this.tasks, this.stop, this);
}, firing: false, nextExpires: 1.0E99, onTick: function() {
  var me = this, tasks = me.tasks, now = Ext.Date.now(), nextExpires = 1.0E99, len = tasks.length, expires, newTasks, i, task, rt, remove;
  me.timerId = null;
  me.firing = true;
  for (i = 0; i < len || i < (len = tasks.length); ++i) 
    {
      task = tasks[i];
      if (!(remove = task.stopped)) 
      {
        expires = task.taskRunTime + task.interval;
        if (expires <= now) 
        {
          rt = 1;
          try {
            rt = task.run.apply(task.scope || task, task.args || [++task.taskRunCount]);
          }          catch (taskError) {
  try {
    if (task.onError) 
    {
      rt = task.onError.call(task.scope || task, task, taskError);
    }
  }  catch (ignore) {
}
}
          task.taskRunTime = now;
          if (rt === false || task.taskRunCount === task.repeat) 
          {
            me.stop(task);
            remove = true;
          } else {
            remove = task.stopped;
            expires = now + task.interval;
          }
        }
        if (!remove && task.duration && task.duration <= (now - task.taskStartTime)) 
        {
          me.stop(task);
          remove = true;
        }
      }
      if (remove) 
      {
        task.pending = false;
        if (!newTasks) 
        {
          newTasks = tasks.slice(0, i);
        }
      } else {
        if (newTasks) 
        {
          newTasks.push(task);
        }
        if (nextExpires > expires) 
        {
          nextExpires = expires;
        }
      }
    }
  if (newTasks) 
  {
    me.tasks = newTasks;
  }
  me.firing = false;
  if (me.tasks.length) 
  {
    me.startTimer(nextExpires - now, Ext.Date.now());
  }
  if (me.fireIdleEvent !== false) 
  {
    Ext.EventManager.idleEvent.fire();
  }
}, startTimer: function(timeout, now) {
  var me = this, expires = now + timeout, timerId = me.timerId;
  if (timerId && me.nextExpires - expires > me.interval) 
  {
    clearTimeout(timerId);
    timerId = null;
  }
  if (!timerId) 
  {
    if (timeout < me.interval) 
    {
      timeout = me.interval;
    }
    me.timerId = setTimeout(me.timerFn, timeout);
    me.nextExpires = expires;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'TaskRunner'], function() {
  var me = this, proto = me.prototype;
  proto.destroy = proto.stopAll;
  Ext.util.TaskManager = Ext.TaskManager = new me();
  me.Task = new Ext.Class({isTask: true, stopped: true, fireOnStart: false, constructor: function(config) {
  Ext.apply(this, config);
}, restart: function(interval) {
  if (interval !== undefined) 
  {
    this.interval = interval;
  }
  this.manager.start(this);
}, start: function(interval) {
  if (this.stopped) 
  {
    this.restart(interval);
  }
}, stop: function() {
  this.manager.stop(this);
}});
  proto = me.Task.prototype;
  proto.destroy = proto.stop;
}));
;

(Ext.cmd.derive('Ext.util.TaskManager', Ext.util.TaskRunner, {alternateClassName: ['Ext.TaskManager'], singleton: true}, 0, 0, 0, 0, 0, 0, [Ext.util, 'TaskManager', Ext, 'TaskManager'], 0));
;

(Ext.cmd.derive('Ext.perf.Accumulator', Ext.Base, (function() {
  var currentFrame = null, khrome = Ext.global['chrome'], formatTpl, getTimestamp = function() {
  getTimestamp = function() {
  return new Date().getTime();
};
  var interval, toolbox;
  if (Ext.isChrome && khrome && khrome.Interval) 
  {
    interval = new khrome.Interval();
    interval.start();
    getTimestamp = function() {
  return interval.microseconds() / 1000;
};
  } else if (window.ActiveXObject) 
  {
    try {
      toolbox = new ActiveXObject('SenchaToolbox.Toolbox');
      Ext.senchaToolbox = toolbox;
      getTimestamp = function() {
  return toolbox.milliseconds;
};
    }    catch (e) {
}
  } else if (Date.now) 
  {
    getTimestamp = Date.now;
  }
  Ext.perf.getTimestamp = Ext.perf.Accumulator.getTimestamp = getTimestamp;
  return getTimestamp();
};
  function adjustSet(set, time) {
    set.sum += time;
    set.min = Math.min(set.min, time);
    set.max = Math.max(set.max, time);
  }
  function leaveFrame(time) {
    var totalTime = time ? time : (getTimestamp() - this.time), me = this, accum = me.accum;
    ++accum.count;
    if (!--accum.depth) 
    {
      adjustSet(accum.total, totalTime);
    }
    adjustSet(accum.pure, totalTime - me.childTime);
    currentFrame = me.parent;
    if (currentFrame) 
    {
      ++currentFrame.accum.childCount;
      currentFrame.childTime += totalTime;
    }
  }
  function makeSet() {
    return {min: Number.MAX_VALUE, max: 0, sum: 0};
  }
  function makeTap(me, fn) {
    return function() {
  var frame = me.enter(), ret = fn.apply(this, arguments);
  frame.leave();
  return ret;
};
  }
  function round(x) {
    return Math.round(x * 100) / 100;
  }
  function setToJSON(count, childCount, calibration, set) {
    var data = {avg: 0, min: set.min, max: set.max, sum: 0};
    if (count) 
    {
      calibration = calibration || 0;
      data.sum = set.sum - childCount * calibration;
      data.avg = data.sum / count;
    }
    return data;
  }
  return {constructor: function(name) {
  var me = this;
  me.count = me.childCount = me.depth = me.maxDepth = 0;
  me.pure = makeSet();
  me.total = makeSet();
  me.name = name;
}, statics: {getTimestamp: getTimestamp}, format: function(calibration) {
  if (!formatTpl) 
  {
    formatTpl = new Ext.XTemplate(['{name} - {count} call(s)', '<tpl if="count">', '<tpl if="childCount">', ' ({childCount} children)', '</tpl>', '<tpl if="depth - 1">', ' ({depth} deep)', '</tpl>', '<tpl for="times">', ', {type}: {[this.time(values.sum)]} msec (', 'avg={[this.time(values.sum / parent.count)]}', ')', '</tpl>', '</tpl>'].join(''), {time: function(t) {
  return Math.round(t * 100) / 100;
}});
  }
  var data = this.getData(calibration);
  data.name = this.name;
  data.pure.type = 'Pure';
  data.total.type = 'Total';
  data.times = [data.pure, data.total];
  return formatTpl.apply(data);
}, getData: function(calibration) {
  var me = this;
  return {count: me.count, childCount: me.childCount, depth: me.maxDepth, pure: setToJSON(me.count, me.childCount, calibration, me.pure), total: setToJSON(me.count, me.childCount, calibration, me.total)};
}, enter: function() {
  var me = this, frame = {accum: me, leave: leaveFrame, childTime: 0, parent: currentFrame};
  ++me.depth;
  if (me.maxDepth < me.depth) 
  {
    me.maxDepth = me.depth;
  }
  currentFrame = frame;
  frame.time = getTimestamp();
  return frame;
}, monitor: function(fn, scope, args) {
  var frame = this.enter();
  if (args) 
  {
    fn.apply(scope, args);
  } else {
    fn.call(scope);
  }
  frame.leave();
}, report: function() {
  Ext.log(this.format());
}, tap: function(className, methodName) {
  var me = this, methods = typeof methodName == 'string' ? [methodName] : methodName, klass, statik, i, parts, length, name, src, tapFunc;
  tapFunc = function() {
  if (typeof className == 'string') 
  {
    klass = Ext.global;
    parts = className.split('.');
    for (i = 0 , length = parts.length; i < length; ++i) 
      {
        klass = klass[parts[i]];
      }
  } else {
    klass = className;
  }
  for (i = 0 , length = methods.length; i < length; ++i) 
    {
      name = methods[i];
      statik = name.charAt(0) == '!';
      if (statik) 
      {
        name = name.substring(1);
      } else {
        statik = !(name in klass.prototype);
      }
      src = statik ? klass : klass.prototype;
      src[name] = makeTap(me, src[name]);
    }
};
  Ext.ClassManager.onCreated(tapFunc, me, className);
  return me;
}};
}()), 1, 0, 0, 0, 0, 0, [Ext.perf, 'Accumulator'], function() {
  Ext.perf.getTimestamp = this.getTimestamp;
}));
;

(Ext.cmd.derive('Ext.perf.Monitor', Ext.Base, {singleton: true, alternateClassName: 'Ext.Perf', constructor: function() {
  this.accumulators = [];
  this.accumulatorsByName = {};
}, calibrate: function() {
  var accum = new Ext.perf.Accumulator('$'), total = accum.total, getTimestamp = Ext.perf.Accumulator.getTimestamp, count = 0, frame, endTime, startTime;
  startTime = getTimestamp();
  do {
    frame = accum.enter();
    frame.leave();
    ++count;
  } while (total.sum < 100);
  endTime = getTimestamp();
  return (endTime - startTime) / count;
}, get: function(name) {
  var me = this, accum = me.accumulatorsByName[name];
  if (!accum) 
  {
    me.accumulatorsByName[name] = accum = new Ext.perf.Accumulator(name);
    me.accumulators.push(accum);
  }
  return accum;
}, enter: function(name) {
  return this.get(name).enter();
}, monitor: function(name, fn, scope) {
  this.get(name).monitor(fn, scope);
}, report: function() {
  var me = this, accumulators = me.accumulators, calibration = me.calibrate();
  accumulators.sort(function(a, b) {
  return (a.name < b.name) ? -1 : ((b.name < a.name) ? 1 : 0);
});
  me.updateGC();
  Ext.log('Calibration: ' + Math.round(calibration * 100) / 100 + ' msec/sample');
  Ext.each(accumulators, function(accum) {
  Ext.log(accum.format(calibration));
});
}, getData: function(all) {
  var ret = {}, accumulators = this.accumulators;
  Ext.each(accumulators, function(accum) {
  if (all || accum.count) 
  {
    ret[accum.name] = accum.getData();
  }
});
  return ret;
}, reset: function() {
  Ext.each(this.accumulators, function(accum) {
  var me = accum;
  me.count = me.childCount = me.depth = me.maxDepth = 0;
  me.pure = {min: Number.MAX_VALUE, max: 0, sum: 0};
  me.total = {min: Number.MAX_VALUE, max: 0, sum: 0};
});
}, updateGC: function() {
  var accumGC = this.accumulatorsByName.GC, toolbox = Ext.senchaToolbox, bucket;
  if (accumGC) 
  {
    accumGC.count = toolbox.garbageCollectionCounter || 0;
    if (accumGC.count) 
    {
      bucket = accumGC.pure;
      accumGC.total.sum = bucket.sum = toolbox.garbageCollectionMilliseconds;
      bucket.min = bucket.max = bucket.sum / accumGC.count;
      bucket = accumGC.total;
      bucket.min = bucket.max = bucket.sum / accumGC.count;
    }
  }
}, watchGC: function() {
  Ext.perf.getTimestamp();
  var toolbox = Ext.senchaToolbox;
  if (toolbox) 
  {
    this.get("GC");
    toolbox.watchGarbageCollector(false);
  }
}, setup: function(config) {
  if (!config) 
  {
    config = {render: {'Ext.AbstractComponent': 'render'}, layout: {'Ext.layout.Context': 'run'}};
  }
  this.currentConfig = config;
  var key, prop, accum, className, methods;
  for (key in config) 
    {
      if (config.hasOwnProperty(key)) 
      {
        prop = config[key];
        accum = Ext.Perf.get(key);
        for (className in prop) 
          {
            if (prop.hasOwnProperty(className)) 
            {
              methods = prop[className];
              accum.tap(className, methods);
            }
          }
      }
    }
  this.watchGC();
}}, 1, 0, 0, 0, 0, 0, [Ext.perf, 'Monitor', Ext, 'Perf'], 0));
;

Ext.is = {init: function(navigator) {
  var platforms = this.platforms, ln = platforms.length, i, platform;
  navigator = navigator || window.navigator;
  for (i = 0; i < ln; i++) 
    {
      platform = platforms[i];
      this[platform.identity] = platform.regex.test(navigator[platform.property]);
    }
  this.Desktop = this.Mac || this.Windows || (this.Linux && !this.Android);
  this.Tablet = this.iPad;
  this.Phone = !this.Desktop && !this.Tablet;
  this.iOS = this.iPhone || this.iPad || this.iPod;
  this.Standalone = !!window.navigator.standalone;
}, platforms: [{property: 'platform', regex: /iPhone/i, identity: 'iPhone'}, {property: 'platform', regex: /iPod/i, identity: 'iPod'}, {property: 'userAgent', regex: /iPad/i, identity: 'iPad'}, {property: 'userAgent', regex: /Blackberry/i, identity: 'Blackberry'}, {property: 'userAgent', regex: /Android/i, identity: 'Android'}, {property: 'platform', regex: /Mac/i, identity: 'Mac'}, {property: 'platform', regex: /Win/i, identity: 'Windows'}, {property: 'platform', regex: /Linux/i, identity: 'Linux'}]};
Ext.is.init();
(function() {
  var getStyle = function(element, styleName) {
  var view = element.ownerDocument.defaultView, style = (view ? view.getComputedStyle(element, null) : element.currentStyle) || element.style;
  return style[styleName];
}, supportsVectors = {'IE6-quirks': [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], 'IE6-strict': [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], 'IE7-quirks': [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], 'IE7-strict': [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], 'IE8-quirks': [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], 'IE8-strict': [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], 'IE9-quirks': [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], 'IE9-strict': [0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], 'IE10-quirks': [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], 'IE10-strict': [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0]}, doc = document, div = doc.createElement('div');
  function getBrowserKey() {
    var browser = Ext.isIE6 ? 'IE6' : Ext.isIE7 ? 'IE7' : Ext.isIE8 ? 'IE8' : Ext.isIE9 ? 'IE9' : Ext.isIE10 ? 'IE10' : '';
    return browser ? browser + (Ext.isStrict ? '-strict' : '-quirks') : '';
  }
  Ext.supports = {init: function() {
  var me = this, toRun = me.toRun || me.tests, n = toRun.length, notRun = [], browserKey = getBrowserKey(), test, vector, value, docReady = Ext.isReady;
  if (docReady) 
  {
    div.innerHTML = ['<div style="height:30px;width:50px;">', '<div style="height:20px;width:20px;"></div>', '</div>', '<div style="width: 200px; height: 200px; position: relative; padding: 5px;">', '<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>', '</div>', '<div style="position: absolute; left: 10%; top: 10%;"></div>', '<div style="float:left; background-color:transparent;"></div>'].join('');
    doc.body.appendChild(div);
  }
  vector = supportsVectors[browserKey];
  while (n--) 
    {
      test = toRun[n];
      value = vector && vector[n];
      if (value !== undefined) 
      {
        me[test.identity] = value;
      } else if (docReady || test.early) 
      {
        me[test.identity] = test.fn.call(me, doc, div);
      } else {
        notRun.push(test);
      }
    }
  if (docReady) 
  {
    doc.body.removeChild(div);
  }
  me.toRun = notRun;
}, PointerEvents: 'pointerEvents' in document.documentElement.style, LocalStorage: (function() {
  try {
    return 'localStorage' in window && window['localStorage'] !== null;
  }  catch (e) {
  return false;
}
})(), CSS3BoxShadow: 'boxShadow' in document.documentElement.style || 'WebkitBoxShadow' in document.documentElement.style || 'MozBoxShadow' in document.documentElement.style, ClassList: !!document.documentElement.classList, OrientationChange: ((typeof window.orientation != 'undefined') && ('onorientationchange' in window)), DeviceMotion: ('ondevicemotion' in window), Touch: ('ontouchstart' in window) && (!Ext.is.Desktop), TimeoutActualLateness: (function() {
  setTimeout(function() {
  Ext.supports.TimeoutActualLateness = arguments.length !== 0;
}, 0);
}()), tests: [{identity: 'Transitions', fn: function(doc, div) {
  var prefix = ['webkit', 'Moz', 'o', 'ms', 'khtml'], TE = 'TransitionEnd', transitionEndName = [prefix[0] + TE, 'transitionend', prefix[2] + TE, prefix[3] + TE, prefix[4] + TE], ln = prefix.length, i = 0, out = false;
  for (; i < ln; i++) 
    {
      if (getStyle(div, prefix[i] + "TransitionProperty")) 
      {
        Ext.supports.CSS3Prefix = prefix[i];
        Ext.supports.CSS3TransitionEnd = transitionEndName[i];
        out = true;
        break;
      }
    }
  return out;
}}, {identity: 'RightMargin', fn: function(doc, div) {
  var view = doc.defaultView;
  return !(view && view.getComputedStyle(div.firstChild.firstChild, null).marginRight != '0px');
}}, {identity: 'DisplayChangeInputSelectionBug', early: true, fn: function() {
  var webKitVersion = Ext.webKitVersion;
  return 0 < webKitVersion && webKitVersion < 533;
}}, {identity: 'DisplayChangeTextAreaSelectionBug', early: true, fn: function() {
  var webKitVersion = Ext.webKitVersion;
  return 0 < webKitVersion && webKitVersion < 534.24;
}}, {identity: 'TransparentColor', fn: function(doc, div, view) {
  view = doc.defaultView;
  return !(view && view.getComputedStyle(div.lastChild, null).backgroundColor != 'transparent');
}}, {identity: 'ComputedStyle', fn: function(doc, div, view) {
  view = doc.defaultView;
  return view && view.getComputedStyle;
}}, {identity: 'Svg', fn: function(doc) {
  return !!doc.createElementNS && !!doc.createElementNS("http:/" + "/www.w3.org/2000/svg", "svg").createSVGRect;
}}, {identity: 'Canvas', fn: function(doc) {
  return !!doc.createElement('canvas').getContext;
}, early: true}, {identity: 'Vml', fn: function(doc) {
  var d = doc.createElement("div");
  d.innerHTML = "<!--[if vml]><br/><br/><![endif]-->";
  return (d.childNodes.length == 2);
}, early: true}, {identity: 'Float', fn: function(doc) {
  return 'cssFloat' in doc.documentElement.style;
}, early: true}, {identity: 'AudioTag', fn: function(doc) {
  return !!doc.createElement('audio').canPlayType;
}, early: true}, {identity: 'History', fn: function() {
  var history = window.history;
  return !!(history && history.pushState);
}, early: true}, {identity: 'Hashchange', fn: function() {
  var docMode = document.documentMode;
  return 'onhashchange' in window && (docMode === undefined || docMode > 7);
}, early: true}, {identity: 'CSS3DTransform', fn: function() {
  return (typeof WebKitCSSMatrix != 'undefined' && new WebKitCSSMatrix().hasOwnProperty('m41'));
}, early: true}, {identity: 'CSS3LinearGradient', fn: function(doc, div) {
  var property = 'background-image:', webkit = '-webkit-gradient(linear, left top, right bottom, from(black), to(white))', w3c = 'linear-gradient(left top, black, white)', moz = '-moz-' + w3c, ms = '-ms-' + w3c, opera = '-o-' + w3c, options = [property + webkit, property + w3c, property + moz, property + ms, property + opera];
  div.style.cssText = options.join(';');
  return (("" + div.style.backgroundImage).indexOf('gradient') !== -1) && !Ext.isIE9;
}, early: true}, {identity: 'CSS3BorderRadius', fn: function(doc) {
  var domPrefixes = ['borderRadius', 'BorderRadius', 'MozBorderRadius', 'WebkitBorderRadius', 'OBorderRadius', 'KhtmlBorderRadius'], i;
  for (i = 0; i < domPrefixes.length; i++) 
    {
      if (domPrefixes[i] in doc.documentElement.style) 
      {
        return true;
      }
    }
  return false;
}, early: true}, {identity: 'GeoLocation', fn: function() {
  return (typeof navigator != 'undefined' && 'geolocation' in navigator) || (typeof google != 'undefined' && typeof google.gears != 'undefined');
}, early: true}, {identity: 'MouseEnterLeave', fn: function(doc) {
  return ('onmouseenter' in doc.documentElement && 'onmouseleave' in doc.documentElement);
}, early: true}, {identity: 'MouseWheel', fn: function(doc) {
  return ('onmousewheel' in doc.documentElement);
}, early: true}, {identity: 'Opacity', fn: function(doc, div) {
  if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) 
  {
    return false;
  }
  div.style.cssText = 'opacity:0.73';
  return div.style.opacity == '0.73';
}, early: true}, {identity: 'Placeholder', fn: function(doc) {
  return 'placeholder' in doc.createElement('input');
}, early: true}, {identity: 'Direct2DBug', fn: function(doc) {
  return Ext.isString(doc.documentElement.style.msTransformOrigin) && Ext.isIE10m;
}, early: true}, {identity: 'BoundingClientRect', fn: function(doc) {
  return !Ext.isIEQuirks && 'getBoundingClientRect' in doc.documentElement;
}, early: true}, {identity: 'RotatedBoundingClientRect', fn: function(doc) {
  var body = doc.body, supports = false, el = doc.createElement('div'), style = el.style;
  if (el.getBoundingClientRect) 
  {
    style.WebkitTransform = style.MozTransform = style.OTransform = style.transform = 'rotate(90deg)';
    style.width = '100px';
    style.height = '30px';
    body.appendChild(el);
    supports = el.getBoundingClientRect().height !== 100;
    body.removeChild(el);
  }
  return supports;
}}, {identity: 'IncludePaddingInWidthCalculation', fn: function(doc, div) {
  return div.childNodes[1].firstChild.offsetWidth == 210;
}}, {identity: 'IncludePaddingInHeightCalculation', fn: function(doc, div) {
  return div.childNodes[1].firstChild.offsetHeight == 210;
}}, {identity: 'ArraySort', fn: function() {
  var a = [1, 2, 3, 4, 5].sort(function() {
  return 0;
});
  return a[0] === 1 && a[1] === 2 && a[2] === 3 && a[3] === 4 && a[4] === 5;
}, early: true}, {identity: 'Range', fn: function(doc) {
  return !!doc.createRange;
}, early: true}, {identity: 'CreateContextualFragment', fn: function(doc) {
  var range = doc.createRange ? doc.createRange() : false;
  return range && !!range.createContextualFragment;
}, early: true}, {identity: 'WindowOnError', fn: function() {
  return Ext.isIE || Ext.isGecko || Ext.webKitVersion >= 534.16;
}, early: true}, {identity: 'TextAreaMaxLength', fn: function(doc) {
  var el = doc.createElement('textarea');
  return ('maxlength' in el);
}, early: true}, {identity: 'GetPositionPercentage', fn: function(doc, div) {
  return getStyle(div.childNodes[2], 'left') == '10%';
}}, {identity: 'PercentageHeightOverflowBug', fn: function(doc) {
  var hasBug = false, style, el;
  if (Ext.getScrollbarSize().height) 
  {
    el = doc.createElement('div');
    style = el.style;
    style.height = '50px';
    style.width = '50px';
    style.overflow = 'auto';
    style.position = 'absolute';
    el.innerHTML = ['<div style="display:table;height:100%;">', '<div style="width:51px;"></div>', '</div>'].join('');
    doc.body.appendChild(el);
    if (el.firstChild.offsetHeight === 50) 
    {
      hasBug = true;
    }
    doc.body.removeChild(el);
  }
  return hasBug;
}}, {identity: 'xOriginBug', fn: function(doc, div) {
  div.innerHTML = '<div id="b1" style="height:100px;width:100px;direction:rtl;position:relative;overflow:scroll">' + '<div id="b2" style="position:relative;width:100%;height:20px;"></div>' + '<div id="b3" style="position:absolute;width:20px;height:20px;top:0px;right:0px"></div>' + '</div>';
  var outerBox = document.getElementById('b1').getBoundingClientRect(), b2 = document.getElementById('b2').getBoundingClientRect(), b3 = document.getElementById('b3').getBoundingClientRect();
  return (b2.left !== outerBox.left && b3.right !== outerBox.right);
}}, {identity: 'ScrollWidthInlinePaddingBug', fn: function(doc) {
  var hasBug = false, style, el;
  el = doc.createElement('div');
  style = el.style;
  style.height = '50px';
  style.width = '50px';
  style.padding = '10px';
  style.overflow = 'hidden';
  style.position = 'absolute';
  el.innerHTML = '<span style="display:inline-block;zoom:1;height:60px;width:60px;"></span>';
  doc.body.appendChild(el);
  if (el.scrollWidth === 70) 
  {
    hasBug = true;
  }
  doc.body.removeChild(el);
  return hasBug;
}}, {identity: 'rtlVertScrollbarOnRight', fn: function(doc, div) {
  div.innerHTML = '<div style="height:100px;width:100px;direction:rtl;overflow:scroll">' + '<div style="width:20px;height:200px;"></div>' + '</div>';
  var outerBox = div.firstChild, innerBox = outerBox.firstChild;
  return (innerBox.offsetLeft + innerBox.offsetWidth !== outerBox.offsetLeft + outerBox.offsetWidth);
}}, {identity: 'rtlVertScrollbarOverflowBug', fn: function(doc, div) {
  div.innerHTML = '<div style="height:100px;width:100px;direction:rtl;overflow:auto">' + '<div style="width:95px;height:200px;"></div>' + '</div>';
  var outerBox = div.firstChild;
  return outerBox.clientHeight === outerBox.offsetHeight;
}}]};
}());
Ext.supports.init();

Ext.util.DelayedTask = function(fn, scope, args, cancelOnDelay) {
  var me = this, delay, call = function() {
  clearInterval(me.id);
  me.id = null;
  fn.apply(scope, args || []);
  Ext.EventManager.idleEvent.fire();
};
  cancelOnDelay = typeof cancelOnDelay === 'boolean' ? cancelOnDelay : true;
  me.id = null;
  me.delay = function(newDelay, newFn, newScope, newArgs) {
  if (cancelOnDelay) 
  {
    me.cancel();
  }
  if (typeof newDelay === 'number') 
  {
    delay = newDelay;
  }
  fn = newFn || fn;
  scope = newScope || scope;
  args = newArgs || args;
  if (!me.id) 
  {
    me.id = setInterval(call, delay);
  }
};
  me.cancel = function() {
  if (me.id) 
  {
    clearInterval(me.id);
    me.id = null;
  }
};
};

(Ext.cmd.derive('Ext.util.Event', Ext.Base, function() {
  var arraySlice = Array.prototype.slice, arrayInsert = Ext.Array.insert, toArray = Ext.Array.toArray, DelayedTask = Ext.util.DelayedTask;
  return {isEvent: true, suspended: 0, noOptions: {}, constructor: function(observable, name) {
  this.name = name;
  this.observable = observable;
  this.listeners = [];
}, addListener: function(fn, scope, options) {
  var me = this, listeners, listener, priority, isNegativePriority, highestNegativePriorityIndex, hasNegativePriorityIndex, length, index, i, listenerPriority;
  scope = scope || me.observable;
  if (!me.isListening(fn, scope)) 
  {
    listener = me.createListener(fn, scope, options);
    if (me.firing) 
    {
      me.listeners = me.listeners.slice(0);
    }
    listeners = me.listeners;
    index = length = listeners.length;
    priority = options && options.priority;
    highestNegativePriorityIndex = me._highestNegativePriorityIndex;
    hasNegativePriorityIndex = (highestNegativePriorityIndex !== undefined);
    if (priority) 
    {
      isNegativePriority = (priority < 0);
      if (!isNegativePriority || hasNegativePriorityIndex) 
      {
        for (i = (isNegativePriority ? highestNegativePriorityIndex : 0); i < length; i++) 
          {
            listenerPriority = listeners[i].o ? listeners[i].o.priority || 0 : 0;
            if (listenerPriority < priority) 
            {
              index = i;
              break;
            }
          }
      } else {
        me._highestNegativePriorityIndex = index;
      }
    } else if (hasNegativePriorityIndex) 
    {
      index = highestNegativePriorityIndex;
    }
    if (!isNegativePriority && index <= highestNegativePriorityIndex) 
    {
      me._highestNegativePriorityIndex++;
    }
    if (index === length) 
    {
      me.listeners[length] = listener;
    } else {
      arrayInsert(me.listeners, index, [listener]);
    }
  }
}, createListener: function(fn, scope, o) {
  scope = scope || this.observable;
  var me = this, listener = {fn: fn, scope: scope, ev: me}, handler = fn;
  if (o) 
  {
    listener.o = o;
    if (o.single) 
    {
      handler = me.createSingle(handler, listener, o, scope);
    }
    if (o.target) 
    {
      handler = me.createTargeted(handler, listener, o, scope);
    }
    if (o.delay) 
    {
      handler = me.createDelayed(handler, listener, o, scope);
    }
    if (o.buffer) 
    {
      handler = me.createBuffered(handler, listener, o, scope);
    }
  }
  listener.fireFn = handler;
  return listener;
}, findListener: function(fn, scope) {
  var listeners = this.listeners, i = listeners.length, listener, s;
  while (i--) 
    {
      listener = listeners[i];
      if (listener) 
      {
        s = listener.scope;
        if (listener.fn == fn && (s == (scope || this.observable))) 
        {
          return i;
        }
      }
    }
  return -1;
}, isListening: function(fn, scope) {
  return this.findListener(fn, scope) !== -1;
}, removeListener: function(fn, scope) {
  var me = this, index, listener, highestNegativePriorityIndex, k;
  index = me.findListener(fn, scope);
  if (index != -1) 
  {
    listener = me.listeners[index];
    highestNegativePriorityIndex = me._highestNegativePriorityIndex;
    if (me.firing) 
    {
      me.listeners = me.listeners.slice(0);
    }
    if (listener.task) 
    {
      listener.task.cancel();
      delete listener.task;
    }
    k = listener.tasks && listener.tasks.length;
    if (k) 
    {
      while (k--) 
        {
          listener.tasks[k].cancel();
        }
      delete listener.tasks;
    }
    me.listeners.splice(index, 1);
    if (highestNegativePriorityIndex) 
    {
      if (index < highestNegativePriorityIndex) 
      {
        me._highestNegativePriorityIndex--;
      } else if (index === highestNegativePriorityIndex && index === me.listeners.length) 
      {
        delete me._highestNegativePriorityIndex;
      }
    }
    return true;
  }
  return false;
}, clearListeners: function() {
  var listeners = this.listeners, i = listeners.length;
  while (i--) 
    {
      this.removeListener(listeners[i].fn, listeners[i].scope);
    }
}, suspend: function() {
  ++this.suspended;
}, resume: function() {
  if (this.suspended) 
  {
    --this.suspended;
  }
}, isSuspended: function() {
  return this.suspended > 0;
}, fire: function() {
  var me = this, listeners = me.listeners, count = listeners.length, i, args, listener, len;
  if (!me.suspended && count > 0) 
  {
    me.firing = true;
    args = arguments.length ? arraySlice.call(arguments, 0) : [];
    len = args.length;
    for (i = 0; i < count; i++) 
      {
        listener = listeners[i];
        if (listener.o) 
        {
          args[len] = listener.o;
        }
        if (listener && listener.fireFn.apply(listener.scope || me.observable, args) === false) 
        {
          return (me.firing = false);
        }
      }
  }
  me.firing = false;
  return true;
}, createTargeted: function(handler, listener, o, scope) {
  return function() {
  if (o.target === arguments[0]) 
  {
    handler.apply(scope, arguments);
  }
};
}, createBuffered: function(handler, listener, o, scope) {
  listener.task = new DelayedTask();
  return function() {
  listener.task.delay(o.buffer, handler, scope, toArray(arguments));
};
}, createDelayed: function(handler, listener, o, scope) {
  return function() {
  var task = new DelayedTask();
  if (!listener.tasks) 
  {
    listener.tasks = [];
  }
  listener.tasks.push(task);
  task.delay(o.delay || 10, handler, scope, toArray(arguments));
};
}, createSingle: function(handler, listener, o, scope) {
  return function() {
  var event = listener.ev;
  if (event.removeListener(listener.fn, scope) && event.observable) 
  {
    event.observable.hasListeners[event.name]--;
  }
  return handler.apply(scope, arguments);
};
}};
}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Event'], 0));
;

Ext.EventManager = new function() {
  var EventManager = this, doc = document, win = window, supports = Ext.supports, escapeRx = /\\/g, prefix = Ext.baseCSSPrefix, supportsAddEventListener = !Ext.isIE9 && 'addEventListener' in doc, readyEvent, initExtCss = function() {
  var bd = doc.body || doc.getElementsByTagName('body')[0], cls = [], htmlCls = [], supportsLG = supports.CSS3LinearGradient, supportsBR = supports.CSS3BorderRadius, html;
  if (!Ext.scopeCss) 
  {
    cls.push(prefix + 'body');
  }
  if (!bd) 
  {
    return false;
  }
  html = bd.parentNode;
  function add(c) {
    cls.push(prefix + c);
  }
  if (Ext.isIE && Ext.isIE9m) 
  {
    add('ie');
    if (Ext.isIE6) 
    {
      add('ie6');
    } else {
      add('ie7p');
      if (Ext.isIE7) 
      {
        add('ie7');
      } else {
        add('ie8p');
        if (Ext.isIE8) 
        {
          add('ie8');
        } else {
          add('ie9p');
          if (Ext.isIE9) 
          {
            add('ie9');
          }
        }
      }
    }
    if (Ext.isIE7m) 
    {
      add('ie7m');
    }
    if (Ext.isIE8m) 
    {
      add('ie8m');
    }
    if (Ext.isIE9m) 
    {
      add('ie9m');
    }
    if (Ext.isIE7 || Ext.isIE8) 
    {
      add('ie78');
    }
  }
  if (Ext.isIE10) 
  {
    add('ie10');
  }
  if (Ext.isGecko) 
  {
    add('gecko');
    if (Ext.isGecko3) 
    {
      add('gecko3');
    }
    if (Ext.isGecko4) 
    {
      add('gecko4');
    }
    if (Ext.isGecko5) 
    {
      add('gecko5');
    }
  }
  if (Ext.isOpera) 
  {
    add('opera');
  }
  if (Ext.isWebKit) 
  {
    add('webkit');
  }
  if (Ext.isSafari) 
  {
    add('safari');
    if (Ext.isSafari2) 
    {
      add('safari2');
    }
    if (Ext.isSafari3) 
    {
      add('safari3');
    }
    if (Ext.isSafari4) 
    {
      add('safari4');
    }
    if (Ext.isSafari5) 
    {
      add('safari5');
    }
    if (Ext.isSafari5_0) 
    {
      add('safari5_0');
    }
  }
  if (Ext.isChrome) 
  {
    add('chrome');
  }
  if (Ext.isMac) 
  {
    add('mac');
  }
  if (Ext.isLinux) 
  {
    add('linux');
  }
  if (!supportsBR) 
  {
    add('nbr');
  }
  if (!supportsLG) 
  {
    add('nlg');
  }
  if (html) 
  {
    if (Ext.isStrict && (Ext.isIE6 || Ext.isIE7)) 
    {
      Ext.isBorderBox = false;
    } else {
      Ext.isBorderBox = true;
    }
    if (!Ext.isBorderBox) 
    {
      htmlCls.push(prefix + 'content-box');
    }
    if (Ext.isStrict) 
    {
      htmlCls.push(prefix + 'strict');
    } else {
      htmlCls.push(prefix + 'quirks');
    }
    Ext.fly(html, '_internal').addCls(htmlCls);
  }
  Ext.fly(bd, '_internal').addCls(cls);
  return true;
};
  Ext.apply(EventManager, {hasBoundOnReady: false, hasFiredReady: false, deferReadyEvent: 1, onReadyChain: [], readyEvent: (function() {
  readyEvent = new Ext.util.Event();
  readyEvent.fire = function() {
  Ext._beforeReadyTime = Ext._beforeReadyTime || new Date().getTime();
  readyEvent.self.prototype.fire.apply(readyEvent, arguments);
  Ext._afterReadytime = new Date().getTime();
};
  return readyEvent;
}()), idleEvent: new Ext.util.Event(), isReadyPaused: function() {
  return (/[?&]ext-pauseReadyFire\b/i.test(location.search) && !Ext._continueFireReady);
}, bindReadyEvent: function() {
  if (EventManager.hasBoundOnReady) 
  {
    return;
  }
  if (doc.readyState == 'complete') 
  {
    EventManager.onReadyEvent({type: doc.readyState || 'body'});
  } else {
    doc.addEventListener('DOMContentLoaded', EventManager.onReadyEvent, false);
    win.addEventListener('load', EventManager.onReadyEvent, false);
    EventManager.hasBoundOnReady = true;
  }
}, onReadyEvent: function(e) {
  if (e && e.type) 
  {
    EventManager.onReadyChain.push(e.type);
  }
  if (EventManager.hasBoundOnReady) 
  {
    doc.removeEventListener('DOMContentLoaded', EventManager.onReadyEvent, false);
    win.removeEventListener('load', EventManager.onReadyEvent, false);
  }
  if (!Ext.isReady) 
  {
    EventManager.fireDocReady();
  }
}, fireDocReady: function() {
  if (!Ext.isReady) 
  {
    Ext._readyTime = new Date().getTime();
    Ext.isReady = true;
    supports.init();
    EventManager.onWindowUnload();
    readyEvent.onReadyChain = EventManager.onReadyChain;
    if (Ext.isNumber(EventManager.deferReadyEvent)) 
    {
      Ext.Function.defer(EventManager.fireReadyEvent, EventManager.deferReadyEvent);
      EventManager.hasDocReadyTimer = true;
    } else {
      EventManager.fireReadyEvent();
    }
  }
}, fireReadyEvent: function() {
  EventManager.hasDocReadyTimer = false;
  EventManager.isFiring = true;
  while (readyEvent.listeners.length && !EventManager.isReadyPaused()) 
    {
      readyEvent.fire();
    }
  EventManager.isFiring = false;
  EventManager.hasFiredReady = true;
  EventManager.idleEvent.fire();
}, onDocumentReady: function(fn, scope, options) {
  options = options || {};
  options.single = true;
  readyEvent.addListener(fn, scope, options);
  if (!(EventManager.isFiring || EventManager.hasDocReadyTimer)) 
  {
    if (Ext.isReady) 
    {
      EventManager.fireReadyEvent();
    } else {
      EventManager.bindReadyEvent();
    }
  }
}, stoppedMouseDownEvent: new Ext.util.Event(), propRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|freezeEvent)$/, getId: function(element) {
  var id;
  element = Ext.getDom(element);
  if (element === doc) 
  {
    id = Ext.documentId;
  } else if (element == win) 
  {
    id = Ext.windowId;
  } else {
    id = Ext.id(element);
  }
  if (!Ext.cache[id]) 
  {
    Ext.addCacheEntry(id, null, element);
  }
  return id;
}, prepareListenerConfig: function(element, config, isRemove) {
  var propRe = EventManager.propRe, key, value, args;
  for (key in config) 
    {
      if (config.hasOwnProperty(key)) 
      {
        if (!propRe.test(key)) 
        {
          value = config[key];
          if (typeof value == 'function') 
          {
            args = [element, key, value, config.scope, config];
          } else {
            args = [element, key, value.fn, value.scope, value];
          }
          if (isRemove) 
          {
            EventManager.removeListener.apply(EventManager, args);
          } else {
            EventManager.addListener.apply(EventManager, args);
          }
        }
      }
    }
}, mouseEnterLeaveRe: /mouseenter|mouseleave/, normalizeEvent: function(eventName, fn) {
  if (EventManager.mouseEnterLeaveRe.test(eventName) && !supports.MouseEnterLeave) 
  {
    if (fn) 
    {
      fn = Ext.Function.createInterceptor(fn, EventManager.contains);
    }
    eventName = eventName == 'mouseenter' ? 'mouseover' : 'mouseout';
  } else if (eventName == 'mousewheel' && !supports.MouseWheel && !Ext.isOpera) 
  {
    eventName = 'DOMMouseScroll';
  }
  return {eventName: eventName, fn: fn};
}, contains: function(event) {
  event = event.browserEvent || event;
  var parent = event.currentTarget, child = EventManager.getRelatedTarget(event);
  if (parent && parent.firstChild) 
  {
    while (child) 
      {
        if (child === parent) 
        {
          return false;
        }
        child = child.parentNode;
        if (child && (child.nodeType != 1)) 
        {
          child = null;
        }
      }
  }
  return true;
}, addListener: function(element, eventName, fn, scope, options) {
  if (typeof eventName !== 'string') 
  {
    EventManager.prepareListenerConfig(element, eventName);
    return;
  }
  var dom = element.dom || Ext.getDom(element), hasAddEventListener, bind, wrap, cache, id, cacheItem, capture;
  if (typeof fn === 'string') 
  {
    fn = Ext.resolveMethod(fn, scope || element);
  }
  options = options || {};
  bind = EventManager.normalizeEvent(eventName, fn);
  wrap = EventManager.createListenerWrap(dom, eventName, bind.fn, scope, options);
  cache = EventManager.getEventListenerCache(element.dom ? element : dom, eventName);
  eventName = bind.eventName;
  hasAddEventListener = supportsAddEventListener || (Ext.isIE9 && !dom.attachEvent);
  if (!hasAddEventListener) 
  {
    id = EventManager.normalizeId(dom);
    if (id) 
    {
      cacheItem = Ext.cache[id][eventName];
      if (cacheItem && cacheItem.firing) 
      {
        cache = EventManager.cloneEventListenerCache(dom, eventName);
      }
    }
  }
  capture = !!options.capture;
  cache.push({fn: fn, wrap: wrap, scope: scope, capture: capture});
  if (!hasAddEventListener) 
  {
    if (cache.length === 1) 
    {
      id = EventManager.normalizeId(dom, true);
      fn = Ext.Function.bind(EventManager.handleSingleEvent, EventManager, [id, eventName], true);
      Ext.cache[id][eventName] = {firing: false, fn: fn};
      dom.attachEvent('on' + eventName, fn);
    }
  } else {
    dom.addEventListener(eventName, wrap, capture);
  }
  if (dom == doc && eventName == 'mousedown') 
  {
    EventManager.stoppedMouseDownEvent.addListener(wrap);
  }
}, normalizeId: function(dom, force) {
  var id;
  if (dom === doc) 
  {
    id = Ext.documentId;
  } else if (dom == win) 
  {
    id = Ext.windowId;
  } else {
    id = dom.id;
  }
  if (!id && force) 
  {
    id = EventManager.getId(dom);
  }
  return id;
}, handleSingleEvent: function(e, id, eventName) {
  var listenerCache = EventManager.getEventListenerCache(id, eventName), attachItem = Ext.cache[id][eventName], len, i;
  if (attachItem.firing) 
  {
    return;
  }
  attachItem.firing = true;
  for (i = 0 , len = listenerCache.length; i < len; ++i) 
    {
      listenerCache[i].wrap(e);
    }
  attachItem.firing = false;
}, removeListener: function(element, eventName, fn, scope) {
  if (typeof eventName !== 'string') 
  {
    EventManager.prepareListenerConfig(element, eventName, true);
    return;
  }
  var dom = Ext.getDom(element), id, el = element.dom ? element : Ext.get(dom), cache = EventManager.getEventListenerCache(el, eventName), bindName = EventManager.normalizeEvent(eventName).eventName, i = cache.length, j, cacheItem, hasRemoveEventListener, listener, wrap;
  if (!dom) 
  {
    return;
  }
  hasRemoveEventListener = supportsAddEventListener || (Ext.isIE9 && !dom.detachEvent);
  if (typeof fn === 'string') 
  {
    fn = Ext.resolveMethod(fn, scope || element);
  }
  while (i--) 
    {
      listener = cache[i];
      if (listener && (!fn || listener.fn == fn) && (!scope || listener.scope === scope)) 
      {
        wrap = listener.wrap;
        if (wrap.task) 
        {
          clearTimeout(wrap.task);
          delete wrap.task;
        }
        j = wrap.tasks && wrap.tasks.length;
        if (j) 
        {
          while (j--) 
            {
              clearTimeout(wrap.tasks[j]);
            }
          delete wrap.tasks;
        }
        if (!hasRemoveEventListener) 
        {
          id = EventManager.normalizeId(dom, true);
          cacheItem = Ext.cache[id][bindName];
          if (cacheItem && cacheItem.firing) 
          {
            cache = EventManager.cloneEventListenerCache(dom, bindName);
          }
          if (cache.length === 1) 
          {
            fn = cacheItem.fn;
            delete Ext.cache[id][bindName];
            dom.detachEvent('on' + bindName, fn);
          }
        } else {
          dom.removeEventListener(bindName, wrap, listener.capture);
        }
        if (wrap && dom == doc && eventName == 'mousedown') 
        {
          EventManager.stoppedMouseDownEvent.removeListener(wrap);
        }
        Ext.Array.erase(cache, i, 1);
      }
    }
}, removeAll: function(element) {
  var id = (typeof element === 'string') ? element : element.id, cache, events, eventName;
  if (id && (cache = Ext.cache[id])) 
  {
    events = cache.events;
    for (eventName in events) 
      {
        if (events.hasOwnProperty(eventName)) 
        {
          EventManager.removeListener(element, eventName);
        }
      }
    cache.events = {};
  }
}, purgeElement: function(element, eventName) {
  var dom = Ext.getDom(element), i = 0, len, childNodes;
  if (eventName) 
  {
    EventManager.removeListener(element, eventName);
  } else {
    EventManager.removeAll(element);
  }
  if (dom && dom.childNodes) 
  {
    childNodes = dom.childNodes;
    for (len = childNodes.length; i < len; i++) 
      {
        EventManager.purgeElement(childNodes[i], eventName);
      }
  }
}, createListenerWrap: function(dom, ename, fn, scope, options) {
  options = options || {};
  var gen, wrap = function(e, args) {
  var f;
  if (!gen) 
  {
    f = ['if(!' + Ext.name + ') {return;}'];
    if (options.buffer || options.delay || options.freezeEvent) 
    {
      if (options.freezeEvent) 
      {
        f.push('e = X.EventObject.setEvent(e);');
      }
      f.push('e = new X.EventObjectImpl(e, ' + (options.freezeEvent ? 'true' : 'false') + ');');
    } else {
      f.push('e = X.EventObject.setEvent(e);');
    }
    if (options.delegate) 
    {
      f.push('var result, t = e.getTarget("' + (options.delegate + '').replace(escapeRx, '\\\\') + '", this);');
      f.push('if(!t) {return;}');
    } else {
      f.push('var t = e.target, result;');
    }
    if (options.target) 
    {
      f.push('if(e.target !== options.target) {return;}');
    }
    if (options.stopEvent) 
    {
      f.push('e.stopEvent();');
    } else {
      if (options.preventDefault) 
      {
        f.push('e.preventDefault();');
      }
      if (options.stopPropagation) 
      {
        f.push('e.stopPropagation();');
      }
    }
    if (options.normalized === false) 
    {
      f.push('e = e.browserEvent;');
    }
    if (options.buffer) 
    {
      f.push('(wrap.task && clearTimeout(wrap.task));');
      f.push('wrap.task = setTimeout(function() {');
    }
    if (options.delay) 
    {
      f.push('wrap.tasks = wrap.tasks || [];');
      f.push('wrap.tasks.push(setTimeout(function() {');
    }
    f.push('result = fn.call(scope || dom, e, t, options);');
    if (options.single) 
    {
      f.push('evtMgr.removeListener(dom, ename, fn, scope);');
    }
    if (ename !== 'mousemove' && ename !== 'unload') 
    {
      f.push('if (evtMgr.idleEvent.listeners.length) {');
      f.push('evtMgr.idleEvent.fire();');
      f.push('}');
    }
    if (options.delay) 
    {
      f.push('}, ' + options.delay + '));');
    }
    if (options.buffer) 
    {
      f.push('}, ' + options.buffer + ');');
    }
    f.push('return result;');
    gen = Ext.cacheableFunctionFactory('e', 'options', 'fn', 'scope', 'ename', 'dom', 'wrap', 'args', 'X', 'evtMgr', f.join('\n'));
  }
  return gen.call(dom, e, options, fn, scope, ename, dom, wrap, args, Ext, EventManager);
};
  return wrap;
}, getEventCache: function(element) {
  var elementCache, eventCache, id;
  if (!element) 
  {
    return [];
  }
  if (element.$cache) 
  {
    elementCache = element.$cache;
  } else {
    if (typeof element === 'string') 
    {
      id = element;
    } else {
      id = EventManager.getId(element);
    }
    elementCache = Ext.cache[id];
  }
  eventCache = elementCache.events || (elementCache.events = {});
  return eventCache;
}, getEventListenerCache: function(element, eventName) {
  var eventCache = EventManager.getEventCache(element);
  return eventCache[eventName] || (eventCache[eventName] = []);
}, cloneEventListenerCache: function(element, eventName) {
  var eventCache = EventManager.getEventCache(element), out;
  if (eventCache[eventName]) 
  {
    out = eventCache[eventName].slice(0);
  } else {
    out = [];
  }
  eventCache[eventName] = out;
  return out;
}, mouseLeaveRe: /(mouseout|mouseleave)/, mouseEnterRe: /(mouseover|mouseenter)/, stopEvent: function(event) {
  EventManager.stopPropagation(event);
  EventManager.preventDefault(event);
}, stopPropagation: function(event) {
  event = event.browserEvent || event;
  if (event.stopPropagation) 
  {
    event.stopPropagation();
  } else {
    event.cancelBubble = true;
  }
}, preventDefault: function(event) {
  event = event.browserEvent || event;
  if (event.preventDefault) 
  {
    event.preventDefault();
  } else {
    event.returnValue = false;
    try {
      if (event.ctrlKey || event.keyCode > 111 && event.keyCode < 124) 
      {
        event.keyCode = -1;
      }
    }    catch (e) {
}
  }
}, getRelatedTarget: function(event) {
  event = event.browserEvent || event;
  var target = event.relatedTarget;
  if (!target) 
  {
    if (EventManager.mouseLeaveRe.test(event.type)) 
    {
      target = event.toElement;
    } else if (EventManager.mouseEnterRe.test(event.type)) 
    {
      target = event.fromElement;
    }
  }
  return EventManager.resolveTextNode(target);
}, getPageX: function(event) {
  return EventManager.getPageXY(event)[0];
}, getPageY: function(event) {
  return EventManager.getPageXY(event)[1];
}, getPageXY: function(event) {
  event = event.browserEvent || event;
  var x = event.pageX, y = event.pageY, docEl = doc.documentElement, body = doc.body;
  if (!x && x !== 0) 
  {
    x = event.clientX + (docEl && docEl.scrollLeft || body && body.scrollLeft || 0) - (docEl && docEl.clientLeft || body && body.clientLeft || 0);
    y = event.clientY + (docEl && docEl.scrollTop || body && body.scrollTop || 0) - (docEl && docEl.clientTop || body && body.clientTop || 0);
  }
  return [x, y];
}, getTarget: function(event) {
  event = event.browserEvent || event;
  return EventManager.resolveTextNode(event.target || event.srcElement);
}, resolveTextNode: Ext.isGecko ? function(node) {
  if (node) 
  {
    var s = HTMLElement.prototype.toString.call(node);
    if (s !== '[xpconnect wrapped native prototype]' && s !== '[object XULElement]') 
    {
      return node.nodeType == 3 ? node.parentNode : node;
    }
  }
} : function(node) {
  return node && node.nodeType == 3 ? node.parentNode : node;
}, curWidth: 0, curHeight: 0, onWindowResize: function(fn, scope, options) {
  var resize = EventManager.resizeEvent;
  if (!resize) 
  {
    EventManager.resizeEvent = resize = new Ext.util.Event();
    EventManager.on(win, 'resize', EventManager.fireResize, null, {buffer: 100});
  }
  resize.addListener(fn, scope, options);
}, fireResize: function() {
  var w = Ext.Element.getViewWidth(), h = Ext.Element.getViewHeight();
  if (EventManager.curHeight != h || EventManager.curWidth != w) 
  {
    EventManager.curHeight = h;
    EventManager.curWidth = w;
    EventManager.resizeEvent.fire(w, h);
  }
}, removeResizeListener: function(fn, scope) {
  var resize = EventManager.resizeEvent;
  if (resize) 
  {
    resize.removeListener(fn, scope);
  }
}, onWindowUnload: function(fn, scope, options) {
  var unload = EventManager.unloadEvent;
  if (!unload) 
  {
    EventManager.unloadEvent = unload = new Ext.util.Event();
    EventManager.addListener(win, 'unload', EventManager.fireUnload);
  }
  if (fn) 
  {
    unload.addListener(fn, scope, options);
  }
}, fireUnload: function() {
  try {
    doc = win = undefined;
    var gridviews, i, ln, el, cache;
    EventManager.unloadEvent.fire();
    if (Ext.isGecko3) 
    {
      gridviews = Ext.ComponentQuery.query('gridview');
      i = 0;
      ln = gridviews.length;
      for (; i < ln; i++) 
        {
          gridviews[i].scrollToTop();
        }
    }
    cache = Ext.cache;
    for (el in cache) 
      {
        if (cache.hasOwnProperty(el)) 
        {
          EventManager.removeAll(el);
        }
      }
  }  catch (e) {
}
}, removeUnloadListener: function(fn, scope) {
  var unload = EventManager.unloadEvent;
  if (unload) 
  {
    unload.removeListener(fn, scope);
  }
}, useKeyDown: Ext.isWebKit ? parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 : !((Ext.isGecko && !Ext.isWindows) || (Ext.isOpera && Ext.operaVersion < 12)), getKeyEvent: function() {
  return EventManager.useKeyDown ? 'keydown' : 'keypress';
}});
  if (!supportsAddEventListener && document.attachEvent) 
  {
    Ext.apply(EventManager, {pollScroll: function() {
  var scrollable = true;
  try {
    document.documentElement.doScroll('left');
  }  catch (e) {
  scrollable = false;
}
  if (scrollable && document.body) 
  {
    EventManager.onReadyEvent({type: 'doScroll'});
  } else {
    EventManager.scrollTimeout = setTimeout(EventManager.pollScroll, 20);
  }
  return scrollable;
}, scrollTimeout: null, readyStatesRe: /complete/i, checkReadyState: function() {
  var state = document.readyState;
  if (EventManager.readyStatesRe.test(state)) 
  {
    EventManager.onReadyEvent({type: state});
  }
}, bindReadyEvent: function() {
  var topContext = true;
  if (EventManager.hasBoundOnReady) 
  {
    return;
  }
  try {
    topContext = window.frameElement === undefined;
  }  catch (e) {
  topContext = false;
}
  if (!topContext || !doc.documentElement.doScroll) 
  {
    EventManager.pollScroll = Ext.emptyFn;
  }
  if (EventManager.pollScroll() === true) 
  {
    return;
  }
  if (doc.readyState == 'complete') 
  {
    EventManager.onReadyEvent({type: 'already ' + (doc.readyState || 'body')});
  } else {
    doc.attachEvent('onreadystatechange', EventManager.checkReadyState);
    window.attachEvent('onload', EventManager.onReadyEvent);
    EventManager.hasBoundOnReady = true;
  }
}, onReadyEvent: function(e) {
  if (e && e.type) 
  {
    EventManager.onReadyChain.push(e.type);
  }
  if (EventManager.hasBoundOnReady) 
  {
    document.detachEvent('onreadystatechange', EventManager.checkReadyState);
    window.detachEvent('onload', EventManager.onReadyEvent);
  }
  if (Ext.isNumber(EventManager.scrollTimeout)) 
  {
    clearTimeout(EventManager.scrollTimeout);
    delete EventManager.scrollTimeout;
  }
  if (!Ext.isReady) 
  {
    EventManager.fireDocReady();
  }
}, onReadyChain: []});
  }
  Ext.onReady = function(fn, scope, options) {
  Ext.Loader.onReady(fn, scope, true, options);
};
  Ext.onDocumentReady = EventManager.onDocumentReady;
  EventManager.on = EventManager.addListener;
  EventManager.un = EventManager.removeListener;
  Ext.onReady(initExtCss);
}();

Ext.setVersion("ext-theme-base", "4.2.3.1477");
Ext.setVersion("ext-theme-classic", "4.2.3.1477");
Ext.setVersion("ext-theme-gray", "4.2.3.1477");
Ext.setVersion("ext-theme-neutral", "4.2.3.1477");

(Ext.cmd.derive('Ext.util.Observable', Ext.Base, function(Observable) {
  var emptyFn = Ext.emptyFn, emptyArray = [], arrayProto = Array.prototype, arraySlice = arrayProto.slice, ExtEvent = Ext.util.Event, ListenerRemover = function(observable) {
  if (observable instanceof ListenerRemover) 
  {
    return observable;
  }
  this.observable = observable;
  if (arguments[1].isObservable) 
  {
    this.managedListeners = true;
  }
  this.args = arraySlice.call(arguments, 1);
};
  ListenerRemover.prototype.destroy = function() {
  this.observable[this.managedListeners ? 'mun' : 'un'].apply(this.observable, this.args);
};
  return {statics: {releaseCapture: function(o) {
  o.fireEventArgs = this.prototype.fireEventArgs;
}, capture: function(o, fn, scope) {
  var newFn = function(eventName, args) {
  return fn.apply(scope, [eventName].concat(args));
};
  this.captureArgs(o, newFn, scope);
}, captureArgs: function(o, fn, scope) {
  o.fireEventArgs = Ext.Function.createInterceptor(o.fireEventArgs, fn, scope);
}, observe: function(cls, listeners) {
  if (cls) 
  {
    if (!cls.isObservable) 
    {
      Ext.applyIf(cls, new this());
      this.captureArgs(cls.prototype, cls.fireEventArgs, cls);
    }
    if (Ext.isObject(listeners)) 
    {
      cls.on(listeners);
    }
  }
  return cls;
}, prepareClass: function(T, mixin) {
  if (!T.HasListeners) 
  {
    var HasListeners = function() {
}, SuperHL = T.superclass.HasListeners || (mixin && mixin.HasListeners) || Observable.HasListeners;
    T.prototype.HasListeners = T.HasListeners = HasListeners;
    HasListeners.prototype = T.hasListeners = new SuperHL();
  }
}}, isObservable: true, eventsSuspended: 0, constructor: function(config) {
  var me = this;
  Ext.apply(me, config);
  if (!me.hasListeners) 
  {
    me.hasListeners = new me.HasListeners();
  }
  me.events = me.events || {};
  if (me.listeners) 
  {
    me.on(me.listeners);
    me.listeners = null;
  }
  if (me.bubbleEvents) 
  {
    me.enableBubble(me.bubbleEvents);
  }
}, onClassExtended: function(T) {
  if (!T.HasListeners) 
  {
    Observable.prepareClass(T);
  }
}, eventOptionsRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|element|destroyable|vertical|horizontal|freezeEvent|priority)$/, addManagedListener: function(item, ename, fn, scope, options, noDestroy) {
  var me = this, managedListeners = me.managedListeners = me.managedListeners || [], config, passedOptions;
  if (typeof ename !== 'string') 
  {
    passedOptions = arguments.length > 4 ? options : ename;
    options = ename;
    for (ename in options) 
      {
        if (options.hasOwnProperty(ename)) 
        {
          config = options[ename];
          if (!me.eventOptionsRe.test(ename)) 
          {
            me.addManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope, config.fn ? config : passedOptions, true);
          }
        }
      }
    if (options && options.destroyable) 
    {
      return new ListenerRemover(me, item, options);
    }
  } else {
    if (typeof fn === 'string') 
    {
      scope = scope || me;
      fn = Ext.resolveMethod(fn, scope);
    }
    if (fn !== emptyFn) 
    {
      managedListeners.push({item: item, ename: ename, fn: fn, scope: scope, options: options});
      item.on(ename, fn, scope, options);
      if (!noDestroy && options && options.destroyable) 
      {
        return new ListenerRemover(me, item, ename, fn, scope);
      }
    }
  }
}, removeManagedListener: function(item, ename, fn, scope) {
  var me = this, options, config, managedListeners, length, i;
  if (typeof ename !== 'string') 
  {
    options = ename;
    for (ename in options) 
      {
        if (options.hasOwnProperty(ename)) 
        {
          config = options[ename];
          if (!me.eventOptionsRe.test(ename)) 
          {
            me.removeManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope);
          }
        }
      }
  } else {
    managedListeners = me.managedListeners ? me.managedListeners.slice() : [];
    if (typeof fn === 'string') 
    {
      scope = scope || me;
      fn = Ext.resolveMethod(fn, scope);
    }
    for (i = 0 , length = managedListeners.length; i < length; i++) 
      {
        me.removeManagedListenerItem(false, managedListeners[i], item, ename, fn, scope);
      }
  }
}, fireEvent: function(eventName) {
  return this.fireEventArgs(eventName, arraySlice.call(arguments, 1));
}, fireEventArgs: function(eventName, args) {
  eventName = eventName.toLowerCase();
  var me = this, events = me.events, event = events && events[eventName], ret = true;
  if (event && me.hasListeners[eventName]) 
  {
    ret = me.continueFireEvent(eventName, args || emptyArray, event.bubble);
  }
  return ret;
}, continueFireEvent: function(eventName, args, bubbles) {
  var target = this, queue, event, ret = true;
  do {
    if (target.eventsSuspended) 
    {
      if ((queue = target.eventQueue)) 
      {
        queue.push([eventName, args, bubbles]);
      }
      return ret;
    } else {
      event = target.events[eventName];
      if (event && event !== true) 
      {
        if ((ret = event.fire.apply(event, args)) === false) 
        {
          break;
        }
      }
    }
  } while (bubbles && (target = target.getBubbleParent()));
  return ret;
}, getBubbleParent: function() {
  var me = this, parent = me.getBubbleTarget && me.getBubbleTarget();
  if (parent && parent.isObservable) 
  {
    return parent;
  }
  return null;
}, addListener: function(ename, fn, scope, options) {
  var me = this, config, event, prevListenerCount = 0;
  if (typeof ename !== 'string') 
  {
    options = ename;
    for (ename in options) 
      {
        if (options.hasOwnProperty(ename)) 
        {
          config = options[ename];
          if (!me.eventOptionsRe.test(ename)) 
          {
            me.addListener(ename, config.fn || config, config.scope || options.scope, config.fn ? config : options);
          }
        }
      }
    if (options && options.destroyable) 
    {
      return new ListenerRemover(me, options);
    }
  } else {
    ename = ename.toLowerCase();
    event = me.events[ename];
    if (event && event.isEvent) 
    {
      prevListenerCount = event.listeners.length;
    } else {
      me.events[ename] = event = new ExtEvent(me, ename);
    }
    if (typeof fn === 'string') 
    {
      scope = scope || me;
      fn = Ext.resolveMethod(fn, scope);
    }
    if (fn !== emptyFn) 
    {
      event.addListener(fn, scope, options);
      if (event.listeners.length !== prevListenerCount) 
      {
        me.hasListeners._incr_(ename);
      }
      if (options && options.destroyable) 
      {
        return new ListenerRemover(me, ename, fn, scope, options);
      }
    }
  }
}, removeListener: function(ename, fn, scope) {
  var me = this, config, event, options;
  if (typeof ename !== 'string') 
  {
    options = ename;
    for (ename in options) 
      {
        if (options.hasOwnProperty(ename)) 
        {
          config = options[ename];
          if (!me.eventOptionsRe.test(ename)) 
          {
            me.removeListener(ename, config.fn || config, config.scope || options.scope);
          }
        }
      }
  } else {
    ename = ename.toLowerCase();
    event = me.events[ename];
    if (event && event.isEvent) 
    {
      if (typeof fn === 'string') 
      {
        scope = scope || me;
        fn = Ext.resolveMethod(fn, scope);
      }
      if (event.removeListener(fn, scope)) 
      {
        me.hasListeners._decr_(ename);
      }
    }
  }
}, clearListeners: function() {
  var events = this.events, hasListeners = this.hasListeners, event, key;
  for (key in events) 
    {
      if (events.hasOwnProperty(key)) 
      {
        event = events[key];
        if (event.isEvent) 
        {
          delete hasListeners[key];
          event.clearListeners();
        }
      }
    }
  this.clearManagedListeners();
}, clearManagedListeners: function() {
  var managedListeners = this.managedListeners || [], i = 0, len = managedListeners.length;
  for (; i < len; i++) 
    {
      this.removeManagedListenerItem(true, managedListeners[i]);
    }
  this.managedListeners = [];
}, removeManagedListenerItem: function(isClear, managedListener, item, ename, fn, scope) {
  if (isClear || (managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope))) 
  {
    managedListener.item.un(managedListener.ename, managedListener.fn, managedListener.scope);
    if (!isClear) 
    {
      Ext.Array.remove(this.managedListeners, managedListener);
    }
  }
}, addEvents: function(o) {
  var me = this, events = me.events || (me.events = {}), arg, args, i;
  if (typeof o == 'string') 
  {
    for (args = arguments , i = args.length; i--; ) 
      {
        arg = args[i];
        if (!events[arg]) 
        {
          events[arg] = true;
        }
      }
  } else {
    Ext.applyIf(me.events, o);
  }
}, hasListener: function(ename) {
  return !!this.hasListeners[ename.toLowerCase()];
}, isSuspended: function(event) {
  var suspended = this.eventsSuspended > 0;
  if (!suspended && event) 
  {
    event = this.events[event];
    if (event && event.isEvent) 
    {
      return event.isSuspended();
    }
  }
  return suspended;
}, suspendEvents: function(queueSuspended) {
  this.eventsSuspended += 1;
  if (queueSuspended && !this.eventQueue) 
  {
    this.eventQueue = [];
  }
}, suspendEvent: function(eventName) {
  var len = arguments.length, events = this.events, i, event, ename;
  for (i = 0; i < len; i++) 
    {
      ename = arguments[i];
      event = events[ename];
      if (!event || typeof event == 'boolean') 
      {
        events[ename] = event = new ExtEvent(this, ename);
      }
      event.suspend();
    }
}, resumeEvent: function() {
  var len = arguments.length, i, event;
  for (i = 0; i < len; i++) 
    {
      event = this.events[arguments[i]];
      if (event && event.resume) 
      {
        event.resume();
      }
    }
}, resumeEvents: function() {
  var me = this, queued = me.eventQueue, qLen, q;
  if (me.eventsSuspended && !--me.eventsSuspended) 
  {
    delete me.eventQueue;
    if (queued) 
    {
      qLen = queued.length;
      for (q = 0; q < qLen; q++) 
        {
          me.continueFireEvent.apply(me, queued[q]);
        }
    }
  }
}, relayEvents: function(origin, events, prefix) {
  var me = this, len = events.length, i = 0, oldName, relayers = {};
  for (; i < len; i++) 
    {
      oldName = events[i];
      relayers[oldName] = me.createRelayer(prefix ? prefix + oldName : oldName);
    }
  me.mon(origin, relayers, null, null, undefined);
  return new ListenerRemover(me, origin, relayers);
}, createRelayer: function(newName, beginEnd) {
  var me = this;
  return function() {
  return me.fireEventArgs.call(me, newName, beginEnd ? arraySlice.apply(arguments, beginEnd) : arguments);
};
}, enableBubble: function(eventNames) {
  if (eventNames) 
  {
    var me = this, names = (typeof eventNames == 'string') ? arguments : eventNames, length = names.length, events = me.events, ename, event, i;
    for (i = 0; i < length; ++i) 
      {
        ename = names[i].toLowerCase();
        event = events[ename];
        if (!event || typeof event == 'boolean') 
        {
          events[ename] = event = new ExtEvent(me, ename);
        }
        me.hasListeners._incr_(ename);
        event.bubble = true;
      }
  }
}};
}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Observable'], function() {
  var Observable = this, proto = Observable.prototype, HasListeners = function() {
}, prepareMixin = function(T) {
  if (!T.HasListeners) 
  {
    var proto = T.prototype;
    Observable.prepareClass(T, this);
    T.onExtended(function(U) {
  Observable.prepareClass(U);
});
    if (proto.onClassMixedIn) 
    {
      Ext.override(T, {onClassMixedIn: function(U) {
  prepareMixin.call(this, U);
  this.callParent(arguments);
}});
    } else {
      proto.onClassMixedIn = function(U) {
  prepareMixin.call(this, U);
};
    }
  }
}, globalEvents;
  HasListeners.prototype = {_decr_: function(ev) {
  if (!--this[ev]) 
  {
    delete this[ev];
  }
}, _incr_: function(ev) {
  if (this.hasOwnProperty(ev)) 
  {
    ++this[ev];
  } else {
    this[ev] = 1;
  }
}};
  proto.HasListeners = Observable.HasListeners = HasListeners;
  Observable.createAlias({on: 'addListener', un: 'removeListener', mon: 'addManagedListener', mun: 'removeManagedListener'});
  Observable.observeClass = Observable.observe;
  Ext.globalEvents = globalEvents = new Observable({events: {idle: Ext.EventManager.idleEvent, ready: Ext.EventManager.readyEvent}});
  Ext.on = function() {
  return globalEvents.addListener.apply(globalEvents, arguments);
};
  Ext.un = function() {
  return globalEvents.removeListener.apply(globalEvents, arguments);
};
  function getMethodEvent(method) {
    var e = (this.methodEvents = this.methodEvents || {})[method], returnValue, v, cancel, obj = this, makeCall;
    if (!e) 
    {
      this.methodEvents[method] = e = {};
      e.originalFn = this[method];
      e.methodName = method;
      e.before = [];
      e.after = [];
      makeCall = function(fn, scope, args) {
  if ((v = fn.apply(scope || obj, args)) !== undefined) 
  {
    if (typeof v == 'object') 
    {
      if (v.returnValue !== undefined) 
      {
        returnValue = v.returnValue;
      } else {
        returnValue = v;
      }
      cancel = !!v.cancel;
    } else if (v === false) 
    {
      cancel = true;
    } else {
      returnValue = v;
    }
  }
};
      this[method] = function() {
  var args = Array.prototype.slice.call(arguments, 0), b, i, len;
  returnValue = v = undefined;
  cancel = false;
  for (i = 0 , len = e.before.length; i < len; i++) 
    {
      b = e.before[i];
      makeCall(b.fn, b.scope, args);
      if (cancel) 
      {
        return returnValue;
      }
    }
  if ((v = e.originalFn.apply(obj, args)) !== undefined) 
  {
    returnValue = v;
  }
  for (i = 0 , len = e.after.length; i < len; i++) 
    {
      b = e.after[i];
      makeCall(b.fn, b.scope, args);
      if (cancel) 
      {
        return returnValue;
      }
    }
  return returnValue;
};
    }
    return e;
  }
  Ext.apply(proto, {onClassMixedIn: prepareMixin, beforeMethod: function(method, fn, scope) {
  getMethodEvent.call(this, method).before.push({fn: fn, scope: scope});
}, afterMethod: function(method, fn, scope) {
  getMethodEvent.call(this, method).after.push({fn: fn, scope: scope});
}, removeMethodListener: function(method, fn, scope) {
  var e = this.getMethodEvent(method), i, len;
  for (i = 0 , len = e.before.length; i < len; i++) 
    {
      if (e.before[i].fn == fn && e.before[i].scope == scope) 
      {
        Ext.Array.erase(e.before, i, 1);
        return;
      }
    }
  for (i = 0 , len = e.after.length; i < len; i++) 
    {
      if (e.after[i].fn == fn && e.after[i].scope == scope) 
      {
        Ext.Array.erase(e.after, i, 1);
        return;
      }
    }
}, toggleEventLogging: function(toggle) {
  Ext.util.Observable[toggle ? 'capture' : 'releaseCapture'](this, function(en) {
  if (Ext.isDefined(Ext.global.console)) 
  {
    Ext.global.console.log(en, arguments);
  }
});
}});
}));
;

(Ext.cmd.derive('Ext.EventObjectImpl', Ext.Base, {BACKSPACE: 8, TAB: 9, NUM_CENTER: 12, ENTER: 13, RETURN: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 44, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, CONTEXT_MENU: 93, NUM_ZERO: 96, NUM_ONE: 97, NUM_TWO: 98, NUM_THREE: 99, NUM_FOUR: 100, NUM_FIVE: 101, NUM_SIX: 102, NUM_SEVEN: 103, NUM_EIGHT: 104, NUM_NINE: 105, NUM_MULTIPLY: 106, NUM_PLUS: 107, NUM_MINUS: 109, NUM_PERIOD: 110, NUM_DIVISION: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, WHEEL_SCALE: (function() {
  var scale;
  if (Ext.isGecko) 
  {
    scale = 3;
  } else if (Ext.isMac) 
  {
    if (Ext.isSafari && Ext.webKitVersion >= 532) 
    {
      scale = 120;
    } else {
      scale = 12;
    }
    scale *= 3;
  } else {
    scale = 120;
  }
  return scale;
}()), clickRe: /(dbl)?click/, safariKeys: {3: 13, 63234: 37, 63235: 39, 63232: 38, 63233: 40, 63276: 33, 63277: 34, 63272: 46, 63273: 36, 63275: 35}, btnMap: Ext.isIE9m ? {1: 0, 4: 1, 2: 2} : {0: 0, 1: 1, 2: 2}, isEvent: true, constructor: function(event, freezeEvent) {
  if (event) 
  {
    this.setEvent(event.browserEvent || event, freezeEvent);
  }
}, setEvent: function(event, freezeEvent) {
  var me = this, button;
  if (event === me || (event && event.browserEvent)) 
  {
    return event;
  }
  me.browserEvent = event;
  if (event) 
  {
    button = event.button ? me.btnMap[event.button] : (event.which ? event.which - 1 : -1);
    if (me.clickRe.test(event.type) && button == -1) 
    {
      button = 0;
    }
    me.type = event.type;
    me.button = button;
    me.shiftKey = event.shiftKey;
    me.ctrlKey = event.ctrlKey || event.metaKey || false;
    me.altKey = event.altKey;
    me.keyCode = event.keyCode;
    me.charCode = event.charCode;
    me.target = Ext.EventManager.getTarget(event);
    me.relatedTarget = Ext.EventManager.getRelatedTarget(event);
    me.currentTarget = event.currentTarget;
    me.xy = (freezeEvent ? me.getXY() : null);
  } else {
    me.button = -1;
    me.shiftKey = false;
    me.ctrlKey = false;
    me.altKey = false;
    me.keyCode = 0;
    me.charCode = 0;
    me.target = null;
    me.xy = [0, 0];
  }
  return me;
}, clone: function() {
  return new this.self(this.browserEvent, this);
}, stopEvent: function() {
  this.stopPropagation();
  this.preventDefault();
}, preventDefault: function() {
  if (this.browserEvent) 
  {
    Ext.EventManager.preventDefault(this.browserEvent);
  }
}, stopPropagation: function() {
  var browserEvent = this.browserEvent;
  if (browserEvent) 
  {
    if (browserEvent.type == 'mousedown') 
    {
      Ext.EventManager.stoppedMouseDownEvent.fire(this);
    }
    Ext.EventManager.stopPropagation(browserEvent);
  }
}, getCharCode: function() {
  return this.charCode || this.keyCode;
}, getKey: function() {
  return this.normalizeKey(this.keyCode || this.charCode);
}, normalizeKey: function(key) {
  return Ext.isWebKit ? (this.safariKeys[key] || key) : key;
}, getPageX: function() {
  return this.getX();
}, getPageY: function() {
  return this.getY();
}, getX: function() {
  return this.getXY()[0];
}, getY: function() {
  return this.getXY()[1];
}, getXY: function() {
  if (!this.xy) 
  {
    this.xy = Ext.EventManager.getPageXY(this.browserEvent);
  }
  return this.xy;
}, getTarget: function(selector, maxDepth, returnEl) {
  if (selector) 
  {
    return Ext.fly(this.target).findParent(selector, maxDepth, returnEl);
  }
  return returnEl ? Ext.get(this.target) : this.target;
}, getRelatedTarget: function(selector, maxDepth, returnEl) {
  if (selector && this.relatedTarget) 
  {
    return Ext.fly(this.relatedTarget).findParent(selector, maxDepth, returnEl);
  }
  return returnEl ? Ext.get(this.relatedTarget) : this.relatedTarget;
}, correctWheelDelta: function(delta) {
  var scale = this.WHEEL_SCALE, ret = Math.round(delta / scale);
  if (!ret && delta) 
  {
    ret = (delta < 0) ? -1 : 1;
  }
  return ret;
}, getWheelDeltas: function() {
  var me = this, event = me.browserEvent, dx = 0, dy = 0;
  if (Ext.isDefined(event.wheelDeltaX)) 
  {
    dx = event.wheelDeltaX;
    dy = event.wheelDeltaY;
  } else if (event.wheelDelta) 
  {
    dy = event.wheelDelta;
  } else if (event.detail) 
  {
    dy = -event.detail;
    if (dy > 100) 
    {
      dy = 3;
    } else if (dy < -100) 
    {
      dy = -3;
    }
    if (Ext.isDefined(event.axis) && event.axis === event.HORIZONTAL_AXIS) 
    {
      dx = dy;
      dy = 0;
    }
  }
  return {x: me.correctWheelDelta(dx), y: me.correctWheelDelta(dy)};
}, getWheelDelta: function() {
  var deltas = this.getWheelDeltas();
  return deltas.y;
}, within: function(el, related, allowEl) {
  if (el) 
  {
    var t = related ? this.getRelatedTarget() : this.getTarget(), result;
    if (t) 
    {
      result = Ext.fly(el, '_internal').contains(t);
      if (!result && allowEl) 
      {
        result = t == Ext.getDom(el);
      }
      return result;
    }
  }
  return false;
}, isNavKeyPress: function() {
  var me = this, k = this.normalizeKey(me.keyCode);
  return (k >= 33 && k <= 40) || k == me.RETURN || k == me.TAB || k == me.ESC;
}, isSpecialKey: function() {
  var k = this.normalizeKey(this.keyCode);
  return (this.type == 'keypress' && this.ctrlKey) || this.isNavKeyPress() || (k == this.BACKSPACE) || (k >= 16 && k <= 20) || (k >= 44 && k <= 46);
}, getPoint: function() {
  var xy = this.getXY();
  return new Ext.util.Point(xy[0], xy[1]);
}, hasModifier: function() {
  var me = this;
  return !!(me.ctrlKey || me.altKey || me.shiftKey || me.metaKey);
}, injectEvent: (function() {
  var API, dispatchers = {}, crazyIEButtons;
  if (!Ext.isIE9m && document.createEvent) 
  {
    API = {createHtmlEvent: function(doc, type, bubbles, cancelable) {
  var event = doc.createEvent('HTMLEvents');
  event.initEvent(type, bubbles, cancelable);
  return event;
}, createMouseEvent: function(doc, type, bubbles, cancelable, detail, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
  var event = doc.createEvent('MouseEvents'), view = doc.defaultView || window;
  if (event.initMouseEvent) 
  {
    event.initMouseEvent(type, bubbles, cancelable, view, detail, clientX, clientY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
  } else {
    event = doc.createEvent('UIEvents');
    event.initEvent(type, bubbles, cancelable);
    event.view = view;
    event.detail = detail;
    event.screenX = clientX;
    event.screenY = clientY;
    event.clientX = clientX;
    event.clientY = clientY;
    event.ctrlKey = ctrlKey;
    event.altKey = altKey;
    event.metaKey = metaKey;
    event.shiftKey = shiftKey;
    event.button = button;
    event.relatedTarget = relatedTarget;
  }
  return event;
}, createUIEvent: function(doc, type, bubbles, cancelable, detail) {
  var event = doc.createEvent('UIEvents'), view = doc.defaultView || window;
  event.initUIEvent(type, bubbles, cancelable, view, detail);
  return event;
}, fireEvent: function(target, type, event) {
  target.dispatchEvent(event);
}, fixTarget: function(target) {
  if (target == window && !target.dispatchEvent) 
  {
    return document;
  }
  return target;
}};
  } else if (document.createEventObject) 
  {
    crazyIEButtons = {0: 1, 1: 4, 2: 2};
    API = {createHtmlEvent: function(doc, type, bubbles, cancelable) {
  var event = doc.createEventObject();
  event.bubbles = bubbles;
  event.cancelable = cancelable;
  return event;
}, createMouseEvent: function(doc, type, bubbles, cancelable, detail, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
  var event = doc.createEventObject();
  event.bubbles = bubbles;
  event.cancelable = cancelable;
  event.detail = detail;
  event.screenX = clientX;
  event.screenY = clientY;
  event.clientX = clientX;
  event.clientY = clientY;
  event.ctrlKey = ctrlKey;
  event.altKey = altKey;
  event.shiftKey = shiftKey;
  event.metaKey = metaKey;
  event.button = crazyIEButtons[button] || button;
  event.relatedTarget = relatedTarget;
  return event;
}, createUIEvent: function(doc, type, bubbles, cancelable, detail) {
  var event = doc.createEventObject();
  event.bubbles = bubbles;
  event.cancelable = cancelable;
  return event;
}, fireEvent: function(target, type, event) {
  target.fireEvent('on' + type, event);
}, fixTarget: function(target) {
  if (target == document) 
  {
    return document.documentElement;
  }
  return target;
}};
  }
  Ext.Object.each({load: [false, false], unload: [false, false], select: [true, false], change: [true, false], submit: [true, true], reset: [true, false], resize: [true, false], scroll: [true, false]}, function(name, value) {
  var bubbles = value[0], cancelable = value[1];
  dispatchers[name] = function(targetEl, srcEvent) {
  var e = API.createHtmlEvent(name, bubbles, cancelable);
  API.fireEvent(targetEl, name, e);
};
});
  function createMouseEventDispatcher(type, detail) {
    var cancelable = (type != 'mousemove');
    return function(targetEl, srcEvent) {
  var xy = srcEvent.getXY(), e = API.createMouseEvent(targetEl.ownerDocument, type, true, cancelable, detail, xy[0], xy[1], srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget);
  API.fireEvent(targetEl, type, e);
};
  }
  Ext.each(['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mousemove', 'mouseout'], function(eventName) {
  dispatchers[eventName] = createMouseEventDispatcher(eventName, 1);
});
  Ext.Object.each({focusin: [true, false], focusout: [true, false], activate: [true, true], focus: [false, false], blur: [false, false]}, function(name, value) {
  var bubbles = value[0], cancelable = value[1];
  dispatchers[name] = function(targetEl, srcEvent) {
  var e = API.createUIEvent(targetEl.ownerDocument, name, bubbles, cancelable, 1);
  API.fireEvent(targetEl, name, e);
};
});
  if (!API) 
  {
    dispatchers = {};
    API = {fixTarget: Ext.identityFn};
  }
  function cannotInject(target, srcEvent) {
  }
  return function(target) {
  var me = this, dispatcher = dispatchers[me.type] || cannotInject, t = target ? (target.dom || target) : me.getTarget();
  t = API.fixTarget(t);
  dispatcher(t, me);
};
}())}, 1, 0, 0, 0, 0, 0, [Ext, 'EventObjectImpl'], function() {
  Ext.EventObject = new Ext.EventObjectImpl();
}));
;

(Ext.cmd.derive('Ext.dom.AbstractQuery', Ext.Base, {select: function(q, root) {
  var results = [], nodes, i, j, qlen, nlen;
  root = root || document;
  if (typeof root == 'string') 
  {
    root = document.getElementById(root);
  }
  q = Ext.splitAndUnescape(q, ",");
  for (i = 0 , qlen = q.length; i < qlen; i++) 
    {
      if (typeof q[i] == 'string') 
      {
        if (typeof q[i][0] == '@') 
        {
          nodes = root.getAttributeNode(q[i].substring(1));
          results.push(nodes);
        } else {
          nodes = root.querySelectorAll(q[i]);
          for (j = 0 , nlen = nodes.length; j < nlen; j++) 
            {
              results.push(nodes[j]);
            }
        }
      }
    }
  return results;
}, selectNode: function(q, root) {
  return this.select(q, root)[0];
}, is: function(el, q) {
  if (typeof el == "string") 
  {
    el = document.getElementById(el);
  }
  return this.select(q).indexOf(el) !== -1;
}}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'AbstractQuery'], 0));
;

(Ext.cmd.derive('Ext.dom.AbstractHelper', Ext.Base, {emptyTags: /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i, confRe: /^(?:tag|children|cn|html|tpl|tplData)$/i, endRe: /end/i, styleSepRe: /\s*(?::|;)\s*/, attributeTransform: {cls: 'class', htmlFor: 'for'}, closeTags: {}, decamelizeName: (function() {
  var camelCaseRe = /([a-z])([A-Z])/g, cache = {};
  function decamel(match, p1, p2) {
    return p1 + '-' + p2.toLowerCase();
  }
  return function(s) {
  return cache[s] || (cache[s] = s.replace(camelCaseRe, decamel));
};
}()), generateMarkup: function(spec, buffer) {
  var me = this, specType = typeof spec, attr, val, tag, i, closeTags;
  if (specType == "string" || specType == "number") 
  {
    buffer.push(spec);
  } else if (Ext.isArray(spec)) 
  {
    for (i = 0; i < spec.length; i++) 
      {
        if (spec[i]) 
        {
          me.generateMarkup(spec[i], buffer);
        }
      }
  } else {
    tag = spec.tag || 'div';
    buffer.push('<', tag);
    for (attr in spec) 
      {
        if (spec.hasOwnProperty(attr)) 
        {
          val = spec[attr];
          if (!me.confRe.test(attr)) 
          {
            if (typeof val == "object") 
            {
              buffer.push(' ', attr, '="');
              me.generateStyles(val, buffer, true).push('"');
            } else {
              buffer.push(' ', me.attributeTransform[attr] || attr, '="', val, '"');
            }
          }
        }
      }
    if (me.emptyTags.test(tag)) 
    {
      buffer.push('/>');
    } else {
      buffer.push('>');
      if ((val = spec.tpl)) 
      {
        val.applyOut(spec.tplData, buffer);
      }
      if ((val = spec.html)) 
      {
        buffer.push(val);
      }
      if ((val = spec.cn || spec.children)) 
      {
        me.generateMarkup(val, buffer);
      }
      closeTags = me.closeTags;
      buffer.push(closeTags[tag] || (closeTags[tag] = '</' + tag + '>'));
    }
  }
  return buffer;
}, generateStyles: function(styles, buffer, encode) {
  var a = buffer || [], name, val;
  for (name in styles) 
    {
      if (styles.hasOwnProperty(name)) 
      {
        val = styles[name];
        name = this.decamelizeName(name);
        if (encode && Ext.String.hasHtmlCharacters(val)) 
        {
          val = Ext.String.htmlEncode(val);
        }
        a.push(name, ':', val, ';');
      }
    }
  return buffer || a.join('');
}, markup: function(spec) {
  if (typeof spec == "string") 
  {
    return spec;
  }
  var buf = this.generateMarkup(spec, []);
  return buf.join('');
}, applyStyles: function(el, styles) {
  if (styles) 
  {
    var i = 0, len;
    el = Ext.fly(el, '_applyStyles');
    if (typeof styles == 'function') 
    {
      styles = styles.call();
    }
    if (typeof styles == 'string') 
    {
      styles = Ext.util.Format.trim(styles).split(this.styleSepRe);
      for (len = styles.length; i < len; ) 
        {
          el.setStyle(styles[i++], styles[i++]);
        }
    } else if (Ext.isObject(styles)) 
    {
      el.setStyle(styles);
    }
  }
}, insertHtml: function(where, el, html) {
  var hash = {}, setStart, range, frag, rangeEl;
  where = where.toLowerCase();
  hash.beforebegin = ['BeforeBegin', 'previousSibling'];
  hash.afterend = ['AfterEnd', 'nextSibling'];
  range = el.ownerDocument.createRange();
  setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
  if (hash[where]) 
  {
    range[setStart](el);
    frag = range.createContextualFragment(html);
    el.parentNode.insertBefore(frag, where == 'beforebegin' ? el : el.nextSibling);
    return el[(where == 'beforebegin' ? 'previous' : 'next') + 'Sibling'];
  } else {
    rangeEl = (where == 'afterbegin' ? 'first' : 'last') + 'Child';
    if (el.firstChild) 
    {
      range[setStart](el[rangeEl]);
      frag = range.createContextualFragment(html);
      if (where == 'afterbegin') 
      {
        el.insertBefore(frag, el.firstChild);
      } else {
        el.appendChild(frag);
      }
    } else {
      el.innerHTML = html;
    }
    return el[rangeEl];
  }
  throw 'Illegal insertion point -> "' + where + '"';
}, insertBefore: function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'beforebegin');
}, insertAfter: function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'afterend', 'nextSibling');
}, insertFirst: function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'afterbegin', 'firstChild');
}, append: function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'beforeend', '', true);
}, overwrite: function(el, o, returnElement) {
  el = Ext.getDom(el);
  el.innerHTML = this.markup(o);
  return returnElement ? Ext.get(el.firstChild) : el.firstChild;
}, doInsert: function(el, o, returnElement, pos, sibling, append) {
  var newNode = this.insertHtml(pos, Ext.getDom(el), this.markup(o));
  return returnElement ? Ext.get(newNode, true) : newNode;
}}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'AbstractHelper'], 0));
;

Ext.define('Ext.dom.AbstractElement_static', {override: 'Ext.dom.AbstractElement', inheritableStatics: {unitRe: /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i, camelRe: /(-[a-z])/gi, msRe: /^-ms-/, cssRe: /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*)?;?/gi, opacityRe: /alpha\(opacity=(.*)\)/i, propertyCache: {}, defaultUnit: "px", borders: {l: 'border-left-width', r: 'border-right-width', t: 'border-top-width', b: 'border-bottom-width'}, paddings: {l: 'padding-left', r: 'padding-right', t: 'padding-top', b: 'padding-bottom'}, margins: {l: 'margin-left', r: 'margin-right', t: 'margin-top', b: 'margin-bottom'}, addUnits: function(size, units) {
  if (typeof size == 'number') 
  {
    return size + (units || this.defaultUnit || 'px');
  }
  if (size === "" || size == "auto" || size === undefined || size === null) 
  {
    return size || '';
  }
  if (!this.unitRe.test(size)) 
  {
    return size || '';
  }
  return size;
}, isAncestor: function(p, c) {
  var ret = false;
  p = Ext.getDom(p);
  c = Ext.getDom(c);
  if (p && c) 
  {
    if (p.contains) 
    {
      return p.contains(c);
    } else if (p.compareDocumentPosition) 
    {
      return !!(p.compareDocumentPosition(c) & 16);
    } else {
      while ((c = c.parentNode)) 
        {
          ret = c == p || ret;
        }
    }
  }
  return ret;
}, parseBox: function(box) {
  box = box || 0;
  var type = typeof box, parts, ln;
  if (type === 'number') 
  {
    return {top: box, right: box, bottom: box, left: box};
  } else if (type !== 'string') 
  {
    return box;
  }
  parts = box.split(' ');
  ln = parts.length;
  if (ln == 1) 
  {
    parts[1] = parts[2] = parts[3] = parts[0];
  } else if (ln == 2) 
  {
    parts[2] = parts[0];
    parts[3] = parts[1];
  } else if (ln == 3) 
  {
    parts[3] = parts[1];
  }
  return {top: parseFloat(parts[0]) || 0, right: parseFloat(parts[1]) || 0, bottom: parseFloat(parts[2]) || 0, left: parseFloat(parts[3]) || 0};
}, unitizeBox: function(box, units) {
  var a = this.addUnits, b = this.parseBox(box);
  return a(b.top, units) + ' ' + a(b.right, units) + ' ' + a(b.bottom, units) + ' ' + a(b.left, units);
}, camelReplaceFn: function(m, a) {
  return a.charAt(1).toUpperCase();
}, normalize: function(prop) {
  if (prop == 'float') 
  {
    prop = Ext.supports.Float ? 'cssFloat' : 'styleFloat';
  }
  return this.propertyCache[prop] || (this.propertyCache[prop] = prop.replace(this.msRe, 'ms-').replace(this.camelRe, this.camelReplaceFn));
}, getDocumentHeight: function() {
  return Math.max(!Ext.isStrict ? document.body.scrollHeight : document.documentElement.scrollHeight, this.getViewportHeight());
}, getDocumentWidth: function() {
  return Math.max(!Ext.isStrict ? document.body.scrollWidth : document.documentElement.scrollWidth, this.getViewportWidth());
}, getViewportHeight: function() {
  return window.innerHeight;
}, getViewportWidth: function() {
  return window.innerWidth;
}, getViewSize: function() {
  return {width: window.innerWidth, height: window.innerHeight};
}, getOrientation: function() {
  if (Ext.supports.OrientationChange) 
  {
    return (window.orientation == 0) ? 'portrait' : 'landscape';
  }
  return (window.innerHeight > window.innerWidth) ? 'portrait' : 'landscape';
}, fromPoint: function(x, y) {
  return Ext.get(document.elementFromPoint(x, y));
}, parseStyles: function(styles) {
  var out = {}, cssRe = this.cssRe, matches;
  if (styles) 
  {
    cssRe.lastIndex = 0;
    while ((matches = cssRe.exec(styles))) 
      {
        out[matches[1]] = matches[2] || '';
      }
  }
  return out;
}}}, function() {
  var doc = document, activeElement = null, isCSS1 = doc.compatMode == "CSS1Compat";
  if (!('activeElement' in doc) && doc.addEventListener) 
  {
    doc.addEventListener('focus', function(ev) {
  if (ev && ev.target) 
  {
    activeElement = (ev.target == doc) ? null : ev.target;
  }
}, true);
  }
  function makeSelectionRestoreFn(activeEl, start, end) {
    return function() {
  activeEl.selectionStart = start;
  activeEl.selectionEnd = end;
};
  }
  this.addInheritableStatics({getActiveElement: function() {
  var active;
  try {
    active = doc.activeElement;
  }  catch (e) {
}
  active = active || activeElement;
  if (!active) 
  {
    active = activeElement = document.body;
  }
  return active;
}, getRightMarginFixCleaner: function(target) {
  var supports = Ext.supports, hasInputBug = supports.DisplayChangeInputSelectionBug, hasTextAreaBug = supports.DisplayChangeTextAreaSelectionBug, activeEl, tag, start, end;
  if (hasInputBug || hasTextAreaBug) 
  {
    activeEl = doc.activeElement || activeElement;
    tag = activeEl && activeEl.tagName;
    if ((hasTextAreaBug && tag == 'TEXTAREA') || (hasInputBug && tag == 'INPUT' && activeEl.type == 'text')) 
    {
      if (Ext.dom.Element.isAncestor(target, activeEl)) 
      {
        start = activeEl.selectionStart;
        end = activeEl.selectionEnd;
        if (Ext.isNumber(start) && Ext.isNumber(end)) 
        {
          return makeSelectionRestoreFn(activeEl, start, end);
        }
      }
    }
  }
  return Ext.emptyFn;
}, getViewWidth: function(full) {
  return full ? Ext.dom.Element.getDocumentWidth() : Ext.dom.Element.getViewportWidth();
}, getViewHeight: function(full) {
  return full ? Ext.dom.Element.getDocumentHeight() : Ext.dom.Element.getViewportHeight();
}, getDocumentHeight: function() {
  return Math.max(!isCSS1 ? doc.body.scrollHeight : doc.documentElement.scrollHeight, Ext.dom.Element.getViewportHeight());
}, getDocumentWidth: function() {
  return Math.max(!isCSS1 ? doc.body.scrollWidth : doc.documentElement.scrollWidth, Ext.dom.Element.getViewportWidth());
}, getViewportHeight: function() {
  return Ext.isIE9m ? (Ext.isStrict ? doc.documentElement.clientHeight : doc.body.clientHeight) : self.innerHeight;
}, getViewportWidth: function() {
  return (!Ext.isStrict && !Ext.isOpera) ? doc.body.clientWidth : Ext.isIE9m ? doc.documentElement.clientWidth : self.innerWidth;
}, serializeForm: function(form) {
  var fElements = form.elements || (document.forms[form] || Ext.getDom(form)).elements, hasSubmit = false, encoder = encodeURIComponent, data = '', eLen = fElements.length, element, name, type, options, hasValue, e, o, oLen, opt;
  for (e = 0; e < eLen; e++) 
    {
      element = fElements[e];
      name = element.name;
      type = element.type;
      options = element.options;
      if (!element.disabled && name) 
      {
        if (/select-(one|multiple)/i.test(type)) 
        {
          oLen = options.length;
          for (o = 0; o < oLen; o++) 
            {
              opt = options[o];
              if (opt.selected) 
              {
                hasValue = opt.hasAttribute ? opt.hasAttribute('value') : opt.getAttributeNode('value').specified;
                data += Ext.String.format("{0}={1}&", encoder(name), encoder(hasValue ? opt.value : opt.text));
              }
            }
        } else if (!(/file|undefined|reset|button/i.test(type))) 
        {
          if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) 
          {
            data += encoder(name) + '=' + encoder(element.value) + '&';
            hasSubmit = /submit/i.test(type);
          }
        }
      }
    }
  return data.substr(0, data.length - 1);
}});
});

Ext.define('Ext.dom.AbstractElement_insertion', {override: 'Ext.dom.AbstractElement', appendChild: function(el, returnDom) {
  var me = this, insertEl, eLen, e, oldUseDom;
  if (el.nodeType || el.dom || typeof el == 'string') 
  {
    el = Ext.getDom(el);
    me.dom.appendChild(el);
    return !returnDom ? Ext.get(el) : el;
  } else if (el.length) 
  {
    insertEl = Ext.fly(document.createDocumentFragment(), '_internal');
    eLen = el.length;
    Ext.DomHelper.useDom = true;
    for (e = 0; e < eLen; e++) 
      {
        insertEl.appendChild(el[e], returnDom);
      }
    Ext.DomHelper.useDom = oldUseDom;
    me.dom.appendChild(insertEl.dom);
    return returnDom ? insertEl.dom : insertEl;
  } else {
    return me.createChild(el, null, returnDom);
  }
}, appendTo: function(el) {
  Ext.getDom(el).appendChild(this.dom);
  return this;
}, insertBefore: function(el) {
  el = Ext.getDom(el);
  el.parentNode.insertBefore(this.dom, el);
  return this;
}, insertAfter: function(el) {
  el = Ext.getDom(el);
  el.parentNode.insertBefore(this.dom, el.nextSibling);
  return this;
}, insertFirst: function(el, returnDom) {
  el = el || {};
  if (el.nodeType || el.dom || typeof el == 'string') 
  {
    el = Ext.getDom(el);
    this.dom.insertBefore(el, this.dom.firstChild);
    return !returnDom ? Ext.get(el) : el;
  } else {
    return this.createChild(el, this.dom.firstChild, returnDom);
  }
}, insertSibling: function(el, where, returnDom) {
  var me = this, DomHelper = Ext.core.DomHelper, oldUseDom = DomHelper.useDom, isAfter = (where || 'before').toLowerCase() == 'after', rt, insertEl, eLen, e;
  if (Ext.isArray(el)) 
  {
    insertEl = Ext.fly(document.createDocumentFragment(), '_internal');
    eLen = el.length;
    DomHelper.useDom = true;
    for (e = 0; e < eLen; e++) 
      {
        rt = insertEl.appendChild(el[e], returnDom);
      }
    DomHelper.useDom = oldUseDom;
    me.dom.parentNode.insertBefore(insertEl.dom, isAfter ? me.dom.nextSibling : me.dom);
    return rt;
  }
  el = el || {};
  if (el.nodeType || el.dom) 
  {
    rt = me.dom.parentNode.insertBefore(Ext.getDom(el), isAfter ? me.dom.nextSibling : me.dom);
    if (!returnDom) 
    {
      rt = Ext.get(rt);
    }
  } else {
    if (isAfter && !me.dom.nextSibling) 
    {
      rt = DomHelper.append(me.dom.parentNode, el, !returnDom);
    } else {
      rt = DomHelper[isAfter ? 'insertAfter' : 'insertBefore'](me.dom, el, !returnDom);
    }
  }
  return rt;
}, replace: function(el) {
  el = Ext.get(el);
  this.insertBefore(el);
  el.remove();
  return this;
}, replaceWith: function(el) {
  var me = this;
  if (el.nodeType || el.dom || typeof el == 'string') 
  {
    el = Ext.get(el);
    me.dom.parentNode.insertBefore(el.dom, me.dom);
  } else {
    el = Ext.core.DomHelper.insertBefore(me.dom, el);
  }
  delete Ext.cache[me.id];
  Ext.removeNode(me.dom);
  me.id = Ext.id(me.dom = el);
  Ext.dom.AbstractElement.addToCache(me.isFlyweight ? new Ext.dom.AbstractElement(me.dom) : me);
  return me;
}, createChild: function(config, insertBefore, returnDom) {
  config = config || {tag: 'div'};
  if (insertBefore) 
  {
    return Ext.core.DomHelper.insertBefore(insertBefore, config, returnDom !== true);
  } else {
    return Ext.core.DomHelper.append(this.dom, config, returnDom !== true);
  }
}, wrap: function(config, returnDom, selector) {
  var newEl = Ext.core.DomHelper.insertBefore(this.dom, config || {tag: "div"}, true), target = newEl;
  if (selector) 
  {
    target = Ext.DomQuery.selectNode(selector, newEl.dom);
  }
  target.appendChild(this.dom);
  return returnDom ? newEl.dom : newEl;
}, insertHtml: function(where, html, returnEl) {
  var el = Ext.core.DomHelper.insertHtml(where, this.dom, html);
  return returnEl ? Ext.get(el) : el;
}});

Ext.define('Ext.dom.AbstractElement_style', {override: 'Ext.dom.AbstractElement'}, function() {
  var Element = this, wordsRe = /\w/g, spacesRe = /\s+/, transparentRe = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i, hasClassList = Ext.supports.ClassList, PADDING = 'padding', MARGIN = 'margin', BORDER = 'border', LEFT_SUFFIX = '-left', RIGHT_SUFFIX = '-right', TOP_SUFFIX = '-top', BOTTOM_SUFFIX = '-bottom', WIDTH = '-width', borders = {l: BORDER + LEFT_SUFFIX + WIDTH, r: BORDER + RIGHT_SUFFIX + WIDTH, t: BORDER + TOP_SUFFIX + WIDTH, b: BORDER + BOTTOM_SUFFIX + WIDTH}, paddings = {l: PADDING + LEFT_SUFFIX, r: PADDING + RIGHT_SUFFIX, t: PADDING + TOP_SUFFIX, b: PADDING + BOTTOM_SUFFIX}, margins = {l: MARGIN + LEFT_SUFFIX, r: MARGIN + RIGHT_SUFFIX, t: MARGIN + TOP_SUFFIX, b: MARGIN + BOTTOM_SUFFIX}, internalFly = new Element.Fly();
  Ext.override(Element, {styleHooks: {}, addStyles: function(sides, styles) {
  var totalSize = 0, sidesArr = (sides || '').match(wordsRe), i, len = sidesArr.length, side, styleSides = [];
  if (len == 1) 
  {
    totalSize = Math.abs(parseFloat(this.getStyle(styles[sidesArr[0]])) || 0);
  } else if (len) 
  {
    for (i = 0; i < len; i++) 
      {
        side = sidesArr[i];
        styleSides.push(styles[side]);
      }
    styleSides = this.getStyle(styleSides);
    for (i = 0; i < len; i++) 
      {
        side = sidesArr[i];
        totalSize += Math.abs(parseFloat(styleSides[styles[side]]) || 0);
      }
  }
  return totalSize;
}, addCls: (function() {
  var addWithClassList = function(className) {
  var me = this, dom = me.dom, trimRe = me.trimRe, origClassName = className, classList, newCls, i, len, cls;
  if (typeof (className) == 'string') 
  {
    className = className.replace(trimRe, '').split(spacesRe);
  }
  if (dom && className && !!(len = className.length)) 
  {
    if (!dom.className) 
    {
      dom.className = className.join(' ');
    } else {
      classList = dom.classList;
      if (classList) 
      {
        for (i = 0; i < len; ++i) 
          {
            cls = className[i];
            if (cls) 
            {
              if (!classList.contains(cls)) 
              {
                if (newCls) 
                {
                  newCls.push(cls);
                } else {
                  newCls = dom.className.replace(trimRe, '');
                  newCls = newCls ? [newCls, cls] : [cls];
                }
              }
            }
          }
        if (newCls) 
        {
          dom.className = newCls.join(' ');
        }
      } else {
        addWithoutClassList(origClassName);
      }
    }
  }
  return me;
}, addWithoutClassList = function(className) {
  var me = this, dom = me.dom, elClasses;
  if (dom && className && className.length) 
  {
    elClasses = Ext.Element.mergeClsList(dom.className, className);
    if (elClasses.changed) 
    {
      dom.className = elClasses.join(' ');
    }
  }
  return me;
};
  return hasClassList ? addWithClassList : addWithoutClassList;
})(), removeCls: function(className) {
  var me = this, dom = me.dom, classList, len, elClasses;
  if (typeof (className) == 'string') 
  {
    className = className.replace(me.trimRe, '').split(spacesRe);
  }
  if (dom && dom.className && className && !!(len = className.length)) 
  {
    classList = dom.classList;
    if (len === 1 && classList) 
    {
      if (className[0]) 
      {
        classList.remove(className[0]);
      }
    } else {
      elClasses = Ext.Element.removeCls(dom.className, className);
      if (elClasses.changed) 
      {
        dom.className = elClasses.join(' ');
      }
    }
  }
  return me;
}, radioCls: function(className) {
  var cn = this.dom.parentNode.childNodes, v, i, len;
  className = Ext.isArray(className) ? className : [className];
  for (i = 0 , len = cn.length; i < len; i++) 
    {
      v = cn[i];
      if (v && v.nodeType == 1) 
      {
        internalFly.attach(v).removeCls(className);
      }
    }
  return this.addCls(className);
}, toggleCls: (function() {
  var toggleWithClassList = function(className) {
  var me = this, dom = me.dom, classList;
  if (dom) 
  {
    className = className.replace(me.trimRe, '');
    if (className) 
    {
      classList = dom.classList;
      if (classList) 
      {
        classList.toggle(className);
      } else {
        toggleWithoutClassList(className);
      }
    }
  }
  return me;
}, toggleWithoutClassList = function(className) {
  return this.hasCls(className) ? this.removeCls(className) : this.addCls(className);
};
  return hasClassList ? toggleWithClassList : toggleWithoutClassList;
})(), hasCls: (function() {
  var hasClsWithClassList = function(className) {
  var dom = this.dom, out = false, classList;
  if (dom && className) 
  {
    classList = dom.classList;
    if (classList) 
    {
      out = classList.contains(className);
    } else {
      out = hasClsWithoutClassList(className);
    }
  }
  return out;
}, hasClsWithoutClassList = function(className) {
  var dom = this.dom;
  return dom ? className && (' ' + dom.className + ' ').indexOf(' ' + className + ' ') !== -1 : false;
};
  return hasClassList ? hasClsWithClassList : hasClsWithoutClassList;
})(), replaceCls: function(oldClassName, newClassName) {
  return this.removeCls(oldClassName).addCls(newClassName);
}, isStyle: function(style, val) {
  return this.getStyle(style) == val;
}, getStyle: function(property, inline) {
  var me = this, dom = me.dom, multiple = typeof property != 'string', hooks = me.styleHooks, prop = property, props = prop, len = 1, domStyle, camel, values, hook, out, style, i;
  if (multiple) 
  {
    values = {};
    prop = props[0];
    i = 0;
    if (!(len = props.length)) 
    {
      return values;
    }
  }
  if (!dom || dom.documentElement) 
  {
    return values || '';
  }
  domStyle = dom.style;
  if (inline) 
  {
    style = domStyle;
  } else {
    style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);
    if (!style) 
    {
      inline = true;
      style = domStyle;
    }
  }
  do {
    hook = hooks[prop];
    if (!hook) 
    {
      hooks[prop] = hook = {name: Element.normalize(prop)};
    }
    if (hook.get) 
    {
      out = hook.get(dom, me, inline, style);
    } else {
      camel = hook.name;
      out = style[camel];
    }
    if (!multiple) 
    {
      return out;
    }
    values[prop] = out;
    prop = props[++i];
  } while (i < len);
  return values;
}, getStyles: function() {
  var props = Ext.Array.slice(arguments), len = props.length, inline;
  if (len && typeof props[len - 1] == 'boolean') 
  {
    inline = props.pop();
  }
  return this.getStyle(props, inline);
}, isTransparent: function(prop) {
  var value = this.getStyle(prop);
  return value ? transparentRe.test(value) : false;
}, setStyle: function(prop, value) {
  var me = this, dom = me.dom, hooks = me.styleHooks, style = dom.style, name = prop, hook;
  if (typeof name == 'string') 
  {
    hook = hooks[name];
    if (!hook) 
    {
      hooks[name] = hook = {name: Element.normalize(name)};
    }
    value = (value == null) ? '' : value;
    if (hook.set) 
    {
      hook.set(dom, value, me);
    } else {
      style[hook.name] = value;
    }
    if (hook.afterSet) 
    {
      hook.afterSet(dom, value, me);
    }
  } else {
    for (name in prop) 
      {
        if (prop.hasOwnProperty(name)) 
        {
          hook = hooks[name];
          if (!hook) 
          {
            hooks[name] = hook = {name: Element.normalize(name)};
          }
          value = prop[name];
          value = (value == null) ? '' : value;
          if (hook.set) 
          {
            hook.set(dom, value, me);
          } else {
            style[hook.name] = value;
          }
          if (hook.afterSet) 
          {
            hook.afterSet(dom, value, me);
          }
        }
      }
  }
  return me;
}, getHeight: function(contentHeight) {
  var dom = this.dom, height = contentHeight ? (dom.clientHeight - this.getPadding("tb")) : dom.offsetHeight;
  return height > 0 ? height : 0;
}, getWidth: function(contentWidth) {
  var dom = this.dom, width = contentWidth ? (dom.clientWidth - this.getPadding("lr")) : dom.offsetWidth;
  return width > 0 ? width : 0;
}, setWidth: function(width) {
  var me = this;
  me.dom.style.width = Element.addUnits(width);
  return me;
}, setHeight: function(height) {
  var me = this;
  me.dom.style.height = Element.addUnits(height);
  return me;
}, getBorderWidth: function(side) {
  return this.addStyles(side, borders);
}, getPadding: function(side) {
  return this.addStyles(side, paddings);
}, margins: margins, applyStyles: function(styles) {
  if (styles) 
  {
    var i, len, dom = this.dom;
    if (typeof styles == 'function') 
    {
      styles = styles.call();
    }
    if (typeof styles == 'string') 
    {
      styles = Ext.util.Format.trim(styles).split(/\s*(?::|;)\s*/);
      for (i = 0 , len = styles.length; i < len; ) 
        {
          dom.style[Element.normalize(styles[i++])] = styles[i++];
        }
    } else if (typeof styles == 'object') 
    {
      this.setStyle(styles);
    }
  }
}, setSize: function(width, height) {
  var me = this, style = me.dom.style;
  if (Ext.isObject(width)) 
  {
    height = width.height;
    width = width.width;
  }
  style.width = Element.addUnits(width);
  style.height = Element.addUnits(height);
  return me;
}, getViewSize: function() {
  var doc = document, dom = this.dom;
  if (dom == doc || dom == doc.body) 
  {
    return {width: Element.getViewportWidth(), height: Element.getViewportHeight()};
  } else {
    return {width: dom.clientWidth, height: dom.clientHeight};
  }
}, getSize: function(contentSize) {
  var dom = this.dom;
  return {width: Math.max(0, contentSize ? (dom.clientWidth - this.getPadding("lr")) : dom.offsetWidth), height: Math.max(0, contentSize ? (dom.clientHeight - this.getPadding("tb")) : dom.offsetHeight)};
}, repaint: function() {
  var dom = this.dom;
  this.addCls(Ext.baseCSSPrefix + 'repaint');
  setTimeout(function() {
  internalFly.attach(dom).removeCls(Ext.baseCSSPrefix + 'repaint');
}, 1);
  return this;
}, getMargin: function(side) {
  var me = this, hash = {t: "top", l: "left", r: "right", b: "bottom"}, key, o, margins;
  if (!side) 
  {
    margins = [];
    for (key in me.margins) 
      {
        if (me.margins.hasOwnProperty(key)) 
        {
          margins.push(me.margins[key]);
        }
      }
    o = me.getStyle(margins);
    if (o && typeof o == 'object') 
    {
      for (key in me.margins) 
        {
          if (me.margins.hasOwnProperty(key)) 
          {
            o[hash[key]] = parseFloat(o[me.margins[key]]) || 0;
          }
        }
    }
    return o;
  } else {
    return me.addStyles(side, me.margins);
  }
}, mask: function(msg, msgCls, transparent) {
  var me = this, dom = me.dom, data = (me.$cache || me.getCache()).data, el = data.mask, mask, size, cls = '', prefix = Ext.baseCSSPrefix;
  me.addCls(prefix + 'masked');
  if (me.getStyle("position") == "static") 
  {
    me.addCls(prefix + 'masked-relative');
  }
  if (el) 
  {
    el.remove();
  }
  if (msgCls && typeof msgCls == 'string') 
  {
    cls = ' ' + msgCls;
  } else {
    cls = ' ' + prefix + 'mask-gray';
  }
  mask = me.createChild({role: 'presentation', cls: prefix + 'mask' + ((transparent !== false) ? '' : (' ' + prefix + 'mask-gray')), html: msg ? ('<div class="' + (msgCls || (prefix + 'mask-message')) + '" role="presentation">' + msg + '</div>') : ''});
  size = me.getSize();
  data.mask = mask;
  if (dom === document.body) 
  {
    size.height = window.innerHeight;
    if (me.orientationHandler) 
    {
      Ext.EventManager.unOrientationChange(me.orientationHandler, me);
    }
    me.orientationHandler = function() {
  size = me.getSize();
  size.height = window.innerHeight;
  mask.setSize(size);
};
    Ext.EventManager.onOrientationChange(me.orientationHandler, me);
  }
  mask.setSize(size);
  if (Ext.is.iPad) 
  {
    Ext.repaint();
  }
}, unmask: function() {
  var me = this, data = (me.$cache || me.getCache()).data, mask = data.mask, prefix = Ext.baseCSSPrefix;
  if (mask) 
  {
    mask.remove();
    delete data.mask;
  }
  me.removeCls([prefix + 'masked', prefix + 'masked-relative']);
  if (me.dom === document.body) 
  {
    Ext.EventManager.unOrientationChange(me.orientationHandler, me);
    delete me.orientationHandler;
  }
}});
  Ext.onReady(function() {
  var supports = Ext.supports, styleHooks, colorStyles, i, name, camel;
  function fixTransparent(dom, el, inline, style) {
    var value = style[this.name] || '';
    return transparentRe.test(value) ? 'transparent' : value;
  }
  function fixRightMargin(dom, el, inline, style) {
    var result = style.marginRight, domStyle, display;
    if (result != '0px') 
    {
      domStyle = dom.style;
      display = domStyle.display;
      domStyle.display = 'inline-block';
      result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, null)).marginRight;
      domStyle.display = display;
    }
    return result;
  }
  function fixRightMarginAndInputFocus(dom, el, inline, style) {
    var result = style.marginRight, domStyle, cleaner, display;
    if (result != '0px') 
    {
      domStyle = dom.style;
      cleaner = Element.getRightMarginFixCleaner(dom);
      display = domStyle.display;
      domStyle.display = 'inline-block';
      result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, '')).marginRight;
      domStyle.display = display;
      cleaner();
    }
    return result;
  }
  styleHooks = Element.prototype.styleHooks;
  if (supports.init) 
  {
    supports.init();
  }
  if (!supports.RightMargin) 
  {
    styleHooks.marginRight = styleHooks['margin-right'] = {name: 'marginRight', get: (supports.DisplayChangeInputSelectionBug || supports.DisplayChangeTextAreaSelectionBug) ? fixRightMarginAndInputFocus : fixRightMargin};
  }
  if (!supports.TransparentColor) 
  {
    colorStyles = ['background-color', 'border-color', 'color', 'outline-color'];
    for (i = colorStyles.length; i--; ) 
      {
        name = colorStyles[i];
        camel = Element.normalize(name);
        styleHooks[name] = styleHooks[camel] = {name: camel, get: fixTransparent};
      }
  }
});
});

Ext.define('Ext.dom.AbstractElement_traversal', {override: 'Ext.dom.AbstractElement', findParent: function(simpleSelector, limit, returnEl) {
  var target = this.dom, topmost = document.documentElement, depth = 0, stopEl;
  limit = limit || 50;
  if (isNaN(limit)) 
  {
    stopEl = Ext.getDom(limit);
    limit = Number.MAX_VALUE;
  }
  while (target && target.nodeType == 1 && depth < limit && target != topmost && target != stopEl) 
    {
      if (Ext.DomQuery.is(target, simpleSelector)) 
      {
        return returnEl ? Ext.get(target) : target;
      }
      depth++;
      target = target.parentNode;
    }
  return null;
}, findParentNode: function(simpleSelector, limit, returnEl) {
  var p = Ext.fly(this.dom.parentNode, '_internal');
  return p ? p.findParent(simpleSelector, limit, returnEl) : null;
}, up: function(simpleSelector, limit, returnDom) {
  return this.findParentNode(simpleSelector, limit, !returnDom);
}, select: function(selector, composite) {
  return Ext.dom.Element.select(selector, this.dom, composite);
}, query: function(selector) {
  return Ext.DomQuery.select(selector, this.dom);
}, down: function(selector, returnDom) {
  var n = Ext.DomQuery.selectNode(selector, this.dom);
  return returnDom ? n : Ext.get(n);
}, child: function(selector, returnDom) {
  var node, me = this, id;
  id = Ext.id(me.dom);
  id = Ext.escapeId(id);
  node = Ext.DomQuery.selectNode('#' + id + " > " + selector, me.dom);
  return returnDom ? node : Ext.get(node);
}, parent: function(selector, returnDom) {
  return this.matchNode('parentNode', 'parentNode', selector, returnDom);
}, next: function(selector, returnDom) {
  return this.matchNode('nextSibling', 'nextSibling', selector, returnDom);
}, prev: function(selector, returnDom) {
  return this.matchNode('previousSibling', 'previousSibling', selector, returnDom);
}, first: function(selector, returnDom) {
  return this.matchNode('nextSibling', 'firstChild', selector, returnDom);
}, last: function(selector, returnDom) {
  return this.matchNode('previousSibling', 'lastChild', selector, returnDom);
}, matchNode: function(dir, start, selector, returnDom) {
  if (!this.dom) 
  {
    return null;
  }
  var n = this.dom[start];
  while (n) 
    {
      if (n.nodeType == 1 && (!selector || Ext.DomQuery.is(n, selector))) 
      {
        return !returnDom ? Ext.get(n) : n;
      }
      n = n[dir];
    }
  return null;
}, isAncestor: function(element) {
  return this.self.isAncestor.call(this.self, this.dom, element);
}});

(Ext.cmd.derive('Ext.dom.AbstractElement', Ext.Base, {trimRe: /^\s+|\s+$/g, whitespaceRe: /\s/, inheritableStatics: {trimRe: /^\s+|\s+$/g, whitespaceRe: /\s/, get: function(el) {
  var me = this, document = window.document, El = Ext.dom.Element, cacheItem, docEl, extEl, dom, id;
  if (!el) 
  {
    return null;
  }
  if (el.isFly) 
  {
    el = el.dom;
  }
  if (typeof el == "string") 
  {
    if (el == Ext.windowId) 
    {
      return El.get(window);
    } else if (el == Ext.documentId) 
    {
      return El.get(document);
    }
    cacheItem = Ext.cache[el];
    if (cacheItem && cacheItem.skipGarbageCollection) 
    {
      extEl = cacheItem.el;
      return extEl;
    }
    if (!(dom = document.getElementById(el))) 
    {
      return null;
    }
    if (cacheItem && cacheItem.el) 
    {
      extEl = Ext.updateCacheEntry(cacheItem, dom).el;
    } else {
      extEl = new El(dom, !!cacheItem);
    }
    return extEl;
  } else if (el.tagName) 
  {
    if (!(id = el.id)) 
    {
      id = Ext.id(el);
    }
    cacheItem = Ext.cache[id];
    if (cacheItem && cacheItem.el) 
    {
      extEl = Ext.updateCacheEntry(cacheItem, el).el;
    } else {
      extEl = new El(el, !!cacheItem);
    }
    return extEl;
  } else if (el instanceof me) 
  {
    if (el != me.docEl && el != me.winEl) 
    {
      id = el.id;
      cacheItem = Ext.cache[id];
      if (cacheItem) 
      {
        Ext.updateCacheEntry(cacheItem, document.getElementById(id) || el.dom);
      }
    }
    return el;
  } else if (el.isComposite) 
  {
    return el;
  } else if (Ext.isArray(el)) 
  {
    return me.select(el);
  } else if (el === document) 
  {
    if (!me.docEl) 
    {
      docEl = me.docEl = Ext.Object.chain(El.prototype);
      docEl.dom = document;
      docEl.el = docEl;
      docEl.id = Ext.id(document);
      me.addToCache(docEl);
    }
    return me.docEl;
  } else if (el === window) 
  {
    if (!me.winEl) 
    {
      me.winEl = Ext.Object.chain(El.prototype);
      me.winEl.dom = window;
      me.winEl.id = Ext.id(window);
      me.addToCache(me.winEl);
    }
    return me.winEl;
  }
  return null;
}, addToCache: function(el, id) {
  if (el) 
  {
    Ext.addCacheEntry(id, el);
  }
  return el;
}, addMethods: function() {
  this.override.apply(this, arguments);
}, mergeClsList: function() {
  var clsList, clsHash = {}, i, length, j, listLength, clsName, result = [], changed = false, trimRe = this.trimRe, whitespaceRe = this.whitespaceRe;
  for (i = 0 , length = arguments.length; i < length; i++) 
    {
      clsList = arguments[i];
      if (Ext.isString(clsList)) 
      {
        clsList = clsList.replace(trimRe, '').split(whitespaceRe);
      }
      if (clsList) 
      {
        for (j = 0 , listLength = clsList.length; j < listLength; j++) 
          {
            clsName = clsList[j];
            if (!clsHash[clsName]) 
            {
              if (i) 
              {
                changed = true;
              }
              clsHash[clsName] = true;
            }
          }
      }
    }
  for (clsName in clsHash) 
    {
      result.push(clsName);
    }
  result.changed = changed;
  return result;
}, removeCls: function(existingClsList, removeClsList) {
  var clsHash = {}, i, length, clsName, result = [], changed = false, whitespaceRe = this.whitespaceRe;
  if (existingClsList) 
  {
    if (Ext.isString(existingClsList)) 
    {
      existingClsList = existingClsList.replace(this.trimRe, '').split(whitespaceRe);
    }
    for (i = 0 , length = existingClsList.length; i < length; i++) 
      {
        clsHash[existingClsList[i]] = true;
      }
  }
  if (removeClsList) 
  {
    if (Ext.isString(removeClsList)) 
    {
      removeClsList = removeClsList.split(whitespaceRe);
    }
    for (i = 0 , length = removeClsList.length; i < length; i++) 
      {
        clsName = removeClsList[i];
        if (clsHash[clsName]) 
        {
          changed = true;
          delete clsHash[clsName];
        }
      }
  }
  for (clsName in clsHash) 
    {
      result.push(clsName);
    }
  result.changed = changed;
  return result;
}, VISIBILITY: 1, DISPLAY: 2, OFFSETS: 3, ASCLASS: 4}, constructor: function(element, forceNew) {
  var me = this, dom = typeof element == 'string' ? document.getElementById(element) : element, id;
  me.el = me;
  if (!dom) 
  {
    return null;
  }
  id = dom.id;
  if (!forceNew && id && Ext.cache[id]) 
  {
    return Ext.cache[id].el;
  }
  me.dom = dom;
  me.id = id || Ext.id(dom);
  me.self.addToCache(me);
}, set: function(o, useSet) {
  var el = this.dom, attr, value;
  for (attr in o) 
    {
      if (o.hasOwnProperty(attr)) 
      {
        value = o[attr];
        if (attr == 'style') 
        {
          this.applyStyles(value);
        } else if (attr == 'cls') 
        {
          el.className = value;
        } else if (useSet !== false) 
        {
          if (value === undefined) 
          {
            el.removeAttribute(attr);
          } else {
            el.setAttribute(attr, value);
          }
        } else {
          el[attr] = value;
        }
      }
    }
  return this;
}, defaultUnit: "px", is: function(simpleSelector) {
  return Ext.DomQuery.is(this.dom, simpleSelector);
}, getValue: function(asNumber) {
  var val = this.dom.value;
  return asNumber ? parseInt(val, 10) : val;
}, remove: function() {
  var me = this, dom = me.dom;
  if (me.isAnimate) 
  {
    me.stopAnimation();
  }
  if (dom) 
  {
    Ext.removeNode(dom);
    delete me.dom;
  }
}, contains: (function() {
  var isXpc = function(el) {
  var s;
  try {
    el = el.dom || el;
  }  catch (e) {
  return true;
}
  s = HTMLElement.prototype.toString.call(el);
  return s === '[xpconnect wrapped native prototype]' || s === '[object XULElement]';
};
  return function(el) {
  if (!el || (Ext.isGecko3 && isXpc(el))) 
  {
    return false;
  }
  var me = this, dom = el.dom || el;
  return (dom === me.dom) || Ext.dom.AbstractElement.isAncestor(me.dom, dom);
};
}()), getAttribute: function(name, ns) {
  var dom = this.dom;
  return dom.getAttributeNS(ns, name) || dom.getAttribute(ns + ":" + name) || dom.getAttribute(name) || dom[name];
}, update: function(html) {
  if (this.dom) 
  {
    this.dom.innerHTML = html;
  }
  return this;
}, setHTML: function(html) {
  if (this.dom) 
  {
    this.dom.innerHTML = html;
  }
  return this;
}, getHTML: function() {
  return this.dom ? this.dom.innerHTML : '';
}, hide: function() {
  this.setVisible(false);
  return this;
}, show: function() {
  this.setVisible(true);
  return this;
}, setVisible: function(visible, animate) {
  var me = this, statics = me.self, mode = me.getVisibilityMode(), prefix = Ext.baseCSSPrefix;
  switch (mode) {
    case statics.VISIBILITY:
      me.removeCls([prefix + 'hidden-display', prefix + 'hidden-offsets']);
      me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-visibility');
      break;
    case statics.DISPLAY:
      me.removeCls([prefix + 'hidden-visibility', prefix + 'hidden-offsets']);
      me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-display');
      break;
    case statics.OFFSETS:
      me.removeCls([prefix + 'hidden-visibility', prefix + 'hidden-display']);
      me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-offsets');
      break;
  }
  return me;
}, getVisibilityMode: function() {
  var data = (this.$cache || this.getCache()).data, visMode = data.visibilityMode;
  if (visMode === undefined) 
  {
    data.visibilityMode = visMode = this.self.DISPLAY;
  }
  return visMode;
}, setVisibilityMode: function(mode) {
  (this.$cache || this.getCache()).data.visibilityMode = mode;
  return this;
}, getCache: function() {
  var me = this, id = me.dom.id || Ext.id(me.dom);
  me.$cache = Ext.cache[id] || Ext.addCacheEntry(id, null, me.dom);
  return me.$cache;
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'AbstractElement'], function() {
  var AbstractElement = this;
  Ext.getDetachedBody = function() {
  var detachedEl = AbstractElement.detachedBodyEl;
  if (!detachedEl) 
  {
    detachedEl = document.createElement('div');
    AbstractElement.detachedBodyEl = detachedEl = new AbstractElement.Fly(detachedEl);
    detachedEl.isDetachedBody = true;
  }
  return detachedEl;
};
  Ext.getElementById = function(id) {
  var el = document.getElementById(id), detachedBodyEl;
  if (!el && (detachedBodyEl = AbstractElement.detachedBodyEl)) 
  {
    el = detachedBodyEl.dom.querySelector('#' + Ext.escapeId(id));
  }
  return el;
};
  Ext.get = function(el) {
  return Ext.dom.Element.get(el);
};
  this.addStatics({Fly: new Ext.Class({extend: AbstractElement, isFly: true, constructor: function(dom) {
  this.dom = dom;
  this.el = this;
}, attach: function(dom) {
  this.dom = dom;
  this.$cache = dom && dom.id ? Ext.cache[dom.id] : null;
  return this;
}}), _flyweights: {}, fly: function(dom, named) {
  var fly = null, _flyweights = AbstractElement._flyweights;
  named = named || '_global';
  dom = Ext.getDom(dom);
  if (dom) 
  {
    fly = _flyweights[named] || (_flyweights[named] = new AbstractElement.Fly());
    fly.dom = dom;
    fly.$cache = dom.id ? Ext.cache[dom.id] : null;
  }
  return fly;
}});
  Ext.fly = function() {
  return AbstractElement.fly.apply(AbstractElement, arguments);
};
  (function(proto) {
  proto.destroy = proto.remove;
  if (document.querySelector) 
  {
    proto.getById = function(id, asDom) {
  var dom = document.getElementById(id) || this.dom.querySelector('#' + Ext.escapeId(id));
  return asDom ? dom : (dom ? Ext.get(dom) : null);
};
  } else {
    proto.getById = function(id, asDom) {
  var dom = document.getElementById(id);
  return asDom ? dom : (dom ? Ext.get(dom) : null);
};
  }
}(this.prototype));
}));
;

(Ext.cmd.derive('Ext.dom.Helper', Ext.dom.AbstractHelper, (function() {
  var afterbegin = 'afterbegin', afterend = 'afterend', beforebegin = 'beforebegin', beforeend = 'beforeend', ts = '<table>', te = '</table>', tbs = ts + '<tbody>', tbe = '</tbody>' + te, trs = tbs + '<tr>', tre = '</tr>' + tbe, detachedDiv = document.createElement('div'), bbValues = ['BeforeBegin', 'previousSibling'], aeValues = ['AfterEnd', 'nextSibling'], bb_ae_PositionHash = {beforebegin: bbValues, afterend: aeValues}, fullPositionHash = {beforebegin: bbValues, afterend: aeValues, afterbegin: ['AfterBegin', 'firstChild'], beforeend: ['BeforeEnd', 'lastChild']};
  return {tableRe: /^(?:table|thead|tbody|tr|td)$/i, tableElRe: /td|tr|tbody|thead/i, useDom: false, createDom: function(o, parentNode) {
  var el, doc = document, useSet, attr, val, cn, i, l;
  if (Ext.isArray(o)) 
  {
    el = doc.createDocumentFragment();
    for (i = 0 , l = o.length; i < l; i++) 
      {
        this.createDom(o[i], el);
      }
  } else if (typeof o == 'string') 
  {
    el = doc.createTextNode(o);
  } else {
    el = doc.createElement(o.tag || 'div');
    useSet = !!el.setAttribute;
    for (attr in o) 
      {
        if (!this.confRe.test(attr)) 
        {
          val = o[attr];
          if (attr == 'cls') 
          {
            el.className = val;
          } else {
            if (useSet) 
            {
              el.setAttribute(attr, val);
            } else {
              el[attr] = val;
            }
          }
        }
      }
    Ext.DomHelper.applyStyles(el, o.style);
    if ((cn = o.children || o.cn)) 
    {
      this.createDom(cn, el);
    } else if (o.html) 
    {
      el.innerHTML = o.html;
    }
  }
  if (parentNode) 
  {
    parentNode.appendChild(el);
  }
  return el;
}, ieTable: function(depth, openingTags, htmlContent, closingTags) {
  detachedDiv.innerHTML = [openingTags, htmlContent, closingTags].join('');
  var i = -1, el = detachedDiv, ns;
  while (++i < depth) 
    {
      el = el.firstChild;
    }
  ns = el.nextSibling;
  if (ns) 
  {
    ns = el;
    el = document.createDocumentFragment();
    while (ns) 
      {
        nx = ns.nextSibling;
        el.appendChild(ns);
        ns = nx;
      }
  }
  return el;
}, insertIntoTable: function(tag, where, destinationEl, html) {
  var node, before, bb = where == beforebegin, ab = where == afterbegin, be = where == beforeend, ae = where == afterend;
  if (tag == 'td' && (ab || be) || !this.tableElRe.test(tag) && (bb || ae)) 
  {
    return null;
  }
  before = bb ? destinationEl : ae ? destinationEl.nextSibling : ab ? destinationEl.firstChild : null;
  if (bb || ae) 
  {
    destinationEl = destinationEl.parentNode;
  }
  if (tag == 'td' || (tag == 'tr' && (be || ab))) 
  {
    node = this.ieTable(4, trs, html, tre);
  } else if (((tag == 'tbody' || tag == 'thead') && (be || ab)) || (tag == 'tr' && (bb || ae))) 
  {
    node = this.ieTable(3, tbs, html, tbe);
  } else {
    node = this.ieTable(2, ts, html, te);
  }
  destinationEl.insertBefore(node, before);
  return node;
}, createContextualFragment: function(html) {
  var fragment = document.createDocumentFragment(), length, childNodes;
  detachedDiv.innerHTML = html;
  childNodes = detachedDiv.childNodes;
  length = childNodes.length;
  while (length--) 
    {
      fragment.appendChild(childNodes[0]);
    }
  return fragment;
}, applyStyles: function(el, styles) {
  if (styles) 
  {
    if (typeof styles == "function") 
    {
      styles = styles.call();
    }
    if (typeof styles == "string") 
    {
      styles = Ext.dom.Element.parseStyles(styles);
    }
    if (typeof styles == "object") 
    {
      Ext.fly(el, '_applyStyles').setStyle(styles);
    }
  }
}, createHtml: function(spec) {
  return this.markup(spec);
}, doInsert: function(el, o, returnElement, pos, sibling, append) {
  el = el.dom || Ext.getDom(el);
  var newNode;
  if (this.useDom) 
  {
    newNode = this.createDom(o, null);
    if (append) 
    {
      el.appendChild(newNode);
    } else {
      (sibling == 'firstChild' ? el : el.parentNode).insertBefore(newNode, el[sibling] || el);
    }
  } else {
    newNode = this.insertHtml(pos, el, this.markup(o));
  }
  return returnElement ? Ext.get(newNode, true) : newNode;
}, overwrite: function(el, html, returnElement) {
  var newNode;
  el = Ext.getDom(el);
  html = this.markup(html);
  if (Ext.isIE && this.tableRe.test(el.tagName)) 
  {
    while (el.firstChild) 
      {
        el.removeChild(el.firstChild);
      }
    if (html) 
    {
      newNode = this.insertHtml('afterbegin', el, html);
      return returnElement ? Ext.get(newNode) : newNode;
    }
    return null;
  }
  el.innerHTML = html;
  return returnElement ? Ext.get(el.firstChild) : el.firstChild;
}, insertHtml: function(where, el, html) {
  var hashVal, range, rangeEl, setStart, frag;
  where = where.toLowerCase();
  if (el.insertAdjacentHTML) 
  {
    if (Ext.isIE && this.tableRe.test(el.tagName) && (frag = this.insertIntoTable(el.tagName.toLowerCase(), where, el, html))) 
    {
      return frag;
    }
    if ((hashVal = fullPositionHash[where])) 
    {
      if (Ext.global.MSApp && Ext.global.MSApp.execUnsafeLocalFunction) 
      {
        MSApp.execUnsafeLocalFunction(function() {
  el.insertAdjacentHTML(hashVal[0], html);
});
      } else {
        el.insertAdjacentHTML(hashVal[0], html);
      }
      return el[hashVal[1]];
    }
  } else {
    if (el.nodeType === 3) 
    {
      where = where === 'afterbegin' ? 'beforebegin' : where;
      where = where === 'beforeend' ? 'afterend' : where;
    }
    range = Ext.supports.CreateContextualFragment ? el.ownerDocument.createRange() : undefined;
    setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
    if (bb_ae_PositionHash[where]) 
    {
      if (range) 
      {
        range[setStart](el);
        frag = range.createContextualFragment(html);
      } else {
        frag = this.createContextualFragment(html);
      }
      el.parentNode.insertBefore(frag, where == beforebegin ? el : el.nextSibling);
      return el[(where == beforebegin ? 'previous' : 'next') + 'Sibling'];
    } else {
      rangeEl = (where == afterbegin ? 'first' : 'last') + 'Child';
      if (el.firstChild) 
      {
        if (range) 
        {
          range[setStart](el[rangeEl]);
          frag = range.createContextualFragment(html);
        } else {
          frag = this.createContextualFragment(html);
        }
        if (where == afterbegin) 
        {
          el.insertBefore(frag, el.firstChild);
        } else {
          el.appendChild(frag);
        }
      } else {
        el.innerHTML = html;
      }
      return el[rangeEl];
    }
  }
}, createTemplate: function(o) {
  var html = this.markup(o);
  return new Ext.Template(html);
}};
})(), 0, 0, 0, 0, 0, 0, [Ext.dom, 'Helper'], function() {
  Ext.ns('Ext.core');
  Ext.DomHelper = Ext.core.DomHelper = new this();
}));
;

(Ext.cmd.derive('Ext.Template', Ext.Base, {inheritableStatics: {from: function(el, config) {
  el = Ext.getDom(el);
  return new this(el.value || el.innerHTML, config || '');
}}, useEval: Ext.isGecko, constructor: function(html) {
  var me = this, args = arguments, buffer = [], i = 0, length = args.length, value;
  me.initialConfig = {};
  if (length === 1 && Ext.isArray(html)) 
  {
    args = html;
    length = args.length;
  }
  if (length > 1) 
  {
    for (; i < length; i++) 
      {
        value = args[i];
        if (typeof value == 'object') 
        {
          Ext.apply(me.initialConfig, value);
          Ext.apply(me, value);
        } else {
          buffer.push(value);
        }
      }
  } else {
    buffer.push(html);
  }
  me.html = buffer.join('');
  if (me.compiled) 
  {
    me.compile();
  }
}, isTemplate: true, disableFormats: false, re: /\{(?:(?:(\d*)|([\w\-]+))(?:\:([A-Za-z_\.]*)(?:\((.*?)?\))?)?)\}/g, apply: function(values) {
  if (this.compiled) 
  {
    return this.compiled(values).join('');
  }
  return this.evaluate(values);
}, evaluate: function(values) {
  var me = this, useFormat = me.disableFormats !== true, fm = Ext.util.Format, tpl = me;
  function fn(match, index, name, formatFn, args) {
    if (name == null || name == '') 
    {
      name = index;
    }
    if (formatFn && useFormat) 
    {
      if (args) 
      {
        args = [values[name]].concat(Ext.functionFactory('return [' + args + '];')());
      } else {
        args = [values[name]];
      }
      if (formatFn.substr(0, 5) === "this.") 
      {
        return tpl[formatFn.substr(5)].apply(tpl, args);
      } else if (fm[formatFn]) 
      {
        return fm[formatFn].apply(fm, args);
      } else {
        return match;
      }
    } else {
      return values[name] !== undefined ? values[name] : "";
    }
  }
  return me.html.replace(me.re, fn);
}, applyOut: function(values, out) {
  var me = this;
  if (me.compiled) 
  {
    out.push.apply(out, me.compiled(values));
  } else {
    out.push(me.apply(values));
  }
  return out;
}, applyTemplate: function() {
  return this.apply.apply(this, arguments);
}, set: function(html, compile) {
  var me = this;
  me.html = html;
  me.compiled = null;
  return compile ? me.compile() : me;
}, compileARe: /\\/g, compileBRe: /(\r\n|\n)/g, compileCRe: /'/g, compile: function() {
  var me = this, code;
  code = me.html.replace(me.compileARe, '\\\\').replace(me.compileBRe, '\\n').replace(me.compileCRe, "\\'").replace(me.re, Ext.Function.bind(me.regexReplaceFn, me));
  code = (this.disableFormats !== true ? 'var fm=Ext.util.Format;' : '') + (me.useEval ? '$=' : 'return') + " function(v){return ['" + code + "'];};";
  me.compiled = me.useEval ? me.evalCompiled(code) : (new Function('Ext', code))(Ext);
  return me;
}, evalCompiled: function($) {
  eval($);
  return $;
}, regexReplaceFn: function fn(match, index, name, formatFn, args) {
  if (index == null || index == '') 
  {
    index = '"' + name + '"';
  } else if (this.stringFormat) 
  {
    index = parseInt(index) + 1;
  }
  if (formatFn && this.disableFormats !== true) 
  {
    args = args ? ',' + args : "";
    if (formatFn.substr(0, 5) === "this.") 
    {
      formatFn = formatFn + '(';
    } else if (Ext.util.Format[formatFn]) 
    {
      formatFn = "fm." + formatFn + '(';
    } else {
      return match;
    }
    return "'," + formatFn + "v[" + index + "]" + args + "),'";
  } else {
    return "',v[" + index + "] == undefined ? '' : v[" + index + "],'";
  }
}, insertFirst: function(el, values, returnElement) {
  return this.doInsert('afterBegin', el, values, returnElement);
}, insertBefore: function(el, values, returnElement) {
  return this.doInsert('beforeBegin', el, values, returnElement);
}, insertAfter: function(el, values, returnElement) {
  return this.doInsert('afterEnd', el, values, returnElement);
}, append: function(el, values, returnElement) {
  return this.doInsert('beforeEnd', el, values, returnElement);
}, doInsert: function(where, el, values, returnElement) {
  var newNode = Ext.DomHelper.insertHtml(where, Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}, overwrite: function(el, values, returnElement) {
  var newNode = Ext.DomHelper.overwrite(Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}}, 1, 0, 0, 0, 0, 0, [Ext, 'Template'], 0));
;

(Ext.cmd.derive('Ext.XTemplateParser', Ext.Base, {constructor: function(config) {
  Ext.apply(this, config);
}, doTpl: Ext.emptyFn, parse: function(str) {
  var me = this, len = str.length, aliases = {elseif: 'elif'}, topRe = me.topRe, actionsRe = me.actionsRe, index, stack, s, m, t, prev, frame, subMatch, begin, end, actions, prop, expectTplNext;
  me.level = 0;
  me.stack = stack = [];
  for (index = 0; index < len; index = end) 
    {
      topRe.lastIndex = index;
      m = topRe.exec(str);
      if (!m) 
      {
        me.doText(str.substring(index, len));
        break;
      }
      begin = m.index;
      end = topRe.lastIndex;
      if (index < begin) 
      {
        s = str.substring(index, begin);
        if (!(expectTplNext && Ext.String.trim(s) === '')) 
        {
          me.doText(s);
        }
      }
      expectTplNext = false;
      if (m[1]) 
      {
        end = str.indexOf('%}', begin + 2);
        me.doEval(str.substring(begin + 2, end));
        end += 2;
      } else if (m[2]) 
      {
        end = str.indexOf(']}', begin + 2);
        me.doExpr(str.substring(begin + 2, end));
        end += 2;
      } else if (m[3]) 
      {
        me.doTag(m[3]);
      } else if (m[4]) 
      {
        actions = null;
        while ((subMatch = actionsRe.exec(m[4])) !== null) 
          {
            s = subMatch[2] || subMatch[3];
            if (s) 
            {
              s = Ext.String.htmlDecode(s);
              t = subMatch[1];
              t = aliases[t] || t;
              actions = actions || {};
              prev = actions[t];
              if (typeof prev == 'string') 
              {
                actions[t] = [prev, s];
              } else if (prev) 
              {
                actions[t].push(s);
              } else {
                actions[t] = s;
              }
            }
          }
        if (!actions) 
        {
          if (me.elseRe.test(m[4])) 
          {
            me.doElse();
          } else if (me.defaultRe.test(m[4])) 
          {
            me.doDefault();
          } else {
            me.doTpl();
            stack.push({type: 'tpl'});
          }
        } else if (actions['if']) 
        {
          me.doIf(actions['if'], actions);
          stack.push({type: 'if'});
        } else if (actions['switch']) 
        {
          me.doSwitch(actions['switch'], actions);
          stack.push({type: 'switch'});
          expectTplNext = true;
        } else if (actions['case']) 
        {
          me.doCase(actions['case'], actions);
        } else if (actions['elif']) 
        {
          me.doElseIf(actions['elif'], actions);
        } else if (actions['for']) 
        {
          ++me.level;
          if (prop = me.propRe.exec(m[4])) 
          {
            actions.propName = prop[1] || prop[2];
          }
          me.doFor(actions['for'], actions);
          stack.push({type: 'for', actions: actions});
        } else if (actions['foreach']) 
        {
          ++me.level;
          if (prop = me.propRe.exec(m[4])) 
          {
            actions.propName = prop[1] || prop[2];
          }
          me.doForEach(actions['foreach'], actions);
          stack.push({type: 'foreach', actions: actions});
        } else if (actions.exec) 
        {
          me.doExec(actions.exec, actions);
          stack.push({type: 'exec', actions: actions});
        }
      } else if (m[0].length === 5) 
      {
        stack.push({type: 'tpl'});
      } else {
        frame = stack.pop();
        me.doEnd(frame.type, frame.actions);
        if (frame.type == 'for' || frame.type == 'foreach') 
        {
          --me.level;
        }
      }
    }
}, topRe: /(?:(\{\%)|(\{\[)|\{([^{}]+)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g, actionsRe: /\s*(elif|elseif|if|for|foreach|exec|switch|case|eval|between)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g, propRe: /prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/, defaultRe: /^\s*default\s*$/, elseRe: /^\s*else\s*$/}, 1, 0, 0, 0, 0, 0, [Ext, 'XTemplateParser'], 0));
;

(Ext.cmd.derive('Ext.XTemplateCompiler', Ext.XTemplateParser, {useEval: Ext.isGecko, useIndex: Ext.isIE8m, useFormat: true, propNameRe: /^[\w\d\$]*$/, compile: function(tpl) {
  var me = this, code = me.generate(tpl);
  return me.useEval ? me.evalTpl(code) : (new Function('Ext', code))(Ext);
}, generate: function(tpl) {
  var me = this, definitions = 'var fm=Ext.util.Format,ts=Object.prototype.toString;', code;
  me.maxLevel = 0;
  me.body = ['var c0=values, a0=' + me.createArrayTest(0) + ', p0=parent, n0=xcount, i0=xindex, k0, v;\n'];
  if (me.definitions) 
  {
    if (typeof me.definitions === 'string') 
    {
      me.definitions = [me.definitions, definitions];
    } else {
      me.definitions.push(definitions);
    }
  } else {
    me.definitions = [definitions];
  }
  me.switches = [];
  me.parse(tpl);
  me.definitions.push((me.useEval ? '$=' : 'return') + ' function (' + me.fnArgs + ') {', me.body.join(''), '}');
  code = me.definitions.join('\n');
  me.definitions.length = me.body.length = me.switches.length = 0;
  delete me.definitions;
  delete me.body;
  delete me.switches;
  return code;
}, doText: function(text) {
  var me = this, out = me.body;
  text = text.replace(me.aposRe, "\\'").replace(me.newLineRe, '\\n');
  if (me.useIndex) 
  {
    out.push('out[out.length]=\'', text, '\'\n');
  } else {
    out.push('out.push(\'', text, '\')\n');
  }
}, doExpr: function(expr) {
  var out = this.body;
  out.push('if ((v=' + expr + ') != null) out');
  if (this.useIndex) 
  {
    out.push('[out.length]=v+\'\'\n');
  } else {
    out.push('.push(v+\'\')\n');
  }
}, doTag: function(tag) {
  var expr = this.parseTag(tag);
  if (expr) 
  {
    this.doExpr(expr);
  } else {
    this.doText('{' + tag + '}');
  }
}, doElse: function() {
  this.body.push('} else {\n');
}, doEval: function(text) {
  this.body.push(text, '\n');
}, doIf: function(action, actions) {
  var me = this;
  if (action === '.') 
  {
    me.body.push('if (values) {\n');
  } else if (me.propNameRe.test(action)) 
  {
    me.body.push('if (', me.parseTag(action), ') {\n');
  } else {
    me.body.push('if (', me.addFn(action), me.callFn, ') {\n');
  }
  if (actions.exec) 
  {
    me.doExec(actions.exec);
  }
}, doElseIf: function(action, actions) {
  var me = this;
  if (action === '.') 
  {
    me.body.push('else if (values) {\n');
  } else if (me.propNameRe.test(action)) 
  {
    me.body.push('} else if (', me.parseTag(action), ') {\n');
  } else {
    me.body.push('} else if (', me.addFn(action), me.callFn, ') {\n');
  }
  if (actions.exec) 
  {
    me.doExec(actions.exec);
  }
}, doSwitch: function(action) {
  var me = this, key;
  if (action === '.' || action === '#') 
  {
    key = action === '.' ? 'values' : 'xindex';
    me.body.push('switch (', key, ') {\n');
  } else if (me.propNameRe.test(action)) 
  {
    me.body.push('switch (', me.parseTag(action), ') {\n');
  } else {
    me.body.push('switch (', me.addFn(action), me.callFn, ') {\n');
  }
  me.switches.push(0);
}, doCase: function(action) {
  var me = this, cases = Ext.isArray(action) ? action : [action], n = me.switches.length - 1, match, i;
  if (me.switches[n]) 
  {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  for (i = 0 , n = cases.length; i < n; ++i) 
    {
      match = me.intRe.exec(cases[i]);
      cases[i] = match ? match[1] : ("'" + cases[i].replace(me.aposRe, "\\'") + "'");
    }
  me.body.push('case ', cases.join(': case '), ':\n');
}, doDefault: function() {
  var me = this, n = me.switches.length - 1;
  if (me.switches[n]) 
  {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  me.body.push('default:\n');
}, doEnd: function(type, actions) {
  var me = this, L = me.level - 1;
  if (type == 'for' || type == 'foreach') 
  {
    if (actions.exec) 
    {
      me.doExec(actions.exec);
    }
    me.body.push('}\n');
    me.body.push('parent=p', L, ';values=r', L + 1, ';xcount=n' + L + ';xindex=i', L, '+1;xkey=k', L, ';\n');
  } else if (type == 'if' || type == 'switch') 
  {
    me.body.push('}\n');
  }
}, doFor: function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') 
  {
    s = 'values';
  } else if (me.propNameRe.test(action)) 
  {
    s = me.parseTag(action);
  } else {
    s = me.addFn(action) + me.callFn;
  }
  if (me.maxLevel < L) 
  {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') 
  {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '=0,n', L, '=0,c', L, '=', s, ',a', L, '=', me.createArrayTest(L), ',r', L, '=values,p', L, ',k', L, ';\n', 'p', L, '=parent=', parentAssignment, '\n', 'if (c', L, '){if(a', L, '){n', L, '=c', L, '.length;}else if (c', L, '.isMixedCollection){c', L, '=c', L, '.items;n', L, '=c', L, '.length;}else if(c', L, '.isStore){c', L, '=c', L, '.data.items;n', L, '=c', L, '.length;}else{c', L, '=[c', L, '];n', L, '=1;}}\n', 'for (xcount=n', L, ';i', L, '<n' + L + ';++i', L, '){\n', 'values=c', L, '[i', L, ']');
  if (actions.propName) 
  {
    me.body.push('.', actions.propName);
  }
  me.body.push('\n', 'xindex=i', L, '+1\n');
  if (actions.between) 
  {
    me.body.push('if(xindex>1){ out.push("', actions.between, '"); } \n');
  }
}, doForEach: function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') 
  {
    s = 'values';
  } else if (me.propNameRe.test(action)) 
  {
    s = me.parseTag(action);
  } else {
    s = me.addFn(action) + me.callFn;
  }
  if (me.maxLevel < L) 
  {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') 
  {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '=-1,n', L, '=0,c', L, '=', s, ',a', L, '=', me.createArrayTest(L), ',r', L, '=values,p', L, ',k', L, ';\n', 'p', L, '=parent=', parentAssignment, '\n', 'for(k', L, ' in c', L, '){\n', 'xindex=++i', L, '+1;\n', 'xkey=k', L, ';\n', 'values=c', L, '[k', L, '];');
  if (actions.propName) 
  {
    me.body.push('.', actions.propName);
  }
  if (actions.between) 
  {
    me.body.push('if(xindex>1){ out.push("', actions.between, '"); } \n');
  }
}, createArrayTest: ('isArray' in Array) ? function(L) {
  return 'Array.isArray(c' + L + ')';
} : function(L) {
  return 'ts.call(c' + L + ')==="[object Array]"';
}, doExec: function(action, actions) {
  var me = this, name = 'f' + me.definitions.length;
  me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' try { with(values) {', '  ' + action, ' }} catch(e) {', '}', '}');
  me.body.push(name + me.callFn + '\n');
}, addFn: function(body) {
  var me = this, name = 'f' + me.definitions.length;
  if (body === '.') 
  {
    me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return values', '}');
  } else if (body === '..') 
  {
    me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return parent', '}');
  } else {
    me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' try { with(values) {', '  return(' + body + ')', ' }} catch(e) {', '}', '}');
  }
  return name;
}, parseTag: function(tag) {
  var me = this, m = me.tagRe.exec(tag), name, format, args, math, v;
  if (!m) 
  {
    return null;
  }
  name = m[1];
  format = m[2];
  args = m[3];
  math = m[4];
  if (name == '.') 
  {
    if (!me.validTypes) 
    {
      me.definitions.push('var validTypes={string:1,number:1,boolean:1};');
      me.validTypes = true;
    }
    v = 'validTypes[typeof values] || ts.call(values) === "[object Date]" ? values : ""';
  } else if (name == '#') 
  {
    v = 'xindex';
  } else if (name == '$') 
  {
    v = 'xkey';
  } else if (name.substr(0, 7) == "parent.") 
  {
    v = name;
  } else if (isNaN(name) && name.indexOf('-') == -1 && name.indexOf('.') != -1) 
  {
    v = "values." + name;
  } else {
    v = "values['" + name + "']";
  }
  if (math) 
  {
    v = '(' + v + math + ')';
  }
  if (format && me.useFormat) 
  {
    args = args ? ',' + args : "";
    if (format.substr(0, 5) != "this.") 
    {
      format = "fm." + format + '(';
    } else {
      format += '(';
    }
  } else {
    return v;
  }
  return format + v + args + ')';
}, evalTpl: function($) {
  eval($);
  return $;
}, newLineRe: /\r\n|\r|\n/g, aposRe: /[']/g, intRe: /^\s*(\d+)\s*$/, tagRe: /^([\w-\.\#\$]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?$/}, 0, 0, 0, 0, 0, 0, [Ext, 'XTemplateCompiler'], function() {
  var proto = this.prototype;
  proto.fnArgs = 'out,values,parent,xindex,xcount,xkey';
  proto.callFn = '.call(this,' + proto.fnArgs + ')';
}));
;

(Ext.cmd.derive('Ext.XTemplate', Ext.Template, {emptyObj: {}, apply: function(values, parent) {
  return this.applyOut(values, [], parent).join('');
}, applyOut: function(values, out, parent) {
  var me = this, compiler;
  if (!me.fn) 
  {
    compiler = new Ext.XTemplateCompiler({useFormat: me.disableFormats !== true, definitions: me.definitions});
    me.fn = compiler.compile(me.html);
  }
  try {
    me.fn(out, values, parent || me.emptyObj, 1, 1);
  }  catch (e) {
}
  return out;
}, compile: function() {
  return this;
}, statics: {getTpl: function(instance, name) {
  var tpl = instance[name], owner;
  if (tpl && !tpl.isTemplate) 
  {
    tpl = Ext.ClassManager.dynInstantiate('Ext.XTemplate', tpl);
    if (instance.hasOwnProperty(name)) 
    {
      owner = instance;
    } else {
      for (owner = instance.self.prototype; owner && !owner.hasOwnProperty(name); owner = owner.superclass) 
        {
        }
    }
    owner[name] = tpl;
    tpl.owner = owner;
  }
  return tpl || null;
}}}, 0, 0, 0, 0, 0, 0, [Ext, 'XTemplate'], 0));
;

Ext.ns('Ext.core');
Ext.dom.Query = Ext.core.DomQuery = Ext.DomQuery = (function() {
  var DQ, doc = document, cache, simpleCache, valueCache, useClassList = !!doc.documentElement.classList, useElementPointer = !!doc.documentElement.firstElementChild, useChildrenCollection = (function() {
  var d = doc.createElement('div');
  d.innerHTML = '<!-- -->text<!-- -->';
  return d.children && (d.children.length === 0);
})(), nonSpace = /\S/, trimRe = /^\s+|\s+$/g, tplRe = /\{(\d+)\}/g, modeRe = /^(\s?[\/>+~]\s?|\s|$)/, tagTokenRe = /^(#)?([\w\-\*\|\\]+)/, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/, startIdRe = /^\s*#/, isIE = window.ActiveXObject ? true : false, key = 30803, longHex = /\\([0-9a-fA-F]{6})/g, shortHex = /\\([0-9a-fA-F]{1,6})\s{0,1}/g, nonHex = /\\([^0-9a-fA-F]{1})/g, escapes = /\\/g, num, hasEscapes, supportsColonNsSeparator = (function() {
  var xmlDoc, xmlString = '<r><a:b xmlns:a="n"></a:b></r>';
  if (window.DOMParser) 
  {
    xmlDoc = (new DOMParser()).parseFromString(xmlString, "application/xml");
  } else {
    xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
    xmlDoc.loadXML(xmlString);
  }
  return !!xmlDoc.getElementsByTagName('a:b').length;
})(), longHexToChar = function($0, $1) {
  return String.fromCharCode(parseInt($1, 16));
}, shortToLongHex = function($0, $1) {
  while ($1.length < 6) 
    {
      $1 = '0' + $1;
    }
  return '\\' + $1;
}, charToLongHex = function($0, $1) {
  num = $1.charCodeAt(0).toString(16);
  if (num.length === 1) 
  {
    num = '0' + num;
  }
  return '\\0000' + num;
}, unescapeCssSelector = function(selector) {
  return (hasEscapes) ? selector.replace(longHex, longHexToChar) : selector;
}, setupEscapes = function(path) {
  hasEscapes = (path.indexOf('\\') > -1);
  if (hasEscapes) 
  {
    path = path.replace(shortHex, shortToLongHex).replace(nonHex, charToLongHex).replace(escapes, '\\\\');
  }
  return path;
};
  eval("var batch = 30803, child, next, prev, byClassName;");
  child = useChildrenCollection ? function child(parent, index) {
  return parent.children[index];
} : function child(parent, index) {
  var i = 0, n = parent.firstChild;
  while (n) 
    {
      if (n.nodeType == 1) 
      {
        if (++i == index) 
        {
          return n;
        }
      }
      n = n.nextSibling;
    }
  return null;
};
  next = useElementPointer ? function(n) {
  return n.nextElementSibling;
} : function(n) {
  while ((n = n.nextSibling) && n.nodeType != 1) 
    ;
  return n;
};
  prev = useElementPointer ? function(n) {
  return n.previousElementSibling;
} : function(n) {
  while ((n = n.previousSibling) && n.nodeType != 1) 
    ;
  return n;
};
  function children(parent) {
    var n = parent.firstChild, nodeIndex = -1, nextNode;
    while (n) 
      {
        nextNode = n.nextSibling;
        if (n.nodeType == 3 && !nonSpace.test(n.nodeValue)) 
        {
          parent.removeChild(n);
        } else {
          n.nodeIndex = ++nodeIndex;
        }
        n = nextNode;
      }
    return this;
  }
  byClassName = useClassList ? function(nodeSet, cls) {
  cls = unescapeCssSelector(cls);
  if (!cls) 
  {
    return nodeSet;
  }
  var result = [], ri = -1, i, ci, classList;
  for (i = 0; ci = nodeSet[i]; i++) 
    {
      classList = ci.classList;
      if (classList) 
      {
        if (classList.contains(cls)) 
        {
          result[++ri] = ci;
        }
      } else if ((' ' + ci.className + ' ').indexOf(cls) !== -1) 
      {
        result[++ri] = ci;
      }
    }
  return result;
} : function(nodeSet, cls) {
  cls = unescapeCssSelector(cls);
  if (!cls) 
  {
    return nodeSet;
  }
  var result = [], ri = -1, i, ci;
  for (i = 0; ci = nodeSet[i]; i++) 
    {
      if ((' ' + ci.className + ' ').indexOf(cls) !== -1) 
      {
        result[++ri] = ci;
      }
    }
  return result;
};
  function attrValue(n, attr) {
    if (!n.tagName && typeof n.length != "undefined") 
    {
      n = n[0];
    }
    if (!n) 
    {
      return null;
    }
    if (attr == "for") 
    {
      return n.htmlFor;
    }
    if (attr == "class" || attr == "className") 
    {
      return n.className;
    }
    return n.getAttribute(attr) || n[attr];
  }
  function getNodes(ns, mode, tagName) {
    var result = [], ri = -1, cs, i, ni, j, ci, cn, utag, n, cj;
    if (!ns) 
    {
      return result;
    }
    tagName = tagName.replace('|', ':') || "*";
    if (typeof ns.getElementsByTagName != "undefined") 
    {
      ns = [ns];
    }
    if (!mode) 
    {
      tagName = unescapeCssSelector(tagName);
      if (!supportsColonNsSeparator && DQ.isXml(ns[0]) && tagName.indexOf(':') !== -1) 
      {
        for (i = 0; ni = ns[i]; i++) 
          {
            cs = ni.getElementsByTagName(tagName.split(':').pop());
            for (j = 0; ci = cs[j]; j++) 
              {
                if (ci.tagName === tagName) 
                {
                  result[++ri] = ci;
                }
              }
          }
      } else {
        for (i = 0; ni = ns[i]; i++) 
          {
            cs = ni.getElementsByTagName(tagName);
            for (j = 0; ci = cs[j]; j++) 
              {
                result[++ri] = ci;
              }
          }
      }
    } else if (mode == "/" || mode == ">") 
    {
      utag = tagName.toUpperCase();
      for (i = 0; ni = ns[i]; i++) 
        {
          cn = ni.childNodes;
          for (j = 0; cj = cn[j]; j++) 
            {
              if (cj.nodeName == utag || cj.nodeName == tagName || tagName == '*') 
              {
                result[++ri] = cj;
              }
            }
        }
    } else if (mode == "+") 
    {
      utag = tagName.toUpperCase();
      for (i = 0; n = ns[i]; i++) 
        {
          while ((n = n.nextSibling) && n.nodeType != 1) 
            ;
          if (n && (n.nodeName == utag || n.nodeName == tagName || tagName == '*')) 
          {
            result[++ri] = n;
          }
        }
    } else if (mode == "~") 
    {
      utag = tagName.toUpperCase();
      for (i = 0; n = ns[i]; i++) 
        {
          while ((n = n.nextSibling)) 
            {
              if (n.nodeName == utag || n.nodeName == tagName || tagName == '*') 
              {
                result[++ri] = n;
              }
            }
        }
    }
    return result;
  }
  function concat(a, b) {
    a.push.apply(a, b);
    return a;
  }
  function byTag(cs, tagName) {
    if (cs.tagName || cs === doc) 
    {
      cs = [cs];
    }
    if (!tagName) 
    {
      return cs;
    }
    var result = [], ri = -1, i, ci;
    tagName = tagName.toLowerCase();
    for (i = 0; ci = cs[i]; i++) 
      {
        if (ci.nodeType == 1 && ci.tagName.toLowerCase() == tagName) 
        {
          result[++ri] = ci;
        }
      }
    return result;
  }
  function byId(cs, id) {
    id = unescapeCssSelector(id);
    if (cs.tagName || cs === doc) 
    {
      cs = [cs];
    }
    if (!id) 
    {
      return cs;
    }
    var result = [], ri = -1, i, ci;
    for (i = 0; ci = cs[i]; i++) 
      {
        if (ci && ci.id == id) 
        {
          result[++ri] = ci;
          return result;
        }
      }
    return result;
  }
  function byAttribute(cs, attr, value, op, custom) {
    var result = [], ri = -1, useGetStyle = custom == "{", fn = DQ.operators[op], a, xml, hasXml, i, ci;
    value = unescapeCssSelector(value);
    for (i = 0; ci = cs[i]; i++) 
      {
        if (ci.nodeType === 1) 
        {
          if (!hasXml) 
          {
            xml = DQ.isXml(ci);
            hasXml = true;
          }
          if (!xml) 
          {
            if (useGetStyle) 
            {
              a = DQ.getStyle(ci, attr);
            } else if (attr == "class" || attr == "className") 
            {
              a = ci.className;
            } else if (attr == "for") 
            {
              a = ci.htmlFor;
            } else if (attr == "href") 
            {
              a = ci.getAttribute("href", 2);
            } else {
              a = ci.getAttribute(attr);
            }
          } else {
            a = ci.getAttribute(attr);
          }
          if ((fn && fn(a, value)) || (!fn && a)) 
          {
            result[++ri] = ci;
          }
        }
      }
    return result;
  }
  function byPseudo(cs, name, value) {
    value = unescapeCssSelector(value);
    return DQ.pseudos[name](cs, value);
  }
  function nodupIEXml(cs) {
    var d = ++key, r, i, len, c;
    cs[0].setAttribute("_nodup", d);
    r = [cs[0]];
    for (i = 1 , len = cs.length; i < len; i++) 
      {
        c = cs[i];
        if (!c.getAttribute("_nodup") != d) 
        {
          c.setAttribute("_nodup", d);
          r[r.length] = c;
        }
      }
    for (i = 0 , len = cs.length; i < len; i++) 
      {
        cs[i].removeAttribute("_nodup");
      }
    return r;
  }
  function nodup(cs) {
    if (!cs) 
    {
      return [];
    }
    var len = cs.length, c, i, r = cs, cj, ri = -1, d, j;
    if (!len || typeof cs.nodeType != "undefined" || len == 1) 
    {
      return cs;
    }
    if (isIE && typeof cs[0].selectSingleNode != "undefined") 
    {
      return nodupIEXml(cs);
    }
    d = ++key;
    cs[0]._nodup = d;
    for (i = 1; c = cs[i]; i++) 
      {
        if (c._nodup != d) 
        {
          c._nodup = d;
        } else {
          r = [];
          for (j = 0; j < i; j++) 
            {
              r[++ri] = cs[j];
            }
          for (j = i + 1; cj = cs[j]; j++) 
            {
              if (cj._nodup != d) 
              {
                cj._nodup = d;
                r[++ri] = cj;
              }
            }
          return r;
        }
      }
    return r;
  }
  function quickDiffIEXml(c1, c2) {
    var d = ++key, r = [], i, len;
    for (i = 0 , len = c1.length; i < len; i++) 
      {
        c1[i].setAttribute("_qdiff", d);
      }
    for (i = 0 , len = c2.length; i < len; i++) 
      {
        if (c2[i].getAttribute("_qdiff") != d) 
        {
          r[r.length] = c2[i];
        }
      }
    for (i = 0 , len = c1.length; i < len; i++) 
      {
        c1[i].removeAttribute("_qdiff");
      }
    return r;
  }
  function quickDiff(c1, c2) {
    var len1 = c1.length, d = ++key, r = [], i, len;
    if (!len1) 
    {
      return c2;
    }
    if (isIE && typeof c1[0].selectSingleNode != "undefined") 
    {
      return quickDiffIEXml(c1, c2);
    }
    for (i = 0; i < len1; i++) 
      {
        c1[i]._qdiff = d;
      }
    for (i = 0 , len = c2.length; i < len; i++) 
      {
        if (c2[i]._qdiff != d) 
        {
          r[r.length] = c2[i];
        }
      }
    return r;
  }
  function quickId(ns, mode, root, id) {
    if (ns == root) 
    {
      id = unescapeCssSelector(id);
      var d = root.ownerDocument || root;
      return d.getElementById(id);
    }
    ns = getNodes(ns, mode, "*");
    return byId(ns, id);
  }
  return DQ = {clearCache: function() {
  cache && cache.clear();
  valueCache && valueCache.clear();
  simpleCache && simpleCache.clear();
}, getStyle: function(el, name) {
  return Ext.fly(el, '_DomQuery').getStyle(name);
}, compile: function(path, type) {
  type = type || "select";
  var fn = ["var f = function(root) {\n var mode; ++batch; var n = root || document;\n"], lastPath, matchers = DQ.matchers, matchersLn = matchers.length, modeMatch, lmode = path.match(modeRe), tokenMatch, matched, j, t, m;
  path = setupEscapes(path);
  if (lmode && lmode[1]) 
  {
    fn[fn.length] = 'mode="' + lmode[1].replace(trimRe, "") + '";';
    path = path.replace(lmode[1], "");
  }
  while (path.substr(0, 1) == "/") 
    {
      path = path.substr(1);
    }
  while (path && lastPath != path) 
    {
      lastPath = path;
      tokenMatch = path.match(tagTokenRe);
      if (type == "select") 
      {
        if (tokenMatch) 
        {
          if (tokenMatch[1] == "#") 
          {
            fn[fn.length] = 'n = quickId(n, mode, root, "' + tokenMatch[2] + '");';
          } else {
            fn[fn.length] = 'n = getNodes(n, mode, "' + tokenMatch[2] + '");';
          }
          path = path.replace(tokenMatch[0], "");
        } else if (path.substr(0, 1) != '@') 
        {
          fn[fn.length] = 'n = getNodes(n, mode, "*");';
        }
      } else {
        if (tokenMatch) 
        {
          if (tokenMatch[1] == "#") 
          {
            fn[fn.length] = 'n = byId(n, "' + tokenMatch[2] + '");';
          } else {
            fn[fn.length] = 'n = byTag(n, "' + tokenMatch[2] + '");';
          }
          path = path.replace(tokenMatch[0], "");
        }
      }
      while (!(modeMatch = path.match(modeRe))) 
        {
          matched = false;
          for (j = 0; j < matchersLn; j++) 
            {
              t = matchers[j];
              m = path.match(t.re);
              if (m) 
              {
                fn[fn.length] = t.select.replace(tplRe, function(x, i) {
  return m[i];
});
                path = path.replace(m[0], "");
                matched = true;
                break;
              }
            }
          if (!matched) 
          {
            Ext.Error.raise({sourceClass: 'Ext.DomQuery', sourceMethod: 'compile', msg: 'Error parsing selector. Parsing failed at "' + path + '"'});
          }
        }
      if (modeMatch[1]) 
      {
        fn[fn.length] = 'mode="' + modeMatch[1].replace(trimRe, "") + '";';
        path = path.replace(modeMatch[1], "");
      }
    }
  fn[fn.length] = "return nodup(n);\n}";
  eval(fn.join(""));
  return f;
}, jsSelect: function(path, root, type) {
  if (!cache) 
  {
    DQ._cache = cache = new Ext.util.LruCache({maxSize: 200});
  }
  root = root || doc;
  if (typeof root == "string") 
  {
    root = doc.getElementById(root);
  }
  var paths = Ext.splitAndUnescape(path, ","), results = [], query, i, len, subPath, result;
  for (i = 0 , len = paths.length; i < len; i++) 
    {
      subPath = paths[i].replace(trimRe, "");
      query = cache.get(subPath);
      if (!query) 
      {
        query = DQ.compile(subPath, type);
        if (!query) 
        {
          Ext.Error.raise({sourceClass: 'Ext.DomQuery', sourceMethod: 'jsSelect', msg: subPath + ' is not a valid selector'});
        }
        cache.add(subPath, query);
      } else {
        setupEscapes(subPath);
      }
      result = query(root);
      if (result && result !== doc) 
      {
        results = results.concat(result);
      }
    }
  if (paths.length > 1) 
  {
    return nodup(results);
  }
  return results;
}, isXml: function(el) {
  var docEl = (el ? el.ownerDocument || el : 0).documentElement;
  return docEl ? docEl.nodeName !== "HTML" : false;
}, select: doc.querySelectorAll ? function(path, root, type, single) {
  root = root || doc;
  if (!DQ.isXml(root)) 
  {
    try {
      if (root.parentNode && (root.nodeType !== 9) && path.indexOf(',') === -1 && !startIdRe.test(path)) 
      {
        path = '#' + Ext.escapeId(Ext.id(root)) + ' ' + path;
        root = root.parentNode;
      }
      return single ? [root.querySelector(path)] : Ext.Array.toArray(root.querySelectorAll(path));
    }    catch (e) {
}
  }
  return DQ.jsSelect.call(this, path, root, type);
} : function(path, root, type) {
  return DQ.jsSelect.call(this, path, root, type);
}, selectNode: function(path, root) {
  return Ext.DomQuery.select(path, root, null, true)[0];
}, selectValue: function(path, root, defaultValue) {
  if (!valueCache) 
  {
    DQ._valueCache = valueCache = new Ext.util.LruCache({maxSize: 200});
  }
  path = path.replace(trimRe, "");
  var query = valueCache.get(path), n, v;
  if (!query) 
  {
    query = DQ.compile(path, "select");
    valueCache.add(path, query);
  } else {
    setupEscapes(path);
  }
  n = query(root);
  n = n[0] ? n[0] : n;
  if (typeof n.normalize == 'function') 
  {
    n.normalize();
  }
  v = (n && n.firstChild ? n.firstChild.nodeValue : null);
  return ((v === null || v === undefined || v === '') ? defaultValue : v);
}, selectNumber: function(path, root, defaultValue) {
  var v = DQ.selectValue(path, root, defaultValue || 0);
  return parseFloat(v);
}, is: function(el, ss) {
  if (typeof el == "string") 
  {
    el = doc.getElementById(el);
  }
  var isArray = Ext.isArray(el), result = DQ.filter(isArray ? el : [el], ss);
  return isArray ? (result.length == el.length) : (result.length > 0);
}, filter: function(els, ss, nonMatches) {
  ss = ss.replace(trimRe, "");
  if (!simpleCache) 
  {
    DQ._simpleCache = simpleCache = new Ext.util.LruCache({maxSize: 200});
  }
  var query = simpleCache.get(ss), result;
  if (!query) 
  {
    query = DQ.compile(ss, "simple");
    simpleCache.add(ss, query);
  } else {
    setupEscapes(ss);
  }
  result = query(els);
  return nonMatches ? quickDiff(result, els) : result;
}, matchers: [{re: /^\.([\w\-\\]+)/, select: useClassList ? 'n = byClassName(n, "{1}");' : 'n = byClassName(n, " {1} ");'}, {re: /^\:([\w\-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/, select: 'n = byPseudo(n, "{1}", "{2}");'}, {re: /^(?:([\[\{])(?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/, select: 'n = byAttribute(n, "{2}", "{4}", "{3}", "{1}");'}, {re: /^#([\w\-\\]+)/, select: 'n = byId(n, "{1}");'}, {re: /^@([\w\-\.]+)/, select: 'return {firstChild:{nodeValue:attrValue(n, "{1}")}};'}], operators: {"=": function(a, v) {
  return a == v;
}, "!=": function(a, v) {
  return a != v;
}, "^=": function(a, v) {
  return a && a.substr(0, v.length) == v;
}, "$=": function(a, v) {
  return a && a.substr(a.length - v.length) == v;
}, "*=": function(a, v) {
  return a && a.indexOf(v) !== -1;
}, "%=": function(a, v) {
  return (a % v) === 0;
}, "|=": function(a, v) {
  return a && (a == v || a.substr(0, v.length + 1) == v + '-');
}, "~=": function(a, v) {
  return a && (' ' + a + ' ').indexOf(' ' + v + ' ') != -1;
}}, pseudos: {"first-child": function(c) {
  var r = [], ri = -1, n, i, ci;
  for (i = 0; (ci = n = c[i]); i++) 
    {
      while ((n = n.previousSibling) && n.nodeType != 1) 
        ;
      if (!n) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, "last-child": function(c) {
  var r = [], ri = -1, n, i, ci;
  for (i = 0; (ci = n = c[i]); i++) 
    {
      while ((n = n.nextSibling) && n.nodeType != 1) 
        ;
      if (!n) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, "nth-child": function(c, a) {
  var r = [], ri = -1, m = nthRe.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !nthRe2.test(a) && "n+" + a || a), f = (m[1] || 1) - 0, l = m[2] - 0, i, n, j, cn, pn;
  for (i = 0; n = c[i]; i++) 
    {
      pn = n.parentNode;
      if (batch != pn._batch) 
      {
        j = 0;
        for (cn = pn.firstChild; cn; cn = cn.nextSibling) 
          {
            if (cn.nodeType == 1) 
            {
              cn.nodeIndex = ++j;
            }
          }
        pn._batch = batch;
      }
      if (f == 1) 
      {
        if (l === 0 || n.nodeIndex == l) 
        {
          r[++ri] = n;
        }
      } else if ((n.nodeIndex + l) % f === 0) 
      {
        r[++ri] = n;
      }
    }
  return r;
}, "only-child": function(c) {
  var r = [], ri = -1, i, ci;
  for (i = 0; ci = c[i]; i++) 
    {
      if (!prev(ci) && !next(ci)) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, "empty": function(c) {
  var r = [], ri = -1, i, ci, cns, j, cn, empty;
  for (i = 0; ci = c[i]; i++) 
    {
      cns = ci.childNodes;
      j = 0;
      empty = true;
      while (cn = cns[j]) 
        {
          ++j;
          if (cn.nodeType == 1 || cn.nodeType == 3) 
          {
            empty = false;
            break;
          }
        }
      if (empty) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, "contains": function(c, v) {
  var r = [], ri = -1, i, ci;
  for (i = 0; ci = c[i]; i++) 
    {
      if ((ci.textContent || ci.innerText || ci.text || '').indexOf(v) != -1) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, "nodeValue": function(c, v) {
  var r = [], ri = -1, i, ci;
  for (i = 0; ci = c[i]; i++) 
    {
      if (ci.firstChild && ci.firstChild.nodeValue == v) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, "checked": function(c) {
  var r = [], ri = -1, i, ci;
  for (i = 0; ci = c[i]; i++) 
    {
      if (ci.checked === true) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, "not": function(c, ss) {
  return DQ.filter(c, ss, true);
}, "any": function(c, selectors) {
  var ss = selectors.split('|'), r = [], ri = -1, s, i, ci, j;
  for (i = 0; ci = c[i]; i++) 
    {
      for (j = 0; s = ss[j]; j++) 
        {
          if (DQ.is(ci, s)) 
          {
            r[++ri] = ci;
            break;
          }
        }
    }
  return r;
}, "odd": function(c) {
  return this["nth-child"](c, "odd");
}, "even": function(c) {
  return this["nth-child"](c, "even");
}, "nth": function(c, a) {
  return c[a - 1] || [];
}, "first": function(c) {
  return c[0] || [];
}, "last": function(c) {
  return c[c.length - 1] || [];
}, "has": function(c, ss) {
  var s = DQ.select, r = [], ri = -1, i, ci;
  for (i = 0; ci = c[i]; i++) 
    {
      if (s(ss, ci).length > 0) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, "next": function(c, ss) {
  var is = DQ.is, r = [], ri = -1, i, ci, n;
  for (i = 0; ci = c[i]; i++) 
    {
      n = next(ci);
      if (n && is(n, ss)) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, "prev": function(c, ss) {
  var is = DQ.is, r = [], ri = -1, i, ci, n;
  for (i = 0; ci = c[i]; i++) 
    {
      n = prev(ci);
      if (n && is(n, ss)) 
      {
        r[++ri] = ci;
      }
    }
  return r;
}, focusable: function(candidates) {
  var len = candidates.length, results = [], i = 0, c;
  for (; i < len; i++) 
    {
      c = candidates[i];
      if (Ext.fly(c, '_DomQuery').isFocusable()) 
      {
        results.push(c);
      }
    }
  return results;
}, visible: function(candidates, deep) {
  var len = candidates.length, results = [], i = 0, c;
  for (; i < len; i++) 
    {
      c = candidates[i];
      if (Ext.fly(c, '_DomQuery').isVisible(deep)) 
      {
        results.push(c);
      }
    }
  return results;
}}};
}());
Ext.query = Ext.DomQuery.select;

Ext.define('Ext.dom.Element_anim', {override: 'Ext.dom.Element', animate: function(config) {
  var me = this, animId = me.dom.id || Ext.id(me.dom), listeners, anim, end;
  if (!Ext.fx.Manager.hasFxBlock(animId)) 
  {
    if (config.listeners) 
    {
      listeners = config.listeners;
      delete config.listeners;
    }
    if (config.internalListeners) 
    {
      config.listeners = config.internalListeners;
      delete config.internalListeners;
    }
    end = config.autoEnd;
    delete config.autoEnd;
    anim = new Ext.fx.Anim(me.anim(config));
    if (listeners) 
    {
      anim.on(listeners);
    }
    Ext.fx.Manager.queueFx(anim);
    if (end) 
    {
      anim.jumpToEnd();
    }
  }
  return me;
}, anim: function(config) {
  if (!Ext.isObject(config)) 
  {
    return (config) ? {} : false;
  }
  var me = this, duration = config.duration || Ext.fx.Anim.prototype.duration, easing = config.easing || 'ease', animConfig;
  if (config.stopAnimation) 
  {
    me.stopAnimation();
  }
  Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
  Ext.fx.Manager.setFxDefaults(me.id, {delay: 0});
  animConfig = {target: me.dom, remove: config.remove, alternate: config.alternate || false, duration: duration, easing: easing, callback: config.callback, listeners: config.listeners, iterations: config.iterations || 1, scope: config.scope, block: config.block, concurrent: config.concurrent, delay: config.delay || 0, paused: true, keyframes: config.keyframes, from: config.from || {}, to: Ext.apply({}, config)};
  Ext.apply(animConfig.to, config.to);
  delete animConfig.to.to;
  delete animConfig.to.from;
  delete animConfig.to.remove;
  delete animConfig.to.alternate;
  delete animConfig.to.keyframes;
  delete animConfig.to.iterations;
  delete animConfig.to.listeners;
  delete animConfig.to.target;
  delete animConfig.to.paused;
  delete animConfig.to.callback;
  delete animConfig.to.scope;
  delete animConfig.to.duration;
  delete animConfig.to.easing;
  delete animConfig.to.concurrent;
  delete animConfig.to.block;
  delete animConfig.to.stopAnimation;
  delete animConfig.to.delay;
  return animConfig;
}, slideIn: function(anchor, obj, slideOut) {
  var me = this, dom = me.dom, elStyle = dom.style, beforeAnim, wrapAnim, restoreScroll, wrapDomParentNode;
  anchor = anchor || "t";
  obj = obj || {};
  beforeAnim = function() {
  var animScope = this, listeners = obj.listeners, el = Ext.fly(dom, '_anim'), box, originalStyles, anim, wrap;
  if (!slideOut) 
  {
    el.fixDisplay();
  }
  box = el.getBox();
  if ((anchor == 't' || anchor == 'b') && box.height === 0) 
  {
    box.height = dom.scrollHeight;
  } else if ((anchor == 'l' || anchor == 'r') && box.width === 0) 
  {
    box.width = dom.scrollWidth;
  }
  originalStyles = el.getStyles('width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index', true);
  el.setSize(box.width, box.height);
  if (obj.preserveScroll) 
  {
    restoreScroll = el.cacheScrollValues();
  }
  wrap = el.wrap({role: 'presentation', id: Ext.id() + '-anim-wrap-for-' + el.dom.id, style: {visibility: slideOut ? 'visible' : 'hidden'}});
  wrapDomParentNode = wrap.dom.parentNode;
  wrap.setPositioning(el.getPositioning(true));
  if (wrap.isStyle('position', 'static')) 
  {
    wrap.position('relative');
  }
  el.clearPositioning('auto');
  wrap.clip();
  if (restoreScroll) 
  {
    restoreScroll();
  }
  el.setStyle({visibility: '', position: 'absolute'});
  if (slideOut) 
  {
    wrap.setSize(box.width, box.height);
  }
  switch (anchor) {
    case 't':
      anim = {from: {width: box.width + 'px', height: '0px'}, to: {width: box.width + 'px', height: box.height + 'px'}};
      elStyle.bottom = '0px';
      break;
    case 'l':
      anim = {from: {width: '0px', height: box.height + 'px'}, to: {width: box.width + 'px', height: box.height + 'px'}};
      me.anchorAnimX(anchor);
      break;
    case 'r':
      anim = {from: {x: box.x + box.width, width: '0px', height: box.height + 'px'}, to: {x: box.x, width: box.width + 'px', height: box.height + 'px'}};
      me.anchorAnimX(anchor);
      break;
    case 'b':
      anim = {from: {y: box.y + box.height, width: box.width + 'px', height: '0px'}, to: {y: box.y, width: box.width + 'px', height: box.height + 'px'}};
      break;
    case 'tl':
      anim = {from: {x: box.x, y: box.y, width: '0px', height: '0px'}, to: {width: box.width + 'px', height: box.height + 'px'}};
      elStyle.bottom = '0px';
      me.anchorAnimX('l');
      break;
    case 'bl':
      anim = {from: {y: box.y + box.height, width: '0px', height: '0px'}, to: {y: box.y, width: box.width + 'px', height: box.height + 'px'}};
      me.anchorAnimX('l');
      break;
    case 'br':
      anim = {from: {x: box.x + box.width, y: box.y + box.height, width: '0px', height: '0px'}, to: {x: box.x, y: box.y, width: box.width + 'px', height: box.height + 'px'}};
      me.anchorAnimX('r');
      break;
    case 'tr':
      anim = {from: {x: box.x + box.width, width: '0px', height: '0px'}, to: {x: box.x, width: box.width + 'px', height: box.height + 'px'}};
      elStyle.bottom = '0px';
      me.anchorAnimX('r');
      break;
  }
  wrap.show();
  wrapAnim = Ext.apply({}, obj);
  delete wrapAnim.listeners;
  wrapAnim = new Ext.fx.Anim(Ext.applyIf(wrapAnim, {target: wrap, duration: 500, easing: 'ease-out', from: slideOut ? anim.to : anim.from, to: slideOut ? anim.from : anim.to}));
  wrapAnim.on('afteranimate', function() {
  var el = Ext.fly(dom, '_anim');
  el.setStyle(originalStyles);
  if (slideOut) 
  {
    if (obj.useDisplay) 
    {
      el.setDisplayed(false);
    } else {
      el.hide();
    }
  }
  if (wrap.dom) 
  {
    if (wrap.dom.parentNode) 
    {
      wrap.dom.parentNode.insertBefore(el.dom, wrap.dom);
    } else {
      wrapDomParentNode.appendChild(el.dom);
    }
    wrap.remove();
  }
  if (restoreScroll) 
  {
    restoreScroll();
  }
  animScope.end();
});
  if (listeners) 
  {
    wrapAnim.on(listeners);
  }
};
  me.animate({duration: obj.duration ? Math.max(obj.duration, 500) * 2 : 1000, listeners: {beforeanimate: beforeAnim}});
  return me;
}, slideOut: function(anchor, o) {
  return this.slideIn(anchor, o, true);
}, puff: function(obj) {
  var me = this, dom = me.dom, beforeAnim, box = me.getBox(), originalStyles = me.getStyles('width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index', 'font-size', 'opacity', true);
  obj = Ext.applyIf(obj || {}, {easing: 'ease-out', duration: 500, useDisplay: false});
  beforeAnim = function() {
  var el = Ext.fly(dom, '_anim');
  el.clearOpacity();
  el.show();
  this.to = {width: box.width * 2, height: box.height * 2, x: box.x - (box.width / 2), y: box.y - (box.height / 2), opacity: 0, fontSize: '200%'};
  this.on('afteranimate', function() {
  var el = Ext.fly(dom, '_anim');
  if (el) 
  {
    if (obj.useDisplay) 
    {
      el.setDisplayed(false);
    } else {
      el.hide();
    }
    el.setStyle(originalStyles);
    Ext.callback(obj.callback, obj.scope);
  }
});
};
  me.animate({duration: obj.duration, easing: obj.easing, listeners: {beforeanimate: {fn: beforeAnim}}});
  return me;
}, switchOff: function(obj) {
  var me = this, dom = me.dom, beforeAnim;
  obj = Ext.applyIf(obj || {}, {easing: 'ease-in', duration: 500, remove: false, useDisplay: false});
  beforeAnim = function() {
  var el = Ext.fly(dom, '_anim'), animScope = this, size = el.getSize(), xy = el.getXY(), keyframe, position;
  el.clearOpacity();
  el.clip();
  position = el.getPositioning();
  keyframe = new Ext.fx.Animator({target: dom, duration: obj.duration, easing: obj.easing, keyframes: {33: {opacity: 0.3}, 66: {height: 1, y: xy[1] + size.height / 2}, 100: {width: 1, x: xy[0] + size.width / 2}}});
  keyframe.on('afteranimate', function() {
  var el = Ext.fly(dom, '_anim');
  if (obj.useDisplay) 
  {
    el.setDisplayed(false);
  } else {
    el.hide();
  }
  el.clearOpacity();
  el.setPositioning(position);
  el.setSize(size);
  animScope.end();
});
};
  me.animate({duration: (Math.max(obj.duration, 500) * 2), listeners: {beforeanimate: {fn: beforeAnim}}, callback: obj.callback, scope: obj.scope});
  return me;
}, frame: function(color, count, obj) {
  var me = this, dom = me.dom, beforeAnim;
  color = color || '#C3DAF9';
  count = count || 1;
  obj = obj || {};
  beforeAnim = function() {
  var el = Ext.fly(dom, '_anim'), animScope = this, box, proxy, proxyAnim;
  el.show();
  box = el.getBox();
  proxy = Ext.getBody().createChild({role: 'presentation', id: el.dom.id + '-anim-proxy', style: {position: 'absolute', 'pointer-events': 'none', 'z-index': 35000, border: '0px solid ' + color}});
  proxyAnim = new Ext.fx.Anim({target: proxy, duration: obj.duration || 1000, iterations: count, from: {top: box.y, left: box.x, borderWidth: 0, opacity: 1, height: box.height, width: box.width}, to: {top: box.y - 20, left: box.x - 20, borderWidth: 10, opacity: 0, height: box.height + 40, width: box.width + 40}});
  proxyAnim.on('afteranimate', function() {
  proxy.remove();
  animScope.end();
});
};
  me.animate({duration: (Math.max(obj.duration, 500) * 2) || 2000, listeners: {beforeanimate: {fn: beforeAnim}}, callback: obj.callback, scope: obj.scope});
  return me;
}, ghost: function(anchor, obj) {
  var me = this, dom = me.dom, beforeAnim;
  anchor = anchor || "b";
  beforeAnim = function() {
  var el = Ext.fly(dom, '_anim'), width = el.getWidth(), height = el.getHeight(), xy = el.getXY(), position = el.getPositioning(), to = {opacity: 0};
  switch (anchor) {
    case 't':
      to.y = xy[1] - height;
      break;
    case 'l':
      to.x = xy[0] - width;
      break;
    case 'r':
      to.x = xy[0] + width;
      break;
    case 'b':
      to.y = xy[1] + height;
      break;
    case 'tl':
      to.x = xy[0] - width;
      to.y = xy[1] - height;
      break;
    case 'bl':
      to.x = xy[0] - width;
      to.y = xy[1] + height;
      break;
    case 'br':
      to.x = xy[0] + width;
      to.y = xy[1] + height;
      break;
    case 'tr':
      to.x = xy[0] + width;
      to.y = xy[1] - height;
      break;
  }
  this.to = to;
  this.on('afteranimate', function() {
  var el = Ext.fly(dom, '_anim');
  if (el) 
  {
    el.hide();
    el.clearOpacity();
    el.setPositioning(position);
  }
});
};
  me.animate(Ext.applyIf(obj || {}, {duration: 500, easing: 'ease-out', listeners: {beforeanimate: beforeAnim}}));
  return me;
}, highlight: function(color, o) {
  var me = this, dom = me.dom, from = {}, restore, to, attr, lns, event, fn;
  if (dom.tagName.match(me.tableTagRe)) 
  {
    return me.select('div').highlight(color, o);
  }
  o = o || {};
  lns = o.listeners || {};
  attr = o.attr || 'backgroundColor';
  from[attr] = color || 'ffff9c';
  if (!o.to) 
  {
    to = {};
    to[attr] = o.endColor || me.getColor(attr, 'ffffff', '');
  } else {
    to = o.to;
  }
  o.listeners = Ext.apply(Ext.apply({}, lns), {beforeanimate: function() {
  restore = dom.style[attr];
  var el = Ext.fly(dom, '_anim');
  el.clearOpacity();
  el.show();
  event = lns.beforeanimate;
  if (event) 
  {
    fn = event.fn || event;
    return fn.apply(event.scope || lns.scope || window, arguments);
  }
}, afteranimate: function() {
  if (dom) 
  {
    dom.style[attr] = restore;
  }
  event = lns.afteranimate;
  if (event) 
  {
    fn = event.fn || event;
    fn.apply(event.scope || lns.scope || window, arguments);
  }
}});
  me.animate(Ext.apply({}, o, {duration: 1000, easing: 'ease-in', from: from, to: to}));
  return me;
}, pause: function(ms) {
  var me = this;
  Ext.fx.Manager.setFxDefaults(me.id, {delay: ms});
  return me;
}, fadeIn: function(o) {
  var me = this, dom = me.dom;
  me.animate(Ext.apply({}, o, {opacity: 1, internalListeners: {beforeanimate: function(anim) {
  var el = Ext.fly(dom, '_anim');
  if (el.isStyle('display', 'none')) 
  {
    el.setDisplayed('');
  } else {
    el.show();
  }
}}}));
  return this;
}, fadeOut: function(o) {
  var me = this, dom = me.dom;
  o = Ext.apply({opacity: 0, internalListeners: {afteranimate: function(anim) {
  if (dom && anim.to.opacity === 0) 
  {
    var el = Ext.fly(dom, '_anim');
    if (o.useDisplay) 
    {
      el.setDisplayed(false);
    } else {
      el.hide();
    }
  }
}}}, o);
  me.animate(o);
  return me;
}, scale: function(w, h, o) {
  this.animate(Ext.apply({}, o, {width: w, height: h}));
  return this;
}, shift: function(config) {
  this.animate(config);
  return this;
}, anchorAnimX: function(anchor) {
  var xName = (anchor === 'l') ? 'right' : 'left';
  this.dom.style[xName] = '0px';
}});

Ext.define('Ext.dom.Element_dd', {override: 'Ext.dom.Element', initDD: function(group, config, overrides) {
  var dd = new Ext.dd.DD(Ext.id(this.dom), group, config);
  return Ext.apply(dd, overrides);
}, initDDProxy: function(group, config, overrides) {
  var dd = new Ext.dd.DDProxy(Ext.id(this.dom), group, config);
  return Ext.apply(dd, overrides);
}, initDDTarget: function(group, config, overrides) {
  var dd = new Ext.dd.DDTarget(Ext.id(this.dom), group, config);
  return Ext.apply(dd, overrides);
}});

Ext.define('Ext.dom.Element_fx', {override: 'Ext.dom.Element'}, function() {
  var Element = Ext.dom.Element, VISIBILITY = "visibility", DISPLAY = "display", NONE = "none", HIDDEN = 'hidden', VISIBLE = 'visible', OFFSETS = "offsets", ASCLASS = "asclass", NOSIZE = 'nosize', ORIGINALDISPLAY = 'originalDisplay', VISMODE = 'visibilityMode', ISVISIBLE = 'isVisible', OFFSETCLASS = Ext.baseCSSPrefix + 'hide-offsets', getDisplay = function(el) {
  var data = (el.$cache || el.getCache()).data, display = data[ORIGINALDISPLAY];
  if (display === undefined) 
  {
    data[ORIGINALDISPLAY] = display = '';
  }
  return display;
}, getVisMode = function(el) {
  var data = (el.$cache || el.getCache()).data, visMode = data[VISMODE];
  if (visMode === undefined) 
  {
    data[VISMODE] = visMode = Element.VISIBILITY;
  }
  return visMode;
};
  Element.override({originalDisplay: "", visibilityMode: 1, setVisible: function(visible, animate) {
  var me = this, dom = me.dom, visMode = getVisMode(me);
  if (typeof animate == 'string') 
  {
    switch (animate) {
      case DISPLAY:
        visMode = Element.DISPLAY;
        break;
      case VISIBILITY:
        visMode = Element.VISIBILITY;
        break;
      case OFFSETS:
        visMode = Element.OFFSETS;
        break;
      case NOSIZE:
      case ASCLASS:
        visMode = Element.ASCLASS;
        break;
    }
    me.setVisibilityMode(visMode);
    animate = false;
  }
  if (!animate || !me.anim) 
  {
    if (visMode == Element.DISPLAY) 
    {
      return me.setDisplayed(visible);
    } else if (visMode == Element.OFFSETS) 
    {
      me[visible ? 'removeCls' : 'addCls'](OFFSETCLASS);
    } else if (visMode == Element.VISIBILITY) 
    {
      me.fixDisplay();
      dom.style.visibility = visible ? '' : HIDDEN;
    } else if (visMode == Element.ASCLASS) 
    {
      me[visible ? 'removeCls' : 'addCls'](me.visibilityCls || Element.visibilityCls);
    }
  } else {
    if (visible) 
    {
      me.setOpacity(0.01);
      me.setVisible(true);
    }
    if (!Ext.isObject(animate)) 
    {
      animate = {duration: 350, easing: 'ease-in'};
    }
    me.animate(Ext.applyIf({callback: function() {
  if (!visible) 
  {
    Ext.fly(dom, '_internal').setVisible(false).setOpacity(1);
  }
}, to: {opacity: (visible) ? 1 : 0}}, animate));
  }
  (me.$cache || me.getCache()).data[ISVISIBLE] = visible;
  return me;
}, hasMetrics: function() {
  var visMode = getVisMode(this);
  return this.isVisible() || (visMode == Element.OFFSETS) || (visMode == Element.VISIBILITY);
}, toggle: function(animate) {
  var me = this;
  me.setVisible(!me.isVisible(), me.anim(animate));
  return me;
}, setDisplayed: function(value) {
  if (typeof value == "boolean") 
  {
    value = value ? getDisplay(this) : NONE;
  }
  this.setStyle(DISPLAY, value);
  return this;
}, fixDisplay: function() {
  var me = this;
  if (me.isStyle(DISPLAY, NONE)) 
  {
    me.setStyle(VISIBILITY, HIDDEN);
    me.setStyle(DISPLAY, getDisplay(me));
    if (me.isStyle(DISPLAY, NONE)) 
    {
      me.setStyle(DISPLAY, "block");
    }
  }
}, hide: function(animate) {
  if (typeof animate == 'string') 
  {
    this.setVisible(false, animate);
    return this;
  }
  this.setVisible(false, this.anim(animate));
  return this;
}, show: function(animate) {
  if (typeof animate == 'string') 
  {
    this.setVisible(true, animate);
    return this;
  }
  this.setVisible(true, this.anim(animate));
  return this;
}});
});

Ext.define('Ext.dom.Element_position', {override: 'Ext.dom.Element'}, function() {
  var flyInstance, Element = this, LEFT = "left", RIGHT = "right", TOP = "top", BOTTOM = "bottom", POSITION = "position", STATIC = "static", RELATIVE = "relative", ZINDEX = "z-index", BODY = 'BODY', PADDING = 'padding', BORDER = 'border', SLEFT = '-left', SRIGHT = '-right', STOP = '-top', SBOTTOM = '-bottom', SWIDTH = '-width', borders = {l: BORDER + SLEFT + SWIDTH, r: BORDER + SRIGHT + SWIDTH, t: BORDER + STOP + SWIDTH, b: BORDER + SBOTTOM + SWIDTH}, paddings = {l: PADDING + SLEFT, r: PADDING + SRIGHT, t: PADDING + STOP, b: PADDING + SBOTTOM}, paddingsTLRB = [paddings.l, paddings.r, paddings.t, paddings.b], bordersTLRB = [borders.l, borders.r, borders.t, borders.b], round = Math.round, doc = document, fly = function(el) {
  if (!flyInstance) 
  {
    flyInstance = new Ext.Element.Fly();
  }
  flyInstance.attach(el);
  return flyInstance;
};
  Element.override({pxRe: /^\d+(?:\.\d*)?px$/i, inheritableStatics: {getX: function(el) {
  return Element.getXY(el)[0];
}, getXY: function(el) {
  var bd = doc.body, docEl = doc.documentElement, leftBorder = 0, topBorder = 0, ret = [0, 0], box, scroll;
  el = Ext.getDom(el);
  if (el != doc && el != bd) 
  {
    if (Ext.isIE) 
    {
      try {
        box = el.getBoundingClientRect();
        topBorder = docEl.clientTop || bd.clientTop;
        leftBorder = docEl.clientLeft || bd.clientLeft;
      }      catch (ex) {
  box = {left: 0, top: 0};
}
    } else {
      box = el.getBoundingClientRect();
    }
    scroll = fly(doc).getScroll();
    ret = [round(box.left + scroll.left - leftBorder), round(box.top + scroll.top - topBorder)];
  }
  return ret;
}, getY: function(el) {
  return Element.getXY(el)[1];
}, setX: function(el, x) {
  Element.setXY(el, [x, false]);
}, setXY: function(el, xy) {
  (el = Ext.fly(el, '_setXY')).position();
  var pts = el.translatePoints(xy), style = el.dom.style, pos;
  style.right = 'auto';
  for (pos in pts) 
    {
      if (!isNaN(pts[pos])) 
      {
        style[pos] = pts[pos] + "px";
      }
    }
}, setY: function(el, y) {
  Element.setXY(el, [false, y]);
}}, center: function(centerIn) {
  return this.alignTo(centerIn || doc, 'c-c');
}, clearPositioning: function(value) {
  value = value || '';
  return this.setStyle({left: value, right: value, top: value, bottom: value, 'z-index': '', position: STATIC});
}, getAnchorToXY: function(el, anchor, local, mySize) {
  return el.getAnchorXY(anchor, local, mySize);
}, getBottom: function(local) {
  return (local ? this.getLocalY() : this.getY()) + this.getHeight();
}, getBorderPadding: function() {
  var paddingWidth = this.getStyle(paddingsTLRB), bordersWidth = this.getStyle(bordersTLRB);
  return {beforeX: (parseFloat(bordersWidth[borders.l]) || 0) + (parseFloat(paddingWidth[paddings.l]) || 0), afterX: (parseFloat(bordersWidth[borders.r]) || 0) + (parseFloat(paddingWidth[paddings.r]) || 0), beforeY: (parseFloat(bordersWidth[borders.t]) || 0) + (parseFloat(paddingWidth[paddings.t]) || 0), afterY: (parseFloat(bordersWidth[borders.b]) || 0) + (parseFloat(paddingWidth[paddings.b]) || 0)};
}, getCenterXY: function() {
  return this.getAlignToXY(doc, 'c-c');
}, getLeft: function(local) {
  return local ? this.getLocalX() : this.getX();
}, getLocalX: function() {
  var me = this, offsetParent = me.dom.offsetParent, x = me.getStyle('left');
  if (!x || x === 'auto') 
  {
    x = 0;
  } else if (me.pxRe.test(x)) 
  {
    x = parseFloat(x);
  } else {
    x = me.getX();
    if (offsetParent) 
    {
      x -= Element.getX(offsetParent);
    }
  }
  return x;
}, getLocalXY: function() {
  var me = this, offsetParent = me.dom.offsetParent, style = me.getStyle(['left', 'top']), x = style.left, y = style.top;
  if (!x || x === 'auto') 
  {
    x = 0;
  } else if (me.pxRe.test(x)) 
  {
    x = parseFloat(x);
  } else {
    x = me.getX();
    if (offsetParent) 
    {
      x -= Element.getX(offsetParent);
    }
  }
  if (!y || y === 'auto') 
  {
    y = 0;
  } else if (me.pxRe.test(y)) 
  {
    y = parseFloat(y);
  } else {
    y = me.getY();
    if (offsetParent) 
    {
      y -= Element.getY(offsetParent);
    }
  }
  return [x, y];
}, getLocalY: function() {
  var me = this, offsetParent = me.dom.offsetParent, y = me.getStyle('top');
  if (!y || y === 'auto') 
  {
    y = 0;
  } else if (me.pxRe.test(y)) 
  {
    y = parseFloat(y);
  } else {
    y = me.getY();
    if (offsetParent) 
    {
      y -= Element.getY(offsetParent);
    }
  }
  return y;
}, getPageBox: function(getRegion) {
  var me = this, dom = me.dom, isDoc = dom.nodeName == BODY, w = isDoc ? Ext.Element.getViewWidth() : dom.offsetWidth, h = isDoc ? Ext.Element.getViewHeight() : dom.offsetHeight, xy = me.getXY(), t = xy[1], r = xy[0] + w, b = xy[1] + h, l = xy[0];
  if (getRegion) 
  {
    return new Ext.util.Region(t, r, b, l);
  } else {
    return {left: l, top: t, width: w, height: h, right: r, bottom: b};
  }
}, getPositioning: function(autoPx) {
  var styles = this.getStyle(['left', 'top', 'position', 'z-index']), dom = this.dom;
  if (autoPx) 
  {
    if (styles.left === 'auto') 
    {
      styles.left = dom.offsetLeft + 'px';
    }
    if (styles.top === 'auto') 
    {
      styles.top = dom.offsetTop + 'px';
    }
  }
  return styles;
}, getRight: function(local) {
  return (local ? this.getLocalX() : this.getX()) + this.getWidth();
}, getTop: function(local) {
  return local ? this.getLocalY() : this.getY();
}, getX: function() {
  return Element.getX(this.dom);
}, getXY: function() {
  return Element.getXY(this.dom);
}, getY: function() {
  return Element.getY(this.dom);
}, moveTo: function(x, y, animate) {
  return this.setXY([x, y], animate);
}, position: function(pos, zIndex, x, y) {
  var me = this;
  if (!pos && me.isStyle(POSITION, STATIC)) 
  {
    me.setStyle(POSITION, RELATIVE);
  } else if (pos) 
  {
    me.setStyle(POSITION, pos);
  }
  if (zIndex) 
  {
    me.setStyle(ZINDEX, zIndex);
  }
  if (x || y) 
  {
    me.setXY([x || false, y || false]);
  }
}, setBottom: function(bottom) {
  this.dom.style[BOTTOM] = this.addUnits(bottom);
  return this;
}, setBounds: function(x, y, width, height, animate) {
  return this.setBox({x: x, y: y, width: width, height: height}, animate);
}, setLeft: function(left) {
  this.dom.style[LEFT] = this.addUnits(left);
  return this;
}, setLeftTop: function(left, top) {
  var me = this, style = me.dom.style;
  style.left = me.addUnits(left);
  style.top = me.addUnits(top);
  return me;
}, setLocalX: function(x) {
  var style = this.dom.style;
  style.right = 'auto';
  style.left = (x === null) ? 'auto' : x + 'px';
}, setLocalXY: function(x, y) {
  var style = this.dom.style;
  style.right = 'auto';
  if (x && x.length) 
  {
    y = x[1];
    x = x[0];
  }
  if (x === null) 
  {
    style.left = 'auto';
  } else if (x !== undefined) 
  {
    style.left = x + 'px';
  }
  if (y === null) 
  {
    style.top = 'auto';
  } else if (y !== undefined) 
  {
    style.top = y + 'px';
  }
}, setLocalY: function(y) {
  this.dom.style.top = (y === null) ? 'auto' : y + 'px';
}, setLocation: function(x, y, animate) {
  return this.setXY([x, y], animate);
}, setPositioning: function(pc) {
  return this.setStyle(pc);
}, setRight: function(right) {
  this.dom.style[RIGHT] = this.addUnits(right);
  return this;
}, setTop: function(top) {
  this.dom.style[TOP] = this.addUnits(top);
  return this;
}, setX: function(x, animate) {
  return this.setXY([x, this.getY()], animate);
}, setXY: function(xy, animate) {
  var me = this;
  if (!animate || !me.anim) 
  {
    Element.setXY(me.dom, xy);
  } else {
    if (!Ext.isObject(animate)) 
    {
      animate = {};
    }
    me.animate(Ext.applyIf({to: {x: xy[0], y: xy[1]}}, animate));
  }
  return this;
}, setY: function(y, animate) {
  return this.setXY([this.getX(), y], animate);
}});
  Element.getTrueXY = Element.getXY;
});

Ext.define('Ext.dom.Element_scroll', {override: 'Ext.dom.Element', isScrollable: function() {
  var dom = this.dom;
  return dom.scrollHeight > dom.clientHeight || dom.scrollWidth > dom.clientWidth;
}, getScroll: function() {
  var me = this, dom = me.dom, doc = document, body = doc.body, docElement = doc.documentElement, left, top;
  if (dom === doc || dom === body) 
  {
    left = docElement.scrollLeft || (body ? body.scrollLeft : 0);
    top = docElement.scrollTop || (body ? body.scrollTop : 0);
  } else {
    left = dom.scrollLeft;
    top = dom.scrollTop;
  }
  return {left: left, top: top};
}, getScrollLeft: function() {
  var dom = this.dom, doc = document;
  if (dom === doc || dom === doc.body) 
  {
    return this.getScroll().left;
  } else {
    return dom.scrollLeft;
  }
}, getScrollTop: function() {
  var dom = this.dom, doc = document;
  if (dom === doc || dom === doc.body) 
  {
    return this.getScroll().top;
  } else {
    return dom.scrollTop;
  }
}, setScrollLeft: function(left) {
  this.dom.scrollLeft = left;
  return this;
}, setScrollTop: function(top) {
  this.dom.scrollTop = top;
  return this;
}, scrollBy: function(deltaX, deltaY, animate) {
  var me = this, dom = me.dom;
  if (deltaX.length) 
  {
    animate = deltaY;
    deltaY = deltaX[1];
    deltaX = deltaX[0];
  } else if (typeof deltaX != 'number') 
  {
    animate = deltaY;
    deltaY = deltaX.y;
    deltaX = deltaX.x;
  }
  if (deltaX) 
  {
    me.scrollTo('left', me.constrainScrollLeft(dom.scrollLeft + deltaX), animate);
  }
  if (deltaY) 
  {
    me.scrollTo('top', me.constrainScrollTop(dom.scrollTop + deltaY), animate);
  }
  return me;
}, scrollTo: function(side, value, animate) {
  var top = /top/i.test(side), me = this, prop = top ? 'scrollTop' : 'scrollLeft', dom = me.dom, animCfg;
  if (!animate || !me.anim) 
  {
    dom[prop] = value;
    dom[prop] = value;
  } else {
    animCfg = {to: {}};
    animCfg.to[prop] = value;
    if (Ext.isObject(animate)) 
    {
      Ext.applyIf(animCfg, animate);
    }
    me.animate(animCfg);
  }
  return me;
}, scrollIntoView: function(container, hscroll, animate, highlight) {
  var me = this, dom = me.dom, offsets = me.getOffsetsTo(container = Ext.getDom(container) || Ext.getBody().dom), left = offsets[0] + container.scrollLeft, top = offsets[1] + container.scrollTop, bottom = top + dom.offsetHeight, right = left + dom.offsetWidth, ctClientHeight = container.clientHeight, ctScrollTop = parseInt(container.scrollTop, 10), ctScrollLeft = parseInt(container.scrollLeft, 10), ctBottom = ctScrollTop + ctClientHeight, ctRight = ctScrollLeft + container.clientWidth, newPos;
  if (highlight) 
  {
    if (animate) 
    {
      animate = Ext.apply({listeners: {afteranimate: function() {
  me.scrollChildFly.attach(dom).highlight();
}}}, animate);
    } else {
      me.scrollChildFly.attach(dom).highlight();
    }
  }
  if (dom.offsetHeight > ctClientHeight || top < ctScrollTop) 
  {
    newPos = top;
  } else if (bottom > ctBottom) 
  {
    newPos = bottom - ctClientHeight;
  }
  if (newPos != null) 
  {
    me.scrollChildFly.attach(container).scrollTo('top', newPos, animate);
  }
  if (hscroll !== false) 
  {
    newPos = null;
    if (dom.offsetWidth > container.clientWidth || left < ctScrollLeft) 
    {
      newPos = left;
    } else if (right > ctRight) 
    {
      newPos = right - container.clientWidth;
    }
    if (newPos != null) 
    {
      me.scrollChildFly.attach(container).scrollTo('left', newPos, animate);
    }
  }
  return me;
}, scrollChildIntoView: function(child, hscroll) {
  this.scrollChildFly.attach(Ext.getDom(child)).scrollIntoView(this, hscroll);
}, scroll: function(direction, distance, animate) {
  if (!this.isScrollable()) 
  {
    return false;
  }
  direction = direction.charAt(0);
  var me = this, dom = me.dom, side = direction === 'r' || direction === 'l' ? 'left' : 'top', scrolled = false, currentScroll, constrainedScroll;
  if (direction === 'l' || direction === 't' || direction === 'u') 
  {
    distance = -distance;
  }
  if (side === 'left') 
  {
    currentScroll = dom.scrollLeft;
    constrainedScroll = me.constrainScrollLeft(currentScroll + distance);
  } else {
    currentScroll = dom.scrollTop;
    constrainedScroll = me.constrainScrollTop(currentScroll + distance);
  }
  if (constrainedScroll !== currentScroll) 
  {
    this.scrollTo(side, constrainedScroll, animate);
    scrolled = true;
  }
  return scrolled;
}, constrainScrollLeft: function(left) {
  var dom = this.dom;
  return Math.max(Math.min(left, dom.scrollWidth - dom.clientWidth), 0);
}, constrainScrollTop: function(top) {
  var dom = this.dom;
  return Math.max(Math.min(top, dom.scrollHeight - dom.clientHeight), 0);
}}, function() {
  this.prototype.scrollChildFly = new this.Fly();
  this.prototype.scrolltoFly = new this.Fly();
});

Ext.define('Ext.dom.Element_style', {override: 'Ext.dom.Element'}, function() {
  var Element = this, view = document.defaultView, adjustDirect2DTableRe = /table-row|table-.*-group/, INTERNAL = '_internal', HIDDEN = 'hidden', HEIGHT = 'height', WIDTH = 'width', ISCLIPPED = 'isClipped', OVERFLOW = 'overflow', OVERFLOWX = 'overflow-x', OVERFLOWY = 'overflow-y', ORIGINALCLIP = 'originalClip', DOCORBODYRE = /#document|body/i, styleHooks, verticalStyleHooks90, verticalStyleHooks270, edges, k, edge, borderWidth;
  if (!view || !view.getComputedStyle) 
  {
    Element.prototype.getStyle = function(property, inline) {
  var me = this, dom = me.dom, multiple = typeof property != 'string', hooks = me.styleHooks, prop = property, props = prop, len = 1, isInline = inline, camel, domStyle, values, hook, out, style, i;
  if (multiple) 
  {
    values = {};
    prop = props[0];
    i = 0;
    if (!(len = props.length)) 
    {
      return values;
    }
  }
  if (!dom || dom.documentElement) 
  {
    return values || '';
  }
  domStyle = dom.style;
  if (inline) 
  {
    style = domStyle;
  } else {
    style = dom.currentStyle;
    if (!style) 
    {
      isInline = true;
      style = domStyle;
    }
  }
  do {
    hook = hooks[prop];
    if (!hook) 
    {
      hooks[prop] = hook = {name: Element.normalize(prop)};
    }
    if (hook.get) 
    {
      out = hook.get(dom, me, isInline, style);
    } else {
      camel = hook.name;
      if (hook.canThrow) 
      {
        try {
          out = style[camel];
        }        catch (e) {
  out = '';
}
      } else {
        out = style ? style[camel] : '';
      }
    }
    if (!multiple) 
    {
      return out;
    }
    values[prop] = out;
    prop = props[++i];
  } while (i < len);
  return values;
};
  }
  Element.override({getHeight: function(contentHeight, preciseHeight) {
  var me = this, hidden = me.isStyle('display', 'none'), height, floating;
  if (hidden) 
  {
    return 0;
  }
  height = me.dom.offsetHeight;
  if (Ext.supports.Direct2DBug) 
  {
    floating = me.adjustDirect2DDimension(HEIGHT);
    if (preciseHeight) 
    {
      height += floating;
    } else if (floating > 0 && floating < 0.5) 
    {
      height++;
    }
  }
  if (contentHeight) 
  {
    height -= me.getBorderWidth("tb") + me.getPadding("tb");
  }
  return (height < 0) ? 0 : height;
}, getWidth: function(contentWidth, preciseWidth) {
  var me = this, dom = me.dom, hidden = me.isStyle('display', 'none'), rect, width, floating;
  if (hidden) 
  {
    return 0;
  }
  if (Ext.supports.BoundingClientRect) 
  {
    rect = dom.getBoundingClientRect();
    width = (me.vertical && !Ext.isIE9 && !Ext.supports.RotatedBoundingClientRect) ? (rect.bottom - rect.top) : (rect.right - rect.left);
    width = preciseWidth ? width : Math.ceil(width);
  } else {
    width = dom.offsetWidth;
  }
  if (Ext.supports.Direct2DBug && !me.vertical) 
  {
    floating = me.adjustDirect2DDimension(WIDTH);
    if (preciseWidth) 
    {
      width += floating;
    } else if (floating > 0 && floating < 0.5) 
    {
      width++;
    }
  }
  if (contentWidth) 
  {
    width -= me.getBorderWidth("lr") + me.getPadding("lr");
  }
  return (width < 0) ? 0 : width;
}, setWidth: function(width, animate) {
  var me = this;
  width = me.adjustWidth(width);
  if (!animate || !me.anim) 
  {
    me.dom.style.width = me.addUnits(width);
  } else {
    if (!Ext.isObject(animate)) 
    {
      animate = {};
    }
    me.animate(Ext.applyIf({to: {width: width}}, animate));
  }
  return me;
}, setHeight: function(height, animate) {
  var me = this;
  height = me.adjustHeight(height);
  if (!animate || !me.anim) 
  {
    me.dom.style.height = me.addUnits(height);
  } else {
    if (!Ext.isObject(animate)) 
    {
      animate = {};
    }
    me.animate(Ext.applyIf({to: {height: height}}, animate));
  }
  return me;
}, applyStyles: function(style) {
  Ext.DomHelper.applyStyles(this.dom, style);
  return this;
}, setSize: function(width, height, animate) {
  var me = this;
  if (Ext.isObject(width)) 
  {
    animate = height;
    height = width.height;
    width = width.width;
  }
  width = me.adjustWidth(width);
  height = me.adjustHeight(height);
  if (!animate || !me.anim) 
  {
    me.dom.style.width = me.addUnits(width);
    me.dom.style.height = me.addUnits(height);
  } else {
    if (animate === true) 
    {
      animate = {};
    }
    me.animate(Ext.applyIf({to: {width: width, height: height}}, animate));
  }
  return me;
}, getViewSize: function() {
  var me = this, dom = me.dom, isDoc = DOCORBODYRE.test(dom.nodeName), ret;
  if (isDoc) 
  {
    ret = {width: Element.getViewWidth(), height: Element.getViewHeight()};
  } else {
    ret = {width: dom.clientWidth, height: dom.clientHeight};
  }
  return ret;
}, getSize: function(contentSize) {
  return {width: this.getWidth(contentSize), height: this.getHeight(contentSize)};
}, adjustWidth: function(width) {
  var me = this, isNum = (typeof width == 'number');
  if (isNum && me.autoBoxAdjust && !me.isBorderBox()) 
  {
    width -= (me.getBorderWidth("lr") + me.getPadding("lr"));
  }
  return (isNum && width < 0) ? 0 : width;
}, adjustHeight: function(height) {
  var me = this, isNum = (typeof height == "number");
  if (isNum && me.autoBoxAdjust && !me.isBorderBox()) 
  {
    height -= (me.getBorderWidth("tb") + me.getPadding("tb"));
  }
  return (isNum && height < 0) ? 0 : height;
}, getColor: function(attr, defaultValue, prefix) {
  var v = this.getStyle(attr), color = prefix || prefix === '' ? prefix : '#', h, len, i = 0;
  if (!v || (/transparent|inherit/.test(v))) 
  {
    return defaultValue;
  }
  if (/^r/.test(v)) 
  {
    v = v.slice(4, v.length - 1).split(',');
    len = v.length;
    for (; i < len; i++) 
      {
        h = parseInt(v[i], 10);
        color += (h < 16 ? '0' : '') + h.toString(16);
      }
  } else {
    v = v.replace('#', '');
    color += v.length == 3 ? v.replace(/^(\w)(\w)(\w)$/, '$1$1$2$2$3$3') : v;
  }
  return (color.length > 5 ? color.toLowerCase() : defaultValue);
}, setOpacity: function(opacity, animate) {
  var me = this;
  if (!me.dom) 
  {
    return me;
  }
  if (!animate || !me.anim) 
  {
    me.setStyle('opacity', opacity);
  } else {
    if (typeof animate != 'object') 
    {
      animate = {duration: 350, easing: 'ease-in'};
    }
    me.animate(Ext.applyIf({to: {opacity: opacity}}, animate));
  }
  return me;
}, clearOpacity: function() {
  return this.setOpacity('');
}, adjustDirect2DDimension: function(dimension) {
  var me = this, dom = me.dom, display = me.getStyle('display'), inlineDisplay = dom.style.display, inlinePosition = dom.style.position, originIndex = dimension === WIDTH ? 0 : 1, currentStyle = dom.currentStyle, floating;
  if (display === 'inline') 
  {
    dom.style.display = 'inline-block';
  }
  dom.style.position = display.match(adjustDirect2DTableRe) ? 'absolute' : 'static';
  floating = (parseFloat(currentStyle[dimension]) || parseFloat(currentStyle.msTransformOrigin.split(' ')[originIndex]) * 2) % 1;
  dom.style.position = inlinePosition;
  if (display === 'inline') 
  {
    dom.style.display = inlineDisplay;
  }
  return floating;
}, clip: function() {
  var me = this, data = (me.$cache || me.getCache()).data, style;
  if (!data[ISCLIPPED]) 
  {
    data[ISCLIPPED] = true;
    style = me.getStyle([OVERFLOW, OVERFLOWX, OVERFLOWY]);
    data[ORIGINALCLIP] = {o: style[OVERFLOW], x: style[OVERFLOWX], y: style[OVERFLOWY]};
    me.setStyle(OVERFLOW, HIDDEN);
    me.setStyle(OVERFLOWX, HIDDEN);
    me.setStyle(OVERFLOWY, HIDDEN);
  }
  return me;
}, unclip: function() {
  var me = this, data = (me.$cache || me.getCache()).data, clip;
  if (data[ISCLIPPED]) 
  {
    data[ISCLIPPED] = false;
    clip = data[ORIGINALCLIP];
    if (clip.o) 
    {
      me.setStyle(OVERFLOW, clip.o);
    }
    if (clip.x) 
    {
      me.setStyle(OVERFLOWX, clip.x);
    }
    if (clip.y) 
    {
      me.setStyle(OVERFLOWY, clip.y);
    }
  }
  return me;
}, boxWrap: function(cls) {
  cls = cls || Ext.baseCSSPrefix + 'box';
  var el = Ext.get(this.insertHtml("beforeBegin", "<div class='" + cls + "' role='presentation'>" + Ext.String.format(Element.boxMarkup, cls) + "</div>"));
  Ext.DomQuery.selectNode('.' + cls + '-mc', el.dom).appendChild(this.dom);
  return el;
}, getComputedHeight: function() {
  var me = this, h = Math.max(me.dom.offsetHeight, me.dom.clientHeight);
  if (!h) 
  {
    h = parseFloat(me.getStyle(HEIGHT)) || 0;
    if (!me.isBorderBox()) 
    {
      h += me.getFrameWidth('tb');
    }
  }
  return h;
}, getComputedWidth: function() {
  var me = this, w = Math.max(me.dom.offsetWidth, me.dom.clientWidth);
  if (!w) 
  {
    w = parseFloat(me.getStyle(WIDTH)) || 0;
    if (!me.isBorderBox()) 
    {
      w += me.getFrameWidth('lr');
    }
  }
  return w;
}, getFrameWidth: function(sides, onlyContentBox) {
  return (onlyContentBox && this.isBorderBox()) ? 0 : (this.getPadding(sides) + this.getBorderWidth(sides));
}, addClsOnOver: function(className, testFn, scope) {
  var me = this, dom = me.dom, hasTest = Ext.isFunction(testFn);
  me.hover(function() {
  if (hasTest && testFn.call(scope || me, me) === false) 
  {
    return;
  }
  Ext.fly(dom, INTERNAL).addCls(className);
}, function() {
  Ext.fly(dom, INTERNAL).removeCls(className);
});
  return me;
}, addClsOnFocus: function(className, testFn, scope) {
  var me = this, dom = me.dom, hasTest = Ext.isFunction(testFn);
  me.on("focus", function() {
  if (hasTest && testFn.call(scope || me, me) === false) 
  {
    return false;
  }
  Ext.fly(dom, INTERNAL).addCls(className);
});
  me.on("blur", function() {
  Ext.fly(dom, INTERNAL).removeCls(className);
});
  return me;
}, addClsOnClick: function(className, testFn, scope) {
  var me = this, dom = me.dom, hasTest = Ext.isFunction(testFn);
  me.on("mousedown", function() {
  if (hasTest && testFn.call(scope || me, me) === false) 
  {
    return false;
  }
  Ext.fly(dom, INTERNAL).addCls(className);
  var d = Ext.getDoc(), fn = function() {
  Ext.fly(dom, INTERNAL).removeCls(className);
  d.removeListener("mouseup", fn);
};
  d.on("mouseup", fn);
});
  return me;
}, getStyleSize: function() {
  var me = this, d = this.dom, isDoc = DOCORBODYRE.test(d.nodeName), s, w, h;
  if (isDoc) 
  {
    return {width: Element.getViewWidth(), height: Element.getViewHeight()};
  }
  s = me.getStyle([HEIGHT, WIDTH], true);
  if (s.width && s.width != 'auto') 
  {
    w = parseFloat(s.width);
    if (me.isBorderBox()) 
    {
      w -= me.getFrameWidth('lr');
    }
  }
  if (s.height && s.height != 'auto') 
  {
    h = parseFloat(s.height);
    if (me.isBorderBox()) 
    {
      h -= me.getFrameWidth('tb');
    }
  }
  return {width: w || me.getWidth(true), height: h || me.getHeight(true)};
}, statics: {selectableCls: Ext.baseCSSPrefix + 'selectable', unselectableCls: Ext.baseCSSPrefix + 'unselectable'}, selectable: function() {
  var me = this;
  me.dom.unselectable = '';
  me.removeCls(Element.unselectableCls);
  me.addCls(Element.selectableCls);
  return me;
}, unselectable: function() {
  var me = this;
  if (Ext.isOpera) 
  {
    me.dom.unselectable = 'on';
  }
  me.removeCls(Element.selectableCls);
  me.addCls(Element.unselectableCls);
  return me;
}, setVertical: function(angle, cls) {
  var me = this, proto = Element.prototype, hooks;
  me.vertical = true;
  if (cls) 
  {
    me.addCls(me.verticalCls = cls);
  }
  me.setWidth = proto.setHeight;
  me.setHeight = proto.setWidth;
  if (!Ext.isIE9m) 
  {
    me.getWidth = proto.getHeight;
    me.getHeight = proto.getWidth;
  }
  me.styleHooks = (angle === 270) ? Element.prototype.verticalStyleHooks270 : Element.prototype.verticalStyleHooks90;
}, setHorizontal: function() {
  var me = this, cls = me.verticalCls;
  delete me.vertical;
  if (cls) 
  {
    delete me.verticalCls;
    me.removeCls(cls);
  }
  delete me.setWidth;
  delete me.setHeight;
  if (!Ext.isIE9m) 
  {
    delete me.getWidth;
    delete me.getHeight;
  }
  delete me.styleHooks;
}});
  Element.prototype.styleHooks = styleHooks = Ext.dom.AbstractElement.prototype.styleHooks;
  Element.prototype.verticalStyleHooks90 = verticalStyleHooks90 = Ext.Object.chain(Element.prototype.styleHooks);
  Element.prototype.verticalStyleHooks270 = verticalStyleHooks270 = Ext.Object.chain(Element.prototype.styleHooks);
  verticalStyleHooks90.width = {name: 'height'};
  verticalStyleHooks90.height = {name: 'width'};
  verticalStyleHooks90['margin-top'] = {name: 'marginLeft'};
  verticalStyleHooks90['margin-right'] = {name: 'marginTop'};
  verticalStyleHooks90['margin-bottom'] = {name: 'marginRight'};
  verticalStyleHooks90['margin-left'] = {name: 'marginBottom'};
  verticalStyleHooks90['padding-top'] = {name: 'paddingLeft'};
  verticalStyleHooks90['padding-right'] = {name: 'paddingTop'};
  verticalStyleHooks90['padding-bottom'] = {name: 'paddingRight'};
  verticalStyleHooks90['padding-left'] = {name: 'paddingBottom'};
  verticalStyleHooks90['border-top'] = {name: 'borderLeft'};
  verticalStyleHooks90['border-right'] = {name: 'borderTop'};
  verticalStyleHooks90['border-bottom'] = {name: 'borderRight'};
  verticalStyleHooks90['border-left'] = {name: 'borderBottom'};
  verticalStyleHooks270.width = {name: 'height'};
  verticalStyleHooks270.height = {name: 'width'};
  verticalStyleHooks270['margin-top'] = {name: 'marginRight'};
  verticalStyleHooks270['margin-right'] = {name: 'marginBottom'};
  verticalStyleHooks270['margin-bottom'] = {name: 'marginLeft'};
  verticalStyleHooks270['margin-left'] = {name: 'marginTop'};
  verticalStyleHooks270['padding-top'] = {name: 'paddingRight'};
  verticalStyleHooks270['padding-right'] = {name: 'paddingBottom'};
  verticalStyleHooks270['padding-bottom'] = {name: 'paddingLeft'};
  verticalStyleHooks270['padding-left'] = {name: 'paddingTop'};
  verticalStyleHooks270['border-top'] = {name: 'borderRight'};
  verticalStyleHooks270['border-right'] = {name: 'borderBottom'};
  verticalStyleHooks270['border-bottom'] = {name: 'borderLeft'};
  verticalStyleHooks270['border-left'] = {name: 'borderTop'};
  if (Ext.isIE7m) 
  {
    styleHooks.fontSize = styleHooks['font-size'] = {name: 'fontSize', canThrow: true};
    styleHooks.fontStyle = styleHooks['font-style'] = {name: 'fontStyle', canThrow: true};
    styleHooks.fontFamily = styleHooks['font-family'] = {name: 'fontFamily', canThrow: true};
  }
  if (Ext.isIEQuirks || Ext.isIE && Ext.ieVersion <= 8) 
  {
    function getBorderWidth(dom, el, inline, style) {
      if (style[this.styleName] == 'none') 
      {
        return '0px';
      }
      return style[this.name];
    }    edges = ['Top', 'Right', 'Bottom', 'Left'];
    k = edges.length;
    while (k--) 
      {
        edge = edges[k];
        borderWidth = 'border' + edge + 'Width';
        styleHooks['border-' + edge.toLowerCase() + '-width'] = styleHooks[borderWidth] = {name: borderWidth, styleName: 'border' + edge + 'Style', get: getBorderWidth};
      }
  }
  Ext.getDoc().on('selectstart', function(ev, dom) {
  var doc = document.documentElement, selectableCls = Element.selectableCls, unselectableCls = Element.unselectableCls, tagName = dom && dom.tagName;
  tagName = tagName && tagName.toLowerCase();
  if (tagName === 'input' || tagName === 'textarea') 
  {
    return;
  }
  while (dom && dom.nodeType === 1 && dom !== doc) 
    {
      var el = Ext.fly(dom);
      if (el.hasCls(selectableCls)) 
      {
        return;
      }
      if (el.hasCls(unselectableCls)) 
      {
        ev.stopEvent();
        return;
      }
      dom = dom.parentNode;
    }
});
});
Ext.onReady(function() {
  var opacityRe = /alpha\(opacity=(.*)\)/i, trimRe = /^\s+|\s+$/g, hooks = Ext.dom.Element.prototype.styleHooks;
  hooks.opacity = {name: 'opacity', afterSet: function(dom, value, el) {
  if (el.isLayer) 
  {
    el.onOpacitySet(value);
  }
}};
  if (!Ext.supports.Opacity && Ext.isIE) 
  {
    Ext.apply(hooks.opacity, {get: function(dom) {
  var filter = dom.style.filter, match, opacity;
  if (filter.match) 
  {
    match = filter.match(opacityRe);
    if (match) 
    {
      opacity = parseFloat(match[1]);
      if (!isNaN(opacity)) 
      {
        return opacity ? opacity / 100 : 0;
      }
    }
  }
  return 1;
}, set: function(dom, value) {
  var style = dom.style, val = style.filter.replace(opacityRe, '').replace(trimRe, '');
  style.zoom = 1;
  if (typeof (value) == 'number' && value >= 0 && value < 1) 
  {
    value *= 100;
    style.filter = val + (val.length ? ' ' : '') + 'alpha(opacity=' + value + ')';
  } else {
    style.filter = val;
  }
}});
  }
});

(Ext.cmd.derive('Ext.util.Positionable', Ext.Base, {_positionTopLeft: ['position', 'top', 'left'], _alignRe: /^([a-z]+)-([a-z]+)(\?)?$/, afterSetPosition: Ext.emptyFn, adjustForConstraints: function(xy, parent) {
  var vector = this.getConstrainVector(parent, xy);
  if (vector) 
  {
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, alignTo: function(element, position, offsets, animate) {
  var me = this, el = me.el;
  return me.setXY(me.getAlignToXY(element, position, offsets), el.anim && !!animate ? el.anim(animate) : false);
}, anchorTo: function(anchorToEl, alignment, offsets, animate, monitorScroll, callback) {
  var me = this, scroll = !Ext.isEmpty(monitorScroll), action = function() {
  me.alignTo(anchorToEl, alignment, offsets, animate);
  Ext.callback(callback, me);
}, anchor = me.getAnchor();
  me.removeAnchor();
  Ext.apply(anchor, {fn: action, scroll: scroll});
  Ext.EventManager.onWindowResize(action, null);
  if (scroll) 
  {
    Ext.EventManager.on(window, 'scroll', action, null, {buffer: !isNaN(monitorScroll) ? monitorScroll : 50});
  }
  action();
  return me;
}, calculateAnchorXY: function(anchor, extraX, extraY, mySize) {
  var me = this, el = me.el, doc = document, isViewport = el.dom == doc.body || el.dom == doc, round = Math.round, xy, myWidth, myHeight;
  anchor = (anchor || "tl").toLowerCase();
  mySize = mySize || {};
  myWidth = mySize.width || (isViewport ? Ext.Element.getViewWidth() : me.getWidth());
  myHeight = mySize.height || (isViewport ? Ext.Element.getViewHeight() : me.getHeight());
  switch (anchor) {
    case 'tl':
      xy = [0, 0];
      break;
    case 'bl':
      xy = [0, myHeight];
      break;
    case 'tr':
      xy = [myWidth, 0];
      break;
    case 'c':
      xy = [round(myWidth * 0.5), round(myHeight * 0.5)];
      break;
    case 't':
      xy = [round(myWidth * 0.5), 0];
      break;
    case 'l':
      xy = [0, round(myHeight * 0.5)];
      break;
    case 'r':
      xy = [myWidth, round(myHeight * 0.5)];
      break;
    case 'b':
      xy = [round(myWidth * 0.5), myHeight];
      break;
    case 'tc':
      xy = [round(myWidth * 0.5), 0];
      break;
    case 'bc':
      xy = [round(myWidth * 0.5), myHeight];
      break;
    case 'br':
      xy = [myWidth, myHeight];
  }
  return [xy[0] + extraX, xy[1] + extraY];
}, convertPositionSpec: Ext.identityFn, getAlignToXY: function(alignToEl, posSpec, offset) {
  var me = this, constrainToEl, constrainTo, alignMatch, myPosition, alignToElPosition, myWidth, myHeight, alignToElRegion, swapY, swapX, constrain, align1, align2, p1y, p1x, p2y, p2x, x, y;
  alignToEl = Ext.get(alignToEl.el || alignToEl);
  if (!alignToEl || !alignToEl.dom) 
  {
  }
  offset = offset || [0, 0];
  posSpec = (!posSpec || posSpec == "?" ? "tl-bl?" : (!(/-/).test(posSpec) && posSpec !== "" ? "tl-" + posSpec : posSpec || "tl-bl")).toLowerCase();
  posSpec = me.convertPositionSpec(posSpec);
  alignMatch = posSpec.match(me._alignRe);
  align1 = alignMatch[1];
  align2 = alignMatch[2];
  constrain = !!alignMatch[3];
  myPosition = me.getAnchorXY(align1, true);
  alignToElPosition = me.getAnchorToXY(alignToEl, align2, false);
  x = alignToElPosition[0] - myPosition[0] + offset[0];
  y = alignToElPosition[1] - myPosition[1] + offset[1];
  if (constrain) 
  {
    constrainToEl = me.constrainTo || me.container || me.el.parent();
    constrainToEl = Ext.get(constrainToEl.el || constrainToEl);
    constrainTo = constrainToEl.getViewRegion();
    constrainTo.right = constrainTo.left + constrainToEl.el.dom.clientWidth;
    myWidth = me.getWidth();
    myHeight = me.getHeight();
    alignToElRegion = alignToEl.getRegion();
    p1y = align1.charAt(0);
    p1x = align1.charAt(align1.length - 1);
    p2y = align2.charAt(0);
    p2x = align2.charAt(align2.length - 1);
    swapY = (x < alignToElRegion.right && x + myWidth >= alignToElRegion.left) && ((p1y == "t" && p2y == "b") || (p1y == "b" && p2y == "t"));
    swapX = (y < alignToElRegion.bottom && y + myHeight >= alignToElRegion.top) && ((p1x == "r" && p2x == "l") || (p1x == "l" && p2x == "r"));
    if (x + myWidth > constrainTo.right) 
    {
      if (swapX) 
      {
        x = alignToElRegion.left - myWidth;
        swapX = false;
      } else {
        x = constrainTo.right - myWidth;
      }
    }
    if (x < constrainTo.left) 
    {
      x = swapX ? alignToElRegion.right : constrainTo.left;
    }
    if (y + myHeight > constrainTo.bottom) 
    {
      if (swapY) 
      {
        y = alignToElRegion.top - myHeight;
        swapY = false;
      } else {
        y = constrainTo.bottom - myHeight;
      }
    }
    if (y < constrainTo.top) 
    {
      y = swapY ? alignToElRegion.bottom : constrainTo.top;
    }
  }
  return [x, y];
}, getAnchor: function() {
  var el = this.el, data = (el.$cache || el.getCache()).data, anchor;
  if (!el.dom) 
  {
    return;
  }
  anchor = data._anchor;
  if (!anchor) 
  {
    anchor = data._anchor = {};
  }
  return anchor;
}, getAnchorXY: function(anchor, local, mySize) {
  var me = this, myPos = me.getXY(), el = me.el, doc = document, isViewport = el.dom == doc.body || el.dom == doc, scroll = el.getScroll(), extraX = isViewport ? scroll.left : local ? 0 : myPos[0], extraY = isViewport ? scroll.top : local ? 0 : myPos[1];
  return me.calculateAnchorXY(anchor, extraX, extraY, mySize);
}, getBox: function(contentBox, local) {
  var me = this, xy = local ? me.getLocalXY() : me.getXY(), x = xy[0], y = xy[1], w = me.getWidth(), h = me.getHeight(), borderPadding, beforeX, beforeY;
  if (contentBox) 
  {
    borderPadding = me.getBorderPadding();
    beforeX = borderPadding.beforeX;
    beforeY = borderPadding.beforeY;
    x += beforeX;
    y += beforeY;
    w -= (beforeX + borderPadding.afterX);
    h -= (beforeY + borderPadding.afterY);
  }
  return {x: x, left: x, 0: x, y: y, top: y, 1: y, width: w, height: h, right: x + w, bottom: y + h};
}, calculateConstrainedPosition: function(constrainTo, proposedPosition, local, proposedSize) {
  var me = this, vector, fp = me.floatParent, parentNode = fp ? fp.getTargetEl() : null, parentOffset, borderPadding, proposedConstrainPosition, xy = false;
  if (local && fp) 
  {
    parentOffset = parentNode.getXY();
    borderPadding = parentNode.getBorderPadding();
    parentOffset[0] += borderPadding.beforeX;
    parentOffset[1] += borderPadding.beforeY;
    if (proposedPosition) 
    {
      proposedConstrainPosition = [proposedPosition[0] + parentOffset[0], proposedPosition[1] + parentOffset[1]];
    }
  } else {
    proposedConstrainPosition = proposedPosition;
  }
  constrainTo = constrainTo || me.constrainTo || parentNode || me.container || me.el.parent();
  vector = (me.constrainHeader ? me.header : me).getConstrainVector(constrainTo, proposedConstrainPosition, proposedSize);
  if (vector) 
  {
    xy = proposedPosition || me.getPosition(local);
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, getConstrainVector: function(constrainTo, proposedPosition, proposedSize) {
  var thisRegion = this.getRegion(), vector = [0, 0], shadowSize = (this.shadow && this.constrainShadow && !this.shadowDisabled) ? this.shadow.getShadowSize() : undefined, overflowed = false, constrainSize, constraintInsets = this.constraintInsets;
  if (!(constrainTo instanceof Ext.util.Region)) 
  {
    constrainTo = Ext.get(constrainTo.el || constrainTo);
    constrainSize = constrainTo.getViewSize();
    constrainTo = constrainTo.getViewRegion();
    constrainTo.right = constrainTo.left + constrainSize.width;
    constrainTo.bottom = constrainTo.top + constrainSize.height;
  }
  if (constraintInsets) 
  {
    constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
    constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.length);
  }
  if (proposedPosition) 
  {
    thisRegion.translateBy(proposedPosition[0] - thisRegion.x, proposedPosition[1] - thisRegion.y);
  }
  if (proposedSize) 
  {
    thisRegion.right = thisRegion.left + proposedSize[0];
    thisRegion.bottom = thisRegion.top + proposedSize[1];
  }
  if (shadowSize) 
  {
    constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
  }
  if (thisRegion.right > constrainTo.right) 
  {
    overflowed = true;
    vector[0] = (constrainTo.right - thisRegion.right);
  }
  if (thisRegion.left + vector[0] < constrainTo.left) 
  {
    overflowed = true;
    vector[0] = (constrainTo.left - thisRegion.left);
  }
  if (thisRegion.bottom > constrainTo.bottom) 
  {
    overflowed = true;
    vector[1] = (constrainTo.bottom - thisRegion.bottom);
  }
  if (thisRegion.top + vector[1] < constrainTo.top) 
  {
    overflowed = true;
    vector[1] = (constrainTo.top - thisRegion.top);
  }
  return overflowed ? vector : false;
}, getOffsetsTo: function(offsetsTo) {
  var o = this.getXY(), e = Ext.fly(offsetsTo.el || offsetsTo, '_internal').getXY();
  return [o[0] - e[0], o[1] - e[1]];
}, getRegion: function() {
  var box = this.getBox();
  return new Ext.util.Region(box.top, box.right, box.bottom, box.left);
}, getViewRegion: function() {
  var me = this, el = me.el, isBody = el.dom.nodeName === 'BODY', borderPadding, scroll, pos, top, left, width, height;
  if (isBody) 
  {
    scroll = el.getScroll();
    left = scroll.left;
    top = scroll.top;
    width = Ext.dom.AbstractElement.getViewportWidth();
    height = Ext.dom.AbstractElement.getViewportHeight();
  } else {
    borderPadding = me.getBorderPadding();
    pos = me.getXY();
    left = pos[0] + borderPadding.beforeX;
    top = pos[1] + borderPadding.beforeY;
    width = me.getWidth(true);
    height = me.getHeight(true);
  }
  return new Ext.util.Region(top, left + width, top + height, left);
}, move: function(direction, distance, animate) {
  var me = this, xy = me.getXY(), x = xy[0], y = xy[1], left = [x - distance, y], right = [x + distance, y], top = [x, y - distance], bottom = [x, y + distance], hash = {l: left, left: left, r: right, right: right, t: top, top: top, up: top, b: bottom, bottom: bottom, down: bottom};
  direction = direction.toLowerCase();
  me.setXY([hash[direction][0], hash[direction][1]], animate);
}, removeAnchor: function() {
  var anchor = this.getAnchor();
  if (anchor && anchor.fn) 
  {
    Ext.EventManager.removeResizeListener(anchor.fn);
    if (anchor.scroll) 
    {
      Ext.EventManager.un(window, 'scroll', anchor.fn);
    }
    delete anchor.fn;
  }
  return this;
}, setBox: function(box, animate) {
  var me = this, el = me.el, x = box.x, y = box.y, xy = [x, y], w = box.width, h = box.height, doConstrain = (me.constrain || me.constrainHeader), constrainedPos = doConstrain && me.calculateConstrainedPosition(null, [x, y], false, [w, h]);
  if (constrainedPos) 
  {
    x = constrainedPos[0];
    y = constrainedPos[1];
  }
  if (!animate || !el.anim) 
  {
    me.setSize(w, h);
    me.setXY([x, y]);
    me.afterSetPosition(x, y);
  } else {
    me.animate(Ext.applyIf({to: {x: x, y: y, width: el.adjustWidth(w), height: el.adjustHeight(h)}, listeners: {afteranimate: Ext.Function.bind(me.afterSetPosition, me, [x, y])}}, animate));
  }
  return me;
}, setRegion: function(region, animate) {
  return this.setBox({x: region.left, y: region.top, width: region.right - region.left, height: region.bottom - region.top}, animate);
}, translatePoints: function(x, y) {
  var pos = this.translateXY(x, y);
  return {left: pos.x, top: pos.y};
}, translateXY: function(x, y) {
  var me = this, el = me.el, styles = el.getStyle(me._positionTopLeft), relative = styles.position == 'relative', left = parseFloat(styles.left), top = parseFloat(styles.top), xy = me.getXY();
  if (Ext.isArray(x)) 
  {
    y = x[1];
    x = x[0];
  }
  if (isNaN(left)) 
  {
    left = relative ? 0 : el.dom.offsetLeft;
  }
  if (isNaN(top)) 
  {
    top = relative ? 0 : el.dom.offsetTop;
  }
  left = (typeof x == 'number') ? x - xy[0] + left : undefined;
  top = (typeof y == 'number') ? y - xy[1] + top : undefined;
  return {x: left, y: top};
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Positionable'], 0));
;

(Ext.cmd.derive('Ext.dom.Element', Ext.dom.AbstractElement, function(Element) {
  var HIDDEN = 'hidden', DOC = document, VISIBILITY = "visibility", DISPLAY = "display", NONE = "none", XMASKED = Ext.baseCSSPrefix + "masked", XMASKEDRELATIVE = Ext.baseCSSPrefix + "masked-relative", EXTELMASKMSG = Ext.baseCSSPrefix + "mask-msg", bodyRe = /^body/i, visFly, noBoxAdjust = Ext.isStrict ? {select: 1} : {input: 1, select: 1, textarea: 1}, isScrolled = function(c) {
  var r = [], ri = -1, i, ci;
  for (i = 0; ci = c[i]; i++) 
    {
      if (ci.scrollTop > 0 || ci.scrollLeft > 0) 
      {
        r[++ri] = ci;
      }
    }
  return r;
};
  return {alternateClassName: ['Ext.Element', 'Ext.core.Element'], isElement: true, tableTagRe: /^(?:tr|td|table|tbody)$/i, addUnits: function() {
  return Element.addUnits.apply(Element, arguments);
}, focus: function(defer, dom) {
  var me = this;
  dom = dom || me.dom;
  try {
    if (Number(defer)) 
    {
      Ext.defer(me.focus, defer, me, [null, dom]);
    } else {
      Ext.globalEvents.fireEvent('beforefocus', dom);
      dom.focus();
    }
  }  catch (e) {
}
  return me;
}, blur: function() {
  var me = this, dom = me.dom;
  if (dom !== document.body) 
  {
    try {
      dom.blur();
    }    catch (e) {
}
    return me;
  } else {
    return me.focus(undefined, dom);
  }
}, isBorderBox: function() {
  var box = Ext.isBorderBox;
  if (Ext.isIE7m && !box) 
  {
    box = ((this.dom.tagName || "").toLowerCase() in noBoxAdjust);
  }
  return box;
}, hover: function(overFn, outFn, scope, options) {
  var me = this;
  me.on('mouseenter', overFn, scope || me.dom, options);
  me.on('mouseleave', outFn, scope || me.dom, options);
  return me;
}, getAttributeNS: function(ns, name) {
  return this.getAttribute(name, ns);
}, getAttribute: (Ext.isIE && !(Ext.isIE9p && DOC.documentMode >= 9)) ? function(name, ns) {
  var d = this.dom, type;
  if (ns) 
  {
    type = typeof d[ns + ":" + name];
    if (type != 'undefined' && type != 'unknown') 
    {
      return d[ns + ":" + name] || null;
    }
    return null;
  }
  if (name === "for") 
  {
    name = "htmlFor";
  }
  return d[name] || null;
} : function(name, ns) {
  var d = this.dom;
  if (ns) 
  {
    return d.getAttributeNS(ns, name) || d.getAttribute(ns + ":" + name);
  }
  return d.getAttribute(name) || d[name] || null;
}, cacheScrollValues: function() {
  var me = this, scrolledDescendants, el, i, scrollValues = [], result = function() {
  for (i = 0; i < scrolledDescendants.length; i++) 
    {
      el = scrolledDescendants[i];
      el.scrollLeft = scrollValues[i][0];
      el.scrollTop = scrollValues[i][1];
    }
};
  if (!Ext.DomQuery.pseudos.isScrolled) 
  {
    Ext.DomQuery.pseudos.isScrolled = isScrolled;
  }
  scrolledDescendants = me.query(':isScrolled');
  for (i = 0; i < scrolledDescendants.length; i++) 
    {
      el = scrolledDescendants[i];
      scrollValues[i] = [el.scrollLeft, el.scrollTop];
    }
  return result;
}, autoBoxAdjust: true, isVisible: function(deep) {
  var me = this, dom = me.dom, stopNode = dom.ownerDocument.documentElement;
  if (!visFly) 
  {
    visFly = new Element.Fly();
  }
  while (dom !== stopNode) 
    {
      if (!dom || dom.nodeType === 11 || (visFly.attach(dom)).isStyle(VISIBILITY, HIDDEN) || visFly.isStyle(DISPLAY, NONE)) 
      {
        return false;
      }
      if (!deep) 
      {
        break;
      }
      dom = dom.parentNode;
    }
  return true;
}, isDisplayed: function() {
  return !this.isStyle(DISPLAY, NONE);
}, enableDisplayMode: function(display) {
  var me = this;
  me.setVisibilityMode(Element.DISPLAY);
  if (!Ext.isEmpty(display)) 
  {
    (me.$cache || me.getCache()).data.originalDisplay = display;
  }
  return me;
}, mask: function(msg, msgCls, elHeight) {
  var me = this, dom = me.dom, setExpression = dom.style.setExpression, data = (me.$cache || me.getCache()).data, maskShimEl = data.maskShimEl, maskEl = data.maskEl, maskMsg = data.maskMsg, widthExpression, heightExpression, docElem, ie6DocElHeight;
  if (!(bodyRe.test(dom.tagName) && me.getStyle('position') == 'static')) 
  {
    me.addCls(XMASKEDRELATIVE);
  }
  if (maskEl) 
  {
    maskEl.remove();
  }
  if (maskMsg) 
  {
    maskMsg.remove();
  }
  if (maskShimEl) 
  {
    maskShimEl.remove();
  }
  if (Ext.isIE6) 
  {
    maskShimEl = Ext.DomHelper.append(dom, {tag: 'iframe', role: 'presentation', cls: Ext.baseCSSPrefix + 'shim ' + Ext.baseCSSPrefix + 'mask-shim'}, true);
    data.maskShimEl = maskShimEl;
    maskShimEl.setDisplayed(true);
  }
  Ext.DomHelper.append(dom, [{role: 'presentation', cls: Ext.baseCSSPrefix + "mask", style: 'top:0;left:0;'}, {role: 'presentation', cls: msgCls ? EXTELMASKMSG + " " + msgCls : EXTELMASKMSG, cn: {tag: 'div', role: 'presentation', cls: Ext.baseCSSPrefix + 'mask-msg-inner', cn: {tag: 'div', role: 'presentation', cls: Ext.baseCSSPrefix + 'mask-msg-text', html: msg || ''}}}]);
  maskMsg = Ext.get(dom.lastChild);
  maskEl = Ext.get(maskMsg.dom.previousSibling);
  data.maskMsg = maskMsg;
  data.maskEl = maskEl;
  me.addCls(XMASKED);
  maskEl.setDisplayed(true);
  if (typeof msg == 'string') 
  {
    maskMsg.setDisplayed(true);
    maskMsg.center(me);
  } else {
    maskMsg.setDisplayed(false);
  }
  if (Ext.isStrict && !Ext.isIE6 && (dom === DOC.body)) 
  {
    maskEl.addCls(Ext.baseCSSPrefix + 'mask-fixed');
  }
  if (dom !== DOC.body || Ext.isIE6 || Ext.isIEQuirks) 
  {
    if (!Ext.supports.IncludePaddingInWidthCalculation && setExpression) 
    {
      try {
        maskEl.dom.style.setExpression('width', 'this.parentNode.clientWidth + "px"');
        widthExpression = 'this.parentNode.clientWidth + "px"';
        if (maskShimEl) 
        {
          maskShimEl.dom.style.setExpression('width', widthExpression);
        }
        maskEl.dom.style.setExpression('width', widthExpression);
      }      catch (e) {
}
    }
    if (!Ext.supports.IncludePaddingInHeightCalculation && setExpression) 
    {
      try {
        heightExpression = 'this.parentNode.' + (dom == DOC.body ? 'scrollHeight' : 'offsetHeight') + ' + "px"';
        if (maskShimEl) 
        {
          maskShimEl.dom.style.setExpression('height', heightExpression);
        }
        maskEl.dom.style.setExpression('height', heightExpression);
      }      catch (e) {
}
    } else if (Ext.isIE9m && !(Ext.isIE7 && Ext.isStrict) && me.getStyle('height') == 'auto') 
    {
      if (Ext.isIE6 && Ext.isStrict) 
      {
        docElem = dom.parentNode;
        ie6DocElHeight = Math.max(docElem.clientHeight, docElem.scrollHeight);
      }
      if (maskShimEl) 
      {
        maskShimEl.setSize(undefined, elHeight || ie6DocElHeight || me.getHeight());
      }
      maskEl.setSize(undefined, elHeight || ie6DocElHeight || me.getHeight());
    }
  }
  return maskEl;
}, unmask: function() {
  var me = this, data = (me.$cache || me.getCache()).data, maskEl = data.maskEl, maskShimEl = data.maskShimEl, maskMsg = data.maskMsg, style;
  if (maskEl) 
  {
    style = maskEl.dom.style;
    if (style.clearExpression) 
    {
      style.clearExpression('width');
      style.clearExpression('height');
    }
    if (maskEl) 
    {
      maskEl.remove();
      delete data.maskEl;
    }
    if (maskMsg) 
    {
      maskMsg.remove();
      delete data.maskMsg;
    }
    me.removeCls([XMASKED, XMASKEDRELATIVE]);
    if (maskShimEl) 
    {
      style = maskShimEl.dom.style;
      if (style.clearExpression) 
      {
        style.clearExpression('width');
        style.clearExpression('height');
      }
      maskShimEl.remove();
      delete data.maskShimEl;
    }
  }
}, isMasked: function() {
  var me = this, data = (me.$cache || me.getCache()).data, maskEl = data.maskEl, maskMsg = data.maskMsg, hasMask = false;
  if (maskEl && maskEl.isVisible()) 
  {
    if (maskMsg) 
    {
      maskMsg.center(me);
    }
    hasMask = true;
  }
  return hasMask;
}, createShim: function() {
  var el = DOC.createElement('iframe'), shim;
  el.frameBorder = '0';
  el.className = Ext.baseCSSPrefix + 'shim';
  el.src = Ext.SSL_SECURE_URL;
  el.setAttribute('role', 'presentation');
  shim = Ext.get(this.dom.parentNode.insertBefore(el, this.dom));
  shim.autoBoxAdjust = false;
  return shim;
}, addKeyListener: function(key, fn, scope) {
  var config;
  if (typeof key != 'object' || Ext.isArray(key)) 
  {
    config = {target: this, key: key, fn: fn, scope: scope};
  } else {
    config = {target: this, key: key.key, shift: key.shift, ctrl: key.ctrl, alt: key.alt, fn: fn, scope: scope};
  }
  return new Ext.util.KeyMap(config);
}, addKeyMap: function(config) {
  return new Ext.util.KeyMap(Ext.apply({target: this}, config));
}, on: function(eventName, fn, scope, options) {
  Ext.EventManager.on(this, eventName, fn, scope || this, options);
  return this;
}, un: function(eventName, fn, scope) {
  Ext.EventManager.un(this, eventName, fn, scope || this);
  return this;
}, removeAllListeners: function() {
  Ext.EventManager.removeAll(this);
  return this;
}, purgeAllListeners: function() {
  Ext.EventManager.purgeElement(this);
  return this;
}, select: function(selector) {
  return Element.select(selector, false, this.dom);
}};
}, 0, 0, 0, 0, 0, [[Ext.util.Positionable.prototype.mixinId || Ext.util.Positionable.$className, Ext.util.Positionable]], [Ext.dom, 'Element', Ext, 'Element', Ext.core, 'Element'], function() {
  var DOC = document, EC = Ext.cache, Element = this, AbstractElement = Ext.dom.AbstractElement, focusRe = /^a|button|embed|iframe|input|object|select|textarea$/i, nonSpaceRe = /\S/, scriptTagRe = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/ig, replaceScriptTagRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, srcRe = /\ssrc=([\'\"])(.*?)\1/i, typeRe = /\stype=([\'\"])(.*?)\1/i, useDocForId = !Ext.isIE8m, internalFly;
  Element.boxMarkup = ['<div class="{0}-tl" role="presentation">', '<div class="{0}-tr" role="presentation">', '<div class="{0}-tc" role="presentation"></div>', '</div>', '</div>', '<div class="{0}-ml" role="presentation">', '<div class="{0}-mr" role="presentation">', '<div class="{0}-mc" role="presentation"></div>', '</div>', '</div>', '<div class="{0}-bl" role="presentation">', '<div class="{0}-br" role="presentation">', '<div class="{0}-bc" role="presentation"></div>', '</div>', '</div>'].join('');
  function garbageCollect() {
    if (!Ext.enableGarbageCollector) 
    {
      clearInterval(Element.collectorThreadId);
    } else {
      var eid, d, o, t;
      for (eid in EC) 
        {
          if (!EC.hasOwnProperty(eid)) 
          {
            continue;
          }
          o = EC[eid];
          if (o.skipGarbageCollection) 
          {
            continue;
          }
          d = o.dom;
          if (d && (!d.parentNode || (!d.offsetParent && !Ext.getElementById(eid)))) 
          {
            if (Ext.enableListenerCollection) 
            {
              Ext.EventManager.removeAll(d);
            }
            delete EC[eid];
          }
        }
      if (Ext.isIE) 
      {
        t = {};
        for (eid in EC) 
          {
            if (!EC.hasOwnProperty(eid)) 
            {
              continue;
            }
            t[eid] = EC[eid];
          }
        EC = Ext.cache = t;
      }
    }
  }
  Element.collectorThreadId = setInterval(garbageCollect, 30000);
  Element.addMethods({monitorMouseLeave: function(delay, handler, scope) {
  var me = this, timer, listeners = {mouseleave: function(e) {
  timer = setTimeout(Ext.Function.bind(handler, scope || me, [e]), delay);
}, mouseenter: function() {
  clearTimeout(timer);
}, freezeEvent: true};
  me.on(listeners);
  return listeners;
}, swallowEvent: function(eventName, preventDefault) {
  var me = this, e, eLen, fn = function(e) {
  e.stopPropagation();
  if (preventDefault) 
  {
    e.preventDefault();
  }
};
  if (Ext.isArray(eventName)) 
  {
    eLen = eventName.length;
    for (e = 0; e < eLen; e++) 
      {
        me.on(eventName[e], fn);
      }
    return me;
  }
  me.on(eventName, fn);
  return me;
}, relayEvent: function(eventName, observable) {
  this.on(eventName, function(e) {
  observable.fireEvent(eventName, e);
});
}, clean: function(forceReclean) {
  var me = this, dom = me.dom, data = (me.$cache || me.getCache()).data, n = dom.firstChild, ni = -1, nx;
  if (data.isCleaned && forceReclean !== true) 
  {
    return me;
  }
  while (n) 
    {
      nx = n.nextSibling;
      if (n.nodeType == 3) 
      {
        if (!(nonSpaceRe.test(n.nodeValue))) 
        {
          dom.removeChild(n);
        } else if (nx && nx.nodeType == 3) 
        {
          n.appendData(Ext.String.trim(nx.data));
          dom.removeChild(nx);
          nx = n.nextSibling;
          n.nodeIndex = ++ni;
        }
      } else {
        internalFly.attach(n).clean();
        n.nodeIndex = ++ni;
      }
      n = nx;
    }
  data.isCleaned = true;
  return me;
}, load: function(options) {
  this.getLoader().load(options);
  return this;
}, getLoader: function() {
  var me = this, data = (me.$cache || me.getCache()).data, loader = data.loader;
  if (!loader) 
  {
    data.loader = loader = new Ext.ElementLoader({target: me});
  }
  return loader;
}, syncContent: function(source) {
  source = Ext.getDom(source);
  var sourceNodes = source.childNodes, sourceLen = sourceNodes.length, dest = this.dom, destNodes = dest.childNodes, destLen = destNodes.length, i, destNode, sourceNode, nodeType, newAttrs, attLen, attName;
  if (Ext.isIE9m && dest.mergeAttributes) 
  {
    dest.mergeAttributes(source, true);
    dest.src = source.src;
  } else {
    newAttrs = source.attributes;
    attLen = newAttrs.length;
    for (i = 0; i < attLen; i++) 
      {
        attName = newAttrs[i].name;
        if (attName !== 'id') 
        {
          dest.setAttribute(attName, newAttrs[i].value);
        }
      }
  }
  if (sourceLen !== destLen) 
  {
    dest.innerHTML = source.innerHTML;
    return;
  }
  for (i = 0; i < sourceLen; i++) 
    {
      sourceNode = sourceNodes[i];
      destNode = destNodes[i];
      nodeType = sourceNode.nodeType;
      if (nodeType !== destNode.nodeType || (nodeType === 1 && sourceNode.tagName !== destNode.tagName)) 
      {
        dest.innerHTML = source.innerHTML;
        return;
      }
      if (nodeType === 3) 
      {
        destNode.data = sourceNode.data;
      } else {
        if (sourceNode.id && destNode.id !== sourceNode.id) 
        {
          destNode.id = sourceNode.id;
        }
        destNode.style.cssText = sourceNode.style.cssText;
        destNode.className = sourceNode.className;
        internalFly.attach(destNode).syncContent(sourceNode);
      }
    }
}, update: function(html, loadScripts, callback) {
  var me = this, id, dom, interval;
  if (!me.dom) 
  {
    return me;
  }
  html = html || '';
  dom = me.dom;
  if (loadScripts !== true) 
  {
    dom.innerHTML = html;
    Ext.callback(callback, me);
    return me;
  }
  id = Ext.id();
  html += '<span id="' + id + '" role="presentation"></span>';
  interval = setInterval(function() {
  var hd, match, attrs, srcMatch, typeMatch, el, s;
  if (!(el = DOC.getElementById(id))) 
  {
    return false;
  }
  clearInterval(interval);
  Ext.removeNode(el);
  hd = Ext.getHead().dom;
  while ((match = scriptTagRe.exec(html))) 
    {
      attrs = match[1];
      srcMatch = attrs ? attrs.match(srcRe) : false;
      if (srcMatch && srcMatch[2]) 
      {
        s = DOC.createElement("script");
        s.src = srcMatch[2];
        typeMatch = attrs.match(typeRe);
        if (typeMatch && typeMatch[2]) 
        {
          s.type = typeMatch[2];
        }
        hd.appendChild(s);
      } else if (match[2] && match[2].length > 0) 
      {
        if (window.execScript) 
        {
          window.execScript(match[2]);
        } else {
          window.eval(match[2]);
        }
      }
    }
  Ext.callback(callback, me);
}, 20);
  dom.innerHTML = html.replace(replaceScriptTagRe, '');
  return me;
}, removeAllListeners: function() {
  this.removeAnchor();
  Ext.EventManager.removeAll(this.dom);
  return this;
}, createProxy: function(config, renderTo, matchBox) {
  config = (typeof config == 'object') ? config : {tag: "div", role: 'presentation', cls: config};
  var me = this, proxy = renderTo ? Ext.DomHelper.append(renderTo, config, true) : Ext.DomHelper.insertBefore(me.dom, config, true);
  proxy.setVisibilityMode(Element.DISPLAY);
  proxy.hide();
  if (matchBox && me.setBox && me.getBox) 
  {
    proxy.setBox(me.getBox());
  }
  return proxy;
}, needsTabIndex: function() {
  if (this.dom) 
  {
    if ((this.dom.nodeName === 'a') && (!this.dom.href)) 
    {
      return true;
    }
    return !focusRe.test(this.dom.nodeName);
  }
}, isFocusable: function(asFocusEl) {
  var dom = this.dom, tabIndexAttr = dom.getAttributeNode('tabIndex'), tabIndex, nodeName = dom.nodeName, canFocus = false;
  if (tabIndexAttr && tabIndexAttr.specified) 
  {
    tabIndex = tabIndexAttr.value;
  }
  if (dom && !dom.disabled) 
  {
    if (tabIndex == -1) 
    {
      canFocus = Ext.enableFocusManager && asFocusEl;
    } else {
      if (focusRe.test(nodeName)) 
      {
        if ((nodeName !== 'a') || dom.href) 
        {
          canFocus = true;
        }
      } else {
        canFocus = tabIndex != null && tabIndex >= 0;
      }
    }
    canFocus = canFocus && this.isVisible(true);
  }
  return canFocus;
}});
  if (Ext.isIE9m) 
  {
    Element.prototype.getById = function(id, asDom) {
  var dom = this.dom, cacheItem, el, ret;
  if (dom) 
  {
    el = (useDocForId && DOC.getElementById(id)) || dom.all[id];
    if (el) 
    {
      if (asDom) 
      {
        ret = el;
      } else {
        cacheItem = EC[id];
        if (cacheItem && cacheItem.el) 
        {
          ret = Ext.updateCacheEntry(cacheItem, el).el;
        } else {
          ret = new Element(el);
        }
      }
      return ret;
    }
  }
  return asDom ? Ext.getDom(id) : Element.get(id);
};
  }
  Element.createAlias({addListener: 'on', removeListener: 'un', clearListeners: 'removeAllListeners', focusable: 'isFocusable'});
  Element.Fly = AbstractElement.Fly = new Ext.Class({extend: Element, isFly: true, constructor: function(dom) {
  this.dom = dom;
  this.el = this;
}, attach: AbstractElement.Fly.prototype.attach});
  internalFly = new Element.Fly();
  if (Ext.isIE9m) 
  {
    Ext.getElementById = function(id) {
  var el = DOC.getElementById(id), detachedBodyEl;
  if (!el && (detachedBodyEl = AbstractElement.detachedBodyEl)) 
  {
    el = detachedBodyEl.dom.all[id];
  }
  return el;
};
  } else if (!DOC.querySelector) 
  {
    Ext.getDetachedBody = Ext.getBody;
    Ext.getElementById = function(id) {
  return DOC.getElementById(id);
};
  }
}));
;

(Ext.cmd.derive('Ext.dom.CompositeElementLite', Ext.Base, {alternateClassName: 'Ext.CompositeElementLite', statics: {importElementMethods: function() {
  var name, elementPrototype = Ext.dom.Element.prototype, prototype = this.prototype;
  for (name in elementPrototype) 
    {
      if (typeof elementPrototype[name] == 'function') 
      {
        (function(key) {
  prototype[key] = prototype[key] || function() {
  return this.invoke(key, arguments);
};
}).call(prototype, name);
      }
    }
}}, constructor: function(elements, root) {
  this.elements = [];
  this.add(elements, root);
  this.el = new Ext.dom.AbstractElement.Fly();
}, isComposite: true, getElement: function(el) {
  return this.el.attach(el);
}, transformElement: function(el) {
  return Ext.getDom(el);
}, getCount: function() {
  return this.elements.length;
}, add: function(els, root) {
  var elements = this.elements, i, ln;
  if (!els) 
  {
    return this;
  }
  if (typeof els == "string") 
  {
    els = Ext.dom.Element.selectorFunction(els, root);
  } else if (els.isComposite) 
  {
    els = els.elements;
  } else if (!Ext.isIterable(els)) 
  {
    els = [els];
  }
  for (i = 0 , ln = els.length; i < ln; ++i) 
    {
      elements.push(this.transformElement(els[i]));
    }
  return this;
}, invoke: function(fn, args) {
  var elements = this.elements, ln = elements.length, element, i;
  fn = Ext.dom.Element.prototype[fn];
  for (i = 0; i < ln; i++) 
    {
      element = elements[i];
      if (element) 
      {
        fn.apply(this.getElement(element), args);
      }
    }
  return this;
}, item: function(index) {
  var el = this.elements[index], out = null;
  if (el) 
  {
    out = this.getElement(el);
  }
  return out;
}, slice: function() {
  return this.elements.slice.apply(this.elements, arguments);
}, addListener: function(eventName, handler, scope, opt) {
  var els = this.elements, len = els.length, i, e;
  for (i = 0; i < len; i++) 
    {
      e = els[i];
      if (e) 
      {
        Ext.EventManager.on(e, eventName, handler, scope || e, opt);
      }
    }
  return this;
}, each: function(fn, scope) {
  var me = this, els = me.elements, len = els.length, i, e;
  for (i = 0; i < len; i++) 
    {
      e = els[i];
      if (e) 
      {
        e = this.getElement(e);
        if (fn.call(scope || e, e, me, i) === false) 
        {
          break;
        }
      }
    }
  return me;
}, fill: function(els) {
  var me = this;
  me.elements = [];
  me.add(els);
  return me;
}, insert: function(index, nodes) {
  Ext.Array.insert(this.elements, index, nodes);
}, filter: function(selector) {
  var me = this, els = me.elements, len = els.length, out = [], i = 0, isFunc = typeof selector == 'function', add, el;
  for (; i < len; i++) 
    {
      el = els[i];
      add = false;
      if (el) 
      {
        el = me.getElement(el);
        if (isFunc) 
        {
          add = selector.call(el, el, me, i) !== false;
        } else {
          add = el.is(selector);
        }
        if (add) 
        {
          out.push(me.transformElement(el));
        }
      }
    }
  me.elements = out;
  return me;
}, indexOf: function(el) {
  return Ext.Array.indexOf(this.elements, this.transformElement(el));
}, replaceElement: function(el, replacement, domReplace) {
  var index = !isNaN(el) ? el : this.indexOf(el), d;
  if (index > -1) 
  {
    replacement = Ext.getDom(replacement);
    if (domReplace) 
    {
      d = this.elements[index];
      d.parentNode.insertBefore(replacement, d);
      Ext.removeNode(d);
    }
    Ext.Array.splice(this.elements, index, 1, replacement);
  }
  return this;
}, clear: function(removeDom) {
  var me = this, els = me.elements, i = els.length - 1;
  if (removeDom) 
  {
    for (; i >= 0; i--) 
      {
        Ext.removeNode(els[i]);
      }
  }
  this.elements = [];
}, addElements: function(els, root) {
  if (!els) 
  {
    return this;
  }
  if (typeof els == "string") 
  {
    els = Ext.dom.Element.selectorFunction(els, root);
  }
  var yels = this.elements, eLen = els.length, e;
  for (e = 0; e < eLen; e++) 
    {
      yels.push(Ext.get(els[e]));
    }
  return this;
}, first: function() {
  return this.item(0);
}, last: function() {
  return this.item(this.getCount() - 1);
}, contains: function(el) {
  return this.indexOf(el) != -1;
}, removeElement: function(keys, removeDom) {
  keys = [].concat(keys);
  var me = this, elements = me.elements, kLen = keys.length, val, el, k;
  for (k = 0; k < kLen; k++) 
    {
      val = keys[k];
      if ((el = (elements[val] || elements[val = me.indexOf(val)]))) 
      {
        if (removeDom) 
        {
          if (el.dom) 
          {
            el.remove();
          } else {
            Ext.removeNode(el);
          }
        }
        Ext.Array.erase(elements, val, 1);
      }
    }
  return me;
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'CompositeElementLite', Ext, 'CompositeElementLite'], function() {
  this.importElementMethods();
  this.prototype.on = this.prototype.addListener;
  if (Ext.DomQuery) 
  {
    Ext.dom.Element.selectorFunction = Ext.DomQuery.select;
  }
  Ext.dom.Element.select = function(selector, root) {
  var elements;
  if (typeof selector == "string") 
  {
    elements = Ext.dom.Element.selectorFunction(selector, root);
  } else if (selector.length !== undefined) 
  {
    elements = selector;
  } else {
  }
  return new Ext.CompositeElementLite(elements);
};
  Ext.select = function() {
  return Ext.dom.Element.select.apply(Ext.dom.Element, arguments);
};
}));
;

(Ext.cmd.derive('Ext.dom.CompositeElement', Ext.dom.CompositeElementLite, {alternateClassName: 'Ext.CompositeElement', getElement: function(el) {
  return el;
}, transformElement: function(el) {
  return Ext.get(el);
}}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'CompositeElement', Ext, 'CompositeElement'], function() {
  Ext.dom.Element.select = function(selector, unique, root) {
  var elements;
  if (typeof selector == "string") 
  {
    elements = Ext.dom.Element.selectorFunction(selector, root);
  } else if (selector.length !== undefined) 
  {
    elements = selector;
  } else {
  }
  return (unique === true) ? new Ext.CompositeElement(elements) : new Ext.CompositeElementLite(elements);
};
}));
;
Ext.select = Ext.Element.select;

(Ext.cmd.derive('Ext.util.HashMap', Ext.Base, {generation: 0, constructor: function(config) {
  config = config || {};
  var me = this, keyFn = config.keyFn;
  me.initialConfig = config;
  me.addEvents('add', 'clear', 'remove', 'replace');
  me.mixins.observable.constructor.call(me, config);
  me.clear(true);
  if (keyFn) 
  {
    me.getKey = keyFn;
  }
}, getCount: function() {
  return this.length;
}, getData: function(key, value) {
  if (value === undefined) 
  {
    value = key;
    key = this.getKey(value);
  }
  return [key, value];
}, getKey: function(o) {
  return o.id;
}, add: function(key, value) {
  var me = this;
  if (arguments.length === 1) 
  {
    value = key;
    key = me.getKey(value);
  }
  if (me.containsKey(key)) 
  {
    return me.replace(key, value);
  }
  me.map[key] = value;
  ++me.length;
  me.generation++;
  if (me.hasListeners.add) 
  {
    me.fireEvent('add', me, key, value);
  }
  return value;
}, replace: function(key, value) {
  var me = this, map = me.map, old;
  if (arguments.length === 1) 
  {
    value = key;
    key = me.getKey(value);
  }
  if (!me.containsKey(key)) 
  {
    me.add(key, value);
  }
  old = map[key];
  map[key] = value;
  me.generation++;
  if (me.hasListeners.replace) 
  {
    me.fireEvent('replace', me, key, value, old);
  }
  return value;
}, remove: function(o) {
  var key = this.findKey(o);
  if (key !== undefined) 
  {
    return this.removeAtKey(key);
  }
  return false;
}, removeAtKey: function(key) {
  var me = this, value;
  if (me.containsKey(key)) 
  {
    value = me.map[key];
    delete me.map[key];
    --me.length;
    me.generation++;
    if (me.hasListeners.remove) 
    {
      me.fireEvent('remove', me, key, value);
    }
    return true;
  }
  return false;
}, get: function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) ? map[key] : undefined;
}, clear: function(initial) {
  var me = this;
  if (initial || me.generation) 
  {
    me.map = {};
    me.length = 0;
    me.generation = initial ? 0 : me.generation + 1;
  }
  if (initial !== true && me.hasListeners.clear) 
  {
    me.fireEvent('clear', me);
  }
  return me;
}, containsKey: function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) && map[key] !== undefined;
}, contains: function(value) {
  return this.containsKey(this.findKey(value));
}, getKeys: function() {
  return this.getArray(true);
}, getValues: function() {
  return this.getArray(false);
}, getArray: function(isKey) {
  var arr = [], key, map = this.map;
  for (key in map) 
    {
      if (map.hasOwnProperty(key)) 
      {
        arr.push(isKey ? key : map[key]);
      }
    }
  return arr;
}, each: function(fn, scope) {
  var items = Ext.apply({}, this.map), key, length = this.length;
  scope = scope || this;
  for (key in items) 
    {
      if (items.hasOwnProperty(key)) 
      {
        if (fn.call(scope, key, items[key], length) === false) 
        {
          break;
        }
      }
    }
  return this;
}, clone: function() {
  var hash = new this.self(this.initialConfig), map = this.map, key;
  hash.suspendEvents();
  for (key in map) 
    {
      if (map.hasOwnProperty(key)) 
      {
        hash.add(key, map[key]);
      }
    }
  hash.resumeEvents();
  return hash;
}, findKey: function(value) {
  var key, map = this.map;
  for (key in map) 
    {
      if (map.hasOwnProperty(key) && map[key] === value) 
      {
        return key;
      }
    }
  return undefined;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.util, 'HashMap'], 0));
;

(Ext.cmd.derive('Ext.AbstractManager', Ext.Base, {typeName: 'type', constructor: function(config) {
  Ext.apply(this, config || {});
  this.all = new Ext.util.HashMap();
  this.types = {};
}, get: function(id) {
  return this.all.get(id);
}, register: function(item) {
  this.all.add(item);
}, unregister: function(item) {
  var all = this.all;
  all.removeAtKey(all.getKey(item));
}, registerType: function(type, cls) {
  this.types[type] = cls;
  cls[this.typeName] = type;
}, isRegistered: function(type) {
  return this.types[type] !== undefined;
}, create: function(config, defaultType) {
  var type = config[this.typeName] || config.type || defaultType, Constructor = this.types[type];
  return new Constructor(config);
}, onAvailable: function(id, fn, scope) {
  var all = this.all, item, callback;
  if (all.containsKey(id)) 
  {
    item = all.get(id);
    fn.call(scope || item, item);
  } else {
    callback = function(map, key, item) {
  if (key == id) 
  {
    fn.call(scope || item, item);
    all.un('add', callback);
  }
};
    all.on('add', callback);
  }
}, each: function(fn, scope) {
  this.all.each(fn, scope || this);
}, getCount: function() {
  return this.all.getCount();
}}, 1, 0, 0, 0, 0, 0, [Ext, 'AbstractManager'], 0));
;

(Ext.cmd.derive('Ext.ComponentManager', Ext.AbstractManager, {alternateClassName: 'Ext.ComponentMgr', singleton: true, typeName: 'xtype', create: function(component, defaultType) {
  if (typeof component == 'string') 
  {
    return Ext.widget(component);
  }
  if (component.isComponent) 
  {
    return component;
  }
  return Ext.widget(component.xtype || defaultType, component);
}, registerType: function(type, cls) {
  this.types[type] = cls;
  cls[this.typeName] = type;
  cls.prototype[this.typeName] = type;
}}, 0, 0, 0, 0, 0, 0, [Ext, 'ComponentManager', Ext, 'ComponentMgr'], function() {
  Ext.getCmp = function(id) {
  return Ext.ComponentManager.get(id);
};
}));
;

(Ext.cmd.derive('Ext.util.LruCache', Ext.util.HashMap, {constructor: function(config) {
  Ext.apply(this, config);
  this.callParent([config]);
}, add: function(key, newValue) {
  var me = this, entry, last;
  me.removeAtKey(key);
  last = me.last;
  entry = {prev: last, next: null, key: key, value: newValue};
  if (last) 
  {
    last.next = entry;
  } else {
    me.first = entry;
  }
  me.last = entry;
  me.callParent([key, entry]);
  me.prune();
  return newValue;
}, insertBefore: function(key, newValue, sibling) {
  var me = this, existingKey, entry;
  if (sibling = this.map[this.findKey(sibling)]) 
  {
    existingKey = me.findKey(newValue);
    if (existingKey) 
    {
      me.unlinkEntry(entry = me.map[existingKey]);
    } else {
      entry = {prev: sibling.prev, next: sibling, key: key, value: newValue};
    }
    if (sibling.prev) 
    {
      entry.prev.next = entry;
    } else {
      me.first = entry;
    }
    entry.next = sibling;
    sibling.prev = entry;
    me.prune();
    return newValue;
  } else {
    return me.add(key, newValue);
  }
}, get: function(key) {
  var entry = this.map[key];
  if (entry) 
  {
    if (entry.next) 
    {
      this.moveToEnd(entry);
    }
    return entry.value;
  }
}, removeAtKey: function(key) {
  this.unlinkEntry(this.map[key]);
  return this.callParent(arguments);
}, clear: function(initial) {
  this.first = this.last = null;
  return this.callParent(arguments);
}, unlinkEntry: function(entry) {
  if (entry) 
  {
    if (entry.next) 
    {
      entry.next.prev = entry.prev;
    } else {
      this.last = entry.prev;
    }
    if (entry.prev) 
    {
      entry.prev.next = entry.next;
    } else {
      this.first = entry.next;
    }
    entry.prev = entry.next = null;
  }
}, moveToEnd: function(entry) {
  this.unlinkEntry(entry);
  if (entry.prev = this.last) 
  {
    this.last.next = entry;
  } else {
    this.first = entry;
  }
  this.last = entry;
}, getArray: function(isKey) {
  var arr = [], entry = this.first;
  while (entry) 
    {
      arr.push(isKey ? entry.key : entry.value);
      entry = entry.next;
    }
  return arr;
}, each: function(fn, scope, reverse) {
  var me = this, entry = reverse ? me.last : me.first, length = me.length;
  scope = scope || me;
  while (entry) 
    {
      if (fn.call(scope, entry.key, entry.value, length) === false) 
      {
        break;
      }
      entry = reverse ? entry.prev : entry.next;
    }
  return me;
}, findKey: function(value) {
  var key, map = this.map;
  for (key in map) 
    {
      if (map.hasOwnProperty(key) && map[key].value === value) 
      {
        return key;
      }
    }
  return undefined;
}, clone: function() {
  var newCache = new this.self(this.initialConfig), map = this.map, key;
  newCache.suspendEvents();
  for (key in map) 
    {
      if (map.hasOwnProperty(key)) 
      {
        newCache.add(key, map[key].value);
      }
    }
  newCache.resumeEvents();
  return newCache;
}, prune: function() {
  var me = this, purgeCount = me.maxSize ? (me.length - me.maxSize) : 0;
  if (purgeCount > 0) 
  {
    for (; me.first && purgeCount; purgeCount--) 
      {
        me.removeAtKey(me.first.key);
      }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'LruCache'], 0));
;

(Ext.cmd.derive('Ext.ComponentQuery', Ext.Base, {singleton: true}, 0, 0, 0, 0, 0, 0, [Ext, 'ComponentQuery'], function() {
  var cq = this, domQueryOperators = Ext.dom.Query.operators, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/, stripLeadingSpaceRe = /^(\s)+/, unescapeRe = /\\(.)/g, regexCache = new Ext.util.LruCache({maxSize: 100}), filterFnPattern = ['var r = [],', 'i = 0,', 'it = items,', 'l = it.length,', 'c;', 'for (; i < l; i++) {', 'c = it[i];', 'if (c.{0}) {', 'r.push(c);', '}', '}', 'return r;'].join(''), filterItems = function(items, operation) {
  return operation.method.apply(this, [items].concat(operation.args));
}, getItems = function(items, mode) {
  var result = [], i = 0, length = items.length, candidate, deep = mode !== '>';
  for (; i < length; i++) 
    {
      candidate = items[i];
      if (candidate.getRefItems) 
      {
        result = result.concat(candidate.getRefItems(deep));
      }
    }
  return result;
}, getAncestors = function(items) {
  var result = [], i = 0, length = items.length, candidate;
  for (; i < length; i++) 
    {
      candidate = items[i];
      while (!!(candidate = candidate.getRefOwner())) 
        {
          result.push(candidate);
        }
    }
  return result;
}, filterByXType = function(items, xtype, shallow) {
  if (xtype === '*') 
  {
    return items.slice();
  } else {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) 
      {
        candidate = items[i];
        if (candidate.isXType(xtype, shallow)) 
        {
          result.push(candidate);
        }
      }
    return result;
  }
}, filterByAttribute = function(items, property, operator, compareTo) {
  var result = [], i = 0, length = items.length, mustBeOwnProperty, presenceOnly, candidate, propValue, j, propLen;
  if (property.charAt(0) === '@') 
  {
    mustBeOwnProperty = true;
    property = property.substr(1);
  }
  if (property.charAt(0) === '?') 
  {
    mustBeOwnProperty = true;
    presenceOnly = true;
    property = property.substr(1);
  }
  for (; i < length; i++) 
    {
      candidate = items[i];
      if (!mustBeOwnProperty || candidate.hasOwnProperty(property)) 
      {
        propValue = candidate[property];
        if (presenceOnly) 
        {
          result.push(candidate);
        } else if (operator === '~=') 
        {
          if (propValue) 
          {
            if (!Ext.isArray(propValue)) 
            {
              propValue = propValue.split(' ');
            }
            for (j = 0 , propLen = propValue.length; j < propLen; j++) 
              {
                if (domQueryOperators[operator](Ext.coerce(propValue[j], compareTo), compareTo)) 
                {
                  result.push(candidate);
                  break;
                }
              }
          }
        } else if (operator === '/=') 
        {
          if (candidate[property] !== undefined && compareTo.test(candidate[property])) 
          {
            result.push(candidate);
          }
        } else if (!compareTo ? !!candidate[property] : domQueryOperators[operator](Ext.coerce(propValue, compareTo), compareTo)) 
        {
          result.push(candidate);
        }
      }
    }
  return result;
}, filterById = function(items, id) {
  var result = [], i = 0, length = items.length, candidate;
  for (; i < length; i++) 
    {
      candidate = items[i];
      if (candidate.getItemId() === id) 
      {
        result.push(candidate);
      }
    }
  return result;
}, filterByPseudo = function(items, name, value) {
  return cq.pseudos[name](items, value);
}, modeRe = /^(\s?([>\^])\s?|\s|$)/, tokenRe = /^(#)?((?:\\\.|[\w\-])+|\*)(?:\((true|false)\))?/, matchers = [{re: /^\.((?:\\\.|[\w\-])+)(?:\((true|false)\))?/, method: filterByXType, argTransform: function(args) {
  if (args[1] !== undefined) 
  {
    args[1] = args[1].replace(unescapeRe, '$1');
  }
  return args.slice(1);
}}, {re: /^(?:\[((?:[@?$])?[\w\-]*)\s*(?:([\^$*~%!\/]?=)\s*(['"])?((?:\\\]|.)*?)\3)?(?!\\)\])/, method: filterByAttribute, argTransform: function(args) {
  var selector = args[0], property = args[1], operator = args[2], quote = args[3], compareTo = args[4], compareRe;
  if (compareTo !== undefined) 
  {
    compareTo = compareTo.replace(unescapeRe, '$1');
  }
  if (operator === '/=') 
  {
    compareRe = regexCache.get(compareTo);
    if (compareRe) 
    {
      compareTo = compareRe;
    } else {
      compareTo = regexCache.add(compareTo, new RegExp(compareTo));
    }
  }
  return [property, operator, compareTo];
}}, {re: /^#((?:\\\.|[\w\-])+)/, method: filterById}, {re: /^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/, method: filterByPseudo, argTransform: function(args) {
  if (args[2] !== undefined) 
  {
    args[2] = args[2].replace(unescapeRe, '$1');
  }
  return args.slice(1);
}}, {re: /^(?:\{([^\}]+)\})/, method: filterFnPattern}];
  cq.Query = Ext.extend(Object, {constructor: function(cfg) {
  cfg = cfg || {};
  Ext.apply(this, cfg);
}, execute: function(root) {
  var operations = this.operations, result = [], op, i, len;
  for (i = 0 , len = operations.length; i < len; i++) 
    {
      op = operations[i];
      result = result.concat(this._execute(root, op));
    }
  return result;
}, _execute: function(root, operations) {
  var i = 0, length = operations.length, operation, workingItems;
  if (!root) 
  {
    workingItems = Ext.ComponentManager.all.getArray();
  } else if (Ext.isIterable(root)) 
  {
    workingItems = root;
  } else if (root.isMixedCollection) 
  {
    workingItems = root.items;
  }
  for (; i < length; i++) 
    {
      operation = operations[i];
      if (operation.mode === '^') 
      {
        workingItems = getAncestors(workingItems || [root]);
      } else if (operation.mode) 
      {
        workingItems = getItems(workingItems || [root], operation.mode);
      } else {
        workingItems = filterItems(workingItems || getItems([root]), operation);
      }
      if (i === length - 1) 
      {
        return workingItems;
      }
    }
  return [];
}, is: function(component) {
  var operations = this.operations, result = false, len = operations.length, op, i;
  if (len === 0) 
  {
    return true;
  }
  for (i = 0; i < len; i++) 
    {
      op = operations[i];
      result = this._is(component, op);
      if (result) 
      {
        return result;
      }
    }
  return false;
}, _is: function(component, operations) {
  var len = operations.length, active = [component], operation, i, j, mode, matches, items, item;
  for (i = len - 1; i >= 0; --i) 
    {
      operation = operations[i];
      mode = operation.mode;
      if (mode) 
      {
        if (mode === '^') 
        {
          active = getItems(active, ' ');
        } else if (mode === '>') 
        {
          items = [];
          for (j = 0 , len = active.length; j < len; ++j) 
            {
              item = active[j].getRefOwner();
              if (item) 
              {
                items.push(item);
              }
            }
          active = items;
        } else {
          active = getAncestors(active);
        }
        if (active.length === 0) 
        {
          return false;
        }
      } else {
        active = filterItems(active, operation);
        if (active.length === 0) 
        {
          return false;
        }
      }
    }
  return true;
}, getMatches: function(components, operations) {
  var len = operations.length, i;
  for (i = 0; i < len; ++i) 
    {
      components = filterItems(components, operations[i]);
      if (components.length === 0) 
      {
        break;
      }
    }
  return components;
}, isMultiMatch: function() {
  return this.operations.length > 1;
}});
  Ext.apply(this, {cache: new Ext.util.LruCache({maxSize: 100}), pseudos: {not: function(components, selector) {
  var CQ = Ext.ComponentQuery, i = 0, length = components.length, results = [], index = -1, component;
  for (; i < length; ++i) 
    {
      component = components[i];
      if (!CQ.is(component, selector)) 
      {
        results[++index] = component;
      }
    }
  return results;
}, first: function(components) {
  var ret = [];
  if (components.length > 0) 
  {
    ret.push(components[0]);
  }
  return ret;
}, last: function(components) {
  var len = components.length, ret = [];
  if (len > 0) 
  {
    ret.push(components[len - 1]);
  }
  return ret;
}, focusable: function(cmps) {
  var len = cmps.length, results = [], i = 0, c;
  for (; i < len; i++) 
    {
      c = cmps[i];
      if (c.isFocusable()) 
      {
        results.push(c);
      }
    }
  return results;
}, "nth-child": function(c, a) {
  var result = [], m = nthRe.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !nthRe2.test(a) && "n+" + a || a), f = (m[1] || 1) - 0, l = m[2] - 0, i, n, nodeIndex;
  for (i = 0; n = c[i]; i++) 
    {
      nodeIndex = i + 1;
      if (f == 1) 
      {
        if (l == 0 || nodeIndex == l) 
        {
          result.push(n);
        }
      } else if ((nodeIndex + l) % f == 0) 
      {
        result.push(n);
      }
    }
  return result;
}}, query: function(selector, root) {
  if (!selector) 
  {
    return Ext.ComponentManager.all.getArray();
  }
  var results = [], noDupResults = [], dupMatcher = {}, query = this.cache.get(selector), resultsLn, cmp, i;
  if (!query) 
  {
    query = this.cache.add(selector, this.parse(selector));
  }
  results = query.execute(root);
  if (query.isMultiMatch()) 
  {
    resultsLn = results.length;
    for (i = 0; i < resultsLn; i++) 
      {
        cmp = results[i];
        if (!dupMatcher[cmp.id]) 
        {
          noDupResults.push(cmp);
          dupMatcher[cmp.id] = true;
        }
      }
    results = noDupResults;
  }
  return results;
}, visitPreOrder: function(selector, root, fn, scope, extraArgs) {
  this._visit(true, selector, root, fn, scope, extraArgs);
}, visitPostOrder: function(selector, root, fn, scope, extraArgs) {
  this._visit(false, selector, root, fn, scope, extraArgs);
}, _visit: function(preOrder, selector, root, fn, scope, extraArgs) {
  var me = this, query = me.cache.get(selector), callArgs = [root], children, len = 0, i, rootMatch;
  if (!query) 
  {
    query = me.cache.add(selector, me.parse(selector));
  }
  rootMatch = query.is(root);
  if (root.getRefItems) 
  {
    children = root.getRefItems();
    len = children.length;
  }
  if (extraArgs) 
  {
    Ext.Array.push(callArgs, extraArgs);
  }
  if (preOrder) 
  {
    if (rootMatch) 
    {
      if (fn.apply(scope || root, callArgs) === false) 
      {
        return false;
      }
    }
  }
  for (i = 0; i < len; i++) 
    {
      if (me._visit.call(me, preOrder, selector, children[i], fn, scope, extraArgs) === false) 
      {
        return false;
      }
    }
  if (!preOrder) 
  {
    if (rootMatch) 
    {
      if (fn.apply(scope || root, callArgs) === false) 
      {
        return false;
      }
    }
  }
}, is: function(component, selector) {
  if (!selector) 
  {
    return true;
  }
  var query = this.cache.get(selector);
  if (!query) 
  {
    query = this.cache.add(selector, this.parse(selector));
  }
  return query.is(component);
}, parse: function(selector) {
  var operations = [], selectors, sel, i, len;
  selectors = Ext.splitAndUnescape(selector, ',');
  for (i = 0 , len = selectors.length; i < len; i++) 
    {
      sel = Ext.String.trim(selectors[i]);
      operations.push(this._parse(sel));
    }
  return new cq.Query({operations: operations});
}, _parse: function(selector) {
  var operations = [], trim = Ext.String.trim, length = matchers.length, lastSelector, tokenMatch, token, matchedChar, modeMatch, selectorMatch, transform, i, matcher, method, args;
  while (selector && lastSelector !== selector) 
    {
      lastSelector = selector;
      tokenMatch = selector.match(tokenRe);
      if (tokenMatch) 
      {
        matchedChar = tokenMatch[1];
        token = trim(tokenMatch[2]).replace(unescapeRe, '$1');
        if (matchedChar === '#') 
        {
          operations.push({method: filterById, args: [token]});
        } else {
          operations.push({method: filterByXType, args: [token, Boolean(tokenMatch[3])]});
        }
        selector = selector.replace(tokenMatch[0], '').replace(stripLeadingSpaceRe, '$1');
      }
      while (!(modeMatch = selector.match(modeRe))) 
        {
          for (i = 0; selector && i < length; i++) 
            {
              matcher = matchers[i];
              selectorMatch = selector.match(matcher.re);
              method = matcher.method;
              transform = matcher.argTransform;
              if (selectorMatch) 
              {
                if (transform) 
                {
                  args = transform(selectorMatch);
                } else {
                  args = selectorMatch.slice(1);
                }
                operations.push({method: Ext.isString(matcher.method) ? Ext.functionFactory('items', Ext.String.format.apply(Ext.String, [method].concat(selectorMatch.slice(1)))) : matcher.method, args: args});
                selector = selector.replace(selectorMatch[0], '').replace(stripLeadingSpaceRe, '$1');
                break;
              }
              if (i === (length - 1)) 
              {
                Ext.Error.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"');
              }
            }
        }
      if (modeMatch[1]) 
      {
        operations.push({mode: modeMatch[2] || modeMatch[1]});
        selector = selector.replace(modeMatch[0], '').replace(stripLeadingSpaceRe, '');
      }
    }
  return operations;
}});
}));
;

(Ext.cmd.derive('Ext.util.ProtoElement', Ext.Base, (function() {
  var splitWords = Ext.String.splitWords, toMap = Ext.Array.toMap;
  return {isProtoEl: true, clsProp: 'cls', styleProp: 'style', removedProp: 'removed', styleIsText: false, constructor: function(config) {
  var me = this;
  Ext.apply(me, config);
  me.classList = splitWords(me.cls);
  me.classMap = toMap(me.classList);
  delete me.cls;
  if (Ext.isFunction(me.style)) 
  {
    me.styleFn = me.style;
    delete me.style;
  } else if (typeof me.style == 'string') 
  {
    me.style = Ext.Element.parseStyles(me.style);
  } else if (me.style) 
  {
    me.style = Ext.apply({}, me.style);
  }
}, flush: function() {
  this.flushClassList = [];
  this.removedClasses = {};
  delete this.style;
  delete this.unselectableAttr;
}, addCls: function(cls) {
  var me = this, add = (typeof cls === 'string') ? splitWords(cls) : cls, length = add.length, list = me.classList, map = me.classMap, flushList = me.flushClassList, i = 0, c;
  for (; i < length; ++i) 
    {
      c = add[i];
      if (!map[c]) 
      {
        map[c] = true;
        list.push(c);
        if (flushList) 
        {
          flushList.push(c);
          delete me.removedClasses[c];
        }
      }
    }
  return me;
}, hasCls: function(cls) {
  return cls in this.classMap;
}, removeCls: function(cls) {
  var me = this, list = me.classList, newList = (me.classList = []), remove = toMap(splitWords(cls)), length = list.length, map = me.classMap, removedClasses = me.removedClasses, i, c;
  for (i = 0; i < length; ++i) 
    {
      c = list[i];
      if (remove[c]) 
      {
        if (removedClasses) 
        {
          if (map[c]) 
          {
            removedClasses[c] = true;
            Ext.Array.remove(me.flushClassList, c);
          }
        }
        delete map[c];
      } else {
        newList.push(c);
      }
    }
  return me;
}, setStyle: function(prop, value) {
  var me = this, style = me.style || (me.style = {});
  if (typeof prop == 'string') 
  {
    if (arguments.length === 1) 
    {
      me.setStyle(Ext.Element.parseStyles(prop));
    } else {
      style[prop] = value;
    }
  } else {
    Ext.apply(style, prop);
  }
  return me;
}, unselectable: function() {
  this.addCls(Ext.dom.Element.unselectableCls);
  if (Ext.isOpera) 
  {
    this.unselectableAttr = true;
  }
}, writeTo: function(to) {
  var me = this, classList = me.flushClassList || me.classList, removedClasses = me.removedClasses, style;
  if (me.styleFn) 
  {
    style = Ext.apply({}, me.styleFn());
    Ext.apply(style, me.style);
  } else {
    style = me.style;
  }
  to[me.clsProp] = classList.join(' ');
  if (style) 
  {
    to[me.styleProp] = me.styleIsText ? Ext.DomHelper.generateStyles(style, null, true) : style;
  }
  if (removedClasses) 
  {
    removedClasses = Ext.Object.getKeys(removedClasses);
    if (removedClasses.length) 
    {
      to[me.removedProp] = removedClasses.join(' ');
    }
  }
  if (me.unselectableAttr) 
  {
    to.unselectable = 'on';
  }
  return to;
}};
}()), 1, 0, 0, 0, 0, 0, [Ext.util, 'ProtoElement'], 0));
;

(Ext.cmd.derive('Ext.PluginManager', Ext.AbstractManager, {alternateClassName: 'Ext.PluginMgr', singleton: true, typeName: 'ptype', create: function(config, defaultType, host) {
  var result;
  if (config.init) 
  {
    result = config;
  } else {
    if (host) 
    {
      config = Ext.apply({}, config);
      config.cmp = host;
    } else {
      host = config.cmp;
    }
    if (config.xclass) 
    {
      result = Ext.create(config);
    } else {
      result = Ext.ClassManager.getByAlias(('plugin.' + (config.ptype || defaultType)));
      if (typeof result === 'function') 
      {
        result = new result(config);
      }
    }
  }
  if (result && host && result.setCmp && !result.setCmpCalled) 
  {
    result.setCmp(host);
    result.setCmpCalled = true;
  }
  return result;
}, findByType: function(type, defaultsOnly) {
  var matches = [], types = this.types, name, item;
  for (name in types) 
    {
      if (!types.hasOwnProperty(name)) 
      {
        continue;
      }
      item = types[name];
      if (item.type == type && (!defaultsOnly || (defaultsOnly === true && item.isDefault))) 
      {
        matches.push(item);
      }
    }
  return matches;
}}, 0, 0, 0, 0, 0, 0, [Ext, 'PluginManager', Ext, 'PluginMgr'], function() {
  Ext.preg = function() {
  return Ext.PluginManager.registerType.apply(Ext.PluginManager, arguments);
};
}));
;

(Ext.cmd.derive('Ext.util.Filter', Ext.Base, {id: null, anyMatch: false, exactMatch: false, caseSensitive: false, disabled: false, operator: null, statics: {createFilterFn: function(filters) {
  return filters && filters.length ? function(candidate) {
  var isMatch = true, length = filters.length, i, filter;
  for (i = 0; isMatch && i < length; i++) 
    {
      filter = filters[i];
      if (!filter.disabled) 
      {
        isMatch = isMatch && filter.filterFn.call(filter.scope || filter, candidate);
      }
    }
  return isMatch;
} : function() {
  return true;
};
}}, operatorFns: {"<": function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) < this.value;
}, "<=": function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) <= this.value;
}, "=": function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) == this.value;
}, ">=": function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) >= this.value;
}, ">": function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) > this.value;
}, "!=": function(candidate) {
  return Ext.coerce(this.getRoot(candidate)[this.property], this.value) != this.value;
}}, constructor: function(config) {
  var me = this;
  me.initialConfig = config;
  Ext.apply(me, config);
  me.filter = me.filter || me.filterFn;
  if (me.filter === undefined) 
  {
    me.setValue(config.value);
  }
}, setValue: function(value) {
  var me = this;
  me.value = value;
  if (me.property === undefined || me.value === undefined) 
  {
  } else {
    me.filter = me.createFilterFn();
  }
  me.filterFn = me.filter;
}, setFilterFn: function(filterFn) {
  this.filterFn = this.filter = filterFn;
}, createFilterFn: function() {
  var me = this, matcher = me.createValueMatcher(), property = me.property;
  if (me.operator) 
  {
    return me.operatorFns[me.operator];
  } else {
    return function(item) {
  var value = me.getRoot(item)[property];
  return matcher === null ? value === null : matcher.test(value);
};
  }
}, getRoot: function(item) {
  var root = this.root;
  return root === undefined ? item : item[root];
}, createValueMatcher: function() {
  var me = this, value = me.value, anyMatch = me.anyMatch, exactMatch = me.exactMatch, caseSensitive = me.caseSensitive, escapeRe = Ext.String.escapeRegex;
  if (value === null) 
  {
    return value;
  }
  if (!value.exec) 
  {
    value = String(value);
    if (anyMatch === true) 
    {
      value = escapeRe(value);
    } else {
      value = '^' + escapeRe(value);
      if (exactMatch === true) 
      {
        value += '$';
      }
    }
    value = new RegExp(value, caseSensitive ? '' : 'i');
  }
  return value;
}, serialize: function() {
  var me = this, result = Ext.apply({}, me.initialConfig);
  result.value = me.value;
  return result;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Filter'], function() {
  this.prototype.operatorFns['=='] = this.prototype.operatorFns['='];
}));
;

(Ext.cmd.derive('Ext.util.AbstractMixedCollection', Ext.Base, {isMixedCollection: true, generation: 0, indexGeneration: 0, constructor: function(allowFunctions, keyFn) {
  var me = this;
  if (arguments.length === 1 && Ext.isObject(allowFunctions)) 
  {
    me.initialConfig = allowFunctions;
    Ext.apply(me, allowFunctions);
  } else {
    me.allowFunctions = allowFunctions === true;
    if (keyFn) 
    {
      me.getKey = keyFn;
    }
    me.initialConfig = {allowFunctions: me.allowFunctions, getKey: me.getKey};
  }
  me.items = [];
  me.map = {};
  me.keys = [];
  me.indexMap = {};
  me.length = 0;
  me.mixins.observable.constructor.call(me);
}, allowFunctions: false, add: function(key, obj) {
  var len = this.length, out;
  if (arguments.length === 1) 
  {
    out = this.insert(len, key);
  } else {
    out = this.insert(len, key, obj);
  }
  return out;
}, getKey: function(o) {
  return o.id;
}, replace: function(key, o) {
  var me = this, old, index;
  if (arguments.length == 1) 
  {
    o = arguments[0];
    key = me.getKey(o);
  }
  old = me.map[key];
  if (typeof key == 'undefined' || key === null || typeof old == 'undefined') 
  {
    return me.add(key, o);
  }
  me.generation++;
  index = me.indexOfKey(key);
  me.items[index] = o;
  me.map[key] = o;
  if (me.hasListeners.replace) 
  {
    me.fireEvent('replace', key, old, o);
  }
  return o;
}, updateKey: function(oldKey, newKey) {
  var me = this, map = me.map, index = me.indexOfKey(oldKey), indexMap = me.indexMap, item;
  if (index > -1) 
  {
    item = map[oldKey];
    delete map[oldKey];
    delete indexMap[oldKey];
    map[newKey] = item;
    indexMap[newKey] = index;
    me.keys[index] = newKey;
    me.indexGeneration = ++me.generation;
  }
}, addAll: function(objs) {
  var me = this, key;
  if (arguments.length > 1 || Ext.isArray(objs)) 
  {
    me.insert(me.length, arguments.length > 1 ? arguments : objs);
  } else {
    for (key in objs) 
      {
        if (objs.hasOwnProperty(key)) 
        {
          if (me.allowFunctions || typeof objs[key] != 'function') 
          {
            me.add(key, objs[key]);
          }
        }
      }
  }
}, each: function(fn, scope) {
  var items = Ext.Array.push([], this.items), i = 0, len = items.length, item;
  for (; i < len; i++) 
    {
      item = items[i];
      if (fn.call(scope || item, item, i, len) === false) 
      {
        break;
      }
    }
}, eachKey: function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = keys.length;
  for (; i < len; i++) 
    {
      fn.call(scope || window, keys[i], items[i], i, len);
    }
}, findBy: function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = items.length;
  for (; i < len; i++) 
    {
      if (fn.call(scope || window, items[i], keys[i])) 
      {
        return items[i];
      }
    }
  return null;
}, insert: function(index, key, obj) {
  var out;
  if (Ext.isIterable(key)) 
  {
    out = this.doInsert(index, key, obj);
  } else {
    if (arguments.length > 2) 
    {
      out = this.doInsert(index, [key], [obj]);
    } else {
      out = this.doInsert(index, [key]);
    }
    out = out[0];
  }
  return out;
}, doInsert: function(index, keys, objects) {
  var me = this, itemKey, removeIndex, i, len = keys.length, deDupedLen = len, fireAdd = me.hasListeners.add, syncIndices, newKeys = {}, passedDuplicates, oldKeys, oldObjects;
  if (objects != null) 
  {
    me.useLinearSearch = true;
  } else {
    objects = keys;
    keys = new Array(len);
    for (i = 0; i < len; i++) 
      {
        keys[i] = this.getKey(objects[i]);
      }
  }
  me.suspendEvents();
  for (i = 0; i < len; i++) 
    {
      itemKey = keys[i];
      removeIndex = me.indexOfKey(itemKey);
      if (removeIndex !== -1) 
      {
        if (removeIndex < index) 
        {
          index--;
        }
        me.removeAt(removeIndex);
      }
      if (itemKey != null) 
      {
        if (newKeys[itemKey] != null) 
        {
          passedDuplicates = true;
          deDupedLen--;
        }
        newKeys[itemKey] = i;
      }
    }
  me.resumeEvents();
  if (passedDuplicates) 
  {
    oldKeys = keys;
    oldObjects = objects;
    keys = new Array(deDupedLen);
    objects = new Array(deDupedLen);
    i = 0;
    for (itemKey in newKeys) 
      {
        keys[i] = oldKeys[newKeys[itemKey]];
        objects[i] = oldObjects[newKeys[itemKey]];
        i++;
      }
    len = deDupedLen;
  }
  syncIndices = index === me.length && me.indexGeneration === me.generation;
  Ext.Array.insert(me.items, index, objects);
  Ext.Array.insert(me.keys, index, keys);
  me.length += len;
  me.generation++;
  if (syncIndices) 
  {
    me.indexGeneration = me.generation;
  }
  for (i = 0; i < len; i++ , index++) 
    {
      itemKey = keys[i];
      if (itemKey != null) 
      {
        me.map[itemKey] = objects[i];
        if (syncIndices) 
        {
          me.indexMap[itemKey] = index;
        }
      }
      if (fireAdd) 
      {
        me.fireEvent('add', index, objects[i], itemKey);
      }
    }
  return objects;
}, remove: function(o) {
  var me = this, removeKey, index;
  if (!me.useLinearSearch && (removeKey = me.getKey(o))) 
  {
    index = me.indexOfKey(removeKey);
  } else {
    index = Ext.Array.indexOf(me.items, o);
  }
  return (index === -1) ? false : me.removeAt(index);
}, removeAll: function(items) {
  var me = this, i;
  if (items || me.hasListeners.remove) 
  {
    if (items) 
    {
      for (i = items.length - 1; i >= 0; --i) 
        {
          me.remove(items[i]);
        }
    } else {
      while (me.length) 
        {
          me.removeAt(0);
        }
    }
  } else {
    me.length = me.items.length = me.keys.length = 0;
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
}, removeAt: function(index) {
  var me = this, o, key;
  if (index < me.length && index >= 0) 
  {
    me.length--;
    o = me.items[index];
    Ext.Array.erase(me.items, index, 1);
    key = me.keys[index];
    if (typeof key != 'undefined') 
    {
      delete me.map[key];
    }
    Ext.Array.erase(me.keys, index, 1);
    if (me.hasListeners.remove) 
    {
      me.fireEvent('remove', o, key);
    }
    me.generation++;
    return o;
  }
  return false;
}, removeRange: function(index, removeCount) {
  var me = this, o, key, i, limit, syncIndices, trimming;
  if (index < me.length && index >= 0) 
  {
    if (!removeCount) 
    {
      removeCount = 1;
    }
    limit = Math.min(index + removeCount, me.length);
    removeCount = limit - index;
    trimming = limit === me.length;
    syncIndices = trimming && me.indexGeneration === me.generation;
    for (i = index; i < limit; i++) 
      {
        key = me.keys[i];
        if (key != null) 
        {
          delete me.map[key];
          if (syncIndices) 
          {
            delete me.indexMap[key];
          }
        }
      }
    o = me.items[i - 1];
    me.length -= removeCount;
    me.generation++;
    if (syncIndices) 
    {
      me.indexGeneration = me.generation;
    }
    if (trimming) 
    {
      me.items.length = me.keys.length = me.length;
    } else {
      me.items.splice(index, removeCount);
      me.keys.splice(index, removeCount);
    }
    return o;
  }
  return false;
}, removeAtKey: function(key) {
  var me = this, keys = me.keys, i;
  if (key == null) 
  {
    for (i = keys.length - 1; i >= 0; i--) 
      {
        if (keys[i] == null) 
        {
          me.removeAt(i);
        }
      }
  } else {
    return me.removeAt(me.indexOfKey(key));
  }
}, getCount: function() {
  return this.length;
}, indexOf: function(o) {
  var me = this, key;
  if (o != null) 
  {
    if (!me.useLinearSearch && (key = me.getKey(o))) 
    {
      return this.indexOfKey(key);
    }
    return Ext.Array.indexOf(me.items, o);
  }
  return -1;
}, indexOfKey: function(key) {
  if (!this.map.hasOwnProperty(key)) 
  {
    return -1;
  }
  if (this.indexGeneration !== this.generation) 
  {
    this.rebuildIndexMap();
  }
  return this.indexMap[key];
}, rebuildIndexMap: function() {
  var me = this, indexMap = me.indexMap = {}, keys = me.keys, len = keys.length, i;
  for (i = 0; i < len; i++) 
    {
      indexMap[keys[i]] = i;
    }
  me.indexGeneration = me.generation;
}, get: function(key) {
  var me = this, mk = me.map[key], item = mk !== undefined ? mk : (typeof key == 'number') ? me.items[key] : undefined;
  return typeof item != 'function' || me.allowFunctions ? item : null;
}, getAt: function(index) {
  return this.items[index];
}, getByKey: function(key) {
  return this.map[key];
}, contains: function(o) {
  var me = this, key;
  if (o != null) 
  {
    if (!me.useLinearSearch && (key = me.getKey(o))) 
    {
      return this.map[key] != null;
    }
    return Ext.Array.indexOf(this.items, o) !== -1;
  }
  return false;
}, containsKey: function(key) {
  return this.map.hasOwnProperty(key);
}, clear: function() {
  var me = this;
  if (me.generation) 
  {
    me.length = 0;
    me.items = [];
    me.keys = [];
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
  if (me.hasListeners.clear) 
  {
    me.fireEvent('clear');
  }
}, first: function() {
  return this.items[0];
}, last: function() {
  return this.items[this.length - 1];
}, sum: function(property, root, start, end) {
  var values = this.extractValues(property, root), length = values.length, sum = 0, i;
  start = start || 0;
  end = (end || end === 0) ? end : length - 1;
  for (i = start; i <= end; i++) 
    {
      sum += values[i];
    }
  return sum;
}, collect: function(property, root, allowNull) {
  var values = this.extractValues(property, root), length = values.length, hits = {}, unique = [], value, strValue, i;
  for (i = 0; i < length; i++) 
    {
      value = values[i];
      strValue = String(value);
      if ((allowNull || !Ext.isEmpty(value)) && !hits[strValue]) 
      {
        hits[strValue] = true;
        unique.push(value);
      }
    }
  return unique;
}, extractValues: function(property, root) {
  var values = this.items;
  if (root) 
  {
    values = Ext.Array.pluck(values, root);
  }
  return Ext.Array.pluck(values, property);
}, hasRange: function(start, end) {
  return (end < this.length);
}, getRange: function(start, end) {
  var me = this, items = me.items, range = [], len = items.length, tmp, reverse;
  if (len < 1) 
  {
    return range;
  }
  if (start > end) 
  {
    reverse = true;
    tmp = start;
    start = end;
    end = tmp;
  }
  if (start < 0) 
  {
    start = 0;
  }
  if (end == null || end >= len) 
  {
    end = len - 1;
  }
  range = items.slice(start, end + 1);
  if (reverse && range.length) 
  {
    range.reverse();
  }
  return range;
}, filter: function(property, value, anyMatch, caseSensitive) {
  var filters = [];
  if (Ext.isString(property)) 
  {
    filters.push(new Ext.util.Filter({property: property, value: value, anyMatch: anyMatch, caseSensitive: caseSensitive}));
  } else if (Ext.isArray(property) || property instanceof Ext.util.Filter) 
  {
    filters = filters.concat(property);
  }
  return this.filterBy(Ext.util.Filter.createFilterFn(filters));
}, filterBy: function(fn, scope) {
  var me = this, newMC = new me.self(me.initialConfig), keys = me.keys, items = me.items, length = items.length, i;
  newMC.getKey = me.getKey;
  for (i = 0; i < length; i++) 
    {
      if (fn.call(scope || me, items[i], keys[i])) 
      {
        newMC.add(keys[i], items[i]);
      }
    }
  newMC.useLinearSearch = me.useLinearSearch;
  return newMC;
}, findIndex: function(property, value, start, anyMatch, caseSensitive) {
  if (Ext.isEmpty(value, false)) 
  {
    return -1;
  }
  value = this.createValueMatcher(value, anyMatch, caseSensitive);
  return this.findIndexBy(function(o) {
  return o && value.test(o[property]);
}, null, start);
}, findIndexBy: function(fn, scope, start) {
  var me = this, keys = me.keys, items = me.items, i = start || 0, len = items.length;
  for (; i < len; i++) 
    {
      if (fn.call(scope || me, items[i], keys[i])) 
      {
        return i;
      }
    }
  return -1;
}, createValueMatcher: function(value, anyMatch, caseSensitive, exactMatch) {
  if (!value.exec) 
  {
    var er = Ext.String.escapeRegex;
    value = String(value);
    if (anyMatch === true) 
    {
      value = er(value);
    } else {
      value = '^' + er(value);
      if (exactMatch === true) 
      {
        value += '$';
      }
    }
    value = new RegExp(value, caseSensitive ? '' : 'i');
  }
  return value;
}, clone: function() {
  var me = this, copy = new me.self(me.initialConfig);
  copy.add(me.keys, me.items);
  copy.useLinearSearch = me.useLinearSearch;
  return copy;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.util, 'AbstractMixedCollection'], 0));
;

(Ext.cmd.derive('Ext.util.Sorter', Ext.Base, {direction: "ASC", constructor: function(config) {
  var me = this;
  Ext.apply(me, config);
  if (me.direction) 
  {
    me.direction = me.direction.toUpperCase();
  }
  me.updateSortFunction();
}, createSortFunction: function(sorterFn) {
  var me = this, direction = me.direction || "ASC", modifier = direction == "DESC" ? -1 : 1;
  return function(o1, o2) {
  return modifier * sorterFn.call(me, o1, o2);
};
}, defaultSorterFn: function(o1, o2) {
  var me = this, transform = me.transform, v1 = me.getRoot(o1)[me.property], v2 = me.getRoot(o2)[me.property];
  if (transform) 
  {
    v1 = transform(v1);
    v2 = transform(v2);
  }
  return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
}, getRoot: function(item) {
  return this.root === undefined ? item : item[this.root];
}, setDirection: function(direction) {
  var me = this;
  me.direction = direction ? direction.toUpperCase() : direction;
  me.updateSortFunction();
}, toggle: function() {
  var me = this;
  me.direction = Ext.String.toggle(me.direction, "ASC", "DESC");
  me.updateSortFunction();
}, updateSortFunction: function(fn) {
  var me = this;
  fn = fn || me.sorterFn || me.defaultSorterFn;
  me.sort = me.createSortFunction(fn);
}, serialize: function() {
  return {root: this.root, property: this.property, direction: this.direction};
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Sorter'], 0));
;

(Ext.cmd.derive('Ext.util.Sortable', Ext.Base, {isSortable: true, defaultSortDirection: "ASC", multiSortLimit: 3, statics: {createComparator: function(sorters) {
  return sorters && sorters.length ? function(r1, r2) {
  var result = sorters[0].sort(r1, r2), length = sorters.length, i = 1;
  for (; !result && i < length; i++) 
    {
      result = sorters[i].sort.call(this, r1, r2);
    }
  return result;
} : function() {
  return 0;
};
}}, initSortable: function() {
  var me = this, sorters = me.sorters;
  me.sorters = new Ext.util.AbstractMixedCollection(false, function(item) {
  return item.id || item.property;
});
  if (sorters) 
  {
    me.sorters.addAll(me.decodeSorters(sorters));
  }
}, sort: function(sorters, direction, insertionPosition, doSort) {
  var me = this, sorter, overFlow;
  if (Ext.isArray(sorters)) 
  {
    doSort = insertionPosition;
    insertionPosition = direction;
  } else if (Ext.isObject(sorters)) 
  {
    sorters = [sorters];
    doSort = insertionPosition;
    insertionPosition = direction;
  } else if (Ext.isString(sorters)) 
  {
    sorter = me.sorters.get(sorters);
    if (!sorter) 
    {
      sorter = {property: sorters, direction: direction};
    } else if (direction == null) 
    {
      sorter.toggle();
    } else {
      sorter.setDirection(direction);
    }
    sorters = [sorter];
  }
  if (sorters && sorters.length) 
  {
    sorters = me.decodeSorters(sorters);
    switch (insertionPosition) {
      case "multi":
        me.sorters.insert(0, sorters[0]);
        overFlow = me.sorters.getCount() - me.multiSortLimit;
        if (overFlow > 0) 
        {
          me.sorters.removeRange(me.multiSortLimit, overFlow);
        }
        break;
      case "prepend":
        me.sorters.insert(0, sorters);
        break;
      case "append":
        me.sorters.addAll(sorters);
        break;
      case undefined:
      case null:
      case "replace":
        me.sorters.clear();
        me.sorters.addAll(sorters);
        break;
      default:
    }
  }
  if (doSort !== false) 
  {
    me.fireEvent('beforesort', me, sorters);
    me.onBeforeSort(sorters);
    if (me.getSorterCount()) 
    {
      me.doSort(me.generateComparator());
    }
  }
  return sorters;
}, getSorterCount: function() {
  return this.sorters.items.length;
}, generateComparator: function() {
  var sorters = this.sorters.getRange();
  return sorters.length ? this.createComparator(sorters) : this.emptyComparator;
}, emptyComparator: function() {
  return 0;
}, onBeforeSort: Ext.emptyFn, decodeSorters: function(sorters) {
  if (!Ext.isArray(sorters)) 
  {
    if (sorters === undefined) 
    {
      sorters = [];
    } else {
      sorters = [sorters];
    }
  }
  var length = sorters.length, Sorter = Ext.util.Sorter, fields = this.model ? this.model.prototype.fields : null, field, config, i;
  for (i = 0; i < length; i++) 
    {
      config = sorters[i];
      if (!(config instanceof Sorter)) 
      {
        if (Ext.isString(config)) 
        {
          config = {property: config};
        }
        Ext.applyIf(config, {root: this.sortRoot, direction: "ASC"});
        if (config.fn) 
        {
          config.sorterFn = config.fn;
        }
        if (typeof config == 'function') 
        {
          config = {sorterFn: config};
        }
        if (fields && !config.transform) 
        {
          field = fields.get(config.property);
          config.transform = field && field.sortType !== Ext.identityFn ? field.sortType : undefined;
        }
        sorters[i] = new Ext.util.Sorter(config);
      }
    }
  return sorters;
}, getSorters: function() {
  return this.sorters.items;
}, getFirstSorter: function() {
  var sorters = this.sorters.items, len = sorters.length, i = 0, sorter;
  for (; i < len; ++i) 
    {
      sorter = sorters[i];
      if (!sorter.isGrouper) 
      {
        return sorter;
      }
    }
  return null;
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Sortable'], function() {
  this.prototype.createComparator = this.createComparator;
}));
;

(Ext.cmd.derive('Ext.util.MixedCollection', Ext.util.AbstractMixedCollection, {constructor: function() {
  var me = this;
  me.callParent(arguments);
  me.addEvents('sort');
  me.mixins.sortable.initSortable.call(me);
}, doSort: function(sorterFn) {
  this.sortBy(sorterFn);
}, _sort: function(property, dir, fn) {
  var me = this, i, len, dsc = String(dir).toUpperCase() == 'DESC' ? -1 : 1, c = [], keys = me.keys, items = me.items, o;
  fn = fn || function(a, b) {
  return a - b;
};
  for (i = 0 , len = items.length; i < len; i++) 
    {
      c[c.length] = {key: keys[i], value: items[i], index: i};
    }
  Ext.Array.sort(c, function(a, b) {
  return fn(a[property], b[property]) * dsc || (a.index < b.index ? -1 : 1);
});
  for (i = 0 , len = c.length; i < len; i++) 
    {
      o = c[i];
      items[i] = o.value;
      keys[i] = o.key;
      me.indexMap[o.key] = i;
    }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me);
}, sortBy: function(sorterFn) {
  var me = this, items = me.items, item, keys = me.keys, key, length = items.length, i;
  for (i = 0; i < length; i++) 
    {
      items[i].$extCollectionIndex = i;
    }
  Ext.Array.sort(items, function(a, b) {
  return sorterFn(a, b) || (a.$extCollectionIndex < b.$extCollectionIndex ? -1 : 1);
});
  for (i = 0; i < length; i++) 
    {
      item = items[i];
      key = me.getKey(item);
      keys[i] = key;
      me.indexMap[key] = i;
      delete items.$extCollectionIndex;
    }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me, items, keys);
}, findInsertionIndex: function(newItem, sorterFn) {
  var me = this, items = me.items, start = 0, end = items.length - 1, middle, comparison;
  if (!sorterFn) 
  {
    sorterFn = me.generateComparator();
  }
  while (start <= end) 
    {
      middle = (start + end) >> 1;
      comparison = sorterFn(newItem, items[middle]);
      if (comparison >= 0) 
      {
        start = middle + 1;
      } else if (comparison < 0) 
      {
        end = middle - 1;
      }
    }
  return start;
}, reorder: function(mapping) {
  var me = this, items = me.items, index = 0, length = items.length, order = [], remaining = [], oldIndex;
  me.suspendEvents();
  for (oldIndex in mapping) 
    {
      order[mapping[oldIndex]] = items[oldIndex];
    }
  for (index = 0; index < length; index++) 
    {
      if (mapping[index] == undefined) 
      {
        remaining.push(items[index]);
      }
    }
  for (index = 0; index < length; index++) 
    {
      if (order[index] == undefined) 
      {
        order[index] = remaining.shift();
      }
    }
  me.clear();
  me.addAll(order);
  me.resumeEvents();
  me.fireEvent('sort', me);
}, sortByKey: function(dir, fn) {
  this._sort('key', dir, fn || function(a, b) {
  var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
  return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
});
}}, 1, 0, 0, 0, 0, [['sortable', Ext.util.Sortable]], [Ext.util, 'MixedCollection'], 0));
;

(Ext.cmd.derive('Ext.fx.target.Target', Ext.Base, {isAnimTarget: true, constructor: function(target) {
  this.target = target;
  this.id = this.getId();
}, getId: function() {
  return this.target.id;
}, remove: function() {
  Ext.destroy(this.target);
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.target, 'Target'], 0));
;

(Ext.cmd.derive('Ext.fx.target.Element', Ext.fx.target.Target, {type: 'element', getElVal: function(el, attr, val) {
  if (val == undefined) 
  {
    if (attr === 'x') 
    {
      val = el.getX();
    } else if (attr === 'y') 
    {
      val = el.getY();
    } else if (attr === 'scrollTop') 
    {
      val = el.getScroll().top;
    } else if (attr === 'scrollLeft') 
    {
      val = el.getScroll().left;
    } else if (attr === 'height') 
    {
      val = el.getHeight();
    } else if (attr === 'width') 
    {
      val = el.getWidth();
    } else {
      val = el.getStyle(attr);
    }
  }
  return val;
}, getAttr: function(attr, val) {
  var el = this.target;
  return [[el, this.getElVal(el, attr, val)]];
}, setAttr: function(targetData) {
  var target = this.target, ln = targetData.length, attrs, attr, o, i, j, ln2;
  for (i = 0; i < ln; i++) 
    {
      attrs = targetData[i].attrs;
      for (attr in attrs) 
        {
          if (attrs.hasOwnProperty(attr)) 
          {
            ln2 = attrs[attr].length;
            for (j = 0; j < ln2; j++) 
              {
                o = attrs[attr][j];
                this.setElVal(o[0], attr, o[1]);
              }
          }
        }
    }
}, setElVal: function(element, attr, value) {
  if (attr === 'x') 
  {
    element.setX(value);
  } else if (attr === 'y') 
  {
    element.setY(value);
  } else if (attr === 'scrollTop') 
  {
    element.scrollTo('top', value);
  } else if (attr === 'scrollLeft') 
  {
    element.scrollTo('left', value);
  } else if (attr === 'width') 
  {
    element.setWidth(value);
  } else if (attr === 'height') 
  {
    element.setHeight(value);
  } else {
    element.setStyle(attr, value);
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'Element'], 0));
;

(Ext.cmd.derive('Ext.fx.target.ElementCSS', Ext.fx.target.Element, {setAttr: function(targetData, isFirstFrame) {
  var cssArr = {attrs: [], duration: [], easing: []}, ln = targetData.length, attributes, attrs, attr, easing, duration, o, i, j, ln2;
  for (i = 0; i < ln; i++) 
    {
      attrs = targetData[i];
      duration = attrs.duration;
      easing = attrs.easing;
      attrs = attrs.attrs;
      for (attr in attrs) 
        {
          if (Ext.Array.indexOf(cssArr.attrs, attr) == -1) 
          {
            cssArr.attrs.push(attr.replace(/[A-Z]/g, function(v) {
  return '-' + v.toLowerCase();
}));
            cssArr.duration.push(duration + 'ms');
            cssArr.easing.push(easing);
          }
        }
    }
  attributes = cssArr.attrs.join(',');
  duration = cssArr.duration.join(',');
  easing = cssArr.easing.join(', ');
  for (i = 0; i < ln; i++) 
    {
      attrs = targetData[i].attrs;
      for (attr in attrs) 
        {
          ln2 = attrs[attr].length;
          for (j = 0; j < ln2; j++) 
            {
              o = attrs[attr][j];
              o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', isFirstFrame ? '' : attributes);
              o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', isFirstFrame ? '' : duration);
              o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', isFirstFrame ? '' : easing);
              o[0].setStyle(attr, o[1]);
              if (isFirstFrame) 
              {
                o = o[0].dom.offsetWidth;
              } else {
                o[0].on(Ext.supports.CSS3TransitionEnd, function() {
  this.setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', null);
  this.setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', null);
  this.setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', null);
}, o[0], {single: true});
              }
            }
        }
    }
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'ElementCSS'], 0));
;

(Ext.cmd.derive('Ext.fx.target.CompositeElement', Ext.fx.target.Element, {isComposite: true, constructor: function(target) {
  target.id = target.id || Ext.id(null, 'ext-composite-');
  this.callParent([target]);
}, getAttr: function(attr, val) {
  var out = [], target = this.target, elements = target.elements, length = elements.length, i, el;
  for (i = 0; i < length; i++) 
    {
      el = elements[i];
      if (el) 
      {
        el = target.getElement(el);
        out.push([el, this.getElVal(el, attr, val)]);
      }
    }
  return out;
}, setAttr: function(targetData) {
  var target = this.target, ln = targetData.length, elements = target.elements, ln3 = elements.length, value, k, attrs, attr, o, i, j, ln2;
  for (i = 0; i < ln; i++) 
    {
      attrs = targetData[i].attrs;
      for (attr in attrs) 
        {
          if (attrs.hasOwnProperty(attr)) 
          {
            ln2 = attrs[attr].length;
            for (j = 0; j < ln2; j++) 
              {
                value = attrs[attr][j][1];
                for (k = 0; k < ln3; ++k) 
                  {
                    el = elements[k];
                    if (el) 
                    {
                      el = target.getElement(el);
                      this.setElVal(el, attr, value);
                    }
                  }
              }
          }
        }
    }
}, remove: function() {
  this.target.remove();
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.target, 'CompositeElement'], 0));
;

(Ext.cmd.derive('Ext.fx.target.CompositeElementCSS', Ext.fx.target.CompositeElement, {setAttr: function() {
  return Ext.fx.target.ElementCSS.prototype.setAttr.apply(this, arguments);
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'CompositeElementCSS'], 0));
;

(Ext.cmd.derive('Ext.fx.target.Sprite', Ext.fx.target.Target, {type: 'draw', getFromPrim: function(sprite, attr) {
  var obj;
  switch (attr) {
    case 'rotate':
    case 'rotation':
      obj = sprite.attr.rotation;
      return {x: obj.x || 0, y: obj.y || 0, degrees: obj.degrees || 0};
    case 'scale':
    case 'scaling':
      obj = sprite.attr.scaling;
      return {x: obj.x || 1, y: obj.y || 1, cx: obj.cx || 0, cy: obj.cy || 0};
    case 'translate':
    case 'translation':
      obj = sprite.attr.translation;
      return {x: obj.x || 0, y: obj.y || 0};
    default:
      return sprite.attr[attr];
  }
}, getAttr: function(attr, val) {
  return [[this.target, val != undefined ? val : this.getFromPrim(this.target, attr)]];
}, setAttr: function(targetData) {
  var ln = targetData.length, spriteArr = [], attrsConf, attr, attrArr, attrs, sprite, idx, value, i, j, x, y, ln2;
  for (i = 0; i < ln; i++) 
    {
      attrsConf = targetData[i].attrs;
      for (attr in attrsConf) 
        {
          attrArr = attrsConf[attr];
          ln2 = attrArr.length;
          for (j = 0; j < ln2; j++) 
            {
              sprite = attrArr[j][0];
              attrs = attrArr[j][1];
              if (attr === 'translate' || attr === 'translation') 
              {
                value = {x: attrs.x, y: attrs.y};
              } else if (attr === 'rotate' || attr === 'rotation') 
              {
                x = attrs.x;
                if (isNaN(x)) 
                {
                  x = null;
                }
                y = attrs.y;
                if (isNaN(y)) 
                {
                  y = null;
                }
                value = {degrees: attrs.degrees, x: x, y: y};
              } else if (attr === 'scale' || attr === 'scaling') 
              {
                x = attrs.x;
                if (isNaN(x)) 
                {
                  x = null;
                }
                y = attrs.y;
                if (isNaN(y)) 
                {
                  y = null;
                }
                value = {x: x, y: y, cx: attrs.cx, cy: attrs.cy};
              } else if (attr === 'width' || attr === 'height' || attr === 'x' || attr === 'y') 
              {
                value = parseFloat(attrs);
              } else {
                value = attrs;
              }
              idx = Ext.Array.indexOf(spriteArr, sprite);
              if (idx == -1) 
              {
                spriteArr.push([sprite, {}]);
                idx = spriteArr.length - 1;
              }
              spriteArr[idx][1][attr] = value;
            }
        }
    }
  ln = spriteArr.length;
  for (i = 0; i < ln; i++) 
    {
      spriteArr[i][0].setAttributes(spriteArr[i][1]);
    }
  this.target.redraw();
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'Sprite'], 0));
;

(Ext.cmd.derive('Ext.fx.target.CompositeSprite', Ext.fx.target.Sprite, {getAttr: function(attr, val) {
  var out = [], sprites = [].concat(this.target.items), length = sprites.length, i, sprite;
  for (i = 0; i < length; i++) 
    {
      sprite = sprites[i];
      out.push([sprite, val != undefined ? val : this.getFromPrim(sprite, attr)]);
    }
  return out;
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'CompositeSprite'], 0));
;

(Ext.cmd.derive('Ext.fx.target.Component', Ext.fx.target.Target, {type: 'component', getPropMethod: {top: function() {
  return this.getPosition(true)[1];
}, left: function() {
  return this.getPosition(true)[0];
}, x: function() {
  return this.getPosition()[0];
}, y: function() {
  return this.getPosition()[1];
}, height: function() {
  return this.getHeight();
}, width: function() {
  return this.getWidth();
}, opacity: function() {
  return this.el.getStyle('opacity');
}}, setMethods: {top: 'setPosition', left: 'setPosition', x: 'setPagePosition', y: 'setPagePosition', height: 'setSize', width: 'setSize', opacity: 'setOpacity'}, getAttr: function(attr, val) {
  return [[this.target, val !== undefined ? val : this.getPropMethod[attr].call(this.target)]];
}, setAttr: function(targetData, isFirstFrame, isLastFrame) {
  var me = this, ln = targetData.length, attrs, attr, o, i, j, targets, left, top, w, h, methodsToCall = {}, methodProps;
  for (i = 0; i < ln; i++) 
    {
      attrs = targetData[i].attrs;
      for (attr in attrs) 
        {
          targets = attrs[attr].length;
          for (j = 0; j < targets; j++) 
            {
              o = attrs[attr][j];
              methodProps = methodsToCall[me.setMethods[attr]] || (methodsToCall[me.setMethods[attr]] = {});
              methodProps.target = o[0];
              methodProps[attr] = o[1];
            }
        }
      if (methodsToCall.setPosition) 
      {
        o = methodsToCall.setPosition;
        left = (o.left === undefined) ? undefined : parseFloat(o.left);
        top = (o.top === undefined) ? undefined : parseFloat(o.top);
        o.target.setPosition(left, top);
      }
      if (methodsToCall.setPagePosition) 
      {
        o = methodsToCall.setPagePosition;
        o.target.setPagePosition(o.x, o.y);
      }
      if (methodsToCall.setSize) 
      {
        o = methodsToCall.setSize;
        w = (o.width === undefined) ? o.target.getWidth() : parseFloat(o.width);
        h = (o.height === undefined) ? o.target.getHeight() : parseFloat(o.height);
        o.target.el.setSize(w, h);
        if (isLastFrame || me.dynamic) 
        {
          Ext.globalEvents.on({idle: Ext.Function.bind(o.target.setSize, o.target, [w, h]), single: true});
        }
      }
      if (methodsToCall.setOpacity) 
      {
        o = methodsToCall.setOpacity;
        o.target.el.setStyle('opacity', o.opacity);
      }
    }
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.target, 'Component'], 0));
;

(Ext.cmd.derive('Ext.fx.Queue', Ext.Base, {constructor: function() {
  this.targets = new Ext.util.HashMap();
  this.fxQueue = {};
}, getFxDefaults: function(targetId) {
  var target = this.targets.get(targetId);
  if (target) 
  {
    return target.fxDefaults;
  }
  return {};
}, setFxDefaults: function(targetId, obj) {
  var target = this.targets.get(targetId);
  if (target) 
  {
    target.fxDefaults = Ext.apply(target.fxDefaults || {}, obj);
  }
}, stopAnimation: function(targetId) {
  var me = this, queue = me.getFxQueue(targetId), ln = queue.length;
  while (ln) 
    {
      queue[ln - 1].end();
      ln--;
    }
}, getActiveAnimation: function(targetId) {
  var queue = this.getFxQueue(targetId);
  return (queue && !!queue.length) ? queue[0] : false;
}, hasFxBlock: function(targetId) {
  var queue = this.getFxQueue(targetId);
  return queue && queue[0] && queue[0].block;
}, getFxQueue: function(targetId) {
  if (!targetId) 
  {
    return false;
  }
  var me = this, queue = me.fxQueue[targetId], target = me.targets.get(targetId);
  if (!target) 
  {
    return false;
  }
  if (!queue) 
  {
    me.fxQueue[targetId] = [];
    if (target.type != 'element') 
    {
      target.target.on('destroy', function() {
  me.fxQueue[targetId] = [];
});
    }
  }
  return me.fxQueue[targetId];
}, queueFx: function(anim) {
  var me = this, target = anim.target, queue, ln;
  if (!target) 
  {
    return;
  }
  queue = me.getFxQueue(target.getId());
  ln = queue.length;
  if (ln) 
  {
    if (anim.concurrent) 
    {
      anim.paused = false;
    } else {
      queue[ln - 1].on('afteranimate', function() {
  anim.paused = false;
});
    }
  } else {
    anim.paused = false;
  }
  anim.on('afteranimate', function() {
  Ext.Array.remove(queue, anim);
  if (queue.length === 0) 
  {
    me.targets.remove(anim.target);
  }
  if (anim.remove) 
  {
    if (target.type == 'element') 
    {
      var el = Ext.get(target.id);
      if (el) 
      {
        el.remove();
      }
    }
  }
}, me, {single: true});
  queue.push(anim);
}}, 1, 0, 0, 0, 0, 0, [Ext.fx, 'Queue'], 0));
;

(Ext.cmd.derive('Ext.fx.Manager', Ext.Base, {singleton: true, constructor: function() {
  var me = this;
  me.items = new Ext.util.MixedCollection();
  me.targetArr = {};
  me.mixins.queue.constructor.call(me);
  me.taskRunner = new Ext.util.TaskRunner();
}, interval: 16, forceJS: true, createTarget: function(target) {
  var me = this, useCSS3 = !me.forceJS && Ext.supports.Transitions, targetObj;
  me.useCSS3 = useCSS3;
  if (target) 
  {
    if (target.tagName || Ext.isString(target) || target.isFly) 
    {
      target = Ext.get(target);
      targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
    } else if (target.dom) 
    {
      targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
    } else if (target.isComposite) 
    {
      targetObj = new Ext.fx.target['CompositeElement' + (useCSS3 ? 'CSS' : '')](target);
    } else if (target.isSprite) 
    {
      targetObj = new Ext.fx.target.Sprite(target);
    } else if (target.isCompositeSprite) 
    {
      targetObj = new Ext.fx.target.CompositeSprite(target);
    } else if (target.isComponent) 
    {
      targetObj = new Ext.fx.target.Component(target);
    } else if (target.isAnimTarget) 
    {
      return target;
    } else {
      return null;
    }
    me.targets.add(targetObj);
    return targetObj;
  } else {
    return null;
  }
}, addAnim: function(anim) {
  var me = this, items = me.items, task = me.task;
  items.add(anim.id, anim);
  if (!task && items.length) 
  {
    task = me.task = {run: me.runner, interval: me.interval, scope: me};
    me.taskRunner.start(task);
  }
}, removeAnim: function(anim) {
  var me = this, items = me.items, task = me.task;
  items.removeAtKey(anim.id);
  if (task && !items.length) 
  {
    me.taskRunner.stop(task);
    delete me.task;
  }
}, runner: function() {
  var me = this, items = me.items.getRange(), i = 0, len = items.length, anim;
  me.targetArr = {};
  me.timestamp = new Date();
  for (; i < len; i++) 
    {
      anim = items[i];
      if (anim.isReady()) 
      {
        me.startAnim(anim);
      }
    }
  for (i = 0; i < len; i++) 
    {
      anim = items[i];
      if (anim.isRunning()) 
      {
        me.runAnim(anim);
      }
    }
  me.applyPendingAttrs();
}, startAnim: function(anim) {
  anim.start(this.timestamp);
}, runAnim: function(anim, forceEnd) {
  if (!anim) 
  {
    return;
  }
  var me = this, useCSS3 = me.useCSS3 && anim.target.type == 'element', elapsedTime = me.timestamp - anim.startTime, lastFrame = (elapsedTime >= anim.duration), target, o;
  if (forceEnd) 
  {
    elapsedTime = anim.duration;
    lastFrame = true;
  }
  target = this.collectTargetData(anim, elapsedTime, useCSS3, lastFrame);
  if (useCSS3) 
  {
    anim.target.setAttr(target.anims[anim.id].attributes, true);
    me.collectTargetData(anim, anim.duration, useCSS3, lastFrame);
    anim.paused = true;
    target = anim.target.target;
    if (anim.target.isComposite) 
    {
      target = anim.target.target.last();
    }
    o = {};
    o[Ext.supports.CSS3TransitionEnd] = anim.lastFrame;
    o.scope = anim;
    o.single = true;
    target.on(o);
  }
  return target;
}, jumpToEnd: function(anim) {
  var target = this.runAnim(anim, true);
  this.applyAnimAttrs(target, target.anims[anim.id]);
}, collectTargetData: function(anim, elapsedTime, useCSS3, isLastFrame) {
  var targetId = anim.target.getId(), target = this.targetArr[targetId];
  if (!target) 
  {
    target = this.targetArr[targetId] = {id: targetId, el: anim.target, anims: {}};
  }
  target.anims[anim.id] = {id: anim.id, anim: anim, elapsed: elapsedTime, isLastFrame: isLastFrame, attributes: [{duration: anim.duration, easing: (useCSS3 && anim.reverse) ? anim.easingFn.reverse().toCSS3() : anim.easing, attrs: anim.runAnim(elapsedTime)}]};
  return target;
}, applyAnimAttrs: function(target, animWrap) {
  var anim = animWrap.anim;
  if (animWrap.attributes && anim.isRunning()) 
  {
    target.el.setAttr(animWrap.attributes, false, animWrap.isLastFrame);
    if (animWrap.isLastFrame) 
    {
      anim.lastFrame();
    }
  }
}, applyPendingAttrs: function() {
  var targetArr = this.targetArr, target, targetId, animWrap, anim, animId;
  for (targetId in targetArr) 
    {
      if (targetArr.hasOwnProperty(targetId)) 
      {
        target = targetArr[targetId];
        for (animId in target.anims) 
          {
            if (target.anims.hasOwnProperty(animId)) 
            {
              animWrap = target.anims[animId];
              anim = animWrap.anim;
              if (animWrap.attributes && anim.isRunning()) 
              {
                target.el.setAttr(animWrap.attributes, false, animWrap.isLastFrame);
                if (animWrap.isLastFrame) 
                {
                  anim.lastFrame();
                }
              }
            }
          }
      }
    }
}}, 1, 0, 0, 0, 0, [['queue', Ext.fx.Queue]], [Ext.fx, 'Manager'], 0));
;

(Ext.cmd.derive('Ext.fx.Animator', Ext.Base, {isAnimator: true, duration: 250, delay: 0, delayStart: 0, dynamic: false, easing: 'ease', running: false, paused: false, damper: 1, iterations: 1, currentIteration: 0, keyframeStep: 0, animKeyFramesRE: /^(from|to|\d+%?)$/, constructor: function(config) {
  var me = this;
  config = Ext.apply(me, config || {});
  me.config = config;
  me.id = Ext.id(null, 'ext-animator-');
  me.addEvents('beforeanimate', 'keyframe', 'afteranimate');
  me.mixins.observable.constructor.call(me, config);
  me.timeline = [];
  me.createTimeline(me.keyframes);
  if (me.target) 
  {
    me.applyAnimator(me.target);
    Ext.fx.Manager.addAnim(me);
  }
}, sorter: function(a, b) {
  return a.pct - b.pct;
}, createTimeline: function(keyframes) {
  var me = this, attrs = [], to = me.to || {}, duration = me.duration, prevMs, ms, i, ln, pct, attr;
  for (pct in keyframes) 
    {
      if (keyframes.hasOwnProperty(pct) && me.animKeyFramesRE.test(pct)) 
      {
        attr = {attrs: Ext.apply(keyframes[pct], to)};
        if (pct == "from") 
        {
          pct = 0;
        } else if (pct == "to") 
        {
          pct = 100;
        }
        attr.pct = parseInt(pct, 10);
        attrs.push(attr);
      }
    }
  Ext.Array.sort(attrs, me.sorter);
  ln = attrs.length;
  for (i = 0; i < ln; i++) 
    {
      prevMs = (attrs[i - 1]) ? duration * (attrs[i - 1].pct / 100) : 0;
      ms = duration * (attrs[i].pct / 100);
      me.timeline.push({duration: ms - prevMs, attrs: attrs[i].attrs});
    }
}, applyAnimator: function(target) {
  var me = this, anims = [], timeline = me.timeline, ln = timeline.length, anim, easing, damper, attrs, i;
  if (me.fireEvent('beforeanimate', me) !== false) 
  {
    for (i = 0; i < ln; i++) 
      {
        anim = timeline[i];
        attrs = anim.attrs;
        easing = attrs.easing || me.easing;
        damper = attrs.damper || me.damper;
        delete attrs.easing;
        delete attrs.damper;
        anim = new Ext.fx.Anim({target: target, easing: easing, damper: damper, duration: anim.duration, paused: true, to: attrs});
        anims.push(anim);
      }
    me.animations = anims;
    me.target = anim.target;
    for (i = 0; i < ln - 1; i++) 
      {
        anim = anims[i];
        anim.nextAnim = anims[i + 1];
        anim.on('afteranimate', function() {
  this.nextAnim.paused = false;
});
        anim.on('afteranimate', function() {
  this.fireEvent('keyframe', this, ++this.keyframeStep);
}, me);
      }
    anims[ln - 1].on('afteranimate', function() {
  this.lastFrame();
}, me);
  }
}, start: function(startTime) {
  var me = this, delay = me.delay, delayStart = me.delayStart, delayDelta;
  if (delay) 
  {
    if (!delayStart) 
    {
      me.delayStart = startTime;
      return;
    } else {
      delayDelta = startTime - delayStart;
      if (delayDelta < delay) 
      {
        return;
      } else {
        startTime = new Date(delayStart.getTime() + delay);
      }
    }
  }
  if (me.fireEvent('beforeanimate', me) !== false) 
  {
    me.startTime = startTime;
    me.running = true;
    me.animations[me.keyframeStep].paused = false;
  }
}, lastFrame: function() {
  var me = this, iter = me.iterations, iterCount = me.currentIteration;
  iterCount++;
  if (iterCount < iter) 
  {
    me.startTime = new Date();
    me.currentIteration = iterCount;
    me.keyframeStep = 0;
    me.applyAnimator(me.target);
    me.animations[me.keyframeStep].paused = false;
  } else {
    me.currentIteration = 0;
    me.end();
  }
}, end: function() {
  var me = this;
  me.fireEvent('afteranimate', me, me.startTime, new Date() - me.startTime);
}, isReady: function() {
  return this.paused === false && this.running === false && this.iterations > 0;
}, isRunning: function() {
  return false;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.fx, 'Animator'], 0));
;

(Ext.cmd.derive('Ext.fx.CubicBezier', Ext.Base, {singleton: true, cubicBezierAtTime: function(t, p1x, p1y, p2x, p2y, duration) {
  var cx = 3 * p1x, bx = 3 * (p2x - p1x) - cx, ax = 1 - cx - bx, cy = 3 * p1y, by = 3 * (p2y - p1y) - cy, ay = 1 - cy - by;
  function sampleCurveX(t) {
    return ((ax * t + bx) * t + cx) * t;
  }
  function solve(x, epsilon) {
    var t = solveCurveX(x, epsilon);
    return ((ay * t + by) * t + cy) * t;
  }
  function solveCurveX(x, epsilon) {
    var t0, t1, t2, x2, d2, i;
    for (t2 = x , i = 0; i < 8; i++) 
      {
        x2 = sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) 
        {
          return t2;
        }
        d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
        if (Math.abs(d2) < 1.0E-6) 
        {
          break;
        }
        t2 = t2 - x2 / d2;
      }
    t0 = 0;
    t1 = 1;
    t2 = x;
    if (t2 < t0) 
    {
      return t0;
    }
    if (t2 > t1) 
    {
      return t1;
    }
    while (t0 < t1) 
      {
        x2 = sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) 
        {
          return t2;
        }
        if (x > x2) 
        {
          t0 = t2;
        } else {
          t1 = t2;
        }
        t2 = (t1 - t0) / 2 + t0;
      }
    return t2;
  }
  return solve(t, 1 / (200 * duration));
}, cubicBezier: function(x1, y1, x2, y2) {
  var fn = function(pos) {
  return Ext.fx.CubicBezier.cubicBezierAtTime(pos, x1, y1, x2, y2, 1);
};
  fn.toCSS3 = function() {
  return 'cubic-bezier(' + [x1, y1, x2, y2].join(',') + ')';
};
  fn.reverse = function() {
  return Ext.fx.CubicBezier.cubicBezier(1 - x2, 1 - y2, 1 - x1, 1 - y1);
};
  return fn;
}}, 0, 0, 0, 0, 0, 0, [Ext.fx, 'CubicBezier'], 0));
;

Ext.require('Ext.fx.CubicBezier', function() {
  var math = Math, pi = math.PI, pow = math.pow, sin = math.sin, sqrt = math.sqrt, abs = math.abs, backInSeed = 1.70158;
  Ext.define('Ext.fx.Easing', {singleton: true, linear: Ext.identityFn, ease: function(n) {
  var q = 0.07813 - n / 2, alpha = -0.25, Q = sqrt(0.0066 + q * q), x = Q - q, X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1), y = -Q - q, Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1), t = X + Y + 0.25;
  return pow(1 - t, 2) * 3 * t * 0.1 + (1 - t) * 3 * t * t + t * t * t;
}, easeIn: function(n) {
  return pow(n, 1.7);
}, easeOut: function(n) {
  return pow(n, 0.48);
}, easeInOut: function(n) {
  var q = 0.48 - n / 1.04, Q = sqrt(0.1734 + q * q), x = Q - q, X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1), y = -Q - q, Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1), t = X + Y + 0.5;
  return (1 - t) * 3 * t * t + t * t * t;
}, backIn: function(n) {
  return n * n * ((backInSeed + 1) * n - backInSeed);
}, backOut: function(n) {
  n = n - 1;
  return n * n * ((backInSeed + 1) * n + backInSeed) + 1;
}, elasticIn: function(n) {
  if (n === 0 || n === 1) 
  {
    return n;
  }
  var p = 0.3, s = p / 4;
  return pow(2, -10 * n) * sin((n - s) * (2 * pi) / p) + 1;
}, elasticOut: function(n) {
  return 1 - Ext.fx.Easing.elasticIn(1 - n);
}, bounceIn: function(n) {
  return 1 - Ext.fx.Easing.bounceOut(1 - n);
}, bounceOut: function(n) {
  var s = 7.5625, p = 2.75, l;
  if (n < (1 / p)) 
  {
    l = s * n * n;
  } else {
    if (n < (2 / p)) 
    {
      n -= (1.5 / p);
      l = s * n * n + 0.75;
    } else {
      if (n < (2.5 / p)) 
      {
        n -= (2.25 / p);
        l = s * n * n + 0.9375;
      } else {
        n -= (2.625 / p);
        l = s * n * n + 0.984375;
      }
    }
  }
  return l;
}}, function() {
  var easing = Ext.fx.Easing.self, proto = easing.prototype;
  easing.implement({'back-in': proto.backIn, 'back-out': proto.backOut, 'ease-in': proto.easeIn, 'ease-out': proto.easeOut, 'elastic-in': proto.elasticIn, 'elastic-out': proto.elasticOut, 'bounce-in': proto.bounceIn, 'bounce-out': proto.bounceOut, 'ease-in-out': proto.easeInOut});
});
});

(Ext.cmd.derive('Ext.draw.Color', Ext.Base, {colorToHexRe: /(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/, rgbRe: /\s*rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)\s*/, hexRe: /\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/, lightnessFactor: 0.2, constructor: function(red, green, blue) {
  var me = this, clamp = Ext.Number.constrain;
  me.r = clamp(red, 0, 255);
  me.g = clamp(green, 0, 255);
  me.b = clamp(blue, 0, 255);
}, getRed: function() {
  return this.r;
}, getGreen: function() {
  return this.g;
}, getBlue: function() {
  return this.b;
}, getRGB: function() {
  var me = this;
  return [me.r, me.g, me.b];
}, getHSL: function() {
  var me = this, r = me.r / 255, g = me.g / 255, b = me.b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b), delta = max - min, h, s = 0, l = 0.5 * (max + min);
  if (min != max) 
  {
    s = (l < 0.5) ? delta / (max + min) : delta / (2 - max - min);
    if (r == max) 
    {
      h = 60 * (g - b) / delta;
    } else if (g == max) 
    {
      h = 120 + 60 * (b - r) / delta;
    } else {
      h = 240 + 60 * (r - g) / delta;
    }
    if (h < 0) 
    {
      h += 360;
    }
    if (h >= 360) 
    {
      h -= 360;
    }
  }
  return [h, s, l];
}, getLighter: function(factor) {
  var hsl = this.getHSL();
  factor = factor || this.lightnessFactor;
  hsl[2] = Ext.Number.constrain(hsl[2] + factor, 0, 1);
  return this.fromHSL(hsl[0], hsl[1], hsl[2]);
}, getDarker: function(factor) {
  factor = factor || this.lightnessFactor;
  return this.getLighter(-factor);
}, toString: function() {
  var me = this, round = Math.round, r = round(me.r).toString(16), g = round(me.g).toString(16), b = round(me.b).toString(16);
  r = (r.length == 1) ? '0' + r : r;
  g = (g.length == 1) ? '0' + g : g;
  b = (b.length == 1) ? '0' + b : b;
  return ['#', r, g, b].join('');
}, toHex: function(color) {
  if (Ext.isArray(color)) 
  {
    color = color[0];
  }
  if (!Ext.isString(color)) 
  {
    return '';
  }
  if (color.substr(0, 1) === '#') 
  {
    return color;
  }
  var digits = this.colorToHexRe.exec(color), red, green, blue, rgb;
  if (Ext.isArray(digits)) 
  {
    red = parseInt(digits[2], 10);
    green = parseInt(digits[3], 10);
    blue = parseInt(digits[4], 10);
    rgb = blue | (green << 8) | (red << 16);
    return digits[1] + '#' + ("000000" + rgb.toString(16)).slice(-6);
  } else {
    return color;
  }
}, fromString: function(str) {
  var values, r, g, b, parse = parseInt, firstChar = str.substr(0, 1), colorValue;
  if (firstChar != '#') 
  {
    colorValue = Ext.draw.Color.cssColors[str];
    if (colorValue) 
    {
      str = colorValue;
      firstChar = str.substr(0, 1);
    }
  }
  if ((str.length == 4 || str.length == 7) && firstChar === '#') 
  {
    values = str.match(this.hexRe);
    if (values) 
    {
      r = parse(values[1], 16) >> 0;
      g = parse(values[2], 16) >> 0;
      b = parse(values[3], 16) >> 0;
      if (str.length == 4) 
      {
        r += (r * 16);
        g += (g * 16);
        b += (b * 16);
      }
    }
  } else {
    values = str.match(this.rgbRe);
    if (values) 
    {
      r = values[1];
      g = values[2];
      b = values[3];
    }
  }
  return (typeof r == 'undefined') ? undefined : new Ext.draw.Color(r, g, b);
}, getGrayscale: function() {
  return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
}, fromHSL: function(h, s, l) {
  var C, X, m, i, rgb = [], abs = Math.abs, floor = Math.floor;
  if (s == 0 || h == null) 
  {
    rgb = [l, l, l];
  } else {
    h /= 60;
    C = s * (1 - abs(2 * l - 1));
    X = C * (1 - abs(h - 2 * floor(h / 2) - 1));
    m = l - C / 2;
    switch (floor(h)) {
      case 0:
        rgb = [C, X, 0];
        break;
      case 1:
        rgb = [X, C, 0];
        break;
      case 2:
        rgb = [0, C, X];
        break;
      case 3:
        rgb = [0, X, C];
        break;
      case 4:
        rgb = [X, 0, C];
        break;
      case 5:
        rgb = [C, 0, X];
        break;
    }
    rgb = [rgb[0] + m, rgb[1] + m, rgb[2] + m];
  }
  return new Ext.draw.Color(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
}}, 3, 0, 0, 0, 0, 0, [Ext.draw, 'Color'], function() {
  var prototype = this.prototype;
  this.addStatics({fromHSL: function() {
  return prototype.fromHSL.apply(prototype, arguments);
}, fromString: function() {
  return prototype.fromString.apply(prototype, arguments);
}, toHex: function() {
  return prototype.toHex.apply(prototype, arguments);
}, cssColors: {aliceblue: '#F0F8FF', antiquewhite: '#FAEBD7', aqua: '#00FFFF', aquamarine: '#7FFFD4', azure: '#F0FFFF', beige: '#F5F5DC', bisque: '#FFE4C4', black: '#000000', blanchedalmond: '#FFEBCD', blue: '#0000FF', blueviolet: '#8A2BE2', brown: '#A52A2A', burlywood: '#DEB887', cadetblue: '#5F9EA0', chartreuse: '#7FFF00', chocolate: '#D2691E', coral: '#FF7F50', cornflowerblue: '#6495ED', cornsilk: '#FFF8DC', crimson: '#DC143C', cyan: '#00FFFF', darkblue: '#00008B', darkcyan: '#008B8B', darkgoldenrod: '#B8860B', darkgray: '#A9A9A9', darkgreen: '#006400', darkgrey: '#A9A9A9', darkkhaki: '#BDB76B', darkmagenta: '#8B008B', darkolivegreen: '#556B2F', darkorange: '#FF8C00', darkorchid: '#9932CC', darkred: '#8B0000', darksalmon: '#E9967A', darkseagreen: '#8FBC8F', darkslateblue: '#483D8B', darkslategray: '#2F4F4F', darkslategrey: '#2F4F4F', darkturquoise: '#00CED1', darkviolet: '#9400D3', deeppink: '#FF1493', deepskyblue: '#00BFFF', dimgray: '#696969', dimgrey: '#696969', dodgerblue: '#1E90FF', firebrick: '#B22222', floralwhite: '#FFFAF0', forestgreen: '#228B22', fuchsia: '#FF00FF', gainsboro: '#DCDCDC', ghostwhite: '#F8F8FF', gold: '#FFD700', goldenrod: '#DAA520', gray: '#808080', grey: '#808080', green: '#008000', greenyellow: '#ADFF2F', honeydew: '#F0FFF0', hotpink: '#FF69B4', indianred: '#CD5C5C', indigo: '#4B0082', ivory: '#FFFFF0', khaki: '#F0E68C', lavender: '#E6E6FA', lavenderblush: '#FFF0F5', lawngreen: '#7CFC00', lemonchiffon: '#FFFACD', lightblue: '#ADD8E6', lightcoral: '#F08080', lightcyan: '#E0FFFF', lightgoldenrodyellow: '#FAFAD2', lightgray: '#D3D3D3', lightgreen: '#90EE90', lightgrey: '#D3D3D3', lightpink: '#FFB6C1', lightsalmon: '#FFA07A', lightseagreen: '#20B2AA', lightskyblue: '#87CEFA', lightslategray: '#778899', lightslategrey: '#778899', lightsteelblue: '#B0C4DE', lightyellow: '#FFFFE0', lime: '#00FF00', limegreen: '#32CD32', linen: '#FAF0E6', magenta: '#FF00FF', maroon: '#800000', mediumaquamarine: '#66CDAA', mediumblue: '#0000CD', mediumorchid: '#BA55D3', mediumpurple: '#9370DB', mediumseagreen: '#3CB371', mediumslateblue: '#7B68EE', mediumspringgreen: '#00FA9A', mediumturquoise: '#48D1CC', mediumvioletred: '#C71585', midnightblue: '#191970', mintcream: '#F5FFFA', mistyrose: '#FFE4E1', moccasin: '#FFE4B5', navajowhite: '#FFDEAD', navy: '#000080', oldlace: '#FDF5E6', olive: '#808000', olivedrab: '#6B8E23', orange: '#FFA500', orangered: '#FF4500', orchid: '#DA70D6', palegoldenrod: '#EEE8AA', palegreen: '#98FB98', paleturquoise: '#AFEEEE', palevioletred: '#DB7093', papayawhip: '#FFEFD5', peachpuff: '#FFDAB9', peru: '#CD853F', pink: '#FFC0CB', plum: '#DDA0DD', powderblue: '#B0E0E6', purple: '#800080', red: '#FF0000', rosybrown: '#BC8F8F', royalblue: '#4169E1', saddlebrown: '#8B4513', salmon: '#FA8072', sandybrown: '#F4A460', seagreen: '#2E8B57', seashell: '#FFF5EE', sienna: '#A0522D', silver: '#C0C0C0', skyblue: '#87CEEB', slateblue: '#6A5ACD', slategray: '#708090', slategrey: '#708090', snow: '#FFFAFA', springgreen: '#00FF7F', steelblue: '#4682B4', tan: '#D2B48C', teal: '#008080', thistle: '#D8BFD8', tomato: '#FF6347', turquoise: '#40E0D0', violet: '#EE82EE', wheat: '#F5DEB3', white: '#FFFFFF', whitesmoke: '#F5F5F5', yellow: '#FFFF00', yellowgreen: '#9ACD32'}});
}));
;

(Ext.cmd.derive('Ext.draw.Draw', Ext.Base, {singleton: true, pathToStringRE: /,?([achlmqrstvxz]),?/gi, pathCommandRE: /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig, pathValuesRE: /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig, stopsRE: /^(\d+%?)$/, radian: Math.PI / 180, availableAnimAttrs: {along: "along", blur: null, "clip-rect": "csv", cx: null, cy: null, fill: "color", "fill-opacity": null, "font-size": null, height: null, opacity: null, path: "path", r: null, rotation: "csv", rx: null, ry: null, scale: "csv", stroke: "color", "stroke-opacity": null, "stroke-width": null, translation: "csv", width: null, x: null, y: null}, is: function(o, type) {
  type = String(type).toLowerCase();
  return (type == "object" && o === Object(o)) || (type == "undefined" && typeof o == type) || (type == "null" && o === null) || (type == "array" && Array.isArray && Array.isArray(o)) || (Object.prototype.toString.call(o).toLowerCase().slice(8, -1)) == type;
}, ellipsePath: function(sprite) {
  var attr = sprite.attr;
  return Ext.String.format("M{0},{1}A{2},{3},0,1,1,{0},{4}A{2},{3},0,1,1,{0},{1}z", attr.x, attr.y - attr.ry, attr.rx, attr.ry, attr.y + attr.ry);
}, rectPath: function(sprite) {
  var attr = sprite.attr;
  if (attr.radius) 
  {
    return Ext.String.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", attr.x + attr.radius, attr.y, attr.width - attr.radius * 2, attr.radius, -attr.radius, attr.height - attr.radius * 2, attr.radius * 2 - attr.width, attr.radius * 2 - attr.height);
  } else {
    return Ext.String.format("M{0},{1}L{2},{1},{2},{3},{0},{3}z", attr.x, attr.y, attr.width + attr.x, attr.height + attr.y);
  }
}, path2string: function() {
  return this.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1");
}, pathToString: function(arrayPath) {
  return arrayPath.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1");
}, parsePathString: function(pathString) {
  if (!pathString) 
  {
    return null;
  }
  var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}, data = [], me = this;
  if (me.is(pathString, "array") && me.is(pathString[0], "array")) 
  {
    data = me.pathClone(pathString);
  }
  if (!data.length) 
  {
    String(pathString).replace(me.pathCommandRE, function(a, b, c) {
  var params = [], name = b.toLowerCase();
  c.replace(me.pathValuesRE, function(a, b) {
  b && params.push(+b);
});
  if (name == "m" && params.length > 2) 
  {
    data.push([b].concat(Ext.Array.splice(params, 0, 2)));
    name = "l";
    b = (b == "m") ? "l" : "L";
  }
  while (params.length >= paramCounts[name]) 
    {
      data.push([b].concat(Ext.Array.splice(params, 0, paramCounts[name])));
      if (!paramCounts[name]) 
      {
        break;
      }
    }
});
  }
  data.toString = me.path2string;
  return data;
}, mapPath: function(path, matrix) {
  if (!matrix) 
  {
    return path;
  }
  var x, y, i, ii, j, jj, pathi;
  path = this.path2curve(path);
  for (i = 0 , ii = path.length; i < ii; i++) 
    {
      pathi = path[i];
      for (j = 1 , jj = pathi.length; j < jj - 1; j += 2) 
        {
          x = matrix.x(pathi[j], pathi[j + 1]);
          y = matrix.y(pathi[j], pathi[j + 1]);
          pathi[j] = x;
          pathi[j + 1] = y;
        }
    }
  return path;
}, pathClone: function(pathArray) {
  var res = [], j, jj, i, ii;
  if (!this.is(pathArray, "array") || !this.is(pathArray && pathArray[0], "array")) 
  {
    pathArray = this.parsePathString(pathArray);
  }
  for (i = 0 , ii = pathArray.length; i < ii; i++) 
    {
      res[i] = [];
      for (j = 0 , jj = pathArray[i].length; j < jj; j++) 
        {
          res[i][j] = pathArray[i][j];
        }
    }
  res.toString = this.path2string;
  return res;
}, pathToAbsolute: function(pathArray) {
  if (!this.is(pathArray, "array") || !this.is(pathArray && pathArray[0], "array")) 
  {
    pathArray = this.parsePathString(pathArray);
  }
  var res = [], x = 0, y = 0, mx = 0, my = 0, i = 0, ln = pathArray.length, r, pathSegment, j, ln2;
  if (ln && pathArray[0][0] == "M") 
  {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    i++;
    res[0] = ["M", x, y];
  }
  for (; i < ln; i++) 
    {
      r = res[i] = [];
      pathSegment = pathArray[i];
      if (pathSegment[0] != pathSegment[0].toUpperCase()) 
      {
        r[0] = pathSegment[0].toUpperCase();
        switch (r[0]) {
          case "A":
            r[1] = pathSegment[1];
            r[2] = pathSegment[2];
            r[3] = pathSegment[3];
            r[4] = pathSegment[4];
            r[5] = pathSegment[5];
            r[6] = +(pathSegment[6] + x);
            r[7] = +(pathSegment[7] + y);
            break;
          case "V":
            r[1] = +pathSegment[1] + y;
            break;
          case "H":
            r[1] = +pathSegment[1] + x;
            break;
          case "M":
            mx = +pathSegment[1] + x;
            my = +pathSegment[2] + y;
          default:
            j = 1;
            ln2 = pathSegment.length;
            for (; j < ln2; j++) 
              {
                r[j] = +pathSegment[j] + ((j % 2) ? x : y);
              }
        }
      } else {
        j = 0;
        ln2 = pathSegment.length;
        for (; j < ln2; j++) 
          {
            res[i][j] = pathSegment[j];
          }
      }
      switch (r[0]) {
        case "Z":
          x = mx;
          y = my;
          break;
        case "H":
          x = r[1];
          break;
        case "V":
          y = r[1];
          break;
        case "M":
          pathSegment = res[i];
          ln2 = pathSegment.length;
          mx = pathSegment[ln2 - 2];
          my = pathSegment[ln2 - 1];
        default:
          pathSegment = res[i];
          ln2 = pathSegment.length;
          x = pathSegment[ln2 - 2];
          y = pathSegment[ln2 - 1];
      }
    }
  res.toString = this.path2string;
  return res;
}, pathToRelative: function(pathArray) {
  if (!this.is(pathArray, "array") || !this.is(pathArray && pathArray[0], "array")) 
  {
    pathArray = this.parsePathString(pathArray);
  }
  var res = [], x = 0, y = 0, mx = 0, my = 0, start = 0, r, pa, i, j, k, len, ii, jj, kk;
  if (pathArray[0][0] == "M") 
  {
    x = pathArray[0][1];
    y = pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res.push(["M", x, y]);
  }
  for (i = start , ii = pathArray.length; i < ii; i++) 
    {
      r = res[i] = [];
      pa = pathArray[i];
      if (pa[0] != pa[0].toLowerCase()) 
      {
        r[0] = pa[0].toLowerCase();
        switch (r[0]) {
          case "a":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +(pa[6] - x).toFixed(3);
            r[7] = +(pa[7] - y).toFixed(3);
            break;
          case "v":
            r[1] = +(pa[1] - y).toFixed(3);
            break;
          case "m":
            mx = pa[1];
            my = pa[2];
          default:
            for (j = 1 , jj = pa.length; j < jj; j++) 
              {
                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
              }
        }
      } else {
        r = res[i] = [];
        if (pa[0] == "m") 
        {
          mx = pa[1] + x;
          my = pa[2] + y;
        }
        for (k = 0 , kk = pa.length; k < kk; k++) 
          {
            res[i][k] = pa[k];
          }
      }
      len = res[i].length;
      switch (res[i][0]) {
        case "z":
          x = mx;
          y = my;
          break;
        case "h":
          x += +res[i][len - 1];
          break;
        case "v":
          y += +res[i][len - 1];
          break;
        default:
          x += +res[i][len - 2];
          y += +res[i][len - 1];
      }
    }
  res.toString = this.path2string;
  return res;
}, path2curve: function(path) {
  var me = this, points = me.pathToAbsolute(path), ln = points.length, attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null}, i, seg, segLn, point;
  for (i = 0; i < ln; i++) 
    {
      points[i] = me.command2curve(points[i], attrs);
      if (points[i].length > 7) 
      {
        points[i].shift();
        point = points[i];
        while (point.length) 
          {
            Ext.Array.splice(points, i++, 0, ["C"].concat(Ext.Array.splice(point, 0, 6)));
          }
        Ext.Array.erase(points, i, 1);
        ln = points.length;
        i--;
      }
      seg = points[i];
      segLn = seg.length;
      attrs.x = seg[segLn - 2];
      attrs.y = seg[segLn - 1];
      attrs.bx = parseFloat(seg[segLn - 4]) || attrs.x;
      attrs.by = parseFloat(seg[segLn - 3]) || attrs.y;
    }
  return points;
}, interpolatePaths: function(path, path2) {
  var me = this, p = me.pathToAbsolute(path), p2 = me.pathToAbsolute(path2), attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null}, attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null}, fixArc = function(pp, i) {
  if (pp[i].length > 7) 
  {
    pp[i].shift();
    var pi = pp[i];
    while (pi.length) 
      {
        Ext.Array.splice(pp, i++, 0, ["C"].concat(Ext.Array.splice(pi, 0, 6)));
      }
    Ext.Array.erase(pp, i, 1);
    ii = Math.max(p.length, p2.length || 0);
  }
}, fixM = function(path1, path2, a1, a2, i) {
  if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") 
  {
    Ext.Array.splice(path2, i, 0, ["M", a2.x, a2.y]);
    a1.bx = 0;
    a1.by = 0;
    a1.x = path1[i][1];
    a1.y = path1[i][2];
    ii = Math.max(p.length, p2.length || 0);
  }
}, i, ii, seg, seg2, seglen, seg2len;
  for (i = 0 , ii = Math.max(p.length, p2.length || 0); i < ii; i++) 
    {
      p[i] = me.command2curve(p[i], attrs);
      fixArc(p, i);
      (p2[i] = me.command2curve(p2[i], attrs2));
      fixArc(p2, i);
      fixM(p, p2, attrs, attrs2, i);
      fixM(p2, p, attrs2, attrs, i);
      seg = p[i];
      seg2 = p2[i];
      seglen = seg.length;
      seg2len = seg2.length;
      attrs.x = seg[seglen - 2];
      attrs.y = seg[seglen - 1];
      attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
      attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
      attrs2.bx = (parseFloat(seg2[seg2len - 4]) || attrs2.x);
      attrs2.by = (parseFloat(seg2[seg2len - 3]) || attrs2.y);
      attrs2.x = seg2[seg2len - 2];
      attrs2.y = seg2[seg2len - 1];
    }
  return [p, p2];
}, command2curve: function(pathCommand, d) {
  var me = this;
  if (!pathCommand) 
  {
    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
  }
  if (pathCommand[0] != "T" && pathCommand[0] != "Q") 
  {
    d.qx = d.qy = null;
  }
  switch (pathCommand[0]) {
    case "M":
      d.X = pathCommand[1];
      d.Y = pathCommand[2];
      break;
    case "A":
      pathCommand = ["C"].concat(me.arc2curve.apply(me, [d.x, d.y].concat(pathCommand.slice(1))));
      break;
    case "S":
      pathCommand = ["C", d.x + (d.x - (d.bx || d.x)), d.y + (d.y - (d.by || d.y))].concat(pathCommand.slice(1));
      break;
    case "T":
      d.qx = d.x + (d.x - (d.qx || d.x));
      d.qy = d.y + (d.y - (d.qy || d.y));
      pathCommand = ["C"].concat(me.quadratic2curve(d.x, d.y, d.qx, d.qy, pathCommand[1], pathCommand[2]));
      break;
    case "Q":
      d.qx = pathCommand[1];
      d.qy = pathCommand[2];
      pathCommand = ["C"].concat(me.quadratic2curve(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[3], pathCommand[4]));
      break;
    case "L":
      pathCommand = ["C"].concat(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[1], pathCommand[2]);
      break;
    case "H":
      pathCommand = ["C"].concat(d.x, d.y, pathCommand[1], d.y, pathCommand[1], d.y);
      break;
    case "V":
      pathCommand = ["C"].concat(d.x, d.y, d.x, pathCommand[1], d.x, pathCommand[1]);
      break;
    case "Z":
      pathCommand = ["C"].concat(d.x, d.y, d.X, d.Y, d.X, d.Y);
      break;
  }
  return pathCommand;
}, quadratic2curve: function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3, _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
}, rotate: function(x, y, rad) {
  var cos = Math.cos(rad), sin = Math.sin(rad), X = x * cos - y * sin, Y = x * sin + y * cos;
  return {x: X, y: Y};
}, arc2curve: function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  var me = this, PI = Math.PI, radian = me.radian, _120 = PI * 120 / 180, rad = radian * (+angle || 0), res = [], math = Math, mcos = math.cos, msin = math.sin, msqrt = math.sqrt, mabs = math.abs, masin = math.asin, xy, x, y, h, rx2, ry2, k, cx, cy, f1, f2, df, c1, s1, c2, s2, t, hx, hy, m1, m2, m3, m4, newres, i, ln, f2old, x2old, y2old;
  if (!recursive) 
  {
    xy = me.rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = me.rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    x = (x1 - x2) / 2;
    y = (y1 - y2) / 2;
    h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
    if (h > 1) 
    {
      h = msqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    rx2 = rx * rx;
    ry2 = ry * ry;
    k = (large_arc_flag == sweep_flag ? -1 : 1) * msqrt(mabs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = masin(((y1 - cy) / ry).toFixed(7));
    f2 = masin(((y2 - cy) / ry).toFixed(7));
    f1 = x1 < cx ? PI - f1 : f1;
    f2 = x2 < cx ? PI - f2 : f2;
    if (f1 < 0) 
    {
      f1 = PI * 2 + f1;
    }
    if (f2 < 0) 
    {
      f2 = PI * 2 + f2;
    }
    if (sweep_flag && f1 > f2) 
    {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f2 > f1) 
    {
      f2 = f2 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  df = f2 - f1;
  if (mabs(df) > _120) 
  {
    f2old = f2;
    x2old = x2;
    y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * mcos(f2);
    y2 = cy + ry * msin(f2);
    res = me.arc2curve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  c1 = mcos(f1);
  s1 = msin(f1);
  c2 = mcos(f2);
  s2 = msin(f2);
  t = math.tan(df / 4);
  hx = 4 / 3 * rx * t;
  hy = 4 / 3 * ry * t;
  m1 = [x1, y1];
  m2 = [x1 + hx * s1, y1 - hy * c1];
  m3 = [x2 + hx * s2, y2 - hy * c2];
  m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) 
  {
    return [m2, m3, m4].concat(res);
  } else {
    res = [m2, m3, m4].concat(res).join().split(",");
    newres = [];
    ln = res.length;
    for (i = 0; i < ln; i++) 
      {
        newres[i] = i % 2 ? me.rotate(res[i - 1], res[i], rad).y : me.rotate(res[i], res[i + 1], rad).x;
      }
    return newres;
  }
}, rotateAndTranslatePath: function(sprite) {
  var alpha = sprite.rotation.degrees, cx = sprite.rotation.x, cy = sprite.rotation.y, dx = sprite.translation.x, dy = sprite.translation.y, path, i, p, xy, j, res = [];
  if (!alpha && !dx && !dy) 
  {
    return this.pathToAbsolute(sprite.attr.path);
  }
  dx = dx || 0;
  dy = dy || 0;
  path = this.pathToAbsolute(sprite.attr.path);
  for (i = path.length; i--; ) 
    {
      p = res[i] = path[i].slice();
      if (p[0] == "A") 
      {
        xy = this.rotatePoint(p[6], p[7], alpha, cx, cy);
        p[6] = xy.x + dx;
        p[7] = xy.y + dy;
      } else {
        j = 1;
        while (p[j + 1] != null) 
          {
            xy = this.rotatePoint(p[j], p[j + 1], alpha, cx, cy);
            p[j] = xy.x + dx;
            p[j + 1] = xy.y + dy;
            j += 2;
          }
      }
    }
  return res;
}, rotatePoint: function(x, y, alpha, cx, cy) {
  if (!alpha) 
  {
    return {x: x, y: y};
  }
  cx = cx || 0;
  cy = cy || 0;
  x = x - cx;
  y = y - cy;
  alpha = alpha * this.radian;
  var cos = Math.cos(alpha), sin = Math.sin(alpha);
  return {x: x * cos - y * sin + cx, y: x * sin + y * cos + cy};
}, pathDimensions: function(path) {
  if (!path || !(path + "")) 
  {
    return {x: 0, y: 0, width: 0, height: 0};
  }
  path = this.path2curve(path);
  var x = 0, y = 0, X = [], Y = [], i = 0, ln = path.length, p, xmin, ymin, xmax, ymax, dim;
  for (; i < ln; i++) 
    {
      p = path[i];
      if (p[0] == "M") 
      {
        x = p[1];
        y = p[2];
        X.push(x);
        Y.push(y);
      } else {
        dim = this.curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
        X = X.concat(dim.min.x, dim.max.x);
        Y = Y.concat(dim.min.y, dim.max.y);
        x = p[5];
        y = p[6];
      }
    }
  xmin = Math.min.apply(0, X);
  ymin = Math.min.apply(0, Y);
  xmax = Math.max.apply(0, X);
  ymax = Math.max.apply(0, Y);
  return {x: Math.round(xmin), y: Math.round(ymin), path: path, width: Math.round(xmax - xmin), height: Math.round(ymax - ymin)};
}, intersectInside: function(path, cp1, cp2) {
  return (cp2[0] - cp1[0]) * (path[1] - cp1[1]) > (cp2[1] - cp1[1]) * (path[0] - cp1[0]);
}, intersectIntersection: function(s, e, cp1, cp2) {
  var p = [], dcx = cp1[0] - cp2[0], dcy = cp1[1] - cp2[1], dpx = s[0] - e[0], dpy = s[1] - e[1], n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0], n2 = s[0] * e[1] - s[1] * e[0], n3 = 1 / (dcx * dpy - dcy * dpx);
  p[0] = (n1 * dpx - n2 * dcx) * n3;
  p[1] = (n1 * dpy - n2 * dcy) * n3;
  return p;
}, intersect: function(subjectPolygon, clipPolygon) {
  var me = this, i = 0, ln = clipPolygon.length, cp1 = clipPolygon[ln - 1], outputList = subjectPolygon, cp2, s, e, ln2, inputList, j;
  for (; i < ln; ++i) 
    {
      cp2 = clipPolygon[i];
      inputList = outputList;
      outputList = [];
      s = inputList[inputList.length - 1];
      j = 0;
      ln2 = inputList.length;
      for (; j < ln2; j++) 
        {
          e = inputList[j];
          if (me.intersectInside(e, cp1, cp2)) 
          {
            if (!me.intersectInside(s, cp1, cp2)) 
            {
              outputList.push(me.intersectIntersection(s, e, cp1, cp2));
            }
            outputList.push(e);
          } else if (me.intersectInside(s, cp1, cp2)) 
          {
            outputList.push(me.intersectIntersection(s, e, cp1, cp2));
          }
          s = e;
        }
      cp1 = cp2;
    }
  return outputList;
}, bezier: function(a, b, c, d, x) {
  if (x === 0) 
  {
    return a;
  } else if (x === 1) 
  {
    return d;
  }
  var du = 1 - x, d3 = du * du * du, r = x / du;
  return d3 * (a + r * (3 * b + r * (3 * c + d * r)));
}, bezierDim: function(a, b, c, d) {
  var points = [], r, A, top, C, delta, bottom, s, min, max, i;
  if (a + 3 * c == d + 3 * b) 
  {
    r = a - b;
    r /= 2 * (a - b - b + c);
    if (r < 1 && r > 0) 
    {
      points.push(r);
    }
  } else {
    A = a - 3 * b + 3 * c - d;
    top = 2 * (a - b - b + c);
    C = a - b;
    delta = top * top - 4 * A * C;
    bottom = A + A;
    if (delta === 0) 
    {
      r = top / bottom;
      if (r < 1 && r > 0) 
      {
        points.push(r);
      }
    } else if (delta > 0) 
    {
      s = Math.sqrt(delta);
      r = (s + top) / bottom;
      if (r < 1 && r > 0) 
      {
        points.push(r);
      }
      r = (top - s) / bottom;
      if (r < 1 && r > 0) 
      {
        points.push(r);
      }
    }
  }
  min = Math.min(a, d);
  max = Math.max(a, d);
  for (i = 0; i < points.length; i++) 
    {
      min = Math.min(min, this.bezier(a, b, c, d, points[i]));
      max = Math.max(max, this.bezier(a, b, c, d, points[i]));
    }
  return [min, max];
}, curveDim: function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  var x = this.bezierDim(p1x, c1x, c2x, p2x), y = this.bezierDim(p1y, c1y, c2y, p2y);
  return {min: {x: x[0], y: y[0]}, max: {x: x[1], y: y[1]}};
}, getAnchors: function(prevX, prevY, curX, curY, nextX, nextY, value) {
  value = value || 4;
  var M = Math, PI = M.PI, halfPI = PI / 2, abs = M.abs, sin = M.sin, cos = M.cos, atan = M.atan, control1Length, control2Length, control1Angle, control2Angle, control1X, control1Y, control2X, control2Y, alpha;
  control1Length = (curX - prevX) / value;
  control2Length = (nextX - curX) / value;
  if ((curY >= prevY && curY >= nextY) || (curY <= prevY && curY <= nextY)) 
  {
    control1Angle = control2Angle = halfPI;
  } else {
    control1Angle = atan((curX - prevX) / abs(curY - prevY));
    if (prevY < curY) 
    {
      control1Angle = PI - control1Angle;
    }
    control2Angle = atan((nextX - curX) / abs(curY - nextY));
    if (nextY < curY) 
    {
      control2Angle = PI - control2Angle;
    }
  }
  alpha = halfPI - ((control1Angle + control2Angle) % (PI * 2)) / 2;
  if (alpha > halfPI) 
  {
    alpha -= PI;
  }
  control1Angle += alpha;
  control2Angle += alpha;
  control1X = curX - control1Length * sin(control1Angle);
  control1Y = curY + control1Length * cos(control1Angle);
  control2X = curX + control2Length * sin(control2Angle);
  control2Y = curY + control2Length * cos(control2Angle);
  if ((curY > prevY && control1Y < prevY) || (curY < prevY && control1Y > prevY)) 
  {
    control1X += abs(prevY - control1Y) * (control1X - curX) / (control1Y - curY);
    control1Y = prevY;
  }
  if ((curY > nextY && control2Y < nextY) || (curY < nextY && control2Y > nextY)) 
  {
    control2X -= abs(nextY - control2Y) * (control2X - curX) / (control2Y - curY);
    control2Y = nextY;
  }
  return {x1: control1X, y1: control1Y, x2: control2X, y2: control2Y};
}, smooth: function(originalPath, value) {
  var path = this.path2curve(originalPath), newp = [path[0]], x = path[0][1], y = path[0][2], j, points, i = 1, ii = path.length, beg = 1, mx = x, my = y, pathi, pathil, pathim, pathiml, pathip, pathipl, begl;
  for (; i < ii; i++) 
    {
      pathi = path[i];
      pathil = pathi.length;
      pathim = path[i - 1];
      pathiml = pathim.length;
      pathip = path[i + 1];
      pathipl = pathip && pathip.length;
      if (pathi[0] == "M") 
      {
        mx = pathi[1];
        my = pathi[2];
        j = i + 1;
        while (path[j][0] != "C") 
          {
            j++;
          }
        newp.push(["M", mx, my]);
        beg = newp.length;
        x = mx;
        y = my;
        continue;
      }
      if (pathi[pathil - 2] == mx && pathi[pathil - 1] == my && (!pathip || pathip[0] == "M")) 
      {
        begl = newp[beg].length;
        points = this.getAnchors(pathim[pathiml - 2], pathim[pathiml - 1], mx, my, newp[beg][begl - 2], newp[beg][begl - 1], value);
        newp[beg][1] = points.x2;
        newp[beg][2] = points.y2;
      } else if (!pathip || pathip[0] == "M") 
      {
        points = {x1: pathi[pathil - 2], y1: pathi[pathil - 1]};
      } else {
        points = this.getAnchors(pathim[pathiml - 2], pathim[pathiml - 1], pathi[pathil - 2], pathi[pathil - 1], pathip[pathipl - 2], pathip[pathipl - 1], value);
      }
      newp.push(["C", x, y, points.x1, points.y1, pathi[pathil - 2], pathi[pathil - 1]]);
      x = points.x2;
      y = points.y2;
    }
  return newp;
}, findDotAtSegment: function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  return {x: Math.pow(t1, 3) * p1x + Math.pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + Math.pow(t, 3) * p2x, y: Math.pow(t1, 3) * p1y + Math.pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + Math.pow(t, 3) * p2y};
}, snapEnds: function(from, to, stepsMax, prettyNumbers) {
  if (Ext.isDate(from)) 
  {
    return this.snapEndsByDate(from, to, stepsMax);
  }
  var step = (to - from) / stepsMax, level = Math.floor(Math.log(step) / Math.LN10) + 1, m = Math.pow(10, level), cur, floor, modulo = Math.round((step % m) * Math.pow(10, 2 - level)), interval = [[0, 15], [10, 1], [20, 4], [25, 2], [50, 9], [100, 15]], stepCount = 0, value, weight, i, topValue, topWeight = 1000000000, ln = interval.length;
  floor = Math.floor(from / m) * m;
  if (from == floor && floor > 0) 
  {
    floor = Math.floor((from - (m / 10)) / m) * m;
  }
  if (prettyNumbers) 
  {
    for (i = 0; i < ln; i++) 
      {
        value = interval[i][0];
        weight = (value - modulo) < 0 ? 1000000 : (value - modulo) / interval[i][1];
        if (weight < topWeight) 
        {
          topValue = value;
          topWeight = weight;
        }
      }
    step = Math.floor(step * Math.pow(10, -level)) * Math.pow(10, level) + topValue * Math.pow(10, level - 2);
    if (from < 0 && to >= 0) 
    {
      cur = 0;
      while (cur > from) 
        {
          cur -= step;
          stepCount++;
        }
      from = +cur.toFixed(10);
      cur = 0;
      while (cur < to) 
        {
          cur += step;
          stepCount++;
        }
      to = +cur.toFixed(10);
    } else {
      cur = from = floor;
      while (cur < to) 
        {
          cur += step;
          stepCount++;
        }
    }
    to = +cur.toFixed(10);
  } else {
    from = floor;
    stepCount = stepsMax;
  }
  return {from: from, to: to, power: level, step: step, steps: stepCount};
}, snapEndsByDate: function(from, to, stepsMax, lockEnds) {
  var selectedStep = false, scales = [[Ext.Date.MILLI, [1, 2, 5, 10, 20, 50, 100, 200, 250, 500]], [Ext.Date.SECOND, [1, 2, 5, 10, 15, 30]], [Ext.Date.MINUTE, [1, 2, 5, 10, 15, 30]], [Ext.Date.HOUR, [1, 2, 3, 4, 6, 12]], [Ext.Date.DAY, [1, 2, 7, 14]], [Ext.Date.MONTH, [1, 2, 3, 6]]], sLen = scales.length, stop = false, scale, j, yearDiff, s;
  for (s = 0; s < sLen; s++) 
    {
      scale = scales[s];
      if (!stop) 
      {
        for (j = 0; j < scale[1].length; j++) 
          {
            if (to < Ext.Date.add(from, scale[0], scale[1][j] * stepsMax)) 
            {
              selectedStep = [scale[0], scale[1][j]];
              stop = true;
              break;
            }
          }
      }
    }
  if (!selectedStep) 
  {
    yearDiff = this.snapEnds(from.getFullYear(), to.getFullYear() + 1, stepsMax, lockEnds);
    selectedStep = [Date.YEAR, Math.round(yearDiff.step)];
  }
  return this.snapEndsByDateAndStep(from, to, selectedStep, lockEnds);
}, snapEndsByDateAndStep: function(from, to, step, lockEnds) {
  var fromStat = [from.getFullYear(), from.getMonth(), from.getDate(), from.getHours(), from.getMinutes(), from.getSeconds(), from.getMilliseconds()], testFrom, testTo, date, year, month, day, fractionalMonth, stepsArray, stepUnit = step[0], stepValue = step[1], steps = 0;
  if (lockEnds) 
  {
    testFrom = from;
  } else {
    switch (stepUnit) {
      case Ext.Date.MILLI:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3], fromStat[4], fromStat[5], Math.floor(fromStat[6] / stepValue) * stepValue);
        break;
      case Ext.Date.SECOND:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3], fromStat[4], Math.floor(fromStat[5] / stepValue) * stepValue, 0);
        break;
      case Ext.Date.MINUTE:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3], Math.floor(fromStat[4] / stepValue) * stepValue, 0, 0);
        break;
      case Ext.Date.HOUR:
        testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], Math.floor(fromStat[3] / stepValue) * stepValue, 0, 0, 0);
        break;
      case Ext.Date.DAY:
        testFrom = new Date(fromStat[0], fromStat[1], Math.floor((fromStat[2] - 1) / stepValue) * stepValue + 1, 0, 0, 0, 0);
        break;
      case Ext.Date.MONTH:
        testFrom = new Date(fromStat[0], Math.floor(fromStat[1] / stepValue) * stepValue, 1, 0, 0, 0, 0);
        steps = [];
        stepsArray = true;
        break;
      default:
        testFrom = new Date(Math.floor(fromStat[0] / stepValue) * stepValue, 0, 1, 0, 0, 0, 0);
        steps = [];
        stepsArray = true;
        break;
    }
  }
  fractionalMonth = ((stepUnit === Ext.Date.MONTH) && (stepValue == 1 / 2 || stepValue == 1 / 3 || stepValue == 1 / 4));
  testTo = new Date(testFrom);
  while (testTo < to) 
    {
      if (fractionalMonth) 
      {
        date = new Date(testTo);
        year = date.getFullYear();
        month = date.getMonth();
        day = date.getDate();
        switch (stepValue) {
          case 1 / 2:
            if (day >= 15) 
            {
              day = 1;
              if (++month > 11) 
              {
                year++;
              }
            } else {
              day = 15;
            }
            break;
          case 1 / 3:
            if (day >= 20) 
            {
              day = 1;
              if (++month > 11) 
              {
                year++;
              }
            } else {
              if (day >= 10) 
              {
                day = 20;
              } else {
                day = 10;
              }
            }
            break;
          case 1 / 4:
            if (day >= 22) 
            {
              day = 1;
              if (++month > 11) 
              {
                year++;
              }
            } else {
              if (day >= 15) 
              {
                day = 22;
              } else {
                if (day >= 8) 
                {
                  day = 15;
                } else {
                  day = 8;
                }
              }
            }
            break;
        }
        testTo.setYear(year);
        testTo.setMonth(month);
        testTo.setDate(day);
        steps.push(new Date(testTo));
      } else if (stepsArray) 
      {
        testTo = Ext.Date.add(testTo, stepUnit, stepValue);
        steps.push(new Date(testTo));
      } else {
        testTo = Ext.Date.add(testTo, stepUnit, stepValue);
        steps++;
      }
    }
  if (lockEnds) 
  {
    testTo = to;
  }
  if (stepsArray) 
  {
    return {from: +testFrom, to: +testTo, steps: steps};
  } else {
    return {from: +testFrom, to: +testTo, step: (testTo - testFrom) / steps, steps: steps};
  }
}, sorter: function(a, b) {
  return a.offset - b.offset;
}, rad: function(degrees) {
  return degrees % 360 * Math.PI / 180;
}, normalizeRadians: function(radian) {
  var twoPi = 2 * Math.PI;
  if (radian >= 0) 
  {
    return radian % twoPi;
  }
  return ((radian % twoPi) + twoPi) % twoPi;
}, degrees: function(radian) {
  return radian * 180 / Math.PI % 360;
}, normalizeDegrees: function(degrees) {
  if (degrees >= 0) 
  {
    return degrees % 360;
  }
  return ((degrees % 360) + 360) % 360;
}, withinBox: function(x, y, bbox) {
  bbox = bbox || {};
  return (x >= bbox.x && x <= (bbox.x + bbox.width) && y >= bbox.y && y <= (bbox.y + bbox.height));
}, parseGradient: function(gradient) {
  var me = this, type = gradient.type || 'linear', angle = gradient.angle || 0, radian = me.radian, stops = gradient.stops, stopsArr = [], stop, vector, max, stopObj;
  if (type == 'linear') 
  {
    vector = [0, 0, Math.cos(angle * radian), Math.sin(angle * radian)];
    max = 1 / (Math.max(Math.abs(vector[2]), Math.abs(vector[3])) || 1);
    vector[2] *= max;
    vector[3] *= max;
    if (vector[2] < 0) 
    {
      vector[0] = -vector[2];
      vector[2] = 0;
    }
    if (vector[3] < 0) 
    {
      vector[1] = -vector[3];
      vector[3] = 0;
    }
  }
  for (stop in stops) 
    {
      if (stops.hasOwnProperty(stop) && me.stopsRE.test(stop)) 
      {
        stopObj = {offset: parseInt(stop, 10), color: Ext.draw.Color.toHex(stops[stop].color) || '#ffffff', opacity: stops[stop].opacity || 1};
        stopsArr.push(stopObj);
      }
    }
  Ext.Array.sort(stopsArr, me.sorter);
  if (type == 'linear') 
  {
    return {id: gradient.id, type: type, vector: vector, stops: stopsArr};
  } else {
    return {id: gradient.id, type: type, centerX: gradient.centerX, centerY: gradient.centerY, focalX: gradient.focalX, focalY: gradient.focalY, radius: gradient.radius, vector: vector, stops: stopsArr};
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'Draw'], 0));
;

(Ext.cmd.derive('Ext.fx.PropertyHandler', Ext.Base, {statics: {defaultHandler: {pixelDefaultsRE: /width|height|top$|bottom$|left$|right$/i, unitRE: /^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/, scrollRE: /^scroll/i, computeDelta: function(from, end, damper, initial, attr) {
  damper = (typeof damper == 'number') ? damper : 1;
  var unitRE = this.unitRE, match = unitRE.exec(from), start, units;
  if (match) 
  {
    from = match[1];
    units = match[2];
    if (!this.scrollRE.test(attr) && !units && this.pixelDefaultsRE.test(attr)) 
    {
      units = 'px';
    }
  }
  from = +from || 0;
  match = unitRE.exec(end);
  if (match) 
  {
    end = match[1];
    units = match[2] || units;
  }
  end = +end || 0;
  start = (initial != null) ? initial : from;
  return {from: from, delta: (end - start) * damper, units: units};
}, get: function(from, end, damper, initialFrom, attr) {
  var ln = from.length, out = [], i, initial, res, j, len;
  for (i = 0; i < ln; i++) 
    {
      if (initialFrom) 
      {
        initial = initialFrom[i][1].from;
      }
      if (Ext.isArray(from[i][1]) && Ext.isArray(end)) 
      {
        res = [];
        j = 0;
        len = from[i][1].length;
        for (; j < len; j++) 
          {
            res.push(this.computeDelta(from[i][1][j], end[j], damper, initial, attr));
          }
        out.push([from[i][0], res]);
      } else {
        out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
      }
    }
  return out;
}, set: function(values, easing) {
  var ln = values.length, out = [], i, val, res, len, j;
  for (i = 0; i < ln; i++) 
    {
      val = values[i][1];
      if (Ext.isArray(val)) 
      {
        res = [];
        j = 0;
        len = val.length;
        for (; j < len; j++) 
          {
            res.push(val[j].from + val[j].delta * easing + (val[j].units || 0));
          }
        out.push([values[i][0], res]);
      } else {
        out.push([values[i][0], val.from + val.delta * easing + (val.units || 0)]);
      }
    }
  return out;
}}, stringHandler: {computeDelta: function(from, end, damper, initial, attr) {
  return {from: from, delta: end};
}, get: function(from, end, damper, initialFrom, attr) {
  var ln = from.length, out = [], i, initial, res, j, len;
  for (i = 0; i < ln; i++) 
    {
      out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
    }
  return out;
}, set: function(values, easing) {
  var ln = values.length, out = [], i, val, res, len, j;
  for (i = 0; i < ln; i++) 
    {
      val = values[i][1];
      out.push([values[i][0], val.delta]);
    }
  return out;
}}, color: {rgbRE: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i, hexRE: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i, hex3RE: /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i, parseColor: function(color, damper) {
  damper = (typeof damper == 'number') ? damper : 1;
  var out = false, reList = [this.hexRE, this.rgbRE, this.hex3RE], length = reList.length, match, base, re, i;
  for (i = 0; i < length; i++) 
    {
      re = reList[i];
      base = (i % 2 === 0) ? 16 : 10;
      match = re.exec(color);
      if (match && match.length === 4) 
      {
        if (i === 2) 
        {
          match[1] += match[1];
          match[2] += match[2];
          match[3] += match[3];
        }
        out = {red: parseInt(match[1], base), green: parseInt(match[2], base), blue: parseInt(match[3], base)};
        break;
      }
    }
  return out || color;
}, computeDelta: function(from, end, damper, initial) {
  from = this.parseColor(from);
  end = this.parseColor(end, damper);
  var start = initial ? initial : from, tfrom = typeof start, tend = typeof end;
  if (tfrom == 'string' || tfrom == 'undefined' || tend == 'string' || tend == 'undefined') 
  {
    return end || start;
  }
  return {from: from, delta: {red: Math.round((end.red - start.red) * damper), green: Math.round((end.green - start.green) * damper), blue: Math.round((end.blue - start.blue) * damper)}};
}, get: function(start, end, damper, initialFrom) {
  var ln = start.length, out = [], i, initial;
  for (i = 0; i < ln; i++) 
    {
      if (initialFrom) 
      {
        initial = initialFrom[i][1].from;
      }
      out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
    }
  return out;
}, set: function(values, easing) {
  var ln = values.length, out = [], i, val, parsedString, from, delta;
  for (i = 0; i < ln; i++) 
    {
      val = values[i][1];
      if (val) 
      {
        from = val.from;
        delta = val.delta;
        val = (typeof val == 'object' && 'red' in val) ? 'rgb(' + val.red + ', ' + val.green + ', ' + val.blue + ')' : val;
        val = (typeof val == 'object' && val.length) ? val[0] : val;
        if (typeof val == 'undefined') 
        {
          return [];
        }
        parsedString = typeof val == 'string' ? val : 'rgb(' + [(from.red + Math.round(delta.red * easing)) % 256, (from.green + Math.round(delta.green * easing)) % 256, (from.blue + Math.round(delta.blue * easing)) % 256].join(',') + ')';
        out.push([values[i][0], parsedString]);
      }
    }
  return out;
}}, object: {interpolate: function(prop, damper) {
  damper = (typeof damper == 'number') ? damper : 1;
  var out = {}, p;
  for (p in prop) 
    {
      out[p] = parseFloat(prop[p]) * damper;
    }
  return out;
}, computeDelta: function(from, end, damper, initial) {
  from = this.interpolate(from);
  end = this.interpolate(end, damper);
  var start = initial ? initial : from, delta = {}, p;
  for (p in end) 
    {
      delta[p] = end[p] - start[p];
    }
  return {from: from, delta: delta};
}, get: function(start, end, damper, initialFrom) {
  var ln = start.length, out = [], i, initial;
  for (i = 0; i < ln; i++) 
    {
      if (initialFrom) 
      {
        initial = initialFrom[i][1].from;
      }
      out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
    }
  return out;
}, set: function(values, easing) {
  var ln = values.length, out = [], outObject = {}, i, from, delta, val, p;
  for (i = 0; i < ln; i++) 
    {
      val = values[i][1];
      from = val.from;
      delta = val.delta;
      for (p in from) 
        {
          outObject[p] = from[p] + delta[p] * easing;
        }
      out.push([values[i][0], outObject]);
    }
  return out;
}}, path: {computeDelta: function(from, end, damper, initial) {
  damper = (typeof damper == 'number') ? damper : 1;
  var start;
  from = +from || 0;
  end = +end || 0;
  start = (initial != null) ? initial : from;
  return {from: from, delta: (end - start) * damper};
}, forcePath: function(path) {
  if (!Ext.isArray(path) && !Ext.isArray(path[0])) 
  {
    path = Ext.draw.Draw.parsePathString(path);
  }
  return path;
}, get: function(start, end, damper, initialFrom) {
  var endPath = this.forcePath(end), out = [], startLn = start.length, startPathLn, pointsLn, i, deltaPath, initial, j, k, path, startPath;
  for (i = 0; i < startLn; i++) 
    {
      startPath = this.forcePath(start[i][1]);
      deltaPath = Ext.draw.Draw.interpolatePaths(startPath, endPath);
      startPath = deltaPath[0];
      endPath = deltaPath[1];
      startPathLn = startPath.length;
      path = [];
      for (j = 0; j < startPathLn; j++) 
        {
          deltaPath = [startPath[j][0]];
          pointsLn = startPath[j].length;
          for (k = 1; k < pointsLn; k++) 
            {
              initial = initialFrom && initialFrom[0][1][j][k].from;
              deltaPath.push(this.computeDelta(startPath[j][k], endPath[j][k], damper, initial));
            }
          path.push(deltaPath);
        }
      out.push([start[i][0], path]);
    }
  return out;
}, set: function(values, easing) {
  var ln = values.length, out = [], i, j, k, newPath, calcPath, deltaPath, deltaPathLn, pointsLn;
  for (i = 0; i < ln; i++) 
    {
      deltaPath = values[i][1];
      newPath = [];
      deltaPathLn = deltaPath.length;
      for (j = 0; j < deltaPathLn; j++) 
        {
          calcPath = [deltaPath[j][0]];
          pointsLn = deltaPath[j].length;
          for (k = 1; k < pointsLn; k++) 
            {
              calcPath.push(deltaPath[j][k].from + deltaPath[j][k].delta * easing);
            }
          newPath.push(calcPath.join(','));
        }
      out.push([values[i][0], newPath.join(',')]);
    }
  return out;
}}}}, 0, 0, 0, 0, 0, 0, [Ext.fx, 'PropertyHandler'], function() {
  var props = ['outlineColor', 'backgroundColor', 'borderColor', 'borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor', 'fill', 'stroke'], length = props.length, i = 0, prop;
  for (; i < length; i++) 
    {
      prop = props[i];
      this[prop] = this.color;
    }
  props = ['cursor'];
  length = props.length;
  i = 0;
  for (; i < length; i++) 
    {
      prop = props[i];
      this[prop] = this.stringHandler;
    }
}));
;

(Ext.cmd.derive('Ext.fx.Anim', Ext.Base, {isAnimation: true, duration: 250, delay: 0, delayStart: 0, dynamic: false, easing: 'ease', damper: 1, bezierRE: /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/, reverse: false, running: false, paused: false, iterations: 1, autoEnd: false, alternate: false, currentIteration: 0, startTime: 0, frameCount: 0, constructor: function(config) {
  var me = this, curve;
  config = config || {};
  if (config.keyframes) 
  {
    return new Ext.fx.Animator(config);
  }
  Ext.apply(me, config);
  if (me.from === undefined) 
  {
    me.from = {};
  }
  me.propHandlers = {};
  me.config = config;
  me.target = Ext.fx.Manager.createTarget(me.target);
  me.easingFn = Ext.fx.Easing[me.easing];
  me.target.dynamic = me.dynamic;
  if (!me.easingFn) 
  {
    me.easingFn = String(me.easing).match(me.bezierRE);
    if (me.easingFn && me.easingFn.length == 5) 
    {
      curve = me.easingFn;
      me.easingFn = Ext.fx.CubicBezier.cubicBezier(+curve[1], +curve[2], +curve[3], +curve[4]);
    }
  }
  me.id = Ext.id(null, 'ext-anim-');
  me.addEvents('beforeanimate', 'afteranimate', 'lastframe');
  me.mixins.observable.constructor.call(me);
  Ext.fx.Manager.addAnim(me);
  if (config.autoEnd) 
  {
    me.running = true;
    me.jumpToEnd();
  }
}, setAttr: function(attr, value) {
  return Ext.fx.Manager.items.get(this.id).setAttr(this.target, attr, value);
}, initAttrs: function() {
  var me = this, from = me.from, to = me.to, initialFrom = me.initialFrom || {}, out = {}, start, end, propHandler, attr;
  for (attr in to) 
    {
      if (to.hasOwnProperty(attr)) 
      {
        start = me.target.getAttr(attr, from[attr]);
        end = to[attr];
        if (!Ext.fx.PropertyHandler[attr]) 
        {
          if (Ext.isObject(end)) 
          {
            propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.object;
          } else {
            propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.defaultHandler;
          }
        } else {
          propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler[attr];
        }
        out[attr] = propHandler.get(start, end, me.damper, initialFrom[attr], attr);
      }
    }
  me.currentAttrs = out;
}, start: function(startTime) {
  var me = this, delay = me.delay, delayStart = me.delayStart, delayDelta;
  if (delay) 
  {
    if (!delayStart) 
    {
      me.delayStart = startTime;
      return;
    } else {
      delayDelta = startTime - delayStart;
      if (delayDelta < delay) 
      {
        return;
      } else {
        startTime = new Date(delayStart.getTime() + delay);
      }
    }
  }
  if (me.fireEvent('beforeanimate', me) !== false) 
  {
    me.startTime = startTime;
    if (!me.paused && !me.currentAttrs) 
    {
      me.initAttrs();
    }
    me.running = true;
    me.frameCount = 0;
  }
}, jumpToEnd: function() {
  var me = this;
  if (!me.endWasCalled) 
  {
    if (!me.currentAttrs) 
    {
      me.initAttrs();
    }
    Ext.fx.Manager.jumpToEnd(me);
    me.end();
  }
}, runAnim: function(elapsedTime) {
  var me = this, attrs = me.currentAttrs, duration = me.duration, easingFn = me.easingFn, propHandlers = me.propHandlers, ret = {}, easing, values, attr, lastFrame;
  if (elapsedTime >= duration) 
  {
    elapsedTime = duration;
    lastFrame = true;
  }
  if (me.reverse) 
  {
    elapsedTime = duration - elapsedTime;
  }
  for (attr in attrs) 
    {
      if (attrs.hasOwnProperty(attr)) 
      {
        values = attrs[attr];
        easing = lastFrame ? 1 : easingFn(elapsedTime / duration);
        ret[attr] = propHandlers[attr].set(values, easing);
      }
    }
  me.frameCount++;
  return ret;
}, lastFrame: function() {
  var me = this, iter = me.iterations, iterCount = me.currentIteration;
  iterCount++;
  if (iterCount < iter) 
  {
    if (me.alternate) 
    {
      me.reverse = !me.reverse;
    }
    me.startTime = new Date();
    me.currentIteration = iterCount;
    me.paused = false;
  } else {
    me.currentIteration = 0;
    me.end();
    me.fireEvent('lastframe', me, me.startTime);
  }
}, endWasCalled: 0, end: function() {
  var me = this;
  if (me.endWasCalled++) 
  {
    return;
  }
  me.startTime = 0;
  me.paused = false;
  me.running = false;
  Ext.fx.Manager.removeAnim(me);
  me.fireEvent('afteranimate', me, me.startTime);
  Ext.callback(me.callback, me.scope, [me, me.startTime]);
  if (me.remove) 
  {
    me.target.remove();
  }
}, isReady: function() {
  return this.paused === false && this.running === false && this.iterations > 0;
}, isRunning: function() {
  return this.paused === false && this.running === true && this.isAnimator !== true;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.fx, 'Anim'], 0));
;
Ext.enableFx = true;

(Ext.cmd.derive('Ext.util.Animate', Ext.Base, {isAnimate: true, animate: function(animObj) {
  var me = this;
  if (Ext.fx.Manager.hasFxBlock(me.id)) 
  {
    return me;
  }
  Ext.fx.Manager.queueFx(new Ext.fx.Anim(me.anim(animObj)));
  return this;
}, anim: function(config) {
  if (!Ext.isObject(config)) 
  {
    return (config) ? {} : false;
  }
  var me = this;
  if (config.stopAnimation) 
  {
    me.stopAnimation();
  }
  Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
  return Ext.apply({target: me, paused: true}, config);
}, getAnimationProps: function() {
  var me = this, layout = me.layout;
  return layout && layout.animate ? layout.animate : {};
}, stopFx: Ext.Function.alias(Ext.util.Animate, 'stopAnimation'), stopAnimation: function() {
  Ext.fx.Manager.stopAnimation(this.id);
  return this;
}, syncFx: function() {
  Ext.fx.Manager.setFxDefaults(this.id, {concurrent: true});
  return this;
}, sequenceFx: function() {
  Ext.fx.Manager.setFxDefaults(this.id, {concurrent: false});
  return this;
}, hasActiveFx: Ext.Function.alias(Ext.util.Animate, 'getActiveAnimation'), getActiveAnimation: function() {
  return Ext.fx.Manager.getActiveAnimation(this.id);
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Animate'], function() {
  Ext.applyIf(Ext.Element.prototype, this.prototype);
  Ext.CompositeElementLite.importElementMethods();
}));
;

(Ext.cmd.derive('Ext.util.ElementContainer', Ext.Base, {childEls: [], constructor: function() {
  var me = this, childEls;
  if (me.hasOwnProperty('childEls')) 
  {
    childEls = me.childEls;
    delete me.childEls;
    me.addChildEls.apply(me, childEls);
  }
}, destroy: function() {
  var me = this, childEls = me.getChildEls(), child, childName, i, k;
  for (i = childEls.length; i--; ) 
    {
      childName = childEls[i];
      if (typeof childName != 'string') 
      {
        childName = childName.name;
      }
      child = me[childName];
      if (child) 
      {
        me[childName] = null;
        child.remove();
      }
    }
}, addChildEls: function() {
  var me = this, args = arguments;
  if (me.hasOwnProperty('childEls')) 
  {
    me.childEls.push.apply(me.childEls, args);
  } else {
    me.childEls = me.getChildEls().concat(Array.prototype.slice.call(args));
  }
  me.prune(me.childEls, false);
}, applyChildEls: function(el, id) {
  var me = this, childEls = me.getChildEls(), baseId, childName, i, selector, value;
  baseId = (id || me.id) + '-';
  for (i = childEls.length; i--; ) 
    {
      childName = childEls[i];
      if (typeof childName == 'string') 
      {
        value = el.getById(baseId + childName);
      } else {
        if ((selector = childName.select)) 
        {
          value = Ext.select(selector, true, el.dom);
        } else if ((selector = childName.selectNode)) 
        {
          value = Ext.get(Ext.DomQuery.selectNode(selector, el.dom));
        } else {
          value = el.getById(childName.id || (baseId + childName.itemId));
        }
        childName = childName.name;
      }
      me[childName] = value;
    }
}, getChildEls: function() {
  var me = this, self;
  if (me.hasOwnProperty('childEls')) 
  {
    return me.childEls;
  }
  self = me.self;
  return self.$childEls || me.getClassChildEls(self);
}, getClassChildEls: function(cls) {
  var me = this, result = cls.$childEls, childEls, i, length, forked, mixin, mixins, name, parts, proto, supr, superMixins;
  if (!result) 
  {
    supr = cls.superclass;
    if (supr) 
    {
      supr = supr.self;
      parts = [supr.$childEls || me.getClassChildEls(supr)];
      superMixins = supr.prototype.mixins || {};
    } else {
      parts = [];
      superMixins = {};
    }
    proto = cls.prototype;
    mixins = proto.mixins;
    for (name in mixins) 
      {
        if (mixins.hasOwnProperty(name) && !superMixins.hasOwnProperty(name)) 
        {
          mixin = mixins[name].self;
          parts.push(mixin.$childEls || me.getClassChildEls(mixin));
        }
      }
    parts.push(proto.hasOwnProperty('childEls') && proto.childEls);
    for (i = 0 , length = parts.length; i < length; ++i) 
      {
        childEls = parts[i];
        if (childEls && childEls.length) 
        {
          if (!result) 
          {
            result = childEls;
          } else {
            if (!forked) 
            {
              forked = true;
              result = result.slice(0);
            }
            result.push.apply(result, childEls);
          }
        }
      }
    cls.$childEls = result = (result ? me.prune(result, !forked) : []);
  }
  return result;
}, prune: function(childEls, shared) {
  var index = childEls.length, map = {}, name;
  while (index--) 
    {
      name = childEls[index];
      if (typeof name != 'string') 
      {
        name = name.name;
      }
      if (!map[name]) 
      {
        map[name] = 1;
      } else {
        if (shared) 
        {
          shared = false;
          childEls = childEls.slice(0);
        }
        Ext.Array.erase(childEls, index, 1);
      }
    }
  return childEls;
}, removeChildEls: function(testFn) {
  var me = this, old = me.getChildEls(), keepers = (me.childEls = []), n, i, cel;
  for (i = 0 , n = old.length; i < n; ++i) 
    {
      cel = old[i];
      if (!testFn(cel)) 
      {
        keepers.push(cel);
      }
    }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'ElementContainer'], 0));
;

(Ext.cmd.derive('Ext.util.Renderable', Ext.Base, {frameCls: Ext.baseCSSPrefix + 'frame', frameIdRegex: /[\-]frame\d+[TMB][LCR]$/, frameElNames: ['TL', 'TC', 'TR', 'ML', 'MC', 'MR', 'BL', 'BC', 'BR', 'Table'], frameTpl: ['{%this.renderDockedItems(out,values,0);%}', '<tpl if="top">', '<tpl if="left"><div id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></tpl>', '<div id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', '</tpl>', '<tpl if="left"><div id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></tpl>', '<div id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" role="presentation">', '{%this.applyRenderTpl(out, values)%}', '</div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', '<tpl if="bottom">', '<tpl if="left"><div id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></tpl>', '<tpl if="right"><div id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></tpl>', '<div id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></div>', '<tpl if="right"></div></tpl>', '<tpl if="left"></div></tpl>', '</tpl>', '{%this.renderDockedItems(out,values,1);%}'], frameTableTpl: ['{%this.renderDockedItems(out,values,0);%}', '<table id="{fgid}Table" class="', Ext.plainTableCls, '" cellpadding="0" role="presentation">', '<tbody role="presentation">', '<tpl if="top">', '<tr role="presentation">', '<tpl if="left"><td id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></td></tpl>', '<td id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></td>', '<tpl if="right"><td id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></td></tpl>', '</tr>', '</tpl>', '<tr role="presentation">', '<tpl if="left"><td id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></td></tpl>', '<td id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" role="presentation">', '{%this.applyRenderTpl(out, values)%}', '</td>', '<tpl if="right"><td id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></td></tpl>', '</tr>', '<tpl if="bottom">', '<tr role="presentation">', '<tpl if="left"><td id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></td></tpl>', '<td id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></td>', '<tpl if="right"><td id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></td></tpl>', '</tr>', '</tpl>', '</tbody></table>', '{%this.renderDockedItems(out,values,1);%}'], afterRender: function() {
  var me = this, data = {}, protoEl = me.protoEl, target = me.el, item, pre, hide, contentEl;
  me.finishRenderChildren();
  if (me.contentEl) 
  {
    pre = Ext.baseCSSPrefix;
    hide = pre + 'hide-';
    contentEl = Ext.get(me.contentEl);
    contentEl.removeCls([pre + 'hidden', hide + 'display', hide + 'offsets', hide + 'nosize']);
    me.getContentTarget().appendChild(contentEl.dom);
  }
  protoEl.writeTo(data);
  item = data.removed;
  if (item) 
  {
    target.removeCls(item);
  }
  item = data.cls;
  if (item.length) 
  {
    target.addCls(item);
  }
  item = data.style;
  if (data.style) 
  {
    target.setStyle(item);
  }
  me.protoEl = null;
  if (!me.ownerCt) 
  {
    me.updateLayout();
  }
}, afterFirstLayout: function(width, height) {
  var me = this, x = me.x, y = me.y, hasX, hasY, pos, xy, alignSpec = me.defaultAlign, alignOffset = me.alignOffset;
  if (!me.ownerLayout) 
  {
    hasX = Ext.isDefined(x);
    hasY = Ext.isDefined(y);
  }
  if (me.floating && (!hasX || !hasY)) 
  {
    if (me.floatParent) 
    {
      pos = me.floatParent.getTargetEl().getViewRegion();
      xy = me.el.getAlignToXY(me.alignTarget || me.floatParent.getTargetEl(), alignSpec, alignOffset);
      pos.x = xy[0] - pos.x;
      pos.y = xy[1] - pos.y;
    } else {
      xy = me.el.getAlignToXY(me.alignTarget || me.container, alignSpec, alignOffset);
      pos = me.container.translateXY(xy[0], xy[1]);
    }
    x = hasX ? x : pos.x;
    y = hasY ? y : pos.y;
    hasX = hasY = true;
  }
  if (hasX || hasY) 
  {
    me.setPosition(x, y);
  }
  me.onBoxReady(width, height);
}, applyRenderSelectors: function() {
  var me = this, selectors = me.renderSelectors, el = me.el, dom = el.dom, selector;
  me.applyChildEls(el);
  if (selectors) 
  {
    for (selector in selectors) 
      {
        if (selectors.hasOwnProperty(selector) && selectors[selector]) 
        {
          me[selector] = Ext.get(Ext.DomQuery.selectNode(selectors[selector], dom));
        }
      }
  }
}, beforeRender: function() {
  var me = this, target = me.getTargetEl(), overflowEl = me.getOverflowEl(), layout = me.getComponentLayout(), overflowStyle = me.getOverflowStyle();
  me.frame = me.frame || me.alwaysFramed;
  if (!layout.initialized) 
  {
    layout.initLayout();
  }
  if (overflowEl) 
  {
    overflowEl.setStyle(overflowStyle);
    me.overflowStyleSet = true;
  }
  me.setUI(me.ui);
  if (me.disabled) 
  {
    me.disable(true);
  }
}, doApplyRenderTpl: function(out, values) {
  var me = values.$comp, tpl;
  if (!me.rendered) 
  {
    tpl = me.initRenderTpl();
    tpl.applyOut(values.renderData, out);
  }
}, doAutoRender: function() {
  var me = this;
  if (!me.rendered) 
  {
    if (me.floating) 
    {
      me.render(me.renderTo || document.body);
    } else {
      me.render(Ext.isBoolean(me.autoRender) ? Ext.getBody() : me.autoRender);
    }
  }
}, doRenderContent: function(out, renderData) {
  var me = renderData.$comp;
  if (me.html) 
  {
    Ext.DomHelper.generateMarkup(me.html, out);
    delete me.html;
  }
  if (me.tpl) 
  {
    if (!me.tpl.isTemplate) 
    {
      me.tpl = new Ext.XTemplate(me.tpl);
    }
    if (me.data) 
    {
      me.tpl.applyOut(me.data, out);
      delete me.data;
    }
  }
}, doRenderFramingDockedItems: function(out, renderData, after) {
  var me = renderData.$comp;
  if (!me.rendered && me.doRenderDockedItems) 
  {
    renderData.renderData.$skipDockedItems = true;
    me.doRenderDockedItems.call(this, out, renderData, after);
  }
}, finishRender: function(containerIdx) {
  var me = this, tpl, data, el;
  if (!me.el || me.$pid) 
  {
    if (me.container) 
    {
      el = me.container.getById(me.id, true);
    } else {
      el = Ext.getDom(me.id);
    }
    if (!me.el) 
    {
      me.wrapPrimaryEl(el);
    } else {
      delete me.$pid;
      if (!me.el.dom) 
      {
        me.wrapPrimaryEl(me.el);
      }
      el.parentNode.insertBefore(me.el.dom, el);
      Ext.removeNode(el);
    }
  } else if (!me.rendering) 
  {
    tpl = me.initRenderTpl();
    if (tpl) 
    {
      data = me.initRenderData();
      tpl.insertFirst(me.getTargetEl(), data);
    }
  }
  if (!me.container) 
  {
    me.container = Ext.get(me.el.dom.parentNode);
  }
  if (me.ctCls) 
  {
    me.container.addCls(me.ctCls);
  }
  me.onRender(me.container, containerIdx);
  if (!me.overflowStyleSet) 
  {
    me.getOverflowEl().setStyle(me.getOverflowStyle());
  }
  me.el.setVisibilityMode(Ext.Element[me.hideMode.toUpperCase()]);
  if (me.overCls) 
  {
    me.el.hover(me.addOverCls, me.removeOverCls, me);
  }
  if (me.hasListeners.render) 
  {
    me.fireEvent('render', me);
  }
  me.afterRender();
  if (me.hasListeners.afterrender) 
  {
    me.fireEvent('afterrender', me);
  }
  me.initEvents();
  if (me.hidden) 
  {
    me.el.hide();
  }
}, finishRenderChildren: function() {
  var layout = this.getComponentLayout();
  layout.finishRender();
}, getElConfig: function() {
  var me = this, autoEl = me.autoEl, frameInfo = me.getFrameInfo(), config = {tag: 'div', tpl: frameInfo ? me.initFramingTpl(frameInfo.table) : me.initRenderTpl()}, protoEl = me.protoEl, i, frameElNames, len, suffix, frameGenId, frameData;
  me.initStyles(protoEl);
  protoEl.writeTo(config);
  protoEl.flush();
  if (Ext.isString(autoEl)) 
  {
    config.tag = autoEl;
  } else {
    Ext.apply(config, autoEl);
  }
  config.id = me.id;
  if (config.tpl) 
  {
    if (frameInfo) 
    {
      frameElNames = me.frameElNames;
      len = frameElNames.length;
      config.tplData = frameData = me.getFrameRenderData();
      frameData.renderData = me.initRenderData();
      frameGenId = frameData.fgid;
      for (i = 0; i < len; i++) 
        {
          suffix = frameElNames[i];
          me.addChildEls({name: 'frame' + suffix, id: frameGenId + suffix});
        }
      me.addChildEls({name: 'frameBody', id: frameGenId + 'MC'});
    } else {
      config.tplData = me.initRenderData();
    }
  }
  return config;
}, initFramingTpl: function(table) {
  var tpl = this.getFrameTpl(table);
  if (tpl && !tpl.applyRenderTpl) 
  {
    this.setupFramingTpl(tpl);
  }
  return tpl;
}, setupFramingTpl: function(frameTpl) {
  frameTpl.applyRenderTpl = this.doApplyRenderTpl;
  frameTpl.renderDockedItems = this.doRenderFramingDockedItems;
}, getInsertPosition: function(position) {
  if (position !== undefined) 
  {
    if (Ext.isNumber(position)) 
    {
      position = this.container.dom.childNodes[position];
    } else {
      position = Ext.getDom(position);
    }
  }
  return position;
}, getRenderTree: function() {
  var me = this;
  if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) 
  {
    me.beforeRender();
    me.rendering = true;
    if (me.el) 
    {
      return {tag: 'div', role: 'presentation', id: (me.$pid = Ext.id())};
    }
    return me.getElConfig();
  }
  return null;
}, initContainer: function(container) {
  var me = this;
  if (!container && me.el) 
  {
    container = me.el.dom.parentNode;
    me.allowDomMove = false;
  }
  me.container = container.dom ? container : Ext.get(container);
  return me.container;
}, initRenderData: function() {
  var me = this;
  return Ext.apply({$comp: me, id: me.id, ui: me.ui, uiCls: me.uiCls, baseCls: me.baseCls, componentCls: me.componentCls, frame: me.frame, role: me.ariaRole, childElCls: ''}, me.renderData);
}, initRenderTpl: function() {
  var tpl = this.getTpl('renderTpl');
  if (tpl && !tpl.renderContent) 
  {
    this.setupRenderTpl(tpl);
  }
  return tpl;
}, onRender: function(parentNode, containerIdx) {
  var me = this, x = me.x, y = me.y, lastBox = null, width, height, el = me.el;
  me.applyRenderSelectors();
  me.rendering = null;
  me.rendered = true;
  if (x != null) 
  {
    lastBox = {x: x};
  }
  if (y != null) 
  {
    (lastBox = lastBox || {}).y = y;
  }
  if (!me.getFrameInfo() && Ext.isBorderBox) 
  {
    width = me.width;
    height = me.height;
    if (typeof width === 'number') 
    {
      lastBox = lastBox || {};
      lastBox.width = width;
    }
    if (typeof height === 'number') 
    {
      lastBox = lastBox || {};
      lastBox.height = height;
    }
  }
  me.lastBox = el.lastBox = lastBox;
}, render: function(container, position) {
  var me = this, el = me.el && (me.el = Ext.get(me.el)), vetoed, tree, nextSibling;
  Ext.suspendLayouts();
  container = me.initContainer(container);
  nextSibling = me.getInsertPosition(position);
  if (!el) 
  {
    tree = me.getRenderTree();
    if (me.ownerLayout && me.ownerLayout.transformItemRenderTree) 
    {
      tree = me.ownerLayout.transformItemRenderTree(tree);
    }
    if (tree) 
    {
      if (nextSibling) 
      {
        el = Ext.DomHelper.insertBefore(nextSibling, tree);
      } else {
        el = Ext.DomHelper.append(container, tree);
      }
      me.wrapPrimaryEl(el);
    }
  } else {
    if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) 
    {
      me.beforeRender();
      me.initStyles(el);
      if (me.allowDomMove !== false) 
      {
        if (nextSibling) 
        {
          container.dom.insertBefore(el.dom, nextSibling);
        } else {
          container.dom.appendChild(el.dom);
        }
      }
    } else {
      vetoed = true;
    }
  }
  if (el && !vetoed) 
  {
    me.finishRender(position);
  }
  Ext.resumeLayouts(!me.hidden && !container.isDetachedBody);
}, ensureAttachedToBody: function(runLayout) {
  var comp = this, body;
  while (comp.ownerCt) 
    {
      comp = comp.ownerCt;
    }
  if (comp.container.isDetachedBody) 
  {
    comp.container = body = Ext.getBody();
    body.appendChild(comp.el.dom);
    if (runLayout) 
    {
      comp.updateLayout();
    }
    if (typeof comp.x == 'number' || typeof comp.y == 'number') 
    {
      comp.setPosition(comp.x, comp.y);
    }
  }
}, setupRenderTpl: function(renderTpl) {
  renderTpl.renderBody = renderTpl.renderContent = this.doRenderContent;
}, wrapPrimaryEl: function(dom) {
  this.el = Ext.get(dom, true);
}, initFrame: function() {
  if (Ext.supports.CSS3BorderRadius || !this.frame) 
  {
    return;
  }
  var me = this, frameInfo = me.getFrameInfo(), frameTpl, frameGenId, frameElNames = me.frameElNames, len = frameElNames.length, i, frameData, suffix;
  if (frameInfo) 
  {
    frameTpl = me.getFrameTpl(frameInfo.table);
    frameData = me.getFrameRenderData();
    frameGenId = frameData.fgid;
    frameTpl.insertFirst(me.el, frameData);
    me.frameBody = me.el.down('.' + me.frameCls + '-mc');
    me.removeChildEls(function(c) {
  return c.id && me.frameIdRegex.test(c.id);
});
    for (i = 0; i < len; i++) 
      {
        suffix = frameElNames[i];
        me['frame' + suffix] = me.el.getById(frameGenId + suffix);
      }
  }
}, getFrameRenderData: function() {
  var me = this, frameInfo = me.frameSize, frameGenId = (me.frameGenId || 0) + 1;
  me.frameGenId = frameGenId;
  return {$comp: me, fgid: me.id + '-frame' + frameGenId, ui: me.ui, uiCls: me.uiCls, frameCls: me.frameCls, baseCls: me.baseCls, top: !!frameInfo.top, left: !!frameInfo.left, right: !!frameInfo.right, bottom: !!frameInfo.bottom, frameElCls: ''};
}, updateFrame: function() {
  if (Ext.supports.CSS3BorderRadius || !this.frame) 
  {
    return;
  }
  var me = this, wasTable = me.frameSize && me.frameSize.table, oldFrameTL = me.frameTL, oldFrameBL = me.frameBL, oldFrameML = me.frameML, oldFrameMC = me.frameMC, newMCClassName;
  me.initFrame();
  if (oldFrameMC) 
  {
    if (me.frame) 
    {
      newMCClassName = me.frameMC.dom.className;
      oldFrameMC.insertAfter(me.frameMC);
      me.frameMC.remove();
      me.frameBody = me.frameMC = oldFrameMC;
      oldFrameMC.dom.className = newMCClassName;
      if (wasTable) 
      {
        me.el.query('> table')[1].remove();
      } else {
        if (oldFrameTL) 
        {
          oldFrameTL.remove();
        }
        if (oldFrameBL) 
        {
          oldFrameBL.remove();
        }
        if (oldFrameML) 
        {
          oldFrameML.remove();
        }
      }
    }
  } else if (me.frame) 
  {
    me.applyRenderSelectors();
  }
}, getFrameInfo: function() {
  if (Ext.supports.CSS3BorderRadius || !this.frame) 
  {
    return false;
  }
  var me = this, frameInfoCache = me.frameInfoCache, cls = me.getFramingInfoCls() + '-frameInfo', frameInfo = frameInfoCache[cls], max = Math.max, styleEl, match, info, frameTop, frameRight, frameBottom, frameLeft, borderWidthT, borderWidthR, borderWidthB, borderWidthL, paddingT, paddingR, paddingB, paddingL, borderRadiusTL, borderRadiusTR, borderRadiusBR, borderRadiusBL;
  if (frameInfo == null) 
  {
    styleEl = Ext.fly(me.getStyleProxy(cls), 'frame-style-el');
    info = styleEl.getStyle('font-family');
    if (info) 
    {
      info = info.split('-');
      borderRadiusTL = parseInt(info[1], 10);
      borderRadiusTR = parseInt(info[2], 10);
      borderRadiusBR = parseInt(info[3], 10);
      borderRadiusBL = parseInt(info[4], 10);
      borderWidthT = parseInt(info[5], 10);
      borderWidthR = parseInt(info[6], 10);
      borderWidthB = parseInt(info[7], 10);
      borderWidthL = parseInt(info[8], 10);
      paddingT = parseInt(info[9], 10);
      paddingR = parseInt(info[10], 10);
      paddingB = parseInt(info[11], 10);
      paddingL = parseInt(info[12], 10);
      frameTop = max(borderWidthT, max(borderRadiusTL, borderRadiusTR));
      frameRight = max(borderWidthR, max(borderRadiusTR, borderRadiusBR));
      frameBottom = max(borderWidthB, max(borderRadiusBL, borderRadiusBR));
      frameLeft = max(borderWidthL, max(borderRadiusTL, borderRadiusBL));
      frameInfo = {table: info[0].charAt(0) === 't', vertical: info[0].charAt(1) === 'v', top: frameTop, right: frameRight, bottom: frameBottom, left: frameLeft, width: frameLeft + frameRight, height: frameTop + frameBottom, maxWidth: max(frameTop, frameRight, frameBottom, frameLeft), border: {top: borderWidthT, right: borderWidthR, bottom: borderWidthB, left: borderWidthL, width: borderWidthL + borderWidthR, height: borderWidthT + borderWidthB}, padding: {top: paddingT, right: paddingR, bottom: paddingB, left: paddingL, width: paddingL + paddingR, height: paddingT + paddingB}, radius: {tl: borderRadiusTL, tr: borderRadiusTR, br: borderRadiusBR, bl: borderRadiusBL}};
    } else {
      frameInfo = false;
    }
    frameInfoCache[cls] = frameInfo;
  }
  me.frame = !!frameInfo;
  me.frameSize = frameInfo;
  return frameInfo;
}, getFramingInfoCls: function() {
  return this.baseCls + '-' + this.ui;
}, getStyleProxy: function(cls) {
  var result = this.styleProxyEl || (Ext.AbstractComponent.prototype.styleProxyEl = Ext.getBody().createChild({role: 'presentation', style: {position: 'absolute', top: '-10000px'}}, null, true));
  result.className = cls;
  return result;
}, getFrameTpl: function(table) {
  return this.getTpl(table ? 'frameTableTpl' : 'frameTpl');
}, frameInfoCache: {}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Renderable'], 0));
;

(Ext.cmd.derive('Ext.state.Provider', Ext.Base, {prefix: 'ext-', constructor: function(config) {
  config = config || {};
  var me = this;
  Ext.apply(me, config);
  me.addEvents("statechange");
  me.state = {};
  me.mixins.observable.constructor.call(me);
}, get: function(name, defaultValue) {
  return typeof this.state[name] == "undefined" ? defaultValue : this.state[name];
}, clear: function(name) {
  var me = this;
  delete me.state[name];
  me.fireEvent("statechange", me, name, null);
}, set: function(name, value) {
  var me = this;
  me.state[name] = value;
  me.fireEvent("statechange", me, name, value);
}, decodeValue: function(value) {
  var me = this, re = /^(a|n|d|b|s|o|e)\:(.*)$/, matches = re.exec(unescape(value)), all, type, keyValue, values, vLen, v;
  if (!matches || !matches[1]) 
  {
    return;
  }
  type = matches[1];
  value = matches[2];
  switch (type) {
    case 'e':
      return null;
    case 'n':
      return parseFloat(value);
    case 'd':
      return new Date(Date.parse(value));
    case 'b':
      return (value == '1');
    case 'a':
      all = [];
      if (value != '') 
      {
        values = value.split('^');
        vLen = values.length;
        for (v = 0; v < vLen; v++) 
          {
            value = values[v];
            all.push(me.decodeValue(value));
          }
      }
      return all;
    case 'o':
      all = {};
      if (value != '') 
      {
        values = value.split('^');
        vLen = values.length;
        for (v = 0; v < vLen; v++) 
          {
            value = values[v];
            keyValue = value.split('=');
            all[keyValue[0]] = me.decodeValue(keyValue[1]);
          }
      }
      return all;
    default:
      return value;
  }
}, encodeValue: function(value) {
  var flat = '', i = 0, enc, len, key;
  if (value == null) 
  {
    return 'e:1';
  } else if (typeof value == 'number') 
  {
    enc = 'n:' + value;
  } else if (typeof value == 'boolean') 
  {
    enc = 'b:' + (value ? '1' : '0');
  } else if (Ext.isDate(value)) 
  {
    enc = 'd:' + value.toUTCString();
  } else if (Ext.isArray(value)) 
  {
    for (len = value.length; i < len; i++) 
      {
        flat += this.encodeValue(value[i]);
        if (i != len - 1) 
        {
          flat += '^';
        }
      }
    enc = 'a:' + flat;
  } else if (typeof value == 'object') 
  {
    for (key in value) 
      {
        if (typeof value[key] != 'function' && value[key] !== undefined) 
        {
          flat += key + '=' + this.encodeValue(value[key]) + '^';
        }
      }
    enc = 'o:' + flat.substring(0, flat.length - 1);
  } else {
    enc = 's:' + value;
  }
  return escape(enc);
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.state, 'Provider'], 0));
;

(Ext.cmd.derive('Ext.state.Manager', Ext.Base, {singleton: true, constructor: function() {
  this.provider = new Ext.state.Provider();
}, setProvider: function(stateProvider) {
  this.provider = stateProvider;
}, get: function(key, defaultValue) {
  return this.provider.get(key, defaultValue);
}, set: function(key, value) {
  this.provider.set(key, value);
}, clear: function(key) {
  this.provider.clear(key);
}, getProvider: function() {
  return this.provider;
}}, 1, 0, 0, 0, 0, 0, [Ext.state, 'Manager'], 0));
;

(Ext.cmd.derive('Ext.state.Stateful', Ext.Base, {stateful: false, saveDelay: 100, constructor: function(config) {
  var me = this;
  config = config || {};
  if (config.stateful !== undefined) 
  {
    me.stateful = config.stateful;
  }
  if (config.saveDelay !== undefined) 
  {
    me.saveDelay = config.saveDelay;
  }
  me.stateId = me.stateId || config.stateId;
  if (!me.stateEvents) 
  {
    me.stateEvents = [];
  }
  if (config.stateEvents) 
  {
    me.stateEvents.concat(config.stateEvents);
  }
  this.addEvents('beforestaterestore', 'staterestore', 'beforestatesave', 'statesave');
  me.mixins.observable.constructor.call(me);
  if (me.stateful !== false) 
  {
    me.addStateEvents(me.stateEvents);
    me.initState();
  }
}, addStateEvents: function(events) {
  var me = this, i, event, stateEventsByName, eventArray;
  if (me.stateful && me.getStateId()) 
  {
    eventArray = (typeof events == 'string') ? arguments : events;
    stateEventsByName = me.stateEventsByName || (me.stateEventsByName = {});
    for (i = eventArray.length; i--; ) 
      {
        event = eventArray[i];
        if (!stateEventsByName[event]) 
        {
          stateEventsByName[event] = 1;
          me.on(event, me.onStateChange, me);
        }
      }
  }
}, onStateChange: function() {
  var me = this, delay = me.saveDelay, statics, runner;
  if (!me.stateful) 
  {
    return;
  }
  if (delay) 
  {
    if (!me.stateTask) 
    {
      statics = Ext.state.Stateful;
      runner = statics.runner || (statics.runner = new Ext.util.TaskRunner());
      me.stateTask = runner.newTask({run: me.saveState, scope: me, interval: delay, repeat: 1});
    }
    me.stateTask.start();
  } else {
    me.saveState();
  }
}, saveState: function() {
  var me = this, id = me.stateful && me.getStateId(), hasListeners = me.hasListeners, state;
  if (id) 
  {
    state = me.getState() || {};
    if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) 
    {
      Ext.state.Manager.set(id, state);
      if (hasListeners.statesave) 
      {
        me.fireEvent('statesave', me, state);
      }
    }
  }
}, getState: function() {
  return null;
}, applyState: function(state) {
  if (state) 
  {
    Ext.apply(this, state);
  }
}, getStateId: function() {
  var me = this;
  return me.stateId || (me.autoGenId ? null : me.id);
}, initState: function() {
  var me = this, id = me.stateful && me.getStateId(), hasListeners = me.hasListeners, state;
  if (id) 
  {
    state = Ext.state.Manager.get(id);
    if (state) 
    {
      state = Ext.apply({}, state);
      if (!hasListeners.beforestaterestore || me.fireEvent('beforestaterestore', me, state) !== false) 
      {
        me.applyState(state);
        if (hasListeners.staterestore) 
        {
          me.fireEvent('staterestore', me, state);
        }
      }
    }
  }
}, savePropToState: function(propName, state, stateName) {
  var me = this, value = me[propName], config = me.initialConfig;
  if (me.hasOwnProperty(propName)) 
  {
    if (!config || config[propName] !== value) 
    {
      if (state) 
      {
        state[stateName || propName] = value;
      }
      return true;
    }
  }
  return false;
}, savePropsToState: function(propNames, state) {
  var me = this, i, n;
  if (typeof propNames == 'string') 
  {
    me.savePropToState(propNames, state);
  } else {
    for (i = 0 , n = propNames.length; i < n; ++i) 
      {
        me.savePropToState(propNames[i], state);
      }
  }
  return state;
}, destroy: function() {
  var me = this, task = me.stateTask;
  if (task) 
  {
    task.destroy();
    me.stateTask = null;
  }
  me.clearListeners();
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.state, 'Stateful'], 0));
;

(Ext.cmd.derive('Ext.AbstractComponent', Ext.Base, {statics: {AUTO_ID: 1000, pendingLayouts: null, layoutSuspendCount: 0, cancelLayout: function(comp, isDestroying) {
  var context = this.runningLayoutContext || this.pendingLayouts;
  if (context) 
  {
    context.cancelComponent(comp, false, isDestroying);
  }
}, findComponentByElement: function(node) {
  var topmost = document.body, target = node, cmp;
  while (target && target.nodeType === 1 && target !== topmost) 
    {
      cmp = Ext.getCmp(target.id);
      if (cmp) 
      {
        return cmp;
      }
      target = target.parentNode;
    }
  return null;
}, getComponentByElement: function(el) {
  var cmpIdAttr = Ext.Component.componentIdAttribute, cmpId;
  el = Ext.fly(el);
  if (!el) 
  {
    return null;
  }
  cmpId = el.getAttribute(cmpIdAttr);
  if (cmpId) 
  {
    return Ext.getCmp(cmpId);
  } else {
    return Ext.Component.findComponentByElement(el.dom);
  }
}, flushLayouts: function() {
  var me = this, context = me.pendingLayouts;
  if (context && context.invalidQueue.length) 
  {
    me.pendingLayouts = null;
    me.runningLayoutContext = context;
    Ext.override(context, {runComplete: function() {
  me.runningLayoutContext = null;
  var result = this.callParent();
  if (Ext.globalEvents.hasListeners.afterlayout) 
  {
    Ext.globalEvents.fireEvent('afterlayout');
  }
  return result;
}});
    context.run();
  }
}, resumeLayouts: function(flush) {
  if (this.layoutSuspendCount && !--this.layoutSuspendCount) 
  {
    if (flush) 
    {
      this.flushLayouts();
    }
    if (Ext.globalEvents.hasListeners.resumelayouts) 
    {
      Ext.globalEvents.fireEvent('resumelayouts');
    }
  }
}, suspendLayouts: function() {
  ++this.layoutSuspendCount;
}, updateLayout: function(comp, defer) {
  var me = this, running = me.runningLayoutContext, pending;
  if (running) 
  {
    running.queueInvalidate(comp);
  } else {
    pending = me.pendingLayouts || (me.pendingLayouts = new Ext.layout.Context());
    pending.queueInvalidate(comp);
    if (!defer && !me.layoutSuspendCount && !comp.isLayoutSuspended()) 
    {
      me.flushLayouts();
    }
  }
}}, isComponent: true, getAutoId: function() {
  this.autoGenId = true;
  return ++Ext.AbstractComponent.AUTO_ID;
}, deferLayouts: false, autoGenId: false, renderTpl: '{%this.renderContent(out,values)%}', maskElement: null, frameSize: null, tplWriteMode: 'overwrite', baseCls: Ext.baseCSSPrefix + 'component', disabledCls: Ext.baseCSSPrefix + 'item-disabled', ui: 'default', uiCls: [], hidden: false, disabled: false, disabledRe: /^(?:button|input|select|textarea|optgroup|option|fieldset)$/i, nonMaskableRe: (function() {
  var re = ['input', 'select', 'textarea', 'optgroup', 'option', 'table'];
  if (Ext.isIE9m && !(Ext.isIE9 && !Ext.isIEQuirks)) 
  {
    re.push('p');
  }
  return new RegExp('^(?:' + re.join('|') + ')$', 'i');
}()), draggable: false, floating: false, hideMode: 'display', autoShow: false, autoRender: false, allowDomMove: true, rendered: false, componentLayoutCounter: 0, shrinkWrap: 2, weight: 0, maskOnDisable: true, _isLayoutRoot: false, contentPaddingProperty: 'padding', horizontalPosProp: 'left', borderBoxCls: Ext.baseCSSPrefix + 'border-box', rootCls: Ext.baseCSSPrefix + 'body', constructor: function(config) {
  var me = this, i, len, xhooks;
  if (config) 
  {
    Ext.apply(me, config);
    xhooks = me.xhooks;
    if (xhooks) 
    {
      delete me.xhooks;
      Ext.override(me, xhooks);
    }
  } else {
    config = {};
  }
  me.initialConfig = config;
  me.mixins.elementCt.constructor.call(me);
  me.addEvents('beforeactivate', 'activate', 'beforedeactivate', 'deactivate', 'added', 'disable', 'enable', 'beforeshow', 'show', 'beforehide', 'hide', 'removed', 'beforerender', 'render', 'afterrender', 'boxready', 'beforedestroy', 'destroy', 'resize', 'move', 'focus', 'blur');
  me.getId();
  me.setupProtoEl();
  if (me.cls) 
  {
    me.initialCls = me.cls;
    me.protoEl.addCls(me.cls);
  }
  if (me.style) 
  {
    me.initialStyle = me.style;
    me.protoEl.setStyle(me.style);
  }
  me.renderData = me.renderData || {};
  me.renderSelectors = me.renderSelectors || {};
  if (!me.hasListeners) 
  {
    me.hasListeners = new me.HasListeners();
  }
  me.initComponent();
  Ext.ComponentManager.register(me);
  me.mixins.observable.constructor.call(me);
  me.mixins.state.constructor.call(me, config);
  this.addStateEvents('resize');
  if (me.plugins) 
  {
    for (i = 0 , len = me.plugins.length; i < len; i++) 
      {
        me.plugins[i] = me.initPlugin(me.plugins[i]);
      }
  }
  me.loader = me.getLoader();
  if (me.renderTo) 
  {
    me.render(me.renderTo);
  }
  if (me.autoShow && !me.isContained) 
  {
    me.show();
  }
}, initComponent: function() {
  var me = this;
  if (me.plugins && !me.plugins.processed) 
  {
    me.plugins = me.constructPlugins();
  }
  me.setSize(me.width, me.height);
}, getState: function() {
  var me = this, state = null, sizeModel = me.getSizeModel();
  if (sizeModel.width.configured) 
  {
    state = me.addPropertyToState(state, 'width');
  }
  if (sizeModel.height.configured) 
  {
    state = me.addPropertyToState(state, 'height');
  }
  return state;
}, addPropertyToState: function(state, propName, value) {
  var me = this, len = arguments.length;
  if (len == 3 || me.hasOwnProperty(propName)) 
  {
    if (len < 3) 
    {
      value = me[propName];
    }
    if (value !== me.initialConfig[propName]) 
    {
      (state || (state = {}))[propName] = value;
    }
  }
  return state;
}, show: Ext.emptyFn, animate: function(animObj) {
  var me = this, hasToWidth, hasToHeight, toHeight, toWidth, to, clearWidth, clearHeight, curWidth, w, curHeight, h, isExpanding, wasConstrained, wasConstrainedHeader, passedCallback, oldOverflow;
  animObj = animObj || {};
  to = animObj.to || {};
  if (Ext.fx.Manager.hasFxBlock(me.id)) 
  {
    return me;
  }
  hasToWidth = Ext.isDefined(to.width);
  if (hasToWidth) 
  {
    toWidth = Ext.Number.constrain(to.width, me.minWidth, me.maxWidth);
  }
  hasToHeight = Ext.isDefined(to.height);
  if (hasToHeight) 
  {
    toHeight = Ext.Number.constrain(to.height, me.minHeight, me.maxHeight);
  }
  if (!animObj.dynamic && (hasToWidth || hasToHeight)) 
  {
    curWidth = (animObj.from ? animObj.from.width : undefined) || me.getWidth();
    w = curWidth;
    curHeight = (animObj.from ? animObj.from.height : undefined) || me.getHeight();
    h = curHeight;
    isExpanding = false;
    if (hasToHeight && toHeight > curHeight) 
    {
      h = toHeight;
      isExpanding = true;
    }
    if (hasToWidth && toWidth > curWidth) 
    {
      w = toWidth;
      isExpanding = true;
    }
    if (hasToHeight || hasToWidth) 
    {
      oldOverflow = me.el.getStyle('overflow');
      if (oldOverflow !== 'hidden') 
      {
        me.el.setStyle('overflow', 'hidden');
      }
    }
    if (isExpanding) 
    {
      clearWidth = !Ext.isNumber(me.width);
      clearHeight = !Ext.isNumber(me.height);
      me.setSize(w, h);
      me.el.setSize(curWidth, curHeight);
      if (clearWidth) 
      {
        delete me.width;
      }
      if (clearHeight) 
      {
        delete me.height;
      }
    }
    if (hasToWidth) 
    {
      to.width = toWidth;
    }
    if (hasToHeight) 
    {
      to.height = toHeight;
    }
  }
  wasConstrained = me.constrain;
  wasConstrainedHeader = me.constrainHeader;
  if (wasConstrained || wasConstrainedHeader) 
  {
    me.constrain = me.constrainHeader = false;
    passedCallback = animObj.callback;
    animObj.callback = function() {
  me.constrain = wasConstrained;
  me.constrainHeader = wasConstrainedHeader;
  if (passedCallback) 
  {
    passedCallback.call(animObj.scope || me, arguments);
  }
  if (oldOverflow !== 'hidden') 
  {
    me.el.setStyle('overflow', oldOverflow);
  }
};
  }
  return me.mixins.animate.animate.apply(me, arguments);
}, setHiddenState: function(hidden) {
  var hierarchyState = this.getHierarchyState();
  this.hidden = hidden;
  if (hidden) 
  {
    hierarchyState.hidden = true;
  } else {
    delete hierarchyState.hidden;
  }
}, onHide: function() {
  if (this.ownerLayout) 
  {
    this.updateLayout({isRoot: false});
  }
}, onShow: function() {
  this.updateLayout({isRoot: false});
}, constructPlugin: function(plugin) {
  var me = this;
  if (typeof plugin == 'string') 
  {
    plugin = Ext.PluginManager.create({}, plugin, me);
  } else {
    plugin = Ext.PluginManager.create(plugin, null, me);
  }
  return plugin;
}, constructPlugins: function() {
  var me = this, plugins = me.plugins, result, i, len;
  if (plugins) 
  {
    result = [];
    result.processed = true;
    if (!Ext.isArray(plugins)) 
    {
      plugins = [plugins];
    }
    for (i = 0 , len = plugins.length; i < len; i++) 
      {
        result[i] = me.constructPlugin(plugins[i]);
      }
  }
  me.pluginsInitialized = true;
  return result;
}, initPlugin: function(plugin) {
  plugin.init(this);
  return plugin;
}, addPlugin: function(plugin) {
  var me = this;
  plugin = me.constructPlugin(plugin);
  if (me.plugins) 
  {
    me.plugins.push(plugin);
  } else {
    me.plugins = [plugin];
  }
  if (me.pluginsInitialized) 
  {
    me.initPlugin(plugin);
  }
  return plugin;
}, removePlugin: function(plugin) {
  Ext.Array.remove(this.plugins, plugin);
  plugin.destroy();
}, findPlugin: function(ptype) {
  var i, plugins = this.plugins, ln = plugins && plugins.length;
  for (i = 0; i < ln; i++) 
    {
      if (plugins[i].ptype === ptype) 
      {
        return plugins[i];
      }
    }
}, getPlugin: function(pluginId) {
  var i, plugins = this.plugins, ln = plugins && plugins.length;
  for (i = 0; i < ln; i++) 
    {
      if (plugins[i].pluginId === pluginId) 
      {
        return plugins[i];
      }
    }
}, beforeLayout: Ext.emptyFn, registerFloatingItem: function(cmp) {
  var me = this;
  if (!me.floatingDescendants) 
  {
    me.floatingDescendants = new Ext.ZIndexManager(me);
  }
  me.floatingDescendants.register(cmp);
}, unregisterFloatingItem: function(cmp) {
  var me = this;
  if (me.floatingDescendants) 
  {
    me.floatingDescendants.unregister(cmp);
  }
}, layoutSuspendCount: 0, suspendLayouts: function() {
  var me = this;
  if (!me.rendered) 
  {
    return;
  }
  if (++me.layoutSuspendCount === 1) 
  {
    me.suspendLayout = true;
  }
}, resumeLayouts: function(flushOptions) {
  var me = this;
  if (!me.rendered) 
  {
    return;
  }
  if (me.layoutSuspendCount && !--me.layoutSuspendCount) 
  {
    me.suspendLayout = false;
    if (flushOptions && !me.isLayoutSuspended()) 
    {
      me.updateLayout(flushOptions);
    }
  }
}, setupProtoEl: function() {
  var cls = this.initCls();
  this.protoEl = new Ext.util.ProtoElement({cls: cls.join(' ')});
}, initCls: function() {
  var me = this, cls = [me.baseCls, me.getComponentLayout().targetCls];
  if (me.componentCls) 
  {
    cls.push(me.componentCls);
  } else {
    me.componentCls = me.baseCls;
  }
  return cls;
}, setUI: function(ui) {
  var me = this, uiCls = me.uiCls, activeUI = me.activeUI, classes;
  if (ui === activeUI) 
  {
    return;
  }
  if (activeUI) 
  {
    classes = me.removeClsWithUI(uiCls, true);
    if (classes.length) 
    {
      me.removeCls(classes);
    }
    me.removeUIFromElement();
  } else {
    me.uiCls = [];
  }
  me.ui = ui;
  me.activeUI = ui;
  me.addUIToElement();
  classes = me.addClsWithUI(uiCls, true);
  if (classes.length) 
  {
    me.addCls(classes);
  }
  if (me.rendered) 
  {
    me.updateLayout();
  }
}, addClsWithUI: function(classes, skip) {
  var me = this, clsArray = [], i = 0, uiCls = me.uiCls = Ext.Array.clone(me.uiCls), activeUI = me.activeUI, length, cls;
  if (typeof classes === "string") 
  {
    classes = (classes.indexOf(' ') < 0) ? [classes] : Ext.String.splitWords(classes);
  }
  length = classes.length;
  for (; i < length; i++) 
    {
      cls = classes[i];
      if (cls && !me.hasUICls(cls)) 
      {
        uiCls.push(cls);
        if (activeUI) 
        {
          clsArray = clsArray.concat(me.addUIClsToElement(cls));
        }
      }
    }
  if (skip !== true && activeUI) 
  {
    me.addCls(clsArray);
  }
  return clsArray;
}, removeClsWithUI: function(classes, skip) {
  var me = this, clsArray = [], i = 0, extArray = Ext.Array, remove = extArray.remove, uiCls = me.uiCls = extArray.clone(me.uiCls), activeUI = me.activeUI, length, cls;
  if (typeof classes === "string") 
  {
    classes = (classes.indexOf(' ') < 0) ? [classes] : Ext.String.splitWords(classes);
  }
  length = classes.length;
  for (i = 0; i < length; i++) 
    {
      cls = classes[i];
      if (cls && me.hasUICls(cls)) 
      {
        remove(uiCls, cls);
        if (activeUI) 
        {
          clsArray = clsArray.concat(me.removeUIClsFromElement(cls));
        }
      }
    }
  if (skip !== true && activeUI) 
  {
    me.removeCls(clsArray);
  }
  return clsArray;
}, hasUICls: function(cls) {
  var me = this, uiCls = me.uiCls || [];
  return Ext.Array.contains(uiCls, cls);
}, frameElementsArray: ['tl', 'tc', 'tr', 'ml', 'mc', 'mr', 'bl', 'bc', 'br'], addUIClsToElement: function(cls) {
  var me = this, baseClsUi = me.baseCls + '-' + me.ui + '-' + cls, result = [Ext.baseCSSPrefix + cls, me.baseCls + '-' + cls, baseClsUi], frameElementsArray, frameElementsLength, i, el, frameElement;
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) 
  {
    frameElementsArray = me.frameElementsArray;
    frameElementsLength = frameElementsArray.length;
    for (i = 0; i < frameElementsLength; i++) 
      {
        frameElement = frameElementsArray[i];
        el = me['frame' + frameElement.toUpperCase()];
        if (el) 
        {
          el.addCls(baseClsUi + '-' + frameElement);
        }
      }
  }
  return result;
}, removeUIClsFromElement: function(cls) {
  var me = this, baseClsUi = me.baseCls + '-' + me.ui + '-' + cls, result = [Ext.baseCSSPrefix + cls, me.baseCls + '-' + cls, baseClsUi], frameElementsArray, frameElementsLength, i, el, frameElement;
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) 
  {
    frameElementsArray = me.frameElementsArray;
    frameElementsLength = frameElementsArray.length;
    for (i = 0; i < frameElementsLength; i++) 
      {
        frameElement = frameElementsArray[i];
        el = me['frame' + frameElement.toUpperCase()];
        if (el) 
        {
          el.removeCls(baseClsUi + '-' + frameElement);
        }
      }
  }
  return result;
}, addUIToElement: function() {
  var me = this, baseClsUI = me.baseCls + '-' + me.ui, frameElementsArray, frameElementsLength, i, el, frameElement;
  me.addCls(baseClsUI);
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) 
  {
    frameElementsArray = me.frameElementsArray;
    frameElementsLength = frameElementsArray.length;
    for (i = 0; i < frameElementsLength; i++) 
      {
        frameElement = frameElementsArray[i];
        el = me['frame' + frameElement.toUpperCase()];
        if (el) 
        {
          el.addCls(baseClsUI + '-' + frameElement);
        }
      }
  }
}, removeUIFromElement: function() {
  var me = this, baseClsUI = me.baseCls + '-' + me.ui, frameElementsArray, frameElementsLength, i, el, frameElement;
  me.removeCls(baseClsUI);
  if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) 
  {
    frameElementsArray = me.frameElementsArray;
    frameElementsLength = frameElementsArray.length;
    for (i = 0; i < frameElementsLength; i++) 
      {
        frameElement = frameElementsArray[i];
        el = me['frame' + frameElement.toUpperCase()];
        if (el) 
        {
          el.removeCls(baseClsUI + '-' + frameElement);
        }
      }
  }
}, getTpl: function(name) {
  return Ext.XTemplate.getTpl(this, name);
}, initStyles: function(targetEl) {
  var me = this, Element = Ext.Element, margin = me.margin, border = me.border, cls = me.cls, style = me.style, x = me.x, y = me.y, width, height;
  me.initPadding(targetEl);
  if (margin != null) 
  {
    targetEl.setStyle('margin', this.unitizeBox((margin === true) ? 5 : margin));
  }
  if (border != null) 
  {
    me.setBorder(border, targetEl);
  }
  if (cls && cls != me.initialCls) 
  {
    targetEl.addCls(cls);
    me.cls = me.initialCls = null;
  }
  if (style && style != me.initialStyle) 
  {
    targetEl.setStyle(style);
    me.style = me.initialStyle = null;
  }
  if (x != null) 
  {
    targetEl.setStyle(me.horizontalPosProp, (typeof x == 'number') ? (x + 'px') : x);
  }
  if (y != null) 
  {
    targetEl.setStyle('top', (typeof y == 'number') ? (y + 'px') : y);
  }
  if (!me.ownerCt || me.floating) 
  {
    if (Ext.scopeCss) 
    {
      targetEl.addCls(me.rootCls);
    }
    if (Ext.isBorderBox) 
    {
      targetEl.addCls(me.borderBoxCls);
    }
  }
  if (!me.getFrameInfo()) 
  {
    width = me.width;
    height = me.height;
    if (width != null) 
    {
      if (typeof width === 'number') 
      {
        if (Ext.isBorderBox) 
        {
          targetEl.setStyle('width', width + 'px');
        }
      } else {
        targetEl.setStyle('width', width);
      }
    }
    if (height != null) 
    {
      if (typeof height === 'number') 
      {
        if (Ext.isBorderBox) 
        {
          targetEl.setStyle('height', height + 'px');
        }
      } else {
        targetEl.setStyle('height', height);
      }
    }
  }
}, initPadding: function(targetEl) {
  var me = this, padding = me.padding;
  if (padding != null) 
  {
    if (me.layout && me.layout.managePadding && me.contentPaddingProperty === 'padding') 
    {
      targetEl.setStyle('padding', 0);
    } else {
      targetEl.setStyle('padding', this.unitizeBox((padding === true) ? 5 : padding));
    }
  }
}, parseBox: function(box) {
  return Ext.dom.Element.parseBox(box);
}, unitizeBox: function(box) {
  return Ext.dom.Element.unitizeBox(box);
}, setMargin: function(margin, preventLayout) {
  var me = this;
  if (me.rendered) 
  {
    if (!margin && margin !== 0) 
    {
      margin = '';
    } else {
      if (margin === true) 
      {
        margin = 5;
      }
      margin = this.unitizeBox(margin);
    }
    me.getTargetEl().setStyle('margin', margin);
    if (!preventLayout) 
    {
      me.updateLayout();
    }
  } else {
    me.margin = margin;
  }
}, initEvents: function() {
  var me = this, afterRenderEvents = me.afterRenderEvents, afterRenderEvent, el, property, index, len;
  if (afterRenderEvents) 
  {
    for (property in afterRenderEvents) 
      {
        el = me[property];
        if (el && el.on) 
        {
          afterRenderEvent = afterRenderEvents[property];
          for (index = 0 , len = afterRenderEvent.length; index < len; ++index) 
            {
              me.mon(el, afterRenderEvent[index]);
            }
        }
      }
  }
  me.addFocusListener();
}, addFocusListener: function() {
  var me = this, focusEl = me.getFocusEl(), needsTabIndex;
  if (focusEl) 
  {
    if (focusEl.isComponent) 
    {
      return focusEl.addFocusListener();
    }
    needsTabIndex = focusEl.needsTabIndex();
    if (!me.focusListenerAdded && (!needsTabIndex || Ext.enableFocusManager)) 
    {
      if (needsTabIndex) 
      {
        focusEl.dom.tabIndex = -1;
      }
      focusEl.on({focus: me.onFocus, blur: me.onBlur, scope: me});
      me.focusListenerAdded = true;
    }
  }
}, getFocusEl: Ext.emptyFn, isFocusable: function() {
  var me = this, focusEl;
  if ((me.focusable !== false) && (focusEl = me.getFocusEl()) && me.rendered && !me.destroying && !me.isDestroyed && !me.disabled && me.isVisible(true)) 
  {
    return focusEl.isFocusable(true);
  }
}, beforeFocus: Ext.emptyFn, onFocus: function(e) {
  var me = this, focusCls = me.focusCls, focusEl = me.getFocusEl();
  if (!me.disabled) 
  {
    me.beforeFocus(e);
    if (focusCls && focusEl) 
    {
      focusEl.addCls(me.addClsWithUI(focusCls, true));
    }
    if (!me.hasFocus) 
    {
      me.hasFocus = true;
      me.fireEvent('focus', me, e);
    }
  }
}, beforeBlur: Ext.emptyFn, onBlur: function(e) {
  var me = this, focusCls = me.focusCls, focusEl = me.getFocusEl();
  if (me.destroying) 
  {
    return;
  }
  me.beforeBlur(e);
  if (focusCls && focusEl) 
  {
    focusEl.removeCls(me.removeClsWithUI(focusCls, true));
  }
  if (me.validateOnBlur) 
  {
    me.validate();
  }
  me.hasFocus = false;
  me.fireEvent('blur', me, e);
  me.postBlur(e);
}, postBlur: Ext.emptyFn, owns: function(element) {
  var result = false, cmp;
  if (element.isEvent) 
  {
    element = element.target;
  } else if (element.isElement) 
  {
    element = element.dom;
  }
  cmp = Ext.AbstractComponent.findComponentByElement(element);
  if (cmp) 
  {
    result = (cmp === this) || (!!cmp.up(this));
  }
  return result;
}, is: function(selector) {
  return Ext.ComponentQuery.is(this, selector);
}, up: function(selector, limit) {
  var result = this.getRefOwner(), limitSelector = typeof limit === 'string', limitCount = typeof limit === 'number', limitComponent = limit && limit.isComponent, steps = 0;
  if (selector) 
  {
    for (; result; result = result.getRefOwner()) 
      {
        steps++;
        if (selector.isComponent) 
        {
          if (result === selector) 
          {
            return result;
          }
        } else {
          if (Ext.ComponentQuery.is(result, selector)) 
          {
            return result;
          }
        }
        if (limitSelector && result.is(limit)) 
        {
          return;
        }
        if (limitCount && steps === limit) 
        {
          return;
        }
        if (limitComponent && result === limit) 
        {
          return;
        }
      }
  }
  return result;
}, nextSibling: function(selector) {
  var o = this.ownerCt, it, last, idx, c;
  if (o) 
  {
    it = o.items;
    idx = it.indexOf(this) + 1;
    if (idx) 
    {
      if (selector) 
      {
        for (last = it.getCount(); idx < last; idx++) 
          {
            if ((c = it.getAt(idx)).is(selector)) 
            {
              return c;
            }
          }
      } else {
        if (idx < it.getCount()) 
        {
          return it.getAt(idx);
        }
      }
    }
  }
  return null;
}, previousSibling: function(selector) {
  var o = this.ownerCt, it, idx, c;
  if (o) 
  {
    it = o.items;
    idx = it.indexOf(this);
    if (idx != -1) 
    {
      if (selector) 
      {
        for (--idx; idx >= 0; idx--) 
          {
            if ((c = it.getAt(idx)).is(selector)) 
            {
              return c;
            }
          }
      } else {
        if (idx) 
        {
          return it.getAt(--idx);
        }
      }
    }
  }
  return null;
}, previousNode: function(selector, includeSelf) {
  var node = this, ownerCt = node.ownerCt, result, it, i, sib;
  if (includeSelf && node.is(selector)) 
  {
    return node;
  }
  if (ownerCt) 
  {
    for (it = ownerCt.items.items , i = Ext.Array.indexOf(it, node) - 1; i > -1; i--) 
      {
        sib = it[i];
        if (sib.query) 
        {
          result = sib.query(selector);
          result = result[result.length - 1];
          if (result) 
          {
            return result;
          }
        }
        if (sib.is(selector)) 
        {
          return sib;
        }
      }
    return ownerCt.previousNode(selector, true);
  }
  return null;
}, nextNode: function(selector, includeSelf) {
  var node = this, ownerCt = node.ownerCt, result, it, len, i, sib;
  if (includeSelf && node.is(selector)) 
  {
    return node;
  }
  if (ownerCt) 
  {
    for (it = ownerCt.items.items , i = Ext.Array.indexOf(it, node) + 1 , len = it.length; i < len; i++) 
      {
        sib = it[i];
        if (sib.is(selector)) 
        {
          return sib;
        }
        if (sib.down) 
        {
          result = sib.down(selector);
          if (result) 
          {
            return result;
          }
        }
      }
    return ownerCt.nextNode(selector);
  }
  return null;
}, getId: function() {
  return this.id || (this.id = 'ext-comp-' + (this.getAutoId()));
}, getItemId: function() {
  return this.itemId || this.id;
}, getEl: function() {
  return this.el;
}, getTargetEl: function() {
  return this.frameBody || this.el;
}, getOverflowEl: function() {
  return this.getTargetEl();
}, getOverflowStyle: function() {
  var me = this, result = null, auto = me.autoScroll, ox, oy, overflowStyle;
  if (typeof auto === 'boolean') 
  {
    result = {overflow: overflowStyle = (auto ? 'auto' : '')};
    me.scrollFlags = {overflowX: overflowStyle, overflowY: overflowStyle, x: auto, y: auto, both: auto};
  } else {
    ox = me.overflowX;
    oy = me.overflowY;
    if (ox !== undefined || oy !== undefined) 
    {
      if (ox && ox === true) 
      {
        ox = 'auto';
      }
      if (oy && oy === true) 
      {
        oy = 'auto';
      }
      result = {'overflowX': ox = ox || '', 'overflowY': oy = oy || ''};
      me.scrollFlags = {overflowX: ox, overflowY: oy, x: ox = (ox === 'auto' || ox === 'scroll'), y: oy = (oy === 'auto' || oy === 'scroll'), both: ox && oy};
    } else {
      me.scrollFlags = {overflowX: '', overflowY: '', x: false, y: false, both: false};
    }
  }
  if (result && Ext.isIE7m) 
  {
    result.position = 'relative';
  }
  return result;
}, isXType: function(xtype, shallow) {
  if (shallow) 
  {
    return this.xtype === xtype;
  } else {
    return this.xtypesMap[xtype];
  }
}, getXTypes: function() {
  var self = this.self, xtypes, parentPrototype, parentXtypes;
  if (!self.xtypes) 
  {
    xtypes = [];
    parentPrototype = this;
    while (parentPrototype) 
      {
        parentXtypes = parentPrototype.xtypes;
        if (parentXtypes !== undefined) 
        {
          xtypes.unshift.apply(xtypes, parentXtypes);
        }
        parentPrototype = parentPrototype.superclass;
      }
    self.xtypeChain = xtypes;
    self.xtypes = xtypes.join('/');
  }
  return self.xtypes;
}, update: function(htmlOrData, loadScripts, cb) {
  var me = this, isData = (me.tpl && !Ext.isString(htmlOrData)), el, sizeModel = me.getSizeModel(), doLayout = sizeModel.width.shrinkWrap || sizeModel.height.shrinkWrap;
  if (isData) 
  {
    me.data = htmlOrData;
  } else {
    me.html = Ext.isObject(htmlOrData) ? Ext.DomHelper.markup(htmlOrData) : htmlOrData;
  }
  if (me.rendered) 
  {
    if (me.isContainer) 
    {
      el = me.layout.getRenderTarget();
      doLayout = doLayout || me.items.items.length > 0;
    } else {
      el = me.getTargetEl();
    }
    if (isData) 
    {
      me.tpl[me.tplWriteMode](el, htmlOrData || {});
    } else {
      el.update(me.html, loadScripts, cb);
    }
    if (doLayout) 
    {
      me.updateLayout();
    }
  }
}, setVisible: function(visible) {
  return this[visible ? 'show' : 'hide']();
}, isVisible: function(deep) {
  var me = this, hidden;
  if (me.hidden || !me.rendered || me.isDestroyed) 
  {
    hidden = true;
  } else if (deep) 
  {
    hidden = me.isHierarchicallyHidden();
  }
  return !hidden;
}, isHierarchicallyHidden: function() {
  var child = this, hidden = false, parent, parentHierarchyState;
  for (; (parent = child.ownerCt || child.floatParent); child = parent) 
    {
      parentHierarchyState = parent.getHierarchyState();
      if (parentHierarchyState.hidden) 
      {
        hidden = true;
        break;
      }
      if (child.getHierarchyState().collapseImmune) 
      {
        if (parent.collapsed && !child.collapseImmune) 
        {
          hidden = true;
          break;
        }
      } else {
        hidden = !!parentHierarchyState.collapsed;
        break;
      }
    }
  return hidden;
}, onBoxReady: function(width, height) {
  var me = this;
  if (me.disableOnBoxReady) 
  {
    me.onDisable();
  } else if (me.enableOnBoxReady) 
  {
    me.onEnable();
  }
  if (me.resizable) 
  {
    me.initResizable(me.resizable);
  }
  if (me.draggable) 
  {
    me.initDraggable();
  }
  if (me.hasListeners.boxready) 
  {
    me.fireEvent('boxready', me, width, height);
  }
}, enable: function(silent) {
  var me = this;
  delete me.disableOnBoxReady;
  me.removeCls(me.disabledCls);
  if (me.rendered) 
  {
    me.onEnable();
  } else {
    me.enableOnBoxReady = true;
  }
  me.disabled = false;
  delete me.resetDisable;
  if (silent !== true) 
  {
    me.fireEvent('enable', me);
  }
  return me;
}, disable: function(silent) {
  var me = this;
  delete me.enableOnBoxReady;
  me.addCls(me.disabledCls);
  if (me.rendered) 
  {
    me.onDisable();
  } else {
    me.disableOnBoxReady = true;
  }
  me.disabled = true;
  if (silent !== true) 
  {
    delete me.resetDisable;
    me.fireEvent('disable', me);
  }
  return me;
}, onEnable: function() {
  var me = this, dom, nodeName;
  if (me.maskOnDisable) 
  {
    dom = me.el.dom;
    nodeName = dom.nodeName;
    if (me.disabledRe.test(nodeName)) 
    {
      dom.disabled = false;
    }
    if (!me.nonMaskableRe.test(nodeName)) 
    {
      me.unmask();
    }
  }
}, onDisable: function() {
  var me = this, focusCls = me.focusCls, focusEl = me.getFocusEl(), dom, nodeName;
  if (focusCls && focusEl) 
  {
    focusEl.removeCls(me.removeClsWithUI(focusCls, true));
  }
  if (me.maskOnDisable) 
  {
    dom = me.el.dom;
    nodeName = dom.nodeName;
    if (me.disabledRe.test(nodeName)) 
    {
      dom.disabled = true;
    }
    if (!me.nonMaskableRe.test(nodeName)) 
    {
      me.mask();
    }
  }
}, mask: function(msg, msgCls, elHeight) {
  var box = this.lastBox, target = this.getMaskTarget() || this.el;
  if (box) 
  {
    elHeight = box.height;
  }
  target.mask(msg, msgCls, elHeight);
}, unmask: function() {
  (this.getMaskTarget() || this.el).unmask();
}, getMaskTarget: function() {
  return this.maskElement ? this[this.maskElement] : null;
}, isDisabled: function() {
  return this.disabled;
}, setDisabled: function(disabled) {
  return this[disabled ? 'disable' : 'enable']();
}, isHidden: function() {
  return this.hidden;
}, addCls: function(cls) {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  el.addCls.apply(el, arguments);
  return me;
}, addClass: function() {
  return this.addCls.apply(this, arguments);
}, hasCls: function(cls) {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  return el.hasCls.apply(el, arguments);
}, removeCls: function(cls) {
  var me = this, el = me.rendered ? me.el : me.protoEl;
  el.removeCls.apply(el, arguments);
  return me;
}, addOverCls: function() {
  var me = this;
  if (!me.disabled) 
  {
    me.el.addCls(me.overCls);
  }
}, removeOverCls: function() {
  this.el.removeCls(this.overCls);
}, addListener: function(element, listeners, scope, options) {
  var me = this, fn, option;
  if (Ext.isString(element) && (Ext.isObject(listeners) || options && options.element)) 
  {
    if (options.element) 
    {
      fn = listeners;
      listeners = {};
      listeners[element] = fn;
      element = options.element;
      if (scope) 
      {
        listeners.scope = scope;
      }
      for (option in options) 
        {
          if (options.hasOwnProperty(option)) 
          {
            if (me.eventOptionsRe.test(option)) 
            {
              listeners[option] = options[option];
            }
          }
        }
    }
    if (me[element] && me[element].on) 
    {
      me.mon(me[element], listeners);
    } else {
      me.afterRenderEvents = me.afterRenderEvents || {};
      if (!me.afterRenderEvents[element]) 
      {
        me.afterRenderEvents[element] = [];
      }
      me.afterRenderEvents[element].push(listeners);
    }
    return;
  }
  return me.mixins.observable.addListener.apply(me, arguments);
}, removeManagedListenerItem: function(isClear, managedListener, item, ename, fn, scope) {
  var me = this, element = managedListener.options ? managedListener.options.element : null;
  if (element) 
  {
    element = me[element];
    if (element && element.un) 
    {
      if (isClear || (managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope))) 
      {
        element.un(managedListener.ename, managedListener.fn, managedListener.scope);
        if (!isClear) 
        {
          Ext.Array.remove(me.managedListeners, managedListener);
        }
      }
    }
  } else {
    return me.mixins.observable.removeManagedListenerItem.apply(me, arguments);
  }
}, getBubbleTarget: function() {
  return this.ownerCt;
}, isFloating: function() {
  return this.floating;
}, isDraggable: function() {
  return !!this.draggable;
}, isDroppable: function() {
  return !!this.droppable;
}, onAdded: function(container, pos) {
  var me = this;
  me.ownerCt = container;
  if (me.hierarchyState) 
  {
    me.hierarchyState.invalid = true;
    delete me.hierarchyState;
  }
  if (me.hasListeners.added) 
  {
    me.fireEvent('added', me, container, pos);
  }
}, onRemoved: function(destroying) {
  var me = this;
  if (me.hasListeners.removed) 
  {
    me.fireEvent('removed', me, me.ownerCt);
  }
  delete me.ownerCt;
  delete me.ownerLayout;
}, beforeDestroy: Ext.emptyFn, onResize: function(width, height, oldWidth, oldHeight) {
  var me = this;
  if (me.floating && me.constrain) 
  {
    me.doConstrain();
  }
  if (me.hasListeners.resize) 
  {
    me.fireEvent('resize', me, width, height, oldWidth, oldHeight);
  }
}, setSize: function(width, height) {
  var me = this;
  if (width && typeof width == 'object') 
  {
    height = width.height;
    width = width.width;
  }
  if (typeof width == 'number') 
  {
    me.width = Ext.Number.constrain(width, me.minWidth, me.maxWidth);
  } else if (width === null) 
  {
    delete me.width;
  }
  if (typeof height == 'number') 
  {
    me.height = Ext.Number.constrain(height, me.minHeight, me.maxHeight);
  } else if (height === null) 
  {
    delete me.height;
  }
  if (me.rendered && me.isVisible()) 
  {
    me.updateLayout({isRoot: false});
  }
  return me;
}, isLayoutRoot: function() {
  var me = this, ownerLayout = me.ownerLayout;
  if (!ownerLayout || me._isLayoutRoot || me.floating) 
  {
    return true;
  }
  return ownerLayout.isItemLayoutRoot(me);
}, isLayoutSuspended: function() {
  var comp = this, ownerLayout;
  while (comp) 
    {
      if (comp.layoutSuspendCount || comp.suspendLayout) 
      {
        return true;
      }
      ownerLayout = comp.ownerLayout;
      if (!ownerLayout) 
      {
        break;
      }
      comp = ownerLayout.owner;
    }
  return false;
}, updateLayout: function(options) {
  var me = this, defer, lastBox = me.lastBox, isRoot = options && options.isRoot;
  if (lastBox) 
  {
    lastBox.invalid = true;
  }
  if (!me.rendered || me.layoutSuspendCount || me.suspendLayout) 
  {
    return;
  }
  if (me.hidden) 
  {
    Ext.AbstractComponent.cancelLayout(me);
  } else if (typeof isRoot != 'boolean') 
  {
    isRoot = me.isLayoutRoot();
  }
  if (isRoot || !me.ownerLayout || !me.ownerLayout.onContentChange(me)) 
  {
    if (!me.isLayoutSuspended()) 
    {
      defer = (options && options.hasOwnProperty('defer')) ? options.defer : me.deferLayouts;
      Ext.AbstractComponent.updateLayout(me, defer);
    }
  }
}, getSizeModel: function(ownerCtSizeModel) {
  var me = this, models = Ext.layout.SizeModel, ownerContext = me.componentLayout.ownerContext, width = me.width, height = me.height, typeofWidth, typeofHeight, hasPixelWidth, hasPixelHeight, heightModel, ownerLayout, policy, shrinkWrap, topLevel, widthModel;
  if (ownerContext) 
  {
    widthModel = ownerContext.widthModel;
    heightModel = ownerContext.heightModel;
  }
  if (!widthModel || !heightModel) 
  {
    hasPixelWidth = ((typeofWidth = typeof width) == 'number');
    hasPixelHeight = ((typeofHeight = typeof height) == 'number');
    topLevel = me.floating || !(ownerLayout = me.ownerLayout);
    if (topLevel) 
    {
      policy = Ext.layout.Layout.prototype.autoSizePolicy;
      shrinkWrap = me.floating ? 3 : me.shrinkWrap;
      if (hasPixelWidth) 
      {
        widthModel = models.configured;
      }
      if (hasPixelHeight) 
      {
        heightModel = models.configured;
      }
    } else {
      policy = ownerLayout.getItemSizePolicy(me, ownerCtSizeModel);
      shrinkWrap = ownerLayout.isItemShrinkWrap(me);
    }
    if (ownerContext) 
    {
      ownerContext.ownerSizePolicy = policy;
    }
    shrinkWrap = (shrinkWrap === true) ? 3 : (shrinkWrap || 0);
    if (topLevel && shrinkWrap) 
    {
      if (width && typeofWidth == 'string') 
      {
        shrinkWrap &= 2;
      }
      if (height && typeofHeight == 'string') 
      {
        shrinkWrap &= 1;
      }
    }
    if (shrinkWrap !== 3) 
    {
      if (!ownerCtSizeModel) 
      {
        ownerCtSizeModel = me.ownerCt && me.ownerCt.getSizeModel();
      }
      if (ownerCtSizeModel) 
      {
        shrinkWrap |= (ownerCtSizeModel.width.shrinkWrap ? 1 : 0) | (ownerCtSizeModel.height.shrinkWrap ? 2 : 0);
      }
    }
    if (!widthModel) 
    {
      if (!policy.setsWidth) 
      {
        if (hasPixelWidth) 
        {
          widthModel = models.configured;
        } else {
          widthModel = (shrinkWrap & 1) ? models.shrinkWrap : models.natural;
        }
      } else if (policy.readsWidth) 
      {
        if (hasPixelWidth) 
        {
          widthModel = models.calculatedFromConfigured;
        } else {
          widthModel = (shrinkWrap & 1) ? models.calculatedFromShrinkWrap : models.calculatedFromNatural;
        }
      } else {
        widthModel = models.calculated;
      }
    }
    if (!heightModel) 
    {
      if (!policy.setsHeight) 
      {
        if (hasPixelHeight) 
        {
          heightModel = models.configured;
        } else {
          heightModel = (shrinkWrap & 2) ? models.shrinkWrap : models.natural;
        }
      } else if (policy.readsHeight) 
      {
        if (hasPixelHeight) 
        {
          heightModel = models.calculatedFromConfigured;
        } else {
          heightModel = (shrinkWrap & 2) ? models.calculatedFromShrinkWrap : models.calculatedFromNatural;
        }
      } else {
        heightModel = models.calculated;
      }
    }
  }
  return widthModel.pairsByHeightOrdinal[heightModel.ordinal];
}, isDescendant: function(ancestor) {
  if (ancestor.isContainer) 
  {
    for (var c = this.ownerCt; c; c = c.ownerCt) 
      {
        if (c === ancestor) 
        {
          return true;
        }
      }
  }
  return false;
}, doComponentLayout: function() {
  this.updateLayout();
  return this;
}, forceComponentLayout: function() {
  this.updateLayout();
}, setComponentLayout: function(layout) {
  var currentLayout = this.componentLayout;
  if (currentLayout && currentLayout.isLayout && currentLayout != layout) 
  {
    currentLayout.setOwner(null);
  }
  this.componentLayout = layout;
  layout.setOwner(this);
}, getComponentLayout: function() {
  var me = this;
  if (!me.componentLayout || !me.componentLayout.isLayout) 
  {
    me.setComponentLayout(Ext.layout.Layout.create(me.componentLayout, 'autocomponent'));
  }
  return me.componentLayout;
}, afterComponentLayout: function(width, height, oldWidth, oldHeight) {
  var me = this;
  if (++me.componentLayoutCounter === 1) 
  {
    me.afterFirstLayout(width, height);
  }
  if (width !== oldWidth || height !== oldHeight) 
  {
    me.onResize(width, height, oldWidth, oldHeight);
  }
}, beforeComponentLayout: function(width, height) {
  return true;
}, setPosition: function(x, y, animate) {
  var me = this, pos = me.beforeSetPosition.apply(me, arguments);
  if (pos && me.rendered) 
  {
    x = pos.x;
    y = pos.y;
    if (animate) 
    {
      if (x !== me.getLocalX() || y !== me.getLocalY()) 
      {
        me.stopAnimation();
        me.animate(Ext.apply({duration: 1000, listeners: {afteranimate: Ext.Function.bind(me.afterSetPosition, me, [x, y])}, to: {left: x, top: y}}, animate));
      }
    } else {
      me.setLocalXY(x, y);
      me.afterSetPosition(x, y);
    }
  }
  return me;
}, beforeSetPosition: function(x, y, animate) {
  var pos, x0;
  if (x) 
  {
    if (Ext.isNumber(x0 = x[0])) 
    {
      animate = y;
      y = x[1];
      x = x0;
    } else if ((x0 = x.x) !== undefined) 
    {
      animate = y;
      y = x.y;
      x = x0;
    }
  }
  if (this.constrain || this.constrainHeader) 
  {
    pos = this.calculateConstrainedPosition(null, [x, y], true);
    if (pos) 
    {
      x = pos[0];
      y = pos[1];
    }
  }
  pos = {x: this.x = x, y: this.y = y, anim: animate, hasX: x !== undefined, hasY: y !== undefined};
  return (pos.hasX || pos.hasY) ? pos : null;
}, afterSetPosition: function(x, y) {
  var me = this;
  me.onPosition(x, y);
  if (me.hasListeners.move) 
  {
    me.fireEvent('move', me, x, y);
  }
}, onPosition: Ext.emptyFn, setWidth: function(width) {
  return this.setSize(width);
}, setHeight: function(height) {
  return this.setSize(undefined, height);
}, getSize: function(contentSize) {
  return this.el.getSize(contentSize);
}, getWidth: function() {
  return this.el.getWidth();
}, getHeight: function() {
  return this.el.getHeight();
}, getLoader: function() {
  var me = this, autoLoad = me.autoLoad ? (Ext.isObject(me.autoLoad) ? me.autoLoad : {url: me.autoLoad}) : null, loader = me.loader || autoLoad;
  if (loader) 
  {
    if (!loader.isLoader) 
    {
      me.loader = new Ext.ComponentLoader(Ext.apply({target: me, autoLoad: autoLoad}, loader));
    } else {
      loader.setTarget(me);
    }
    return me.loader;
  }
  return null;
}, setDocked: function(dock, layoutParent) {
  var me = this;
  me.dock = dock;
  if (layoutParent && me.ownerCt && me.rendered) 
  {
    me.ownerCt.updateLayout();
  }
  return me;
}, setBorder: function(border, targetEl) {
  var me = this, initial = !!targetEl;
  if (me.rendered || initial) 
  {
    if (!initial) 
    {
      targetEl = me.el;
    }
    if (!border) 
    {
      border = 0;
    } else if (border === true) 
    {
      border = '1px';
    } else {
      border = this.unitizeBox(border);
    }
    targetEl.setStyle('border-width', border);
    if (!initial) 
    {
      me.updateLayout();
    }
  }
  me.border = border;
}, onDestroy: function() {
  var me = this;
  Ext.destroy(me.componentLayout, me.loadMask, me.floatingDescendants);
}, destroy: function() {
  var me = this, selectors = me.renderSelectors, selector, el;
  if (!me.isDestroyed) 
  {
    if (!me.hasListeners.beforedestroy || me.fireEvent('beforedestroy', me) !== false) 
    {
      me.destroying = true;
      me.beforeDestroy();
      if (me.floating) 
      {
        delete me.floatParent;
        if (me.zIndexManager) 
        {
          me.zIndexManager.unregister(me);
        }
      } else if (me.ownerCt && me.ownerCt.remove) 
      {
        me.ownerCt.remove(me, false);
      }
      me.stopAnimation();
      me.onDestroy();
      Ext.destroy(me.plugins);
      if (me.hasListeners.destroy) 
      {
        me.fireEvent('destroy', me);
      }
      Ext.ComponentManager.unregister(me);
      me.mixins.state.destroy.call(me);
      me.clearListeners();
      if (me.rendered) 
      {
        if (!me.preserveElOnDestroy) 
        {
          me.el.remove();
        }
        me.mixins.elementCt.destroy.call(me);
        if (selectors) 
        {
          for (selector in selectors) 
            {
              if (selectors.hasOwnProperty(selector)) 
              {
                el = me[selector];
                if (el) 
                {
                  delete me[selector];
                  el.remove();
                }
              }
            }
        }
        delete me.el;
        delete me.frameBody;
        delete me.rendered;
      }
      delete me.initialConfig;
      me.destroying = false;
      me.isDestroyed = true;
    }
  }
}, isDescendantOf: function(container) {
  return !!this.findParentBy(function(p) {
  return p === container;
});
}, getHierarchyState: function(inner) {
  var me = this, hierarchyState = (inner && me.hierarchyStateInner) || me.hierarchyState, ownerCt = me.ownerCt, parent, layout, hierarchyStateInner, getInner;
  if (!hierarchyState || hierarchyState.invalid) 
  {
    parent = me.getRefOwner();
    if (ownerCt) 
    {
      getInner = me.ownerLayout === ownerCt.layout;
    }
    me.hierarchyState = hierarchyState = Ext.Object.chain(parent ? parent.getHierarchyState(getInner) : Ext.rootHierarchyState);
    me.initHierarchyState(hierarchyState);
    if ((layout = me.componentLayout).initHierarchyState) 
    {
      layout.initHierarchyState(hierarchyState);
    }
    if (me.isContainer) 
    {
      me.hierarchyStateInner = hierarchyStateInner = Ext.Object.chain(hierarchyState);
      layout = me.layout;
      if (layout && layout.initHierarchyState) 
      {
        layout.initHierarchyState(hierarchyStateInner, hierarchyState);
      }
      if (inner) 
      {
        hierarchyState = hierarchyStateInner;
      }
    }
  }
  return hierarchyState;
}, initHierarchyState: function(hierarchyState) {
  var me = this;
  if (me.collapsed) 
  {
    hierarchyState.collapsed = true;
  }
  if (me.hidden) 
  {
    hierarchyState.hidden = true;
  }
  if (me.collapseImmune) 
  {
    hierarchyState.collapseImmune = true;
  }
}, getAnchorToXY: function(el, anchor, local, mySize) {
  return el.getAnchorXY(anchor, local, mySize);
}, getBorderPadding: function() {
  return this.el.getBorderPadding();
}, getLocalX: function() {
  return this.el.getLocalX();
}, getLocalXY: function() {
  return this.el.getLocalXY();
}, getLocalY: function() {
  return this.el.getLocalY();
}, getX: function() {
  return this.el.getX();
}, getXY: function() {
  return this.el.getXY();
}, getY: function() {
  return this.el.getY();
}, setLocalX: function(x) {
  this.el.setLocalX(x);
}, setLocalXY: function(x, y) {
  this.el.setLocalXY(x, y);
}, setLocalY: function(y) {
  this.el.setLocalY(y);
}, setX: function(x, animate) {
  this.el.setX(x, animate);
}, setXY: function(xy, animate) {
  this.el.setXY(xy, animate);
}, setY: function(y, animate) {
  this.el.setY(y, animate);
}}, 1, 0, 0, 0, 0, [['positionable', Ext.util.Positionable], ['observable', Ext.util.Observable], ['animate', Ext.util.Animate], ['elementCt', Ext.util.ElementContainer], ['renderable', Ext.util.Renderable], ['state', Ext.state.Stateful]], [Ext, 'AbstractComponent'], function() {
  var AbstractComponent = this;
  AbstractComponent.createAlias({on: 'addListener', prev: 'previousSibling', next: 'nextSibling'});
  Ext.resumeLayouts = function(flush) {
  AbstractComponent.resumeLayouts(flush);
};
  Ext.suspendLayouts = function() {
  AbstractComponent.suspendLayouts();
};
  Ext.batchLayouts = function(fn, scope) {
  AbstractComponent.suspendLayouts();
  fn.call(scope);
  AbstractComponent.resumeLayouts(true);
};
}));
;

(Ext.cmd.derive('Ext.AbstractPlugin', Ext.Base, {disabled: false, isPlugin: true, constructor: function(config) {
  if (config) 
  {
    this.pluginConfig = config;
    Ext.apply(this, config);
  }
}, clonePlugin: function(overrideCfg) {
  return new this.self(Ext.apply({}, overrideCfg, this.pluginConfig));
}, setCmp: function(cmp) {
  this.cmp = cmp;
}, getCmp: function() {
  return this.cmp;
}, init: Ext.emptyFn, destroy: Ext.emptyFn, enable: function() {
  this.disabled = false;
}, disable: function() {
  this.disabled = true;
}, onClassExtended: function(cls, data, hooks) {
  var alias = data.alias;
  if (alias && !data.ptype) 
  {
    if (Ext.isArray(alias)) 
    {
      alias = alias[0];
    }
    cls.prototype.ptype = alias.split('plugin.')[1];
  }
}}, 1, 0, 0, 0, 0, 0, [Ext, 'AbstractPlugin'], 0));
;

(Ext.cmd.derive('Ext.data.flash.BinaryXhr', Ext.Base, {statics: {flashPluginActivated: function() {
  Ext.data.flash.BinaryXhr.flashPluginActive = true;
  Ext.data.flash.BinaryXhr.flashPlugin = document.getElementById("ext-flash-polyfill");
  Ext.globalEvents.fireEvent("flashready");
}, flashPluginActive: false, flashPluginInjected: false, connectionIndex: 1, liveConnections: {}, flashPlugin: null, onFlashStateChange: function(javascriptId, state, data) {
  var connection;
  connection = this.liveConnections[Number(javascriptId)];
  if (connection) 
  {
    connection.onFlashStateChange(state, data);
  }
}, registerConnection: function(conn) {
  var i = this.connectionIndex;
  this.conectionIndex = this.connectionIndex + 1;
  this.liveConnections[i] = conn;
  return i;
}, injectFlashPlugin: function() {
  var me = this, flashLoaderPath, flashObjectPath;
  me.flashPolyfillEl = Ext.getBody().appendChild({id: 'ext-flash-polyfill', cn: [{tag: 'p', html: 'To view this page ensure that Adobe Flash Player version 11.1.0 or greater is installed.'}, {tag: 'a', href: 'http://www.adobe.com/go/getflashplayer', cn: [{tag: 'img', src: window.location.protocol + '//www.adobe.com/images/shared/download_buttons/get_flash_player.gif', alt: 'Get Adobe Flash player'}]}]});
  flashLoaderPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../../plugins/flash/swfobject.js'].join('/');
  flashObjectPath = "/plugins/flash/FlashPlugin.swf";
  if (Ext.flashPluginPath) 
  {
    flashObjectPath = Ext.flashPluginPath;
  }
  Ext.Loader.loadScript({url: flashLoaderPath, onLoad: function() {
  var swfVersionStr = "11.4.0";
  var xiSwfUrlStr = "playerProductInstall.swf";
  var flashvars = {};
  var params = {};
  params.quality = "high";
  params.bgcolor = "#ffffff";
  params.allowscriptaccess = "sameDomain";
  params.allowfullscreen = "true";
  var attributes = {};
  attributes.id = "ext-flash-polyfill";
  attributes.name = "polyfill";
  attributes.align = "middle";
  swfobject.embedSWF(flashObjectPath, "ext-flash-polyfill", "0", "0", swfVersionStr, xiSwfUrlStr, flashvars, params, attributes);
}, onError: function() {
}, scope: me});
  Ext.globalEvents.addEvents("flashready");
  Ext.data.flash.BinaryXhr.flashPluginInjected = true;
}}, readyState: 0, status: 0, statusText: "", responseBytes: null, javascriptId: null, constructor: function(config) {
  if (!Ext.data.flash.BinaryXhr.flashPluginInjected) 
  {
    Ext.data.flash.BinaryXhr.injectFlashPlugin();
  }
  var me = this;
  Ext.apply(me, config);
  me.requestHeaders = {};
}, abort: function() {
  var me = this;
  if (me.readyState == 4) 
  {
    return;
  }
  me.aborted = true;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) 
  {
    Ext.globalEvents.removeListener("flashready", me.onFlashReady, me);
    return;
  }
  Ext.data.flash.BinaryXhr.flashPlugin.abortRequest(me.javascriptId);
  delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
}, getAllResponseHeaders: function() {
  var headers = [];
  Ext.Object.each(this.responseHeaders, function(name, value) {
  headers.push(name + ': ' + value);
});
  return headers.join('\r\n');
}, getResponseHeader: function(header) {
  var headers = this.responseHeaders;
  return (headers && headers[header]) || null;
}, open: function(method, url, async, user, password) {
  var me = this;
  me.method = method;
  me.url = url;
  me.async = async !== false;
  me.user = user;
  me.password = password;
}, overrideMimeType: function(mimeType) {
  this.mimeType = mimeType;
}, send: function(body) {
  var me = this;
  me.body = body;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) 
  {
    Ext.globalEvents.addListener("flashready", me.onFlashReady, me);
  } else {
    this.onFlashReady();
  }
}, onFlashReady: function() {
  var me = this, req, status;
  me.javascriptId = Ext.data.flash.BinaryXhr.registerConnection(me);
  req = {method: me.method, url: me.url, user: me.user, password: me.password, mimeType: me.mimeType, requestHeaders: me.requestHeaders, body: me.body, javascriptId: me.javascriptId};
  status = Ext.data.flash.BinaryXhr.flashPlugin.postBinary(req);
}, setReadyState: function(state) {
  var me = this;
  if (me.readyState != state) 
  {
    me.readyState = state;
    me.onreadystatechange();
  }
}, setRequestHeader: function(header, value) {
  this.requestHeaders[header] = value;
}, onreadystatechange: Ext.emptyFn, parseData: function(data) {
  var me = this;
  this.status = data.status || 0;
  me.responseHeaders = {};
  if (me.mimeType) 
  {
    me.responseHeaders["content-type"] = me.mimeType;
  }
  if (data.reason == "complete") 
  {
    this.responseBytes = data.data;
    me.responseHeaders["content-length"] = data.data.length;
  } else if (data.reason == "error" || data.reason == "securityError") 
  {
    this.statusText = data.text;
    me.responseHeaders["content-length"] = 0;
  }
}, onFlashStateChange: function(state, data) {
  var me = this;
  if (state == 4) 
  {
    me.parseData(data);
    delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
  }
  me.setReadyState(state);
}}, 1, 0, 0, 0, 0, 0, [Ext.data.flash, 'BinaryXhr'], 0));
;

(Ext.cmd.derive('Ext.data.Connection', Ext.Base, {statics: {requestId: 0}, url: null, async: true, method: null, username: '', password: '', disableCaching: true, withCredentials: false, binary: false, cors: false, isXdr: false, defaultXdrContentType: 'text/plain', disableCachingParam: '_dc', timeout: 30000, useDefaultHeader: true, defaultPostHeader: 'application/x-www-form-urlencoded; charset=UTF-8', useDefaultXhrHeader: true, defaultXhrHeader: 'XMLHttpRequest', constructor: function(config) {
  config = config || {};
  Ext.apply(this, config);
  this.requests = {};
  this.mixins.observable.constructor.call(this);
}, request: function(options) {
  options = options || {};
  var me = this, scope = options.scope || window, username = options.username || me.username, password = options.password || me.password || '', async, requestOptions, request, headers, xhr;
  if (me.fireEvent('beforerequest', me, options) !== false) 
  {
    requestOptions = me.setOptions(options, scope);
    if (me.isFormUpload(options)) 
    {
      me.upload(options.form, requestOptions.url, requestOptions.data, options);
      return null;
    }
    if (options.autoAbort || me.autoAbort) 
    {
      me.abort();
    }
    async = options.async !== false ? (options.async || me.async) : false;
    xhr = me.openRequest(options, requestOptions, async, username, password);
    if (!me.isXdr) 
    {
      headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);
    }
    request = {id: ++Ext.data.Connection.requestId, xhr: xhr, headers: headers, options: options, async: async, binary: options.binary || me.binary, timeout: setTimeout(function() {
  request.timedout = true;
  me.abort(request);
}, options.timeout || me.timeout)};
    me.requests[request.id] = request;
    me.latestId = request.id;
    if (async) 
    {
      if (!me.isXdr) 
      {
        xhr.onreadystatechange = Ext.Function.bind(me.onStateChange, me, [request]);
      }
    }
    if (me.isXdr) 
    {
      me.processXdrRequest(request, xhr);
    }
    xhr.send(requestOptions.data);
    if (!async) 
    {
      return me.onComplete(request);
    }
    return request;
  } else {
    Ext.callback(options.callback, options.scope, [options, undefined, undefined]);
    return null;
  }
}, processXdrRequest: function(request, xhr) {
  var me = this;
  delete request.headers;
  request.contentType = request.options.contentType || me.defaultXdrContentType;
  xhr.onload = Ext.Function.bind(me.onStateChange, me, [request, true]);
  xhr.onerror = xhr.ontimeout = Ext.Function.bind(me.onStateChange, me, [request, false]);
}, processXdrResponse: function(response, xhr) {
  response.getAllResponseHeaders = function() {
  return [];
};
  response.getResponseHeader = function() {
  return '';
};
  response.contentType = xhr.contentType || this.defaultXdrContentType;
}, upload: function(form, url, params, options) {
  form = Ext.getDom(form);
  options = options || {};
  var id = Ext.id(), frame = document.createElement('iframe'), hiddens = [], encoding = 'multipart/form-data', buf = {target: form.target, method: form.method, encoding: form.encoding, enctype: form.enctype, action: form.action}, addField = function(name, value) {
  hiddenItem = document.createElement('input');
  Ext.fly(hiddenItem).set({type: 'hidden', value: value, name: name});
  form.appendChild(hiddenItem);
  hiddens.push(hiddenItem);
}, hiddenItem, obj, value, name, vLen, v, hLen, h;
  Ext.fly(frame).set({id: id, name: id, cls: Ext.baseCSSPrefix + 'hide-display', src: Ext.SSL_SECURE_URL});
  document.body.appendChild(frame);
  if (document.frames) 
  {
    document.frames[id].name = id;
  }
  Ext.fly(form).set({target: id, method: 'POST', enctype: encoding, encoding: encoding, action: url || buf.action});
  if (params) 
  {
    obj = Ext.Object.fromQueryString(params) || {};
    for (name in obj) 
      {
        if (obj.hasOwnProperty(name)) 
        {
          value = obj[name];
          if (Ext.isArray(value)) 
          {
            vLen = value.length;
            for (v = 0; v < vLen; v++) 
              {
                addField(name, value[v]);
              }
          } else {
            addField(name, value);
          }
        }
      }
  }
  Ext.fly(frame).on('load', Ext.Function.bind(this.onUploadComplete, this, [frame, options]), null, {single: !Ext.isOpera});
  form.submit();
  Ext.fly(form).set(buf);
  hLen = hiddens.length;
  for (h = 0; h < hLen; h++) 
    {
      Ext.removeNode(hiddens[h]);
    }
}, onUploadComplete: function(frame, options) {
  var me = this, response = {responseText: '', responseXML: null}, callback, success, doc, contentNode;
  try {
    doc = frame.contentWindow.document || frame.contentDocument || window.frames[frame.id].document;
    if (doc) 
    {
      if (Ext.isOpera && doc.location == 'about:blank') 
      {
        return;
      }
      if (doc.body) 
      {
        if ((contentNode = doc.body.firstChild) && /pre/i.test(contentNode.tagName)) 
        {
          response.responseText = contentNode.textContent || contentNode.innerText;
        } else if ((contentNode = doc.getElementsByTagName('textarea')[0])) 
        {
          response.responseText = contentNode.value;
        } else {
          response.responseText = doc.body.textContent || doc.body.innerText;
        }
      }
      response.responseXML = doc.XMLDocument || doc;
      callback = options.success;
      success = true;
    }
  }  catch (e) {
  response.responseText = '{success:false,message:"' + Ext.String.trim(e.message || e.description) + '"}';
  callback = options.failure;
  success = false;
}
  me.fireEvent('requestcomplete', me, response, options);
  Ext.callback(callback, options.scope, [response, options]);
  Ext.callback(options.callback, options.scope, [options, success, response]);
  setTimeout(function() {
  Ext.removeNode(frame);
}, 100);
}, isFormUpload: function(options) {
  var form = this.getForm(options);
  if (form) 
  {
    return (options.isUpload || (/multipart\/form-data/i).test(form.getAttribute('enctype')));
  }
  return false;
}, getForm: function(options) {
  return Ext.getDom(options.form) || null;
}, setOptions: function(options, scope) {
  var me = this, params = options.params || {}, extraParams = me.extraParams, urlParams = options.urlParams, url = options.url || me.url, jsonData = options.jsonData, method, disableCache, data;
  if (Ext.isFunction(params)) 
  {
    params = params.call(scope, options);
  }
  if (Ext.isFunction(url)) 
  {
    url = url.call(scope, options);
  }
  url = this.setupUrl(options, url);
  data = options.rawData || options.binaryData || options.xmlData || jsonData || null;
  if (jsonData && !Ext.isPrimitive(jsonData)) 
  {
    data = Ext.encode(data);
  }
  if (options.binaryData) 
  {
    if (me.nativeBinaryPostSupport()) 
    {
      data = (new Uint8Array(options.binaryData));
      if ((Ext.isChrome && Ext.chromeVersion < 22) || Ext.isSafari || Ext.isGecko) 
      {
        data = data.buffer;
      }
    }
  }
  if (Ext.isObject(params)) 
  {
    params = Ext.Object.toQueryString(params);
  }
  if (Ext.isObject(extraParams)) 
  {
    extraParams = Ext.Object.toQueryString(extraParams);
  }
  params = params + ((extraParams) ? ((params) ? '&' : '') + extraParams : '');
  urlParams = Ext.isObject(urlParams) ? Ext.Object.toQueryString(urlParams) : urlParams;
  params = this.setupParams(options, params);
  method = (options.method || me.method || ((params || data) ? 'POST' : 'GET')).toUpperCase();
  this.setupMethod(options, method);
  disableCache = options.disableCaching !== false ? (options.disableCaching || me.disableCaching) : false;
  if (method === 'GET' && disableCache) 
  {
    url = Ext.urlAppend(url, (options.disableCachingParam || me.disableCachingParam) + '=' + (new Date().getTime()));
  }
  if ((method == 'GET' || data) && params) 
  {
    url = Ext.urlAppend(url, params);
    params = null;
  }
  if (urlParams) 
  {
    url = Ext.urlAppend(url, urlParams);
  }
  return {url: url, method: method, data: data || params || null};
}, setupUrl: function(options, url) {
  var form = this.getForm(options);
  if (form) 
  {
    url = url || form.action;
  }
  return url;
}, setupParams: function(options, params) {
  var form = this.getForm(options), serializedForm;
  if (form && !this.isFormUpload(options)) 
  {
    serializedForm = Ext.Element.serializeForm(form);
    params = params ? (params + '&' + serializedForm) : serializedForm;
  }
  return params;
}, setupMethod: function(options, method) {
  if (this.isFormUpload(options)) 
  {
    return 'POST';
  }
  return method;
}, setupHeaders: function(xhr, options, data, params) {
  var me = this, headers = Ext.apply({}, options.headers || {}, me.defaultHeaders || {}), contentType = me.defaultPostHeader, jsonData = options.jsonData, xmlData = options.xmlData, type = 'Content-Type', key, header;
  if (!headers.hasOwnProperty(type) && (data || params)) 
  {
    if (data) 
    {
      if (options.rawData) 
      {
        contentType = 'text/plain';
      } else {
        if (xmlData && Ext.isDefined(xmlData)) 
        {
          contentType = 'text/xml';
        } else if (jsonData && Ext.isDefined(jsonData)) 
        {
          contentType = 'application/json';
        }
      }
    }
    headers[type] = contentType;
  }
  if (me.useDefaultXhrHeader && !headers['X-Requested-With']) 
  {
    headers['X-Requested-With'] = me.defaultXhrHeader;
  }
  if (headers[type] === undefined || headers[type] === null) 
  {
    delete headers[type];
  }
  try {
    for (key in headers) 
      {
        if (headers.hasOwnProperty(key)) 
        {
          header = headers[key];
          xhr.setRequestHeader(key, header);
        }
      }
  }  catch (e) {
  me.fireEvent('exception', key, header);
}
  return headers;
}, newRequest: function(options) {
  var me = this, xhr;
  if (options.binaryData) 
  {
    if (me.nativeBinaryPostSupport()) 
    {
      xhr = this.getXhrInstance();
    } else {
      xhr = new Ext.data.flash.BinaryXhr();
    }
  } else if ((options.cors || me.cors) && Ext.isIE && Ext.ieVersion <= 9) 
  {
    xhr = me.getXdrInstance();
    me.isXdr = true;
  } else {
    xhr = me.getXhrInstance();
  }
  return xhr;
}, openRequest: function(options, requestOptions, async, username, password) {
  var me = this, xhr = me.newRequest(options);
  if (username) 
  {
    xhr.open(requestOptions.method, requestOptions.url, async, username, password);
  } else {
    if (me.isXdr) 
    {
      xhr.open(requestOptions.method, requestOptions.url);
    } else {
      xhr.open(requestOptions.method, requestOptions.url, async);
    }
  }
  if (options.binary || me.binary) 
  {
    if (window.Uint8Array) 
    {
      xhr.responseType = 'arraybuffer';
    } else if (xhr.overrideMimeType) 
    {
      xhr.overrideMimeType('text/plain; charset=x-user-defined');
    }
  }
  if (options.withCredentials || me.withCredentials) 
  {
    xhr.withCredentials = true;
  }
  return xhr;
}, getXdrInstance: function() {
  var xdr;
  if (Ext.ieVersion >= 8) 
  {
    xdr = new XDomainRequest();
  } else {
    Ext.Error.raise({msg: 'Your browser does not support CORS'});
  }
  return xdr;
}, getXhrInstance: (function() {
  var options = [function() {
  return new XMLHttpRequest();
}, function() {
  return new ActiveXObject('MSXML2.XMLHTTP.3.0');
}, function() {
  return new ActiveXObject('MSXML2.XMLHTTP');
}, function() {
  return new ActiveXObject('Microsoft.XMLHTTP');
}], i = 0, len = options.length, xhr;
  for (; i < len; ++i) 
    {
      try {
        xhr = options[i];
        xhr();
        break;
      }      catch (e) {
}
    }
  return xhr;
}()), isLoading: function(request) {
  if (!request) 
  {
    request = this.getLatest();
  }
  if (!(request && request.xhr)) 
  {
    return false;
  }
  var state = request.xhr.readyState;
  return ((request.xhr instanceof Ext.data.flash.BinaryXhr) && state != 4) || !(state === 0 || state == 4);
}, abort: function(request) {
  var me = this, xhr;
  if (!request) 
  {
    request = me.getLatest();
  }
  if (request && me.isLoading(request)) 
  {
    xhr = request.xhr;
    try {
      xhr.onreadystatechange = null;
    }    catch (e) {
  xhr.onreadystatechange = Ext.emptyFn;
}
    xhr.abort();
    me.clearTimeout(request);
    if (!request.timedout) 
    {
      request.aborted = true;
    }
    me.onComplete(request);
    me.cleanup(request);
  }
}, abortAll: function() {
  var requests = this.requests, id;
  for (id in requests) 
    {
      if (requests.hasOwnProperty(id)) 
      {
        this.abort(requests[id]);
      }
    }
}, getLatest: function() {
  var id = this.latestId, request;
  if (id) 
  {
    request = this.requests[id];
  }
  return request || null;
}, onStateChange: function(request, xdrResult) {
  var me = this;
  if ((request.xhr && request.xhr.readyState == 4) || me.isXdr) 
  {
    me.clearTimeout(request);
    me.onComplete(request, xdrResult);
    me.cleanup(request);
    Ext.EventManager.idleEvent.fire();
  }
}, clearTimeout: function(request) {
  clearTimeout(request.timeout);
  delete request.timeout;
}, cleanup: function(request) {
  request.xhr = null;
  delete request.xhr;
}, onComplete: function(request, xdrResult) {
  var me = this, options = request.options, xhr, result, success, response;
  try {
    xhr = request.xhr;
    result = me.parseStatus(xhr.status);
    if (result.success) 
    {
      result.success = xhr.readyState === 4;
    }
  }  catch (e) {
  result = {success: false, isException: false};
}
  success = me.isXdr ? xdrResult : result.success;
  if (success) 
  {
    response = me.createResponse(request);
    me.fireEvent('requestcomplete', me, response, options);
    Ext.callback(options.success, options.scope, [response, options]);
  } else {
    if (result.isException || request.aborted || request.timedout) 
    {
      response = me.createException(request);
    } else {
      response = me.createResponse(request);
    }
    me.fireEvent('requestexception', me, response, options);
    Ext.callback(options.failure, options.scope, [response, options]);
  }
  Ext.callback(options.callback, options.scope, [options, success, response]);
  delete me.requests[request.id];
  return response;
}, parseStatus: function(status) {
  status = status == 1223 ? 204 : status;
  var success = (status >= 200 && status < 300) || status == 304, isException = false;
  if (!success) 
  {
    switch (status) {
      case 12002:
      case 12029:
      case 12030:
      case 12031:
      case 12152:
      case 13030:
        isException = true;
        break;
    }
  }
  return {success: success, isException: isException};
}, createResponse: function(request) {
  var me = this, xhr = request.xhr, isXdr = me.isXdr, headers = {}, lines = isXdr ? [] : xhr.getAllResponseHeaders().replace(/\r\n/g, '\n').split('\n'), count = lines.length, line, index, key, response, byteArray;
  while (count--) 
    {
      line = lines[count];
      index = line.indexOf(':');
      if (index >= 0) 
      {
        key = line.substr(0, index).toLowerCase();
        if (line.charAt(index + 1) == ' ') 
        {
          ++index;
        }
        headers[key] = line.substr(index + 1);
      }
    }
  request.xhr = null;
  delete request.xhr;
  response = {request: request, requestId: request.id, status: xhr.status, statusText: xhr.statusText, getResponseHeader: function(header) {
  return headers[header.toLowerCase()];
}, getAllResponseHeaders: function() {
  return headers;
}};
  if (isXdr) 
  {
    me.processXdrResponse(response, xhr);
  }
  if (request.binary) 
  {
    response.responseBytes = me.getByteArray(xhr);
  } else {
    response.responseText = xhr.responseText;
    response.responseXML = xhr.responseXML;
  }
  xhr = null;
  return response;
}, createException: function(request) {
  return {request: request, requestId: request.id, status: request.aborted ? -1 : 0, statusText: request.aborted ? 'transaction aborted' : 'communication failure', aborted: request.aborted, timedout: request.timedout};
}, getByteArray: function(xhr) {
  var response = xhr.response, responseBody = xhr.responseBody, byteArray, responseText, len, i;
  if (xhr instanceof Ext.data.flash.BinaryXhr) 
  {
    byteArray = xhr.responseBytes;
  } else if (window.Uint8Array) 
  {
    byteArray = response ? new Uint8Array(response) : [];
  } else if (Ext.isIE9p) 
  {
    try {
      byteArray = new VBArray(responseBody).toArray();
    }    catch (e) {
  byteArray = [];
}
  } else if (Ext.isIE) 
  {
    if (!this.self.vbScriptInjected) 
    {
      this.injectVBScript();
    }
    getIEByteArray(xhr.responseBody, byteArray = []);
  } else {
    byteArray = [];
    responseText = xhr.responseText;
    len = responseText.length;
    for (i = 0; i < len; i++) 
      {
        byteArray.push(responseText.charCodeAt(i) & 255);
      }
  }
  return byteArray;
}, injectVBScript: function() {
  var scriptTag = document.createElement('script');
  scriptTag.type = 'text/vbscript';
  scriptTag.text = ['Function getIEByteArray(byteArray, out)', 'Dim len, i', 'len = LenB(byteArray)', 'For i = 1 to len', 'out.push(AscB(MidB(byteArray, i, 1)))', 'Next', 'End Function'].join('\n');
  Ext.getHead().dom.appendChild(scriptTag);
  this.self.vbScriptInjected = true;
}, nativeBinaryPostSupport: function() {
  return Ext.isChrome || (Ext.isSafari && Ext.isDefined(window.Uint8Array)) || (Ext.isGecko && Ext.isDefined(window.Uint8Array));
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.data, 'Connection'], 0));
;

(Ext.cmd.derive('Ext.Ajax', Ext.data.Connection, {singleton: true, autoAbort: false}, 0, 0, 0, 0, 0, 0, [Ext, 'Ajax'], 0));
;

(Ext.cmd.derive('Ext.util.Floating', Ext.Base, {focusOnToFront: true, shadow: 'sides', constrain: false, constructor: function(dom) {
  var me = this;
  me.fixed = me.fixed && !(Ext.isIE6 || Ext.isIEQuirks);
  me.el = new Ext.dom.Layer(Ext.apply({preventSync: true, hideMode: me.hideMode, shadow: (typeof me.shadow != 'undefined') ? me.shadow : 'sides', shadowOffset: me.shadowOffset, constrain: false, fixed: me.fixed, shim: (me.shim === false) ? false : undefined}, me.floating), dom);
  if (me.modal && !(Ext.enableFocusManager)) 
  {
    me.mon(me.el, {keydown: me.onKeyDown, scope: me});
  }
  me.mon(me.el, {mousedown: me.onMouseDown, scope: me});
  me.floating = true;
  me.registerWithOwnerCt();
  me.initHierarchyEvents();
}, initFloatConstrain: function() {
  var me = this, floatParent = me.floatParent;
  if ((me.constrain || me.constrainHeader) && !me.constrainTo) 
  {
    me.constrainTo = floatParent ? floatParent.getTargetEl() : me.container;
  }
}, initHierarchyEvents: function() {
  var me = this, syncHidden = this.syncHidden;
  if (!me.hasHierarchyEventListeners) 
  {
    me.mon(me.hierarchyEventSource, {hide: syncHidden, collapse: syncHidden, show: syncHidden, expand: syncHidden, added: syncHidden, scope: me});
    me.hasHierarchyEventListeners = true;
  }
}, registerWithOwnerCt: function() {
  var me = this, ownerCt = me.ownerCt, zip = me.zIndexParent;
  if (zip) 
  {
    zip.unregisterFloatingItem(me);
  }
  zip = me.zIndexParent = me.up('[floating]');
  me.floatParent = ownerCt || zip;
  me.initFloatConstrain();
  delete me.ownerCt;
  if (zip) 
  {
    zip.registerFloatingItem(me);
  } else {
    Ext.WindowManager.register(me);
  }
}, onKeyDown: function(e) {
  var me = this, shift, focusables, first, last;
  if (e.getKey() == Ext.EventObject.TAB) 
  {
    shift = e.shiftKey;
    focusables = me.el.query(':focusable');
    first = focusables[0];
    last = focusables[focusables.length - 1];
    if (first && last && e.target === (shift ? first : last)) 
    {
      e.stopEvent();
      (shift ? last : first).focus(false, true);
    }
  }
}, onMouseDown: function(e) {
  var focusTask = this.focusTask;
  if (this.floating && (!focusTask || !focusTask.id)) 
  {
    this.toFront(!!e.getTarget(':focusable'));
  }
}, syncShadow: function() {
  if (this.floating) 
  {
    this.el.sync(true);
  }
}, onBeforeFloatLayout: function() {
  this.el.preventSync = true;
}, onAfterFloatLayout: function() {
  delete this.el.preventSync;
  this.syncShadow();
}, syncHidden: function() {
  var me = this, hidden = me.hidden || !me.rendered, hierarchicallyHidden = me.hierarchicallyHidden = me.isHierarchicallyHidden(), pendingShow = me.pendingShow;
  if (hidden !== hierarchicallyHidden) 
  {
    if (hierarchicallyHidden) 
    {
      me.hide();
      me.pendingShow = true;
    } else if (pendingShow) 
    {
      delete me.pendingShow;
      if (pendingShow.length) 
      {
        me.show.apply(me, pendingShow);
      } else {
        me.show();
      }
    }
  }
}, setZIndex: function(index) {
  var me = this;
  me.el.setZIndex(index);
  index += 10;
  if (me.floatingDescendants) 
  {
    index = Math.floor(me.floatingDescendants.setBase(index) / 100) * 100 + 10000;
  }
  return index;
}, doConstrain: function(constrainTo) {
  var me = this, xy = me.calculateConstrainedPosition(constrainTo, null, true);
  if (xy) 
  {
    me.setPosition(xy);
  }
}, toFront: function(preventFocus) {
  var me = this, zip = me.zIndexParent, preventFocusSetting = me.preventFocusOnActivate;
  if (zip && me.bringParentToFront !== false) 
  {
    zip.toFront(true);
  }
  if (!Ext.isDefined(preventFocus)) 
  {
    preventFocus = !me.focusOnToFront;
  }
  if (preventFocus) 
  {
    me.preventFocusOnActivate = true;
  }
  if (me.zIndexManager.bringToFront(me, preventFocus)) 
  {
    if (!preventFocus) 
    {
      me.focus(false, true);
    }
    if (me.hasListeners.tofront) 
    {
      me.fireEvent('tofront', me, me.el.getZIndex());
    }
  }
  me.preventFocusOnActivate = preventFocusSetting;
  return me;
}, setActive: function(active, newActive) {
  var me = this;
  if (active) 
  {
    if (me.el.shadow && !me.maximized) 
    {
      me.el.enableShadow(true);
    }
    if (!me.preventFocusOnActivate) 
    {
      me.focus(false, true);
    }
    me.fireEvent('activate', me);
  } else {
    if (me.isWindow && (newActive && newActive.isWindow) && me.hideShadowOnDeactivate) 
    {
      me.el.disableShadow();
    }
    me.fireEvent('deactivate', me);
  }
}, toBack: function() {
  this.zIndexManager.sendToBack(this);
  return this;
}, center: function() {
  var me = this, xy;
  if (me.isVisible()) 
  {
    xy = me.getAlignToXY(me.container, 'c-c');
    me.setPagePosition(xy);
  } else {
    me.needsCenter = true;
  }
  return me;
}, onFloatShow: function() {
  if (this.needsCenter) 
  {
    this.center();
  }
  delete this.needsCenter;
  if (this.toFrontOnShow) 
  {
    this.toFront();
  }
}, fitContainer: function(animate) {
  var me = this, parent = me.floatParent, container = parent ? parent.getTargetEl() : me.container, newBox = container.getViewSize(false), newPosition = parent || (container.dom !== document.body) ? [0, 0] : container.getXY();
  newBox.x = newPosition[0];
  newBox.y = newPosition[1];
  me.setBox(newBox, animate);
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Floating'], 0));
;

(Ext.cmd.derive('Ext.Component', Ext.AbstractComponent, {statics: {DIRECTION_TOP: 'top', DIRECTION_RIGHT: 'right', DIRECTION_BOTTOM: 'bottom', DIRECTION_LEFT: 'left', VERTICAL_DIRECTION_Re: /^(?:top|bottom)$/, INVALID_ID_CHARS_Re: /[\.,\s]/g}, resizeHandles: 'all', floating: false, defaultAlign: 'c-c', alignTarget: null, toFrontOnShow: true, hideMode: 'display', offsetsCls: Ext.baseCSSPrefix + 'hide-offsets', bubbleEvents: [], defaultComponentLayoutType: 'autocomponent', constructor: function(config) {
  var me = this;
  config = config || {};
  if (config.initialConfig) 
  {
    if (config.isAction) 
    {
      me.baseAction = config;
    }
    config = config.initialConfig;
  } else if (config.tagName || config.dom || Ext.isString(config)) 
  {
    config = {applyTo: config, id: config.id || config};
  }
  me.callParent([config]);
  if (me.baseAction) 
  {
    me.baseAction.addComponent(me);
  }
}, initComponent: function() {
  var me = this;
  me.callParent();
  if (me.listeners) 
  {
    me.on(me.listeners);
    me.listeners = null;
  }
  me.enableBubble(me.bubbleEvents);
}, afterRender: function() {
  var me = this;
  me.callParent();
  if (!(me.x && me.y) && (me.pageX || me.pageY)) 
  {
    me.setPagePosition(me.pageX, me.pageY);
  }
}, setAutoScroll: function(scroll) {
  var me = this;
  me.autoScroll = !!scroll;
  if (me.rendered) 
  {
    me.getOverflowEl().setStyle(me.getOverflowStyle());
  }
  me.updateLayout();
  return me;
}, setOverflowXY: function(overflowX, overflowY) {
  var me = this, argCount = arguments.length, ownerCt = me.ownerCt;
  if (argCount) 
  {
    me.overflowX = overflowX || '';
    if (argCount > 1) 
    {
      me.overflowY = overflowY || '';
    }
  }
  if (me.rendered) 
  {
    me.getOverflowEl().setStyle(me.getOverflowStyle());
  }
  (ownerCt || me).updateLayout();
  return me;
}, beforeRender: function() {
  var me = this, floating = me.floating, cls;
  if (floating) 
  {
    me.addCls(Ext.baseCSSPrefix + 'layer');
    cls = floating.cls;
    if (cls) 
    {
      me.addCls(cls);
    }
  }
  return me.callParent();
}, beforeLayout: function() {
  this.callParent(arguments);
  if (this.floating) 
  {
    this.onBeforeFloatLayout();
  }
}, afterComponentLayout: function() {
  this.callParent(arguments);
  if (this.floating) 
  {
    this.onAfterFloatLayout();
  }
}, makeFloating: function(dom) {
  this.mixins.floating.constructor.call(this, dom);
}, wrapPrimaryEl: function(dom) {
  if (this.floating) 
  {
    this.makeFloating(dom);
  } else {
    this.callParent(arguments);
  }
}, initResizable: function(resizable) {
  var me = this;
  resizable = Ext.apply({target: me, dynamic: false, constrainTo: me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : null), handles: me.resizeHandles}, resizable);
  resizable.target = me;
  me.resizer = new Ext.resizer.Resizer(resizable);
}, getDragEl: function() {
  return this.el;
}, initDraggable: function() {
  var me = this, dragTarget = (me.resizer && me.resizer.el !== me.el) ? me.resizerComponent = new Ext.Component({ariaRole: 'presentation', el: me.resizer.el, rendered: true, container: me.container}) : me, ddConfig = Ext.applyIf({el: dragTarget.getDragEl(), constrainTo: (me.constrain || me.draggable.constrain) ? (me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : me.container)) : undefined}, me.draggable);
  if (me.constrain || me.constrainDelegate) 
  {
    ddConfig.constrain = me.constrain;
    ddConfig.constrainDelegate = me.constrainDelegate;
  }
  me.dd = new Ext.util.ComponentDragger(dragTarget, ddConfig);
}, scrollBy: function(deltaX, deltaY, animate) {
  var el;
  if ((el = this.getTargetEl()) && el.dom) 
  {
    el.scrollBy.apply(el, arguments);
  }
}, setLoading: function(load, targetEl) {
  var me = this, config = {target: me};
  if (me.rendered) 
  {
    if (load !== false) 
    {
      if (Ext.isString(load)) 
      {
        config.msg = load;
      } else {
        Ext.apply(config, load);
      }
      if (!me.loadMask || !me.loadMask.isLoadMask) 
      {
        if (targetEl && config.useTargetEl == null) 
        {
          config.useTargetEl = true;
        }
        me.loadMask = new Ext.LoadMask(config);
      } else {
        Ext.apply(me.loadMask, config);
      }
      if (me.loadMask.isVisible()) 
      {
        me.loadMask.afterShow();
      } else {
        me.loadMask.show();
      }
    } else {
      if (me.loadMask && me.loadMask.isLoadMask) 
      {
        me.loadMask.hide();
      }
    }
  }
  return me.loadMask;
}, beforeSetPosition: function() {
  var me = this, pos = me.callParent(arguments), adj;
  if (pos) 
  {
    adj = me.adjustPosition(pos.x, pos.y);
    pos.x = adj.x;
    pos.y = adj.y;
  }
  return pos || null;
}, afterSetPosition: function(ax, ay) {
  this.onPosition(ax, ay);
  this.fireEvent('move', this, ax, ay);
}, showAt: function(x, y, animate) {
  var me = this;
  if (!me.rendered && (me.autoRender || me.floating)) 
  {
    me.x = x;
    me.y = y;
    return me.show();
  }
  if (me.floating) 
  {
    me.setPosition(x, y, animate);
  } else {
    me.setPagePosition(x, y, animate);
  }
  me.show();
}, showBy: function(cmp, pos, off) {
  var me = this;
  if (me.floating && cmp) 
  {
    me.alignTarget = cmp;
    if (pos) 
    {
      me.defaultAlign = pos;
    }
    if (off) 
    {
      me.alignOffset = off;
    }
    me.show();
    if (!me.hidden) 
    {
      me.alignTo(cmp, pos || me.defaultAlign, off || me.alignOffset);
    }
  }
  return me;
}, setPagePosition: function(x, y, animate) {
  var me = this, p, floatParentBox;
  if (Ext.isArray(x)) 
  {
    y = x[1];
    x = x[0];
  }
  me.pageX = x;
  me.pageY = y;
  if (me.floating) 
  {
    if (me.isContainedFloater()) 
    {
      floatParentBox = me.floatParent.getTargetEl().getViewRegion();
      if (Ext.isNumber(x) && Ext.isNumber(floatParentBox.left)) 
      {
        x -= floatParentBox.left;
      }
      if (Ext.isNumber(y) && Ext.isNumber(floatParentBox.top)) 
      {
        y -= floatParentBox.top;
      }
    } else {
      p = me.el.translateXY(x, y);
      x = p.x;
      y = p.y;
    }
    me.setPosition(x, y, animate);
  } else {
    p = me.el.translateXY(x, y);
    me.setPosition(p.x, p.y, animate);
  }
  return me;
}, isContainedFloater: function() {
  return (this.floating && this.floatParent);
}, updateBox: function(box) {
  this.setSize(box.width, box.height);
  this.setPagePosition(box.x, box.y);
  return this;
}, getOuterSize: function() {
  var el = this.el;
  return {width: el.getWidth() + el.getMargin('lr'), height: el.getHeight() + el.getMargin('tb')};
}, adjustPosition: function(x, y) {
  var me = this, floatParentBox;
  if (me.isContainedFloater()) 
  {
    floatParentBox = me.floatParent.getTargetEl().getViewRegion();
    x += floatParentBox.left;
    y += floatParentBox.top;
  }
  return {x: x, y: y};
}, getPosition: function(local) {
  var me = this, xy, isContainedFloater = me.isContainedFloater(), floatParentBox;
  if ((local === true) && !isContainedFloater) 
  {
    return [me.getLocalX(), me.getLocalY()];
  }
  xy = me.getXY();
  if ((local === true) && isContainedFloater) 
  {
    floatParentBox = me.floatParent.getTargetEl().getViewRegion();
    xy[0] -= floatParentBox.left;
    xy[1] -= floatParentBox.top;
  }
  return xy;
}, getId: function() {
  var me = this, xtype;
  if (!me.id) 
  {
    xtype = me.getXType();
    if (xtype) 
    {
      xtype = xtype.replace(Ext.Component.INVALID_ID_CHARS_Re, '-');
    } else {
      xtype = Ext.name.toLowerCase() + '-comp';
    }
    me.id = xtype + '-' + me.getAutoId();
  }
  return me.id;
}, show: function(animateTarget, cb, scope) {
  var me = this, rendered = me.rendered;
  if (me.hierarchicallyHidden || (me.floating && !rendered && me.isHierarchicallyHidden())) 
  {
    if (!rendered) 
    {
      me.initHierarchyEvents();
    }
    if (arguments.length > 1) 
    {
      arguments[0] = null;
      me.pendingShow = arguments;
    } else {
      me.pendingShow = true;
    }
  } else if (rendered && me.isVisible()) 
  {
    if (me.floating) 
    {
      me.onFloatShow();
    }
  } else {
    if (me.fireEvent('beforeshow', me) !== false) 
    {
      me.hidden = false;
      delete this.getHierarchyState().hidden;
      Ext.suspendLayouts();
      if (!rendered && (me.autoRender || me.floating)) 
      {
        me.doAutoRender();
        rendered = me.rendered;
      }
      if (rendered) 
      {
        me.beforeShow();
        Ext.resumeLayouts();
        me.onShow.apply(me, arguments);
        me.afterShow.apply(me, arguments);
      } else {
        Ext.resumeLayouts(true);
      }
    } else {
      me.onShowVeto();
    }
  }
  return me;
}, onShowVeto: Ext.emptyFn, beforeShow: Ext.emptyFn, onShow: function() {
  var me = this;
  me.el.show();
  me.callParent(arguments);
  if (me.floating) 
  {
    if (me.maximized) 
    {
      me.fitContainer();
    } else if (me.constrain) 
    {
      me.doConstrain();
    }
  }
}, getAnimateTarget: function(target) {
  target = target || this.animateTarget;
  if (target) 
  {
    target = target.isComponent ? target.getEl() : Ext.get(target);
  }
  return target || null;
}, afterShow: function(animateTarget, cb, scope) {
  var me = this, myEl = me.el, fromBox, toBox, ghostPanel;
  animateTarget = me.getAnimateTarget(animateTarget);
  if (!me.ghost) 
  {
    animateTarget = null;
  }
  if (animateTarget) 
  {
    toBox = {x: myEl.getX(), y: myEl.getY(), width: myEl.dom.offsetWidth, height: myEl.dom.offsetHeight};
    fromBox = {x: animateTarget.getX(), y: animateTarget.getY(), width: animateTarget.dom.offsetWidth, height: animateTarget.dom.offsetHeight};
    myEl.addCls(me.offsetsCls);
    ghostPanel = me.ghost();
    ghostPanel.el.stopAnimation();
    ghostPanel.setX(-10000);
    me.ghostBox = toBox;
    ghostPanel.el.animate({from: fromBox, to: toBox, listeners: {afteranimate: function() {
  delete ghostPanel.componentLayout.lastComponentSize;
  me.unghost();
  delete me.ghostBox;
  myEl.removeCls(me.offsetsCls);
  me.onShowComplete(cb, scope);
}}});
  } else {
    me.onShowComplete(cb, scope);
  }
  me.fireHierarchyEvent('show');
}, onShowComplete: function(cb, scope) {
  var me = this;
  if (me.floating) 
  {
    me.onFloatShow();
  }
  Ext.callback(cb, scope || me);
  me.fireEvent('show', me);
  delete me.hiddenByLayout;
}, hide: function(animateTarget, cb, scope) {
  var me = this, continueHide;
  if (me.pendingShow) 
  {
    delete me.pendingShow;
  }
  if (!(me.rendered && !me.isVisible())) 
  {
    continueHide = (me.fireEvent('beforehide', me) !== false);
    if (me.hierarchicallyHidden || continueHide) 
    {
      me.hidden = true;
      me.getHierarchyState().hidden = true;
      if (me.rendered) 
      {
        me.onHide.apply(me, arguments);
      }
    }
  }
  return me;
}, onHide: function(animateTarget, cb, scope) {
  var me = this, ghostPanel, fromSize, toBox, activeEl = Ext.Element.getActiveElement();
  if (activeEl === me.el || me.el.contains(activeEl)) 
  {
    Ext.fly(activeEl).blur();
  }
  animateTarget = me.getAnimateTarget(animateTarget);
  if (!me.ghost) 
  {
    animateTarget = null;
  }
  if (animateTarget) 
  {
    toBox = {x: animateTarget.getX(), y: animateTarget.getY(), width: animateTarget.dom.offsetWidth, height: animateTarget.dom.offsetHeight};
    ghostPanel = me.ghost();
    ghostPanel.el.stopAnimation();
    fromSize = me.getSize();
    ghostPanel.el.animate({to: toBox, listeners: {afteranimate: function() {
  delete ghostPanel.componentLayout.lastComponentSize;
  ghostPanel.el.hide();
  ghostPanel.setHiddenState(true);
  ghostPanel.el.setSize(fromSize);
  me.afterHide(cb, scope);
}}});
  }
  me.el.hide();
  if (!animateTarget) 
  {
    me.afterHide(cb, scope);
  }
}, afterHide: function(cb, scope) {
  var me = this;
  me.hiddenByLayout = null;
  Ext.AbstractComponent.prototype.onHide.call(me);
  Ext.callback(cb, scope || me);
  me.fireEvent('hide', me);
  me.fireHierarchyEvent('hide');
}, onDestroy: function() {
  var me = this;
  if (me.rendered) 
  {
    Ext.destroy(me.dd, me.resizer, me.proxy, me.proxyWrap, me.resizerComponent, me.loadMask);
  }
  delete me.focusTask;
  me.callParent();
}, deleteMembers: function() {
  var args = arguments, len = args.length, i = 0;
  for (; i < len; ++i) 
    {
      delete this[args[i]];
    }
}, focus: function(selectText, delay, callback, scope) {
  var me = this, focusEl, focusElDom, containerScrollTop;
  if (delay) 
  {
    me.getFocusTask().delay(Ext.isNumber(delay) ? delay : 10, me.focus, me, [selectText, false, callback, scope]);
    return me;
  }
  if (me.focusTask) 
  {
    me.focusTask.cancel();
  }
  if (me.rendered && !me.isDestroyed && me.isVisible(true) && (focusEl = me.getFocusEl())) 
  {
    if (focusEl.isComponent) 
    {
      return focusEl.focus(selectText, delay);
    }
    if ((focusElDom = focusEl.dom)) 
    {
      if (focusEl.needsTabIndex()) 
      {
        focusElDom.tabIndex = -1;
      }
      if (me.floating) 
      {
        containerScrollTop = me.container.dom.scrollTop;
      }
      focusEl.focus();
      if (selectText) 
      {
        if (Ext.isArray(selectText)) 
        {
          if (me.selectText) 
          {
            me.selectText.apply(me, selectText);
          }
        } else {
          focusElDom.select();
        }
      }
      Ext.callback(callback, scope);
    }
    if (me.floating) 
    {
      if (me !== me.zIndexManager.getActive()) 
      {
        me.toFront(true);
      }
      if (containerScrollTop !== undefined) 
      {
        me.container.dom.scrollTop = containerScrollTop;
      }
    }
  }
  return me;
}, getFocusTask: function() {
  if (!this.focusTask) 
  {
    Ext.Component.prototype.focusTask = new Ext.util.DelayedTask();
  }
  return this.focusTask;
}, cancelFocus: function() {
  var task = this.focusTask;
  if (task) 
  {
    task.cancel();
  }
}, blur: function() {
  var me = this, focusEl;
  if (me.rendered && (focusEl = me.getFocusEl())) 
  {
    me.blurring = true;
    focusEl.blur();
    delete me.blurring;
  }
  return me;
}, getEl: function() {
  return this.el;
}, getResizeEl: function() {
  return this.el;
}, getPositionEl: function() {
  return this.el;
}, getActionEl: function() {
  return this.el;
}, getVisibilityEl: function() {
  return this.el;
}, getRefOwner: function() {
  return this.ownerCt || this.ownerCmp || this.floatParent;
}, getBubbleTarget: function() {
  return this.getRefOwner();
}, getContentTarget: function() {
  return this.el;
}, cloneConfig: function(overrides) {
  overrides = overrides || {};
  var id = overrides.id || Ext.id(), cfg = Ext.applyIf(overrides, this.initialConfig), self;
  cfg.id = id;
  self = Ext.getClass(this);
  return new self(cfg);
}, getXType: function() {
  return this.self.xtype;
}, findParentBy: function(fn) {
  var p;
  for (p = this.getBubbleTarget(); p && !fn(p, this); p = p.getBubbleTarget()) 
    {
    }
  return p || null;
}, findParentByType: function(xtype) {
  return Ext.isFunction(xtype) ? this.findParentBy(function(p) {
  return p.constructor === xtype;
}) : this.up(xtype);
}, bubble: function(fn, scope, args) {
  var p = this;
  while (p) 
    {
      if (fn.apply(scope || p, args || [p]) === false) 
      {
        break;
      }
      p = p.getBubbleTarget();
    }
  return this;
}, getProxy: function() {
  var me = this, target;
  if (!me.proxy) 
  {
    target = Ext.getBody();
    me.proxy = me.el.createProxy(Ext.baseCSSPrefix + 'proxy-el', target, true);
  }
  return me.proxy;
}, fireHierarchyEvent: function(ename) {
  this.hierarchyEventSource.fireEvent(ename, this);
}, onAdded: function() {
  this.callParent(arguments);
  if (this.hierarchyEventSource.hasListeners.added) 
  {
    this.fireHierarchyEvent('added');
  }
}}, 1, ["component", "box"], ["component", "box"], {"component": true, "box": true}, ["widget.box", "widget.component"], [['floating', Ext.util.Floating]], [Ext, 'Component'], function() {
  this.hierarchyEventSource = this.prototype.hierarchyEventSource = new Ext.util.Observable({events: {hide: true, show: true, collapse: true, expand: true, added: true}});
}));
;

Ext.define('Ext.layout.container.border.Region', {override: 'Ext.Component', initBorderRegion: function() {
  var me = this;
  if (!me._borderRegionInited) 
  {
    me._borderRegionInited = true;
    me.addStateEvents(['changeregion', 'changeweight']);
    Ext.override(me, {getState: function() {
  var state = me.callParent();
  state = me.addPropertyToState(state, 'region');
  state = me.addPropertyToState(state, 'weight');
  return state;
}});
  }
}, getOwningBorderContainer: function() {
  var layout = this.getOwningBorderLayout();
  return layout && layout.owner;
}, getOwningBorderLayout: function() {
  var layout = this.ownerLayout;
  return (layout && layout.isBorderLayout) ? layout : null;
}, setBorderRegion: function(region) {
  var me = this, borderLayout, old = me.region;
  if (region !== old) 
  {
    borderLayout = me.getOwningBorderLayout();
    if (borderLayout) 
    {
      var regionFlags = borderLayout.regionFlags[region], placeholder = me.placeholder, splitter = me.splitter, owner = borderLayout.owner, regionMeta = borderLayout.regionMeta, collapsed = me.collapsed || me.floated, delta, items, index;
      if (me.fireEventArgs('beforechangeregion', [me, region]) === false) 
      {
        return old;
      }
      Ext.suspendLayouts();
      me.region = region;
      Ext.apply(me, regionFlags);
      if (me.updateCollapseTool) 
      {
        me.updateCollapseTool();
      }
      if (splitter) 
      {
        Ext.apply(splitter, regionFlags);
        splitter.updateOrientation();
        items = owner.items;
        index = items.indexOf(me);
        if (index >= 0) 
        {
          delta = regionMeta[region].splitterDelta;
          if (items.getAt(index + delta) !== splitter) 
          {
            items.remove(splitter);
            index = items.indexOf(me);
            if (delta > 0) 
            {
              ++index;
            }
            items.insert(index, splitter);
          }
        }
      }
      if (placeholder) 
      {
        if (collapsed) 
        {
          me.expand(false);
        }
        owner.remove(placeholder);
        me.placeholder = null;
        if (collapsed) 
        {
          me.collapse(null, false);
        }
      }
      owner.updateLayout();
      Ext.resumeLayouts(true);
      me.fireEventArgs('changeregion', [me, old]);
    } else {
      me.region = region;
    }
  }
  return old;
}, setRegionWeight: function(weight) {
  var me = this, ownerCt = me.getOwningBorderContainer(), placeholder = me.placeholder, old = me.weight;
  if (weight !== old) 
  {
    if (me.fireEventArgs('beforechangeweight', [me, weight]) !== false) 
    {
      me.weight = weight;
      if (placeholder) 
      {
        placeholder.weight = weight;
      }
      if (ownerCt) 
      {
        ownerCt.updateLayout();
      }
      me.fireEventArgs('changeweight', [me, old]);
    }
  }
  return old;
}});

(Ext.cmd.derive('Ext.ElementLoader', Ext.Base, {statics: {Renderer: {Html: function(loader, response, active) {
  loader.getTarget().update(response.responseText, active.scripts === true);
  return true;
}}}, url: null, params: null, baseParams: null, autoLoad: false, target: null, loadMask: false, ajaxOptions: null, scripts: false, isLoader: true, constructor: function(config) {
  var me = this, autoLoad;
  config = config || {};
  Ext.apply(me, config);
  me.setTarget(me.target);
  me.addEvents('beforeload', 'exception', 'load');
  me.mixins.observable.constructor.call(me);
  if (me.autoLoad) 
  {
    autoLoad = me.autoLoad;
    if (autoLoad === true) 
    {
      autoLoad = {};
    }
    me.load(autoLoad);
  }
}, setTarget: function(target) {
  var me = this;
  target = Ext.get(target);
  if (me.target && me.target != target) 
  {
    me.abort();
  }
  me.target = target;
}, getTarget: function() {
  return this.target || null;
}, abort: function() {
  var active = this.active;
  if (active !== undefined) 
  {
    Ext.Ajax.abort(active.request);
    if (active.mask) 
    {
      this.removeMask();
    }
    delete this.active;
  }
}, removeMask: function() {
  this.target.unmask();
}, addMask: function(mask) {
  this.target.mask(mask === true ? null : mask);
}, load: function(options) {
  options = Ext.apply({}, options);
  var me = this, mask = Ext.isDefined(options.loadMask) ? options.loadMask : me.loadMask, params = Ext.apply({}, options.params), ajaxOptions = Ext.apply({}, options.ajaxOptions), callback = options.callback || me.callback, scope = options.scope || me.scope || me;
  Ext.applyIf(ajaxOptions, me.ajaxOptions);
  Ext.applyIf(options, ajaxOptions);
  Ext.applyIf(params, me.params);
  Ext.apply(params, me.baseParams);
  Ext.applyIf(options, {url: me.url});
  Ext.apply(options, {scope: me, params: params, callback: me.onComplete});
  if (me.fireEvent('beforeload', me, options) === false) 
  {
    return;
  }
  if (mask) 
  {
    me.addMask(mask);
  }
  me.active = {options: options, mask: mask, scope: scope, callback: callback, success: options.success || me.success, failure: options.failure || me.failure, renderer: options.renderer || me.renderer, scripts: Ext.isDefined(options.scripts) ? options.scripts : me.scripts};
  me.active.request = Ext.Ajax.request(options);
  me.setOptions(me.active, options);
}, setOptions: Ext.emptyFn, onComplete: function(options, success, response) {
  var me = this, active = me.active, scope;
  if (active) 
  {
    scope = active.scope;
    if (success) 
    {
      success = me.getRenderer(active.renderer).call(me, me, response, active) !== false;
    }
    if (success) 
    {
      Ext.callback(active.success, scope, [me, response, options]);
      me.fireEvent('load', me, response, options);
    } else {
      Ext.callback(active.failure, scope, [me, response, options]);
      me.fireEvent('exception', me, response, options);
    }
    Ext.callback(active.callback, scope, [me, success, response, options]);
    if (active.mask) 
    {
      me.removeMask();
    }
  }
  delete me.active;
}, getRenderer: function(renderer) {
  if (Ext.isFunction(renderer)) 
  {
    return renderer;
  }
  return this.statics().Renderer.Html;
}, startAutoRefresh: function(interval, options) {
  var me = this;
  me.stopAutoRefresh();
  me.autoRefresh = setInterval(function() {
  me.load(options);
}, interval);
}, stopAutoRefresh: function() {
  clearInterval(this.autoRefresh);
  delete this.autoRefresh;
}, isAutoRefreshing: function() {
  return Ext.isDefined(this.autoRefresh);
}, destroy: function() {
  var me = this;
  me.stopAutoRefresh();
  delete me.target;
  me.abort();
  me.clearListeners();
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext, 'ElementLoader'], 0));
;

(Ext.cmd.derive('Ext.ComponentLoader', Ext.ElementLoader, {statics: {Renderer: {Data: function(loader, response, active) {
  var success = true;
  try {
    loader.getTarget().update(Ext.decode(response.responseText));
  }  catch (e) {
  success = false;
}
  return success;
}, Component: function(loader, response, active) {
  var success = true, target = loader.getTarget(), items = [];
  try {
    items = Ext.decode(response.responseText);
  }  catch (e) {
  success = false;
}
  if (success) 
  {
    target.suspendLayouts();
    if (active.removeAll) 
    {
      target.removeAll();
    }
    target.add(items);
    target.resumeLayouts(true);
  }
  return success;
}}}, target: null, loadMask: false, renderer: 'html', setTarget: function(target) {
  var me = this;
  if (Ext.isString(target)) 
  {
    target = Ext.getCmp(target);
  }
  if (me.target && me.target != target) 
  {
    me.abort();
  }
  me.target = target;
}, removeMask: function() {
  this.target.setLoading(false);
}, addMask: function(mask) {
  this.target.setLoading(mask);
}, setOptions: function(active, options) {
  active.removeAll = Ext.isDefined(options.removeAll) ? options.removeAll : this.removeAll;
}, getRenderer: function(renderer) {
  if (Ext.isFunction(renderer)) 
  {
    return renderer;
  }
  var renderers = this.statics().Renderer;
  switch (renderer) {
    case 'component':
      return renderers.Component;
    case 'data':
      return renderers.Data;
    default:
      return Ext.ElementLoader.Renderer.Html;
  }
}}, 0, 0, 0, 0, 0, 0, [Ext, 'ComponentLoader'], 0));
;

(Ext.cmd.derive('Ext.layout.SizeModel', Ext.Base, {constructor: function(config) {
  var me = this, SizeModel = me.self, sizeModelsArray = SizeModel.sizeModelsArray, name;
  Ext.apply(me, config);
  me[name = me.name] = true;
  me.fixed = !(me.auto = me.natural || me.shrinkWrap);
  sizeModelsArray[me.ordinal = sizeModelsArray.length] = SizeModel[name] = SizeModel.sizeModels[name] = me;
}, statics: {sizeModelsArray: [], sizeModels: {}}, calculated: false, configured: false, constrainedMax: false, constrainedMin: false, natural: false, shrinkWrap: false, calculatedFromConfigured: false, calculatedFromNatural: false, calculatedFromShrinkWrap: false, names: null}, 1, 0, 0, 0, 0, 0, [Ext.layout, 'SizeModel'], function() {
  var SizeModel = this, sizeModelsArray = SizeModel.sizeModelsArray, i, j, n, pairs, sizeModel;
  new SizeModel({name: 'calculated'});
  new SizeModel({name: 'configured', names: {width: 'width', height: 'height'}});
  new SizeModel({name: 'natural'});
  new SizeModel({name: 'shrinkWrap'});
  new SizeModel({name: 'calculatedFromConfigured', configured: true, names: {width: 'width', height: 'height'}});
  new SizeModel({name: 'calculatedFromNatural', natural: true});
  new SizeModel({name: 'calculatedFromShrinkWrap', shrinkWrap: true});
  new SizeModel({name: 'constrainedMax', configured: true, constrained: true, names: {width: 'maxWidth', height: 'maxHeight'}});
  new SizeModel({name: 'constrainedMin', configured: true, constrained: true, names: {width: 'minWidth', height: 'minHeight'}});
  new SizeModel({name: 'constrainedDock', configured: true, constrained: true, constrainedByMin: true, names: {width: 'dockConstrainedWidth', height: 'dockConstrainedHeight'}});
  for (i = 0 , n = sizeModelsArray.length; i < n; ++i) 
    {
      sizeModel = sizeModelsArray[i];
      sizeModel.pairsByHeightOrdinal = pairs = [];
      for (j = 0; j < n; ++j) 
        {
          pairs.push({width: sizeModel, height: sizeModelsArray[j]});
        }
    }
}));
;

(Ext.cmd.derive('Ext.layout.Layout', Ext.Base, {isLayout: true, initialized: false, running: false, autoSizePolicy: {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0}, statics: {layoutsByType: {}, create: function(layout, defaultType) {
  var ClassManager = Ext.ClassManager, layoutsByType = this.layoutsByType, alias, className, config, layoutClass, type, load;
  if (!layout || typeof layout === 'string') 
  {
    type = layout || defaultType;
    config = {};
  } else if (layout.isLayout) 
  {
    return layout;
  } else {
    config = layout;
    type = layout.type || defaultType;
  }
  if (!(layoutClass = layoutsByType[type])) 
  {
    alias = 'layout.' + type;
    className = ClassManager.getNameByAlias(alias);
    if (!className) 
    {
      load = true;
    }
    layoutClass = ClassManager.get(className);
    if (load || !layoutClass) 
    {
      return ClassManager.instantiateByAlias(alias, config || {});
    }
    layoutsByType[type] = layoutClass;
  }
  return new layoutClass(config);
}}, constructor: function(config) {
  var me = this;
  me.id = Ext.id(null, me.type + '-');
  Ext.apply(me, config);
  me.layoutCount = 0;
}, beginLayout: Ext.emptyFn, beginLayoutCycle: function(ownerContext) {
  var me = this, context = me.context, changed;
  if (me.lastWidthModel != ownerContext.widthModel) 
  {
    if (me.lastWidthModel) 
    {
      changed = true;
    }
    me.lastWidthModel = ownerContext.widthModel;
  }
  if (me.lastHeightModel != ownerContext.heightModel) 
  {
    if (me.lastWidthModel) 
    {
      changed = true;
    }
    me.lastHeightModel = ownerContext.heightModel;
  }
  if (changed) 
  {
    (context = ownerContext.context).clearTriggers(me, false);
    context.clearTriggers(me, true);
    me.triggerCount = 0;
  }
}, finishedLayout: function(ownerContext) {
  this.lastWidthModel = ownerContext.widthModel;
  this.lastHeightModel = ownerContext.heightModel;
  this.ownerContext = null;
}, redoLayout: Ext.emptyFn, undoLayout: Ext.emptyFn, getAnimatePolicy: function() {
  return this.animatePolicy;
}, getItemSizePolicy: function(item) {
  return this.autoSizePolicy;
}, isItemBoxParent: function(itemContext) {
  return false;
}, isItemLayoutRoot: function(item) {
  var sizeModel = item.getSizeModel(), width = sizeModel.width, height = sizeModel.height;
  if (!item.componentLayout.lastComponentSize && (width.calculated || height.calculated)) 
  {
    return false;
  }
  return !width.shrinkWrap && !height.shrinkWrap;
}, isItemShrinkWrap: function(item) {
  return item.shrinkWrap;
}, isRunning: function() {
  return !!this.ownerContext;
}, getItemsRenderTree: function(items, renderCfgs) {
  var length = items.length, i, item, itemConfig, result;
  if (length) 
  {
    result = [];
    for (i = 0; i < length; ++i) 
      {
        item = items[i];
        if (!item.rendered) 
        {
          if (renderCfgs && (renderCfgs[item.id] !== undefined)) 
          {
            itemConfig = renderCfgs[item.id];
          } else {
            this.configureItem(item);
            itemConfig = item.getRenderTree();
            if (renderCfgs) 
            {
              renderCfgs[item.id] = itemConfig;
            }
          }
          if (itemConfig) 
          {
            result.push(itemConfig);
          }
        }
      }
  }
  return result;
}, finishRender: Ext.emptyFn, finishRenderItems: function(target, items) {
  var length = items.length, i, item;
  for (i = 0; i < length; i++) 
    {
      item = items[i];
      if (item.rendering) 
      {
        item.finishRender(i);
        this.afterRenderItem(item);
      }
    }
}, renderChildren: function() {
  var me = this, items = me.getLayoutItems(), target = me.getRenderTarget();
  me.renderItems(items, target);
}, renderItems: function(items, target) {
  var me = this, ln = items.length, i = 0, item;
  if (ln) 
  {
    Ext.suspendLayouts();
    for (; i < ln; i++) 
      {
        item = items[i];
        if (item && !item.rendered) 
        {
          me.renderItem(item, target, i);
        } else if (!me.isValidParent(item, target, i)) 
        {
          me.moveItem(item, target, i);
        } else {
          me.configureItem(item);
        }
      }
    Ext.resumeLayouts(true);
  }
}, isValidParent: function(item, target, position) {
  var itemDom = item.el ? item.el.dom : Ext.getDom(item), targetDom = (target && target.dom) || target, parentNode = itemDom.parentNode, className;
  if (parentNode) 
  {
    className = parentNode.className;
    if (className && className.indexOf(Ext.baseCSSPrefix + 'resizable-wrap') !== -1) 
    {
      itemDom = itemDom.parentNode;
    }
  }
  if (itemDom && targetDom) 
  {
    if (typeof position == 'number') 
    {
      position = this.getPositionOffset(position);
      return itemDom === targetDom.childNodes[position];
    }
    return itemDom.parentNode === targetDom;
  }
  return false;
}, getPositionOffset: function(position) {
  return position;
}, configureItem: function(item) {
  item.ownerLayout = this;
}, renderItem: function(item, target, position) {
  var me = this;
  if (!item.rendered) 
  {
    me.configureItem(item);
    item.render(target, position);
    me.afterRenderItem(item);
  }
}, moveItem: function(item, target, position) {
  target = target.dom || target;
  if (typeof position == 'number') 
  {
    position = target.childNodes[position];
  }
  target.insertBefore(item.el.dom, position || null);
  item.container = Ext.get(target);
  this.configureItem(item);
}, onContentChange: function() {
  this.owner.updateLayout();
  return true;
}, initLayout: function() {
  this.initialized = true;
}, setOwner: function(owner) {
  this.owner = owner;
}, getLayoutItems: function() {
  return [];
}, onAdd: function(item) {
  item.ownerLayout = this;
}, afterRenderItem: Ext.emptyFn, onRemove: Ext.emptyFn, onDestroy: Ext.emptyFn, afterRemove: function(item) {
  var me = this, el = item.el, owner = me.owner, removeClasses;
  if (item.rendered) 
  {
    removeClasses = [].concat(me.itemCls || []);
    if (owner.itemCls) 
    {
      removeClasses = Ext.Array.push(removeClasses, owner.itemCls);
    }
    if (removeClasses.length) 
    {
      el.removeCls(removeClasses);
    }
  }
  delete item.ownerLayout;
}, destroy: function() {
  var me = this, target;
  if (me.targetCls) 
  {
    target = me.getTarget();
    if (target) 
    {
      target.removeCls(me.targetCls);
    }
  }
  me.onDestroy();
}, sortWeightedItems: function(items, reverseProp) {
  for (var i = 0, length = items.length; i < length; ++i) 
    {
      items[i].$i = i;
    }
  Ext.Array.sort(items, function(item1, item2) {
  var ret = item2.weight - item1.weight;
  if (!ret) 
  {
    ret = item1.$i - item2.$i;
    if (item1[reverseProp]) 
    {
      ret = -ret;
    }
  }
  return ret;
});
  for (i = 0; i < length; ++i) 
    {
      delete items[i].$i;
    }
}}, 1, 0, 0, 0, 0, 0, [Ext.layout, 'Layout'], function() {
  var Layout = this;
  Layout.prototype.sizeModels = Layout.sizeModels = Ext.layout.SizeModel.sizeModels;
}));
;

(Ext.cmd.derive('Ext.layout.container.Container', Ext.layout.Layout, {alternateClassName: 'Ext.layout.ContainerLayout', type: 'container', beginCollapse: Ext.emptyFn, beginExpand: Ext.emptyFn, animatePolicy: null, childEls: ['overflowPadderEl'], renderTpl: ['{%this.renderBody(out,values)%}'], usesContainerHeight: true, usesContainerWidth: true, usesHeight: true, usesWidth: true, constructor: function() {
  this.callParent(arguments);
  this.mixins.elementCt.constructor.call(this);
}, destroy: function() {
  this.callParent();
  this.mixins.elementCt.destroy.call(this);
}, beginLayout: function(ownerContext) {
  this.callParent(arguments);
  ownerContext.targetContext = ownerContext.paddingContext = ownerContext.getEl('getTarget', this);
  this.cacheChildItems(ownerContext);
}, beginLayoutCycle: function(ownerContext, firstCycle) {
  var me = this;
  me.callParent(arguments);
  if (firstCycle) 
  {
    if (me.usesContainerHeight) 
    {
      ++ownerContext.consumersContainerHeight;
    }
    if (me.usesContainerWidth) 
    {
      ++ownerContext.consumersContainerWidth;
    }
  }
}, cacheChildItems: function(ownerContext) {
  var context = ownerContext.context, childItems = [], items = this.getVisibleItems(), length = items.length, i;
  ownerContext.childItems = childItems;
  ownerContext.visibleItems = items;
  for (i = 0; i < length; ++i) 
    {
      childItems.push(context.getCmp(items[i]));
    }
}, cacheElements: function() {
  var owner = this.owner;
  this.applyChildEls(owner.el, owner.id);
}, configureItem: function(item) {
  var me = this, itemCls = me.itemCls, ownerItemCls = me.owner.itemCls, needsCopy, addClasses;
  item.ownerLayout = me;
  if (itemCls) 
  {
    if (typeof itemCls === 'string') 
    {
      addClasses = [itemCls];
    } else {
      addClasses = itemCls;
      needsCopy = !!addClasses;
    }
  }
  if (ownerItemCls) 
  {
    if (needsCopy) 
    {
      addClasses = Ext.Array.clone(addClasses);
    }
    addClasses = Ext.Array.push(addClasses || [], ownerItemCls);
  }
  if (addClasses) 
  {
    item.addCls(addClasses);
  }
}, doRenderBody: function(out, renderData) {
  this.renderItems(out, renderData);
  this.renderContent(out, renderData);
}, doRenderContainer: function(out, renderData) {
  var me = renderData.$comp.layout, tpl = me.getRenderTpl(), data = me.getRenderData();
  tpl.applyOut(data, out);
}, doRenderItems: function(out, renderData) {
  var me = renderData.$layout, tree = me.getRenderTree();
  if (tree) 
  {
    Ext.DomHelper.generateMarkup(tree, out);
  }
}, finishRender: function() {
  var me = this, target, items;
  me.callParent();
  me.cacheElements();
  target = me.getRenderTarget();
  items = me.getLayoutItems();
  me.finishRenderItems(target, items);
}, notifyOwner: function() {
  this.owner.afterLayout(this);
}, getContainerSize: function(ownerContext, inDom) {
  var targetContext = ownerContext.targetContext, frameInfo = targetContext.getFrameInfo(), padding = ownerContext.paddingContext.getPaddingInfo(), got = 0, needed = 0, gotWidth, gotHeight, width, height;
  if (!ownerContext.widthModel.shrinkWrap) 
  {
    ++needed;
    width = inDom ? targetContext.getDomProp('width') : targetContext.getProp('width');
    gotWidth = (typeof width == 'number');
    if (gotWidth) 
    {
      ++got;
      width -= frameInfo.width + padding.width;
      if (width < 0) 
      {
        width = 0;
      }
    }
  }
  if (!ownerContext.heightModel.shrinkWrap) 
  {
    ++needed;
    height = inDom ? targetContext.getDomProp('height') : targetContext.getProp('height');
    gotHeight = (typeof height == 'number');
    if (gotHeight) 
    {
      ++got;
      height -= frameInfo.height + padding.height;
      if (height < 0) 
      {
        height = 0;
      }
    }
  }
  return {width: width, height: height, needed: needed, got: got, gotAll: got == needed, gotWidth: gotWidth, gotHeight: gotHeight};
}, getPositionOffset: function(position) {
  if (!this.createsInnerCt) 
  {
    var offset = this.owner.itemNodeOffset;
    if (offset) 
    {
      position += offset;
    }
  }
  return position;
}, getLayoutItems: function() {
  var owner = this.owner, items = owner && owner.items;
  return (items && items.items) || [];
}, getRenderData: function() {
  var comp = this.owner;
  return {$comp: comp, $layout: this, ownerId: comp.id};
}, getRenderedItems: function() {
  var me = this, target = me.getRenderTarget(), items = me.getLayoutItems(), ln = items.length, renderedItems = [], i, item;
  for (i = 0; i < ln; i++) 
    {
      item = items[i];
      if (item.rendered && me.isValidParent(item, target, i)) 
      {
        renderedItems.push(item);
      }
    }
  return renderedItems;
}, getRenderTarget: function() {
  return this.owner.getTargetEl();
}, getElementTarget: function() {
  return this.getRenderTarget();
}, getRenderTpl: function() {
  var me = this, renderTpl = Ext.XTemplate.getTpl(this, 'renderTpl');
  if (!renderTpl.renderContent) 
  {
    me.owner.setupRenderTpl(renderTpl);
  }
  return renderTpl;
}, getRenderTree: function() {
  var result, items = this.owner.items, itemsGen, renderCfgs = {};
  do {
    itemsGen = items.generation;
    result = this.getItemsRenderTree(this.getLayoutItems(), renderCfgs);
  } while (items.generation !== itemsGen);
  return result;
}, renderChildren: function() {
  var me = this, ownerItems = me.owner.items, target = me.getRenderTarget(), itemsGen, items;
  do {
    itemsGen = ownerItems.generation;
    items = me.getLayoutItems();
    me.renderItems(items, target);
  } while (ownerItems.generation !== itemsGen);
}, getScrollbarsNeeded: function(width, height, contentWidth, contentHeight) {
  var scrollbarSize = Ext.getScrollbarSize(), hasWidth = typeof width == 'number', hasHeight = typeof height == 'number', needHorz = 0, needVert = 0;
  if (!scrollbarSize.width) 
  {
    return 0;
  }
  if (hasHeight && height < contentHeight) 
  {
    needVert = 2;
    width -= scrollbarSize.width;
  }
  if (hasWidth && width < contentWidth) 
  {
    needHorz = 1;
    if (!needVert && hasHeight) 
    {
      height -= scrollbarSize.height;
      if (height < contentHeight) 
      {
        needVert = 2;
      }
    }
  }
  return needVert + needHorz;
}, getTarget: function() {
  return this.owner.getTargetEl();
}, getVisibleItems: function() {
  var target = this.getRenderTarget(), items = this.getLayoutItems(), ln = items.length, visibleItems = [], i, item;
  for (i = 0; i < ln; i++) 
    {
      item = items[i];
      if (item.rendered && this.isValidParent(item, target, i) && item.hidden !== true) 
      {
        visibleItems.push(item);
      }
    }
  return visibleItems;
}, setupRenderTpl: function(renderTpl) {
  var me = this;
  renderTpl.renderBody = me.doRenderBody;
  renderTpl.renderContainer = me.doRenderContainer;
  renderTpl.renderItems = me.doRenderItems;
}, getContentTarget: function() {
  return this.owner.getDefaultContentTarget();
}}, 1, 0, 0, 0, ["layout.container"], [['elementCt', Ext.util.ElementContainer]], [Ext.layout.container, 'Container', Ext.layout, 'ContainerLayout'], 0));
;

(Ext.cmd.derive('Ext.layout.container.Auto', Ext.layout.container.Container, {type: 'autocontainer', childEls: ['outerCt', 'innerCt', 'clearEl'], reserveScrollbar: false, managePadding: true, manageOverflow: false, lastOverflowAdjust: {width: 0, height: 0}, renderTpl: ['{% if (!(Ext.isIEQuirks || Ext.isIE7m)) { %}', '<span id="{ownerId}-outerCt" style="display:table;" role="presentation">', '<div id="{ownerId}-innerCt" style="display:table-cell;height:100%;', 'vertical-align:top;{%this.renderPadding(out, values)%}" class="{innerCtCls}" role="presentation">', '{%this.renderBody(out,values)%}', '</div>', '</span>', '{% } else if (values.shrinkWrapWidth) { %}', '<table id="{ownerId}-outerCt" class="' + Ext.plainTableCls + '" role="presentation">', '<tbody role="presentation">', '<tr role="presentation">', '<td id="{ownerId}-innerCt" style="vertical-align:top;padding:0;', '{%this.renderPadding(out, values)%}" class="{innerCtCls}" role="presentation">', '{%this.renderBody(out,values)%}', '<div id="{ownerId}-clearEl" class="', Ext.baseCSSPrefix, 'clear"', 'role="presentation"></div>', '</td>', '</tr>', '</tbody>', '</table>', '{% } else { %}', '<div id="{ownerId}-outerCt" style="zoom:1;{%this.renderPadding(out, values)%}" role="presentation">', '<div id="{ownerId}-innerCt" style="zoom:1;height:100%;" class="{innerCtCls}" role="presentation">', '{%this.renderBody(out,values)%}', '<div id="{ownerId}-clearEl" class="', Ext.baseCSSPrefix, 'clear"', 'role="presentation"></div>', '</div>', '</div>', '{% values.$layout.isShrinkWrapTpl = false %}', '{% } %}'], tableTpl: ['<table id="{ownerId}-outerCt" class="' + Ext.plainTableCls + '" role="presentation">', '<tbody role="presentation">', '<tr role="presentation">', '<td id="{ownerId}-innerCt" style="vertical-align:top;padding:0;', '{%this.renderPadding(out, values)%}" class="{innerCtCls}" role="presentation">', '</td>', '</tr>', '</tbody>', '</table>'], isShrinkWrapTpl: true, beginLayout: function(ownerContext) {
  var me = this, bottomPadding, overflowYStyle, overflowXStyle, needsTable;
  me.callParent(arguments);
  me.initContextItems(ownerContext);
  if (!me.isShrinkWrapTpl) 
  {
    if (ownerContext.widthModel.shrinkWrap) 
    {
      needsTable = true;
    }
    if (Ext.isStrict && Ext.isIE7) 
    {
      overflowXStyle = me.getOverflowXStyle(ownerContext);
      if ((overflowXStyle === 'auto' || overflowXStyle === 'scroll') && ownerContext.paddingContext.getPaddingInfo().right) 
      {
        needsTable = true;
      }
    }
    if (needsTable) 
    {
      me.insertTableCt(ownerContext);
    }
  }
  if (!me.isShrinkWrapTpl && Ext.isIE7 && Ext.isStrict && !me.clearElHasPadding) 
  {
    bottomPadding = ownerContext.paddingContext.getPaddingInfo().bottom;
    overflowYStyle = me.getOverflowYStyle(ownerContext);
    if (bottomPadding && (overflowYStyle === 'auto' || overflowYStyle === 'scroll')) 
    {
      me.clearEl.setStyle('height', bottomPadding);
      me.clearElHasPadding = true;
    }
  }
}, beforeLayoutCycle: function(ownerContext) {
  var comp = this.owner, hierarchyState = comp.hierarchyState, hierarchyStateInner = comp.hierarchyStateInner;
  if (!hierarchyState || hierarchyState.invalid) 
  {
    hierarchyState = comp.getHierarchyState();
    hierarchyStateInner = comp.hierarchyStateInner;
  }
  if (ownerContext.widthModel.shrinkWrap && this.isShrinkWrapTpl) 
  {
    hierarchyStateInner.inShrinkWrapTable = true;
  } else {
    delete hierarchyStateInner.inShrinkWrapTable;
  }
}, beginLayoutCycle: function(ownerContext) {
  var me = this, outerCt = me.outerCt, lastOuterCtWidth = me.lastOuterCtWidth || '', lastOuterCtHeight = me.lastOuterCtHeight || '', lastOuterCtTableLayout = me.lastOuterCtTableLayout || '', state = ownerContext.state, overflowXStyle, overflowYStyle, outerCtWidth, outerCtHeight, outerCtTableLayout, deferWidth, hierarchyStateInner;
  me.callParent(arguments);
  outerCtWidth = outerCtHeight = outerCtTableLayout = '';
  if (!ownerContext.widthModel.shrinkWrap && me.isShrinkWrapTpl) 
  {
    if (Ext.isIE7m && Ext.isStrict) 
    {
      overflowYStyle = me.getOverflowYStyle(ownerContext);
      if (overflowYStyle === 'auto' || overflowYStyle === 'scroll') 
      {
        deferWidth = true;
      }
    }
    if (!deferWidth) 
    {
      outerCtWidth = '100%';
    }
    hierarchyStateInner = me.owner.hierarchyStateInner;
    overflowXStyle = me.getOverflowXStyle(ownerContext);
    outerCtTableLayout = (hierarchyStateInner.inShrinkWrapTable || overflowXStyle === 'auto' || overflowXStyle === 'scroll') ? '' : 'fixed';
  }
  if (!ownerContext.heightModel.shrinkWrap && !Ext.supports.PercentageHeightOverflowBug) 
  {
    outerCtHeight = '100%';
  }
  if ((outerCtWidth !== lastOuterCtWidth) || me.hasOuterCtPxWidth) 
  {
    outerCt.setStyle('width', outerCtWidth);
    me.lastOuterCtWidth = outerCtWidth;
    me.hasOuterCtPxWidth = false;
  }
  if (outerCtTableLayout !== lastOuterCtTableLayout) 
  {
    outerCt.setStyle('table-layout', outerCtTableLayout);
    me.lastOuterCtTableLayout = outerCtTableLayout;
  }
  if ((outerCtHeight !== lastOuterCtHeight) || me.hasOuterCtPxHeight) 
  {
    outerCt.setStyle('height', outerCtHeight);
    me.lastOuterCtHeight = outerCtHeight;
    me.hasOuterCtPxHeight = false;
  }
  if (me.hasInnerCtPxHeight) 
  {
    me.innerCt.setStyle('height', '');
    me.hasInnerCtPxHeight = false;
  }
  state.overflowAdjust = state.overflowAdjust || me.lastOverflowAdjust;
}, calculate: function(ownerContext) {
  var me = this, state = ownerContext.state, containerSize = me.getContainerSize(ownerContext, true), calculatedItems = state.calculatedItems || (state.calculatedItems = me.calculateItems ? me.calculateItems(ownerContext, containerSize) : true);
  me.setCtSizeIfNeeded(ownerContext, containerSize);
  if (calculatedItems && ownerContext.hasDomProp('containerChildrenSizeDone')) 
  {
    me.calculateContentSize(ownerContext);
    if (containerSize.gotAll) 
    {
      if (me.manageOverflow && !ownerContext.state.secondPass && !me.reserveScrollbar) 
      {
        me.calculateOverflow(ownerContext, containerSize);
      }
      return;
    }
  }
  me.done = false;
}, calculateContentSize: function(ownerContext) {
  var me = this, containerDimensions = ((ownerContext.widthModel.shrinkWrap ? 1 : 0) | (ownerContext.heightModel.shrinkWrap ? 2 : 0)), calcWidth = (containerDimensions & 1) || undefined, calcHeight = (containerDimensions & 2) || undefined, needed = 0, props = ownerContext.props;
  if (calcWidth) 
  {
    if (isNaN(props.contentWidth)) 
    {
      ++needed;
    } else {
      calcWidth = undefined;
    }
  }
  if (calcHeight) 
  {
    if (isNaN(props.contentHeight)) 
    {
      ++needed;
    } else {
      calcHeight = undefined;
    }
  }
  if (needed) 
  {
    if (calcWidth && !ownerContext.setContentWidth(me.measureContentWidth(ownerContext))) 
    {
      me.done = false;
    }
    if (calcHeight && !ownerContext.setContentHeight(me.measureContentHeight(ownerContext))) 
    {
      me.done = false;
    }
  }
}, calculateOverflow: function(ownerContext) {
  var me = this, width, height, scrollbarSize, scrollbars, xauto, yauto, targetEl;
  xauto = (me.getOverflowXStyle(ownerContext) === 'auto');
  yauto = (me.getOverflowYStyle(ownerContext) === 'auto');
  if (xauto || yauto) 
  {
    scrollbarSize = Ext.getScrollbarSize();
    targetEl = ownerContext.overflowContext.el.dom;
    scrollbars = 0;
    if (targetEl.scrollWidth > targetEl.clientWidth) 
    {
      scrollbars |= 1;
    }
    if (targetEl.scrollHeight > targetEl.clientHeight) 
    {
      scrollbars |= 2;
    }
    width = (yauto && (scrollbars & 2)) ? scrollbarSize.width : 0;
    height = (xauto && (scrollbars & 1)) ? scrollbarSize.height : 0;
    if (width !== me.lastOverflowAdjust.width || height !== me.lastOverflowAdjust.height) 
    {
      me.done = false;
      ownerContext.invalidate({state: {overflowAdjust: {width: width, height: height}, overflowState: scrollbars, secondPass: true}});
    }
  }
}, completeLayout: function(ownerContext) {
  this.lastOverflowAdjust = ownerContext.state.overflowAdjust;
}, doRenderPadding: function(out, renderData) {
  var me = renderData.$layout, owner = renderData.$layout.owner, padding = owner[owner.contentPaddingProperty];
  if (me.managePadding && padding) 
  {
    out.push('padding:', owner.unitizeBox(padding));
  }
}, finishedLayout: function(ownerContext) {
  var innerCt = this.innerCt;
  this.callParent(arguments);
  if (Ext.isIEQuirks || Ext.isIE8m) 
  {
    innerCt.repaint();
  }
  if (Ext.isOpera) 
  {
    innerCt.setStyle('position', 'relative');
    innerCt.dom.scrollWidth;
    innerCt.setStyle('position', '');
  }
}, getContainerSize: function(ownerContext, inDom) {
  var size = this.callParent(arguments), overflowAdjust = ownerContext.state.overflowAdjust;
  if (overflowAdjust) 
  {
    size.width -= overflowAdjust.width;
    size.height -= overflowAdjust.height;
  }
  return size;
}, getRenderData: function() {
  var owner = this.owner, data = this.callParent();
  if ((Ext.isIEQuirks || Ext.isIE7m) && ((owner.shrinkWrap & 1) || (owner.floating && !owner.width))) 
  {
    data.shrinkWrapWidth = true;
  }
  return data;
}, getRenderTarget: function() {
  return this.innerCt;
}, getElementTarget: function() {
  return this.innerCt;
}, getOverflowXStyle: function(ownerContext) {
  return ownerContext.overflowXStyle || (ownerContext.overflowXStyle = this.owner.scrollFlags.overflowX || ownerContext.overflowContext.getStyle('overflow-x'));
}, getOverflowYStyle: function(ownerContext) {
  return ownerContext.overflowYStyle || (ownerContext.overflowYStyle = this.owner.scrollFlags.overflowY || ownerContext.overflowContext.getStyle('overflow-y'));
}, initContextItems: function(ownerContext) {
  var me = this, target = ownerContext.target, customOverflowEl = me.owner.customOverflowEl;
  ownerContext.outerCtContext = ownerContext.getEl('outerCt', me);
  ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);
  if (customOverflowEl) 
  {
    ownerContext.overflowContext = ownerContext.getEl(customOverflowEl);
  } else {
    ownerContext.overflowContext = ownerContext.targetContext;
  }
  if (target[target.contentPaddingProperty] !== undefined) 
  {
    ownerContext.paddingContext = me.isShrinkWrapTpl ? ownerContext.innerCtContext : ownerContext.outerCtContext;
  }
}, initLayout: function() {
  var me = this, scrollbarWidth = Ext.getScrollbarSize().width, owner = me.owner;
  me.callParent();
  if (scrollbarWidth && me.manageOverflow && !me.hasOwnProperty('lastOverflowAdjust')) 
  {
    if (owner.autoScroll || me.reserveScrollbar) 
    {
      me.lastOverflowAdjust = {width: scrollbarWidth, height: 0};
    }
  }
}, insertTableCt: function(ownerContext) {
  var me = this, owner = me.owner, i = 0, renderTpl, fragment, childNodes, childLength, targetEl;
  renderTpl = Ext.XTemplate.getTpl(this, 'tableTpl');
  renderTpl.renderPadding = me.doRenderPadding;
  me.outerCt.dom.removeChild(me.innerCt.dom);
  fragment = document.createDocumentFragment();
  childNodes = me.innerCt.dom.childNodes;
  childLength = childNodes.length;
  for (; i < childLength; i++) 
    {
      fragment.appendChild(childNodes[0]);
    }
  targetEl = me.getTarget();
  targetEl.dom.innerHTML = renderTpl.apply({$layout: me, ownerId: me.owner.id});
  targetEl.down('td').dom.appendChild(fragment);
  me.applyChildEls(owner.el, owner.id);
  me.isShrinkWrapTpl = true;
  ownerContext.removeEl(me.outerCt);
  ownerContext.removeEl(me.innerCt);
  me.initContextItems(ownerContext);
}, measureContentHeight: function(ownerContext) {
  var contentHeight = this.outerCt.getHeight(), target = ownerContext.target;
  if (this.managePadding && (target[target.contentPaddingProperty] === undefined)) 
  {
    contentHeight += ownerContext.targetContext.getPaddingInfo().height;
  }
  return contentHeight;
}, measureContentWidth: function(ownerContext) {
  var dom, style, old, contentWidth, target;
  if (this.chromeCellMeasureBug) 
  {
    dom = this.innerCt.dom;
    style = dom.style;
    old = style.display;
    if (old == 'table-cell') 
    {
      style.display = '';
      dom.offsetWidth;
      style.display = old;
    }
  }
  if (Ext.isSafari) 
  {
    dom = this.outerCt.dom;
    style = dom.style;
    style.display = 'table-cell';
    dom.offsetWidth;
    dom.style.display = 'table';
  }
  contentWidth = this.outerCt.getWidth();
  target = ownerContext.target;
  if (this.managePadding && (target[target.contentPaddingProperty] === undefined)) 
  {
    contentWidth += ownerContext.targetContext.getPaddingInfo().width;
  }
  return contentWidth;
}, setCtSizeIfNeeded: function(ownerContext, containerSize) {
  var me = this, width = containerSize.width, height = containerSize.height, padding = ownerContext.paddingContext.getPaddingInfo(), targetEl = me.getTarget(), overflowXStyle = me.getOverflowXStyle(ownerContext), overflowYStyle = me.getOverflowYStyle(ownerContext), canOverflowX = (overflowXStyle === 'auto' || overflowXStyle === 'scroll'), canOverflowY = (overflowYStyle === 'auto' || overflowYStyle === 'scroll'), scrollbarSize = Ext.getScrollbarSize(), isShrinkWrapTpl = me.isShrinkWrapTpl, manageOverflow = me.manageOverflow, overflowStyleName, needsOuterHeight, needsInnerHeight, needsInnerCtPaddingHeight;
  if (width && !ownerContext.widthModel.shrinkWrap && ((Ext.isIE7m && Ext.isStrict && isShrinkWrapTpl && canOverflowY) || (Ext.isIEQuirks && !isShrinkWrapTpl && !canOverflowX))) 
  {
    if (!manageOverflow) 
    {
      if (canOverflowY && (targetEl.dom.scrollHeight > targetEl.dom.clientHeight)) 
      {
        width -= scrollbarSize.width;
      }
    }
    ownerContext.outerCtContext.setProp('width', width + padding.width);
    me.hasOuterCtPxWidth = true;
  }
  if (height && !ownerContext.heightModel.shrinkWrap) 
  {
    if (Ext.supports.PercentageHeightOverflowBug) 
    {
      needsOuterHeight = true;
    }
    if (((Ext.isIE8 && Ext.isStrict) || Ext.isIE7m && Ext.isStrict && isShrinkWrapTpl)) 
    {
      needsInnerHeight = true;
      needsInnerCtPaddingHeight = !Ext.isIE8;
    }
    if ((needsOuterHeight || needsInnerHeight) && canOverflowX && (targetEl.dom.scrollWidth > targetEl.dom.clientWidth)) 
    {
      height = Math.max(height - scrollbarSize.height, 0);
    }
    if (needsOuterHeight) 
    {
      ownerContext.outerCtContext.setProp('height', height + padding.height);
      me.hasOuterCtPxHeight = true;
    }
    if (needsInnerHeight) 
    {
      if (needsInnerCtPaddingHeight) 
      {
        height += padding.height;
      }
      ownerContext.innerCtContext.setProp('height', height);
      me.hasInnerCtPxHeight = true;
    }
  }
  if (Ext.isIE7 && Ext.isStrict && !isShrinkWrapTpl && (overflowYStyle === 'auto')) 
  {
    overflowStyleName = (overflowXStyle === 'auto') ? 'overflow-x' : 'overflow-y';
    targetEl.setStyle(overflowStyleName, 'hidden');
    targetEl.setStyle(overflowStyleName, 'auto');
  }
}, setupRenderTpl: function(renderTpl) {
  this.callParent(arguments);
  renderTpl.renderPadding = this.doRenderPadding;
}, getContentTarget: function() {
  return this.innerCt;
}}, 0, 0, 0, 0, ["layout.auto", "layout.autocontainer"], 0, [Ext.layout.container, 'Auto'], function() {
  this.prototype.chromeCellMeasureBug = Ext.isChrome && Ext.chromeVersion >= 26;
}));
;

(Ext.cmd.derive('Ext.ZIndexManager', Ext.Base, {alternateClassName: 'Ext.WindowGroup', statics: {zBase: 9000}, constructor: function(container) {
  var me = this;
  me.map = {};
  me.zIndexStack = [];
  me.front = null;
  if (container) 
  {
    if (container.isContainer) 
    {
      container.on('resize', me._onContainerResize, me);
      me.zseed = Ext.Number.from(me.rendered ? container.getEl().getStyle('zIndex') : undefined, me.getNextZSeed());
      me.targetEl = container.getTargetEl();
      me.container = container;
    } else {
      Ext.EventManager.onWindowResize(me._onContainerResize, me);
      me.zseed = me.getNextZSeed();
      me.targetEl = Ext.get(container);
    }
  } else {
    Ext.EventManager.onWindowResize(me._onContainerResize, me);
    me.zseed = me.getNextZSeed();
    Ext.onDocumentReady(function() {
  me.targetEl = Ext.getBody();
});
  }
}, getNextZSeed: function() {
  return (Ext.ZIndexManager.zBase += 10000);
}, setBase: function(baseZIndex) {
  this.zseed = baseZIndex;
  var result = this.assignZIndices();
  this._activateLast();
  return result;
}, assignZIndices: function() {
  var a = this.zIndexStack, len = a.length, i = 0, zIndex = this.zseed, comp, topModal;
  for (; i < len; i++) 
    {
      comp = a[i];
      if (comp && !comp.hidden) 
      {
        zIndex = comp.setZIndex(zIndex);
        if (comp.modal) 
        {
          topModal = comp;
        }
      }
    }
  if (topModal) 
  {
    this._showModalMask(topModal);
  }
  return zIndex;
}, _setActiveChild: function(comp, oldFront) {
  var front = this.front, oldPreventFocus = comp.preventFocusOnActivate;
  if (comp !== front) 
  {
    if (front && !front.destroying) 
    {
      front.setActive(false, comp);
    }
    this.front = comp;
    if (comp && comp != oldFront) 
    {
      comp.preventFocusOnActivate = comp.preventFocusOnActivate || oldFront && (oldFront.preventFocusOnActivate || !oldFront.focusOnToFront);
      comp.setActive(true);
      if (comp.modal) 
      {
        this._showModalMask(comp);
      }
      comp.preventFocusOnActivate = oldPreventFocus;
    }
  }
}, onComponentHide: function(comp) {
  this._activateLast();
}, _activateLast: function() {
  var me = this, stack = me.zIndexStack, i = stack.length - 1, comp;
  for (; i >= 0 && stack[i].hidden; --i) 
    ;
  if ((comp = stack[i])) 
  {
    me._setActiveChild(comp, me.front);
    if (comp.modal) 
    {
      return;
    }
  } else {
    if (me.front && !me.front.destroying) 
    {
      me.front.setActive(false);
    }
    me.front = null;
  }
  for (; i >= 0; --i) 
    {
      comp = stack[i];
      if (comp.isVisible() && comp.modal) 
      {
        me._showModalMask(comp);
        return;
      }
    }
  me._hideModalMask();
}, _showModalMask: function(comp) {
  var me = this, zIndex = comp.el.getStyle('zIndex') - 4, maskTarget = comp.floatParent ? comp.floatParent.getTargetEl() : comp.container, mask = me.mask, shim = me.maskShim, viewSize;
  if (!mask) 
  {
    if (Ext.isIE6) 
    {
      shim = me.maskShim = Ext.getBody().createChild({tag: 'iframe', role: 'presentation', cls: Ext.baseCSSPrefix + 'shim ' + Ext.baseCSSPrefix + 'mask-shim'});
      shim.setVisibilityMode(Ext.Element.DISPLAY);
    }
    mask = me.mask = Ext.getBody().createChild({role: 'presentation', cls: Ext.baseCSSPrefix + 'mask', style: 'height:0;width:0'});
    mask.setVisibilityMode(Ext.Element.DISPLAY);
    mask.on('click', me._onMaskClick, me);
  }
  mask.maskTarget = maskTarget;
  viewSize = me.getMaskBox();
  if (shim) 
  {
    shim.setStyle('zIndex', zIndex);
    shim.show();
    shim.setBox(viewSize);
  }
  mask.setStyle('zIndex', zIndex);
  mask.show();
  mask.setBox(viewSize);
}, _hideModalMask: function() {
  var mask = this.mask, maskShim = this.maskShim;
  if (mask && mask.isVisible()) 
  {
    mask.maskTarget = undefined;
    mask.hide();
    if (maskShim) 
    {
      maskShim.hide();
    }
  }
}, _onMaskClick: function() {
  if (this.front) 
  {
    this.front.focus();
  }
}, getMaskBox: function() {
  var maskTarget = this.mask.maskTarget;
  if (maskTarget.dom === document.body) 
  {
    return {height: Math.max(document.body.scrollHeight, Ext.dom.Element.getDocumentHeight()), width: Math.max(document.body.scrollWidth, document.documentElement.clientWidth), x: 0, y: 0};
  } else {
    return maskTarget.getBox();
  }
}, _onContainerResize: function() {
  var me = this, mask = me.mask, maskShim = me.maskShim, viewSize;
  if (mask && mask.isVisible()) 
  {
    mask.hide();
    if (maskShim) 
    {
      maskShim.hide();
    }
    viewSize = me.getMaskBox();
    if (maskShim) 
    {
      maskShim.setSize(viewSize);
      maskShim.show();
    }
    mask.setSize(viewSize);
    mask.show();
  }
}, register: function(comp) {
  var me = this, compAfterHide = comp.afterHide;
  if (comp.zIndexManager) 
  {
    comp.zIndexManager.unregister(comp);
  }
  comp.zIndexManager = me;
  me.map[comp.id] = comp;
  me.zIndexStack.push(comp);
  comp.afterHide = function() {
  compAfterHide.apply(comp, arguments);
  me.onComponentHide(comp);
};
}, unregister: function(comp) {
  var me = this, map = me.map;
  delete comp.zIndexManager;
  if (map && map[comp.id]) 
  {
    delete map[comp.id];
    delete comp.afterHide;
    Ext.Array.remove(me.zIndexStack, comp);
    me._activateLast();
  }
}, get: function(id) {
  return id.isComponent ? id : this.map[id];
}, bringToFront: function(comp, preventFocus) {
  var me = this, result = false, zIndexStack = me.zIndexStack;
  comp = me.get(comp);
  if (comp !== me.front) 
  {
    Ext.Array.remove(zIndexStack, comp);
    if (comp.preventBringToFront) 
    {
      zIndexStack.unshift(comp);
    } else {
      zIndexStack.push(comp);
    }
    me.assignZIndices();
    if (!preventFocus) 
    {
      me._activateLast();
    }
    result = true;
    me.front = comp;
    if (comp.modal) 
    {
      me._showModalMask(comp);
    }
  }
  return result;
}, sendToBack: function(comp) {
  var me = this;
  comp = me.get(comp);
  Ext.Array.remove(me.zIndexStack, comp);
  me.zIndexStack.unshift(comp);
  me.assignZIndices();
  this._activateLast();
  return comp;
}, hideAll: function() {
  var map = this.map, item, id;
  for (id in map) 
    {
      if (map.hasOwnProperty(id)) 
      {
        item = map[id];
        if (item.isComponent && item.isVisible()) 
        {
          item.hide();
        }
      }
    }
}, hide: function() {
  var i = 0, stack = this.zIndexStack, len = stack.length, comp;
  this.tempHidden = [];
  for (; i < len; i++) 
    {
      comp = stack[i];
      if (comp.isVisible()) 
      {
        this.tempHidden.push(comp);
        comp.el.hide();
        comp.hidden = true;
      }
    }
}, show: function() {
  var i = 0, tempHidden = this.tempHidden, len = tempHidden ? tempHidden.length : 0, comp;
  for (; i < len; i++) 
    {
      comp = tempHidden[i];
      comp.el.show();
      comp.hidden = false;
      comp.setPosition(comp.x, comp.y);
    }
  delete this.tempHidden;
}, getActive: function() {
  return this.front;
}, getBy: function(fn, scope) {
  var r = [], i = 0, stack = this.zIndexStack, len = stack.length, comp;
  for (; i < len; i++) 
    {
      comp = stack[i];
      if (fn.call(scope || comp, comp) !== false) 
      {
        r.push(comp);
      }
    }
  return r;
}, each: function(fn, scope) {
  var map = this.map, id, comp;
  for (id in map) 
    {
      if (map.hasOwnProperty(id)) 
      {
        comp = map[id];
        if (comp.isComponent && fn.call(scope || comp, comp) === false) 
        {
          return;
        }
      }
    }
}, eachBottomUp: function(fn, scope) {
  var stack = this.zIndexStack, i = 0, len = stack.length, comp;
  for (; i < len; i++) 
    {
      comp = stack[i];
      if (comp.isComponent && fn.call(scope || comp, comp) === false) 
      {
        return;
      }
    }
}, eachTopDown: function(fn, scope) {
  var stack = this.zIndexStack, i = stack.length, comp;
  for (; i-- > 0; ) 
    {
      comp = stack[i];
      if (comp.isComponent && fn.call(scope || comp, comp) === false) 
      {
        return;
      }
    }
}, destroy: function() {
  var me = this, map = me.map, comp, id;
  for (id in map) 
    {
      if (map.hasOwnProperty(id)) 
      {
        comp = map[id];
        if (comp.isComponent) 
        {
          comp.destroy();
        }
      }
    }
  Ext.destroy(me.mask);
  Ext.destroy(me.maskShim);
  delete me.zIndexStack;
  delete me.map;
  delete me.container;
  delete me.targetEl;
}}, 1, 0, 0, 0, 0, 0, [Ext, 'ZIndexManager', Ext, 'WindowGroup'], function() {
  Ext.WindowManager = Ext.WindowMgr = new this();
}));
;

(Ext.cmd.derive('Ext.Queryable', Ext.Base, {isQueryable: true, query: function(selector) {
  selector = selector || '*';
  return Ext.ComponentQuery.query(selector, this);
}, queryBy: function(fn, scope) {
  var out = [], items = this.getRefItems(true), i = 0, len = items.length, item;
  for (; i < len; ++i) 
    {
      item = items[i];
      if (fn.call(scope || item, item) !== false) 
      {
        out.push(item);
      }
    }
  return out;
}, queryById: function(id) {
  return this.down('#' + id);
}, child: function(selector) {
  var children = this.getRefItems();
  if (selector && selector.isComponent) 
  {
    selector = '#' + Ext.escapeId(selector.getItemId());
  }
  if (selector) 
  {
    children = Ext.ComponentQuery.query(selector, children);
  }
  if (children.length) 
  {
    return children[0];
  }
  return null;
}, down: function(selector) {
  if (selector && selector.isComponent) 
  {
    selector = '#' + Ext.escapeId(selector.getItemId());
  }
  selector = selector || '';
  return this.query(selector)[0] || null;
}, visitPreOrder: function(selector, fn, scope, extraArgs) {
  Ext.ComponentQuery._visit(true, selector, this, fn, scope, extraArgs);
}, visitPostOrder: function(selector, fn, scope, extraArgs) {
  Ext.ComponentQuery._visit(false, selector, this, fn, scope, extraArgs);
}, getRefItems: function() {
  return [];
}}, 0, 0, 0, 0, 0, 0, [Ext, 'Queryable'], 0));
;

(Ext.cmd.derive('Ext.container.AbstractContainer', Ext.Component, {renderTpl: '{%this.renderContainer(out,values)%}', suspendLayout: false, autoDestroy: true, defaultType: 'panel', detachOnRemove: true, isContainer: true, layoutCounter: 0, baseCls: Ext.baseCSSPrefix + 'container', defaultLayoutType: 'auto', ariaRole: 'presentation', initComponent: function() {
  var me = this;
  me.addEvents('afterlayout', 'beforeadd', 'beforeremove', 'add', 'remove');
  me.callParent();
  me.getLayout();
  me.initItems();
}, initItems: function() {
  var me = this, items = me.items;
  me.items = new Ext.util.AbstractMixedCollection(false, me.getComponentId);
  me.floatingItems = new Ext.util.MixedCollection(false, me.getComponentId);
  if (items) 
  {
    if (!Ext.isArray(items)) 
    {
      items = [items];
    }
    me.add(items);
  }
}, getFocusEl: function() {
  return this.getTargetEl();
}, finishRenderChildren: function() {
  this.callParent();
  var layout = this.getLayout();
  if (layout) 
  {
    layout.finishRender();
  }
}, beforeRender: function() {
  var me = this, layout = me.getLayout(), targetCls;
  me.callParent();
  if (!layout.initialized) 
  {
    layout.initLayout();
  }
  targetCls = layout.targetCls;
  if (targetCls) 
  {
    me.applyTargetCls(targetCls);
  }
}, applyTargetCls: function(targetCls) {
  this.addCls(targetCls);
}, afterComponentLayout: function() {
  var floaters = this.floatingItems.items, floaterCount = floaters.length, i, floater;
  this.callParent(arguments);
  for (i = 0; i < floaterCount; i++) 
    {
      floater = floaters[i];
      if (!floater.rendered && floater.autoShow) 
      {
        floater.show();
      }
    }
}, onPosition: function() {
  this.callParent(arguments);
  this.repositionFloatingItems();
}, onResize: function() {
  this.callParent(arguments);
  this.repositionFloatingItems();
}, repositionFloatingItems: function() {
  var floaters = this.floatingItems.items, floaterCount = floaters.length, i, floater;
  for (i = 0; i < floaterCount; i++) 
    {
      floater = floaters[i];
      if (floater.el && !floater.hidden) 
      {
        floater.setPosition(floater.x, floater.y);
      }
    }
}, setupRenderTpl: function(renderTpl) {
  this.callParent(arguments);
  this.getLayout().setupRenderTpl(renderTpl);
}, getDefaultContentTarget: function() {
  return this.el;
}, getContentTarget: function() {
  return this.getLayout().getContentTarget();
}, setLayout: function(layout) {
  var currentLayout = this.layout;
  if (currentLayout && currentLayout.isLayout && currentLayout != layout) 
  {
    currentLayout.setOwner(null);
  }
  this.layout = layout;
  layout.setOwner(this);
}, getLayout: function() {
  var me = this;
  if (!me.layout || !me.layout.isLayout) 
  {
    me.setLayout(Ext.layout.Layout.create(me.layout, me.self.prototype.layout || me.defaultLayoutType));
  }
  return me.layout;
}, doLayout: function() {
  this.updateLayout();
  return this;
}, afterLayout: function(layout) {
  var me = this;
  ++me.layoutCounter;
  if (me.hasListeners.afterlayout) 
  {
    me.fireEvent('afterlayout', me, layout);
  }
}, prepareItems: function(items, applyDefaults) {
  if (Ext.isArray(items)) 
  {
    items = items.slice();
  } else {
    items = [items];
  }
  var me = this, i = 0, len = items.length, item;
  for (; i < len; i++) 
    {
      item = items[i];
      if (item == null) 
      {
        Ext.Array.erase(items, i, 1);
        --i;
        --len;
      } else {
        if (applyDefaults) 
        {
          item = this.applyDefaults(item);
        }
        item.isContained = me;
        items[i] = me.lookupComponent(item);
        delete item.isContained;
        delete items[i].isContained;
      }
    }
  return items;
}, applyDefaults: function(config) {
  var defaults = this.defaults;
  if (defaults) 
  {
    if (Ext.isFunction(defaults)) 
    {
      defaults = defaults.call(this, config);
    }
    if (Ext.isString(config)) 
    {
      config = Ext.ComponentManager.get(config);
    }
    Ext.applyIf(config, defaults);
  }
  return config;
}, lookupComponent: function(comp) {
  return (typeof comp == 'string') ? Ext.ComponentManager.get(comp) : Ext.ComponentManager.create(comp, this.defaultType);
}, getComponentId: function(comp) {
  return comp.getItemId && comp.getItemId();
}, add: function() {
  var me = this, args = Ext.Array.slice(arguments), index = (typeof args[0] == 'number') ? args.shift() : -1, layout = me.getLayout(), addingArray, items, i, length, item, pos, ret, needsLayout = false;
  if (args.length == 1 && Ext.isArray(args[0])) 
  {
    items = args[0];
    addingArray = true;
  } else {
    items = args;
  }
  if (me.rendered) 
  {
    Ext.suspendLayouts();
  }
  ret = items = me.prepareItems(items, true);
  length = items.length;
  if (!addingArray && length == 1) 
  {
    ret = items[0];
  }
  for (i = 0; i < length; i++) 
    {
      item = items[i];
      pos = (index < 0) ? me.items.length : (index + i);
      if (item.floating) 
      {
        me.floatingItems.add(item);
        item.onAdded(me, pos);
        if (me.hasListeners.add) 
        {
          me.fireEvent('add', me, item, pos);
        }
      } else if ((!me.hasListeners.beforeadd || me.fireEvent('beforeadd', me, item, pos) !== false) && me.onBeforeAdd(item) !== false) 
      {
        me.items.insert(pos, item);
        item.onAdded(me, pos);
        me.onAdd(item, pos);
        layout.onAdd(item, pos);
        needsLayout = true;
        if (me.hasListeners.add) 
        {
          me.fireEvent('add', me, item, pos);
        }
      }
    }
  if (needsLayout) 
  {
    me.updateLayout();
  }
  if (me.rendered) 
  {
    Ext.resumeLayouts(true);
  }
  return ret;
}, onAdd: Ext.emptyFn, onRemove: Ext.emptyFn, insert: function(index, comp) {
  var compIdx;
  if (comp && comp.isComponent) 
  {
    compIdx = this.items.indexOf(comp);
    if (compIdx !== -1) 
    {
      return this.move(compIdx, index);
    }
  }
  return this.add(index, comp);
}, move: function(fromIdx, toIdx) {
  var items = this.items, item;
  if (fromIdx.isComponent) 
  {
    fromIdx = items.indexOf(fromIdx);
  }
  item = items.getAt(fromIdx);
  if (fromIdx !== toIdx) 
  {
    item = items.removeAt(fromIdx);
    if (item === false) 
    {
      return false;
    }
    items.insert(toIdx, item);
    this.onMove(item, fromIdx, toIdx);
    this.updateLayout();
  }
  return item;
}, onMove: Ext.emptyFn, onBeforeAdd: function(item) {
  var owner = item.ownerCt;
  if (owner && owner !== this) 
  {
    owner.remove(item, false);
  }
}, remove: function(comp, autoDestroy) {
  var me = this, c = me.getComponent(comp);
  if (c && (!me.hasListeners.beforeremove || me.fireEvent('beforeremove', me, c) !== false)) 
  {
    me.doRemove(c, autoDestroy);
    if (me.hasListeners.remove) 
    {
      me.fireEvent('remove', me, c);
    }
    if (!me.destroying && !c.floating) 
    {
      me.updateLayout();
    }
  }
  return c;
}, doRemove: function(component, doDestroy) {
  doDestroy = doDestroy === true || (doDestroy !== false && this.autoDestroy);
  var me = this, layout = me.layout, hasLayout = layout && me.rendered, isDestroying = component.destroying || doDestroy, floating = component.floating;
  if (floating) 
  {
    me.floatingItems.remove(component);
  } else {
    me.items.remove(component);
  }
  if (hasLayout && !floating) 
  {
    if (layout.running) 
    {
      Ext.AbstractComponent.cancelLayout(component, isDestroying);
    }
    layout.onRemove(component, isDestroying);
  }
  component.onRemoved(isDestroying);
  me.onRemove(component, isDestroying);
  if (doDestroy) 
  {
    component.destroy();
  } else {
    if (hasLayout && !floating) 
    {
      layout.afterRemove(component);
    }
    if (me.detachOnRemove && component.rendered) 
    {
      me.detachComponent(component);
    }
  }
}, detachComponent: function(component) {
  Ext.getDetachedBody().appendChild(component.getEl());
}, removeAll: function(autoDestroy) {
  var me = this, removeItems = me.items.items.slice().concat(me.floatingItems.items), items = [], i = 0, len = removeItems.length, item;
  me.suspendLayouts();
  for (; i < len; i++) 
    {
      item = removeItems[i];
      me.remove(item, autoDestroy);
      if (item.ownerCt !== me) 
      {
        items.push(item);
      }
    }
  me.resumeLayouts(!!len);
  return items;
}, getRefItems: function(deep) {
  var me = this, items = me.items.items, len = items.length, i = 0, item, result = [];
  for (; i < len; i++) 
    {
      item = items[i];
      result[result.length] = item;
      if (deep && item.getRefItems) 
      {
        result.push.apply(result, item.getRefItems(true));
      }
    }
  items = me.floatingItems.items;
  len = items.length;
  for (i = 0; i < len; i++) 
    {
      item = items[i];
      result[result.length] = item;
      if (deep && item.getRefItems) 
      {
        result.push.apply(result, item.getRefItems(true));
      }
    }
  return result;
}, cascade: function(fn, scope, origArgs) {
  var me = this, cs = me.items ? me.items.items : [], len = cs.length, i = 0, c, args = origArgs ? origArgs.concat(me) : [me], componentIndex = args.length - 1;
  if (fn.apply(scope || me, args) !== false) 
  {
    for (; i < len; i++) 
      {
        c = cs[i];
        if (c.cascade) 
        {
          c.cascade(fn, scope, origArgs);
        } else {
          args[componentIndex] = c;
          fn.apply(scope || c, args);
        }
      }
  }
  return this;
}, isAncestor: function(possibleDescendant) {
  while (possibleDescendant) 
    {
      if (possibleDescendant.ownerCt === this) 
      {
        return true;
      }
      possibleDescendant = possibleDescendant.ownerCt;
    }
}, getComponent: function(comp) {
  if (Ext.isObject(comp)) 
  {
    comp = comp.getItemId();
  }
  var c = this.items.get(comp);
  if (!c && typeof comp != 'number') 
  {
    c = this.floatingItems.get(comp);
  }
  return c;
}, contains: function(comp, deep) {
  var result = false;
  if (deep) 
  {
    this.cascade(function(c) {
  if (c.contains && c.contains(comp)) 
  {
    result = true;
    return false;
  }
});
    return result;
  } else {
    return this.items.contains(comp) || this.floatingItems.contains(comp);
  }
}, nextChild: function(child, selector) {
  var me = this, items = me.items, childIndex = items.indexOf(child), i = 0, len = items.length, result;
  if (childIndex !== -1) 
  {
    if (selector) 
    {
      for (; i < len; i++) 
        {
          result = items.getAt(childIndex + i);
          if (!result || Ext.ComponentQuery.is(result, selector)) 
          {
            break;
          }
        }
    } else {
      result = items.getAt(childIndex + 1);
    }
    if (!result && me.ownerCt) 
    {
      result = me.ownerCt.nextChild(me, selector);
    }
  }
  return result;
}, prevChild: function(child, selector) {
  var me = this, items = me.items, childIndex = items.indexOf(child), i = 0, len = items.length, result;
  if (childIndex !== -1) 
  {
    if (selector) 
    {
      for (; i < len; i++) 
        {
          result = items.getAt(childIndex - i);
          if (!result || Ext.ComponentQuery.is(result, selector)) 
          {
            break;
          }
        }
    } else {
      result = items.getAt(childIndex - 1);
    }
    if (!result && me.ownerCt) 
    {
      result = me.ownerCt.nextChild(me, selector);
    }
  }
  return result;
}, enable: function() {
  this.callParent(arguments);
  var itemsToDisable = this.getChildItemsToDisable(), length = itemsToDisable.length, item, i;
  for (i = 0; i < length; i++) 
    {
      item = itemsToDisable[i];
      if (item.resetDisable) 
      {
        item.enable();
      }
    }
  return this;
}, disable: function() {
  this.callParent(arguments);
  var itemsToDisable = this.getChildItemsToDisable(), length = itemsToDisable.length, item, i;
  for (i = 0; i < length; i++) 
    {
      item = itemsToDisable[i];
      if (item.resetDisable !== false && !item.disabled) 
      {
        item.disable();
        item.resetDisable = true;
      }
    }
  return this;
}, getChildItemsToDisable: function() {
  return this.query('[isFormField],button');
}, beforeDestroy: function() {
  var me = this, items = me.items, floatingItems = me.floatingItems, c;
  if (items) 
  {
    while ((c = items.first())) 
      {
        me.doRemove(c, true);
      }
  }
  if (floatingItems) 
  {
    while ((c = floatingItems.first())) 
      {
        me.doRemove(c, true);
      }
  }
  Ext.destroy(me.layout);
  me.callParent();
}}, 0, 0, ["component", "box"], {"component": true, "box": true}, 0, [['queryable', Ext.Queryable]], [Ext.container, 'AbstractContainer'], 0));
;

(Ext.cmd.derive('Ext.container.Container', Ext.container.AbstractContainer, {alternateClassName: 'Ext.Container', getChildByElement: function(el, deep) {
  var item, itemEl, i = 0, it = this.getRefItems(), ln = it.length;
  el = Ext.getDom(el);
  for (; i < ln; i++) 
    {
      item = it[i];
      itemEl = item.getEl();
      if (itemEl && ((itemEl.dom === el) || itemEl.contains(el))) 
      {
        return (deep && item.getChildByElement) ? item.getChildByElement(el, deep) : item;
      }
    }
  return null;
}}, 0, ["container"], ["container", "component", "box"], {"container": true, "component": true, "box": true}, ["widget.container"], 0, [Ext.container, 'Container', Ext, 'Container'], 0));
;

(Ext.cmd.derive('Ext.layout.container.Editor', Ext.layout.container.Container, {autoSizeDefault: {width: 'field', height: 'field'}, sizePolicies: {$: {$: {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0}, boundEl: {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1}}, boundEl: {$: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0}, boundEl: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1}}}, getItemSizePolicy: function(item) {
  var me = this, autoSize = me.owner.autoSize, key = autoSize && autoSize.width, policy = me.sizePolicies;
  policy = policy[key] || policy.$;
  key = autoSize && autoSize.height;
  policy = policy[key] || policy.$;
  return policy;
}, calculate: function(ownerContext) {
  var me = this, owner = me.owner, autoSize = owner.autoSize, fieldWidth, fieldHeight;
  if (autoSize === true) 
  {
    autoSize = me.autoSizeDefault;
  }
  if (autoSize) 
  {
    fieldWidth = me.getDimension(owner, autoSize.width, 'getWidth', owner.width);
    fieldHeight = me.getDimension(owner, autoSize.height, 'getHeight', owner.height);
  }
  ownerContext.childItems[0].setSize(fieldWidth, fieldHeight);
  ownerContext.setWidth(fieldWidth);
  ownerContext.setHeight(fieldHeight);
  ownerContext.setContentSize(fieldWidth || owner.field.getWidth(), fieldHeight || owner.field.getHeight());
}, getDimension: function(owner, type, getMethod, ownerSize) {
  switch (type) {
    case 'boundEl':
      return owner.boundEl[getMethod]();
    case 'field':
      return undefined;
    default:
      return ownerSize;
  }
}}, 0, 0, 0, 0, ["layout.editor"], 0, [Ext.layout.container, 'Editor'], 0));
;

(Ext.cmd.derive('Ext.Editor', Ext.container.Container, {layout: 'editor', allowBlur: true, revertInvalid: true, value: '', alignment: 'c-c?', offsets: [0, 0], shadow: 'frame', constrain: false, swallowKeys: true, completeOnEnter: true, cancelOnEsc: true, updateEl: false, focusOnToFront: false, hidden: true, baseCls: Ext.baseCSSPrefix + 'editor', initComponent: function() {
  var me = this, field = me.field = Ext.ComponentManager.create(me.field, 'textfield');
  field.inEditor = true;
  field.msgTarget = field.msgTarget || 'qtip';
  me.mon(field, {scope: me, blur: me.onFieldBlur, specialkey: me.onSpecialKey});
  if (field.grow) 
  {
    me.mon(field, 'autosize', me.onFieldAutosize, me, {delay: 1});
  }
  me.floating = {constrain: me.constrain};
  me.items = field;
  me.callParent(arguments);
  me.addEvents('beforestartedit', 'startedit', 'beforecomplete', 'complete', 'canceledit', 'specialkey');
}, onFieldAutosize: function() {
  this.updateLayout();
}, afterRender: function(ct, position) {
  var me = this, field = me.field, inputEl = field.inputEl;
  me.callParent(arguments);
  if (inputEl) 
  {
    inputEl.dom.name = '';
    if (me.swallowKeys) 
    {
      inputEl.swallowEvent(['keypress', 'keydown']);
    }
  }
}, onSpecialKey: function(field, event) {
  var me = this, key = event.getKey(), complete = me.completeOnEnter && key == event.ENTER, cancel = me.cancelOnEsc && key == event.ESC;
  if (complete || cancel) 
  {
    event.stopEvent();
    Ext.defer(function() {
  if (complete) 
  {
    me.completeEdit();
  } else {
    me.cancelEdit();
  }
}, 1);
  }
  me.fireEvent('specialkey', me, field, event);
}, startEdit: function(el, value) {
  var me = this, field = me.field, dom;
  me.completeEdit();
  me.boundEl = Ext.get(el);
  dom = me.boundEl.dom;
  value = Ext.isDefined(value) ? value : Ext.String.trim(dom.textContent || dom.innerText || dom.innerHTML);
  if (!me.rendered && !me.renderTo && me.ownerCt) 
  {
    (me.renderTo = me.ownerCt.el).position();
  }
  if (me.fireEvent('beforestartedit', me, me.boundEl, value) !== false) 
  {
    me.startValue = value;
    me.show();
    field.suspendEvents();
    field.reset();
    field.setValue(value);
    field.resumeEvents();
    me.realign(true);
    field.focus([field.getRawValue().length]);
    if (field.autoSize) 
    {
      field.autoSize();
    }
    me.editing = true;
  }
}, realign: function(autoSize) {
  var me = this;
  if (autoSize === true) 
  {
    me.updateLayout();
  }
  me.alignTo(me.boundEl, me.alignment, me.offsets);
}, completeEdit: function(remainVisible) {
  var me = this, field = me.field, value;
  if (!me.editing) 
  {
    return;
  }
  if (field.assertValue) 
  {
    field.assertValue();
  }
  value = me.getValue();
  if (!field.isValid()) 
  {
    if (me.revertInvalid !== false) 
    {
      me.cancelEdit(remainVisible);
    }
    return;
  }
  if (String(value) === String(me.startValue) && me.ignoreNoChange) 
  {
    me.hideEdit(remainVisible);
    return;
  }
  if (me.fireEvent('beforecomplete', me, value, me.startValue) !== false) 
  {
    value = me.getValue();
    if (me.updateEl && me.boundEl) 
    {
      me.boundEl.update(value);
    }
    me.hideEdit(remainVisible);
    me.fireEvent('complete', me, value, me.startValue);
  }
}, onShow: function() {
  var me = this;
  me.callParent(arguments);
  if (me.hideEl !== false) 
  {
    me.boundEl.hide();
  }
  me.fireEvent('startedit', me, me.boundEl, me.startValue);
}, cancelEdit: function(remainVisible) {
  var me = this, startValue = me.startValue, field = me.field, value;
  if (me.editing) 
  {
    if (field) 
    {
      value = me.editedValue = me.getValue();
      field.suspendEvents();
      me.setValue(startValue);
      field.resumeEvents();
    }
    me.hideEdit(remainVisible);
    me.fireEvent('canceledit', me, value, startValue);
    delete me.editedValue;
  }
}, hideEdit: function(remainVisible) {
  if (remainVisible !== true) 
  {
    this.editing = false;
    this.hide();
  }
}, onFieldBlur: function(field, e) {
  var me = this, target = Ext.Element.getActiveElement();
  if (me.allowBlur === true && me.editing && me.selectSameEditor !== true) 
  {
    me.completeEdit();
  }
  if (Ext.fly(target).isFocusable() || target.getAttribute('tabIndex')) 
  {
    target.focus();
  }
}, onHide: function() {
  var me = this, field = me.field;
  if (me.editing) 
  {
    me.completeEdit();
    return;
  }
  if (field.hasFocus && field.triggerBlur) 
  {
    field.triggerBlur();
  }
  if (field.collapse) 
  {
    field.collapse();
  }
  if (me.hideEl !== false) 
  {
    me.boundEl.show();
  }
  me.callParent(arguments);
}, setValue: function(value) {
  this.field.setValue(value);
}, getValue: function() {
  return this.field.getValue();
}, beforeDestroy: function() {
  var me = this;
  Ext.destroy(me.field);
  delete me.field;
  delete me.boundEl;
  me.callParent(arguments);
}}, 0, ["editor"], ["container", "editor", "component", "box"], {"container": true, "editor": true, "component": true, "box": true}, ["widget.editor"], 0, [Ext, 'Editor'], 0));
;

(Ext.cmd.derive('Ext.util.KeyMap', Ext.Base, {alternateClassName: 'Ext.KeyMap', eventName: 'keydown', constructor: function(config) {
  var me = this;
  if ((arguments.length !== 1) || (typeof config === 'string') || config.dom || config.tagName || config === document || config.isComponent) 
  {
    me.legacyConstructor.apply(me, arguments);
    return;
  }
  Ext.apply(me, config);
  me.bindings = [];
  if (!me.target.isComponent) 
  {
    me.target = Ext.get(me.target);
  }
  if (me.binding) 
  {
    me.addBinding(me.binding);
  } else if (config.key) 
  {
    me.addBinding(config);
  }
  me.enable();
}, legacyConstructor: function(el, binding, eventName) {
  var me = this;
  Ext.apply(me, {target: Ext.get(el), eventName: eventName || me.eventName, bindings: []});
  if (binding) 
  {
    me.addBinding(binding);
  }
  me.enable();
}, addBinding: function(binding) {
  var me = this, keyCode = binding.key, i, len;
  if (me.processing) 
  {
    me.bindings = bindings.slice(0);
  }
  if (Ext.isArray(binding)) 
  {
    for (i = 0 , len = binding.length; i < len; i++) 
      {
        me.addBinding(binding[i]);
      }
    return;
  }
  me.bindings.push(Ext.apply({keyCode: me.processKeys(keyCode)}, binding));
}, removeBinding: function(binding) {
  var me = this, bindings = me.bindings, len = bindings.length, i, item, keys;
  if (me.processing) 
  {
    me.bindings = bindings.slice(0);
  }
  keys = me.processKeys(binding.key);
  for (i = 0; i < len; ++i) 
    {
      item = bindings[i];
      if ((item.fn || item.handler) === (binding.fn || binding.handler) && item.scope === binding.scope) 
      {
        if (binding.alt === item.alt && binding.crtl === item.crtl && binding.shift === item.shift) 
        {
          if (Ext.Array.equals(item.keyCode, keys)) 
          {
            Ext.Array.erase(me.bindings, i, 1);
            return;
          }
        }
      }
    }
}, processKeys: function(keyCode) {
  var processed = false, key, keys, keyString, len, i;
  if (Ext.isString(keyCode)) 
  {
    keys = [];
    keyString = keyCode.toUpperCase();
    for (i = 0 , len = keyString.length; i < len; ++i) 
      {
        keys.push(keyString.charCodeAt(i));
      }
    keyCode = keys;
    processed = true;
  }
  if (!Ext.isArray(keyCode)) 
  {
    keyCode = [keyCode];
  }
  if (!processed) 
  {
    for (i = 0 , len = keyCode.length; i < len; ++i) 
      {
        key = keyCode[i];
        if (Ext.isString(key)) 
        {
          keyCode[i] = key.toUpperCase().charCodeAt(0);
        }
      }
  }
  return keyCode;
}, handleTargetEvent: (function() {
  var tagRe = /input|textarea/i;
  return function(event) {
  var me = this, bindings, i, len, target, contentEditable;
  if (me.enabled) 
  {
    bindings = me.bindings;
    i = 0;
    len = bindings.length;
    event = me.processEvent.apply(me || me.processEventScope, arguments);
    if (me.ignoreInputFields) 
    {
      target = event.target;
      contentEditable = target.contentEditable;
      if (tagRe.test(target.tagName) || (contentEditable === '' || contentEditable === 'true')) 
      {
        return;
      }
    }
    if (!event.getKey) 
    {
      return event;
    }
    me.processing = true;
    for (; i < len; ++i) 
      {
        me.processBinding(bindings[i], event);
      }
    me.processing = false;
  }
};
}()), processEvent: Ext.identityFn, processBinding: function(binding, event) {
  if (this.checkModifiers(binding, event)) 
  {
    var key = event.getKey(), handler = binding.fn || binding.handler, scope = binding.scope || this, keyCode = binding.keyCode, defaultEventAction = binding.defaultEventAction, i, len, keydownEvent = new Ext.EventObjectImpl(event);
    for (i = 0 , len = keyCode.length; i < len; ++i) 
      {
        if (key === keyCode[i]) 
        {
          if (handler.call(scope, key, event) !== true && defaultEventAction) 
          {
            keydownEvent[defaultEventAction]();
          }
          break;
        }
      }
  }
}, checkModifiers: function(binding, event) {
  var keys = ['shift', 'ctrl', 'alt'], i = 0, len = keys.length, val, key;
  for (; i < len; ++i) 
    {
      key = keys[i];
      val = binding[key];
      if (!(val === undefined || (val === event[key + 'Key']))) 
      {
        return false;
      }
    }
  return true;
}, on: function(key, fn, scope) {
  var keyCode, shift, ctrl, alt;
  if (Ext.isObject(key) && !Ext.isArray(key)) 
  {
    keyCode = key.key;
    shift = key.shift;
    ctrl = key.ctrl;
    alt = key.alt;
  } else {
    keyCode = key;
  }
  this.addBinding({key: keyCode, shift: shift, ctrl: ctrl, alt: alt, fn: fn, scope: scope});
}, un: function(key, fn, scope) {
  var keyCode, shift, ctrl, alt;
  if (Ext.isObject(key) && !Ext.isArray(key)) 
  {
    keyCode = key.key;
    shift = key.shift;
    ctrl = key.ctrl;
    alt = key.alt;
  } else {
    keyCode = key;
  }
  this.removeBinding({key: keyCode, shift: shift, ctrl: ctrl, alt: alt, fn: fn, scope: scope});
}, isEnabled: function() {
  return this.enabled;
}, enable: function() {
  var me = this;
  if (!me.enabled) 
  {
    me.target.on(me.eventName, me.handleTargetEvent, me);
    me.enabled = true;
  }
}, disable: function() {
  var me = this;
  if (me.enabled) 
  {
    me.target.removeListener(me.eventName, me.handleTargetEvent, me);
    me.enabled = false;
  }
}, setDisabled: function(disabled) {
  if (disabled) 
  {
    this.disable();
  } else {
    this.enable();
  }
}, destroy: function(removeTarget) {
  var me = this, target = me.target;
  me.bindings = [];
  me.disable();
  if (removeTarget === true) 
  {
    if (target.isComponent) 
    {
      target.destroy();
    } else {
      target.remove();
    }
  }
  delete me.target;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'KeyMap', Ext, 'KeyMap'], 0));
;

(Ext.cmd.derive('Ext.util.KeyNav', Ext.Base, {alternateClassName: 'Ext.KeyNav', statics: {keyOptions: {left: 37, right: 39, up: 38, down: 40, space: 32, pageUp: 33, pageDown: 34, del: 46, backspace: 8, home: 36, end: 35, enter: 13, esc: 27, tab: 9}}, constructor: function(config) {
  var me = this;
  if (arguments.length === 2) 
  {
    me.legacyConstructor.apply(me, arguments);
    return;
  }
  me.setConfig(config);
}, legacyConstructor: function(el, config) {
  this.setConfig(Ext.apply({target: el}, config));
}, setConfig: function(config) {
  var me = this, keymapCfg = {target: config.target, ignoreInputFields: config.ignoreInputFields, eventName: me.getKeyEvent('forceKeyDown' in config ? config.forceKeyDown : me.forceKeyDown, config.eventName)}, map, keyCodes, defaultScope, keyName, binding;
  if (me.map) 
  {
    me.map.destroy();
  }
  if (config.processEvent) 
  {
    keymapCfg.processEvent = config.processEvent;
    keymapCfg.processEventScope = config.processEventScope || me;
  }
  if (config.keyMap) 
  {
    map = me.map = config.keyMap;
  } else {
    map = me.map = new Ext.util.KeyMap(keymapCfg);
    me.destroyKeyMap = true;
  }
  keyCodes = Ext.util.KeyNav.keyOptions;
  defaultScope = config.scope || me;
  for (keyName in config) 
    {
      binding = config[keyName];
      if (binding && (keyName.length === 1 || (keyName = keyCodes[keyName]) || (!isNaN(keyName = parseInt(keyName, 10))))) 
      {
        if (typeof binding === 'function') 
        {
          binding = {handler: binding, defaultEventAction: (config.defaultEventAction !== undefined) ? config.defaultEventAction : me.defaultEventAction};
        }
        map.addBinding({key: keyName, ctrl: binding.ctrl, shift: binding.shift, alt: binding.alt, handler: Ext.Function.bind(me.handleEvent, binding.scope || defaultScope, binding.handler || binding.fn, true), defaultEventAction: (binding.defaultEventAction !== undefined) ? binding.defaultEventAction : me.defaultEventAction});
      }
    }
  map.disable();
  if (!config.disabled) 
  {
    map.enable();
  }
}, handleEvent: function(keyCode, event, handler) {
  return handler.call(this, event);
}, disabled: false, defaultEventAction: "stopEvent", forceKeyDown: false, eventName: 'keypress', destroy: function(removeEl) {
  if (this.destroyKeyMap) 
  {
    this.map.destroy(removeEl);
  }
  delete this.map;
}, enable: function() {
  if (this.map) 
  {
    this.map.enable();
    this.disabled = false;
  }
}, disable: function() {
  if (this.map) 
  {
    this.map.disable();
  }
  this.disabled = true;
}, setDisabled: function(disabled) {
  this.map.setDisabled(disabled);
  this.disabled = disabled;
}, getKeyEvent: function(forceKeyDown, configuredEventName) {
  if (forceKeyDown || (Ext.EventManager.useKeyDown && !configuredEventName)) 
  {
    return 'keydown';
  } else {
    return configuredEventName || this.eventName;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'KeyNav', Ext, 'KeyNav'], 0));
;

(Ext.cmd.derive('Ext.Img', Ext.Component, {autoEl: 'img', baseCls: Ext.baseCSSPrefix + 'img', src: '', alt: '', title: '', imgCls: '', ariaRole: 'img', maskOnDisable: false, initComponent: function() {
  if (this.glyph) 
  {
    this.autoEl = 'div';
  }
  this.callParent();
}, getElConfig: function() {
  var me = this, autoEl = me.autoEl, config = me.callParent(), glyphFontFamily = Ext._glyphFontFamily, glyph = me.glyph, img, glyphParts;
  if (autoEl === 'img' || (Ext.isObject(autoEl) && autoEl.tag === 'img')) 
  {
    img = config;
  } else if (me.glyph) 
  {
    if (typeof glyph === 'string') 
    {
      glyphParts = glyph.split('@');
      glyph = glyphParts[0];
      glyphFontFamily = glyphParts[1];
    }
    config.html = '&#' + glyph + ';';
    if (glyphFontFamily) 
    {
      config.style = 'font-family:' + glyphFontFamily;
    }
  } else {
    config.cn = [img = {tag: 'img', role: me.ariaRole, id: me.id + '-img'}];
  }
  if (img) 
  {
    if (me.imgCls) 
    {
      img.cls = (img.cls ? img.cls + ' ' : '') + me.imgCls;
    }
    img.src = me.src || Ext.BLANK_IMAGE_URL;
  }
  if (me.alt) 
  {
    (img || config).alt = me.alt;
  }
  if (me.title) 
  {
    (img || config).title = me.title;
  }
  return config;
}, onRender: function() {
  var me = this, autoEl = me.autoEl, el;
  me.callParent(arguments);
  el = me.el;
  if (autoEl === 'img' || (Ext.isObject(autoEl) && autoEl.tag === 'img')) 
  {
    me.imgEl = el;
  } else {
    me.imgEl = el.getById(me.id + '-img');
  }
}, onDestroy: function() {
  Ext.destroy(this.imgEl);
  this.imgEl = null;
  this.callParent();
}, setSrc: function(src) {
  var me = this, imgEl = me.imgEl;
  me.src = src;
  if (imgEl) 
  {
    imgEl.dom.src = src || Ext.BLANK_IMAGE_URL;
  }
}, setGlyph: function(glyph) {
  var me = this, glyphFontFamily = Ext._glyphFontFamily, glyphParts, dom;
  if (glyph != me.glyph) 
  {
    if (typeof glyph === 'string') 
    {
      glyphParts = glyph.split('@');
      glyph = glyphParts[0];
      glyphFontFamily = glyphParts[1];
    }
    dom = me.el.dom;
    dom.innerHTML = '&#' + glyph + ';';
    if (glyphFontFamily) 
    {
      dom.style = 'font-family:' + glyphFontFamily;
    }
  }
}}, 0, ["image", "imagecomponent"], ["image", "component", "box", "imagecomponent"], {"image": true, "component": true, "box": true, "imagecomponent": true}, ["widget.image", "widget.imagecomponent"], 0, [Ext, 'Img'], 0));
;

(Ext.cmd.derive('Ext.util.Bindable', Ext.Base, {bindStore: function(store, initial, propertyName) {
  propertyName = propertyName || 'store';
  var me = this, oldStore = me[propertyName];
  if (!initial && oldStore) 
  {
    me.onUnbindStore(oldStore, initial, propertyName);
    if (store !== oldStore && oldStore.autoDestroy) 
    {
      oldStore.destroyStore();
    } else {
      me.unbindStoreListeners(oldStore);
    }
  }
  if (store) 
  {
    store = Ext.data.StoreManager.lookup(store);
    me.bindStoreListeners(store);
    me.onBindStore(store, initial, propertyName);
  }
  me[propertyName] = store || null;
  return me;
}, getStore: function() {
  return this.store;
}, unbindStoreListeners: function(store) {
  var listeners = this.storeListeners;
  if (listeners) 
  {
    store.un(listeners);
  }
}, bindStoreListeners: function(store) {
  var me = this, listeners = Ext.apply({}, me.getStoreListeners(store));
  if (!listeners.scope) 
  {
    listeners.scope = me;
  }
  me.storeListeners = listeners;
  store.on(listeners);
}, getStoreListeners: Ext.emptyFn, onUnbindStore: Ext.emptyFn, onBindStore: Ext.emptyFn}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Bindable'], 0));
;

(Ext.cmd.derive('Ext.LoadMask', Ext.Component, {isLoadMask: true, msg: 'Loading...', msgCls: Ext.baseCSSPrefix + 'mask-loading', maskCls: Ext.baseCSSPrefix + 'mask', cls: Ext.baseCSSPrefix + 'mask-msg', useMsg: true, useTargetEl: false, ariaRole: 'presentation', childEls: ['msgEl', 'msgTextEl'], renderTpl: ['<div id="{id}-msgEl" role="{role}"', '<tpl if="ariaAttr"> {ariaAttr}</tpl>', ' class="{[values.$comp.msgCls]} ', Ext.baseCSSPrefix, 'mask-msg-inner {childElCls}">', '<div id="{id}-msgTextEl" class="', Ext.baseCSSPrefix, 'mask-msg-text', '{childElCls}">{msg}</div>', '</div>'], constructor: function(config) {
  var me = this, comp;
  if (arguments.length === 2) 
  {
    comp = me.target = config;
    config = arguments[1];
  } else {
    comp = config.target;
  }
  me.callParent([config]);
  if (comp.isComponent) 
  {
    me.ownerCt = comp;
    me.hidden = true;
    me.renderTo = me.getMaskTarget();
    me.external = me.renderTo === Ext.getBody();
    me.bindComponent(comp);
  } else {
    comp = Ext.get(comp);
    me.isElement = true;
    me.renderTo = me.target;
  }
  me.render(me.renderTo);
  if (me.store) 
  {
    me.bindStore(me.store, true);
  }
}, getRenderTree: function() {
  return [{cls: this.maskCls, style: 'display:none'}, this.callParent()];
}, onRender: function() {
  this.callParent(arguments);
  this.maskEl = this.el.prev();
}, initRenderData: function() {
  var result = this.callParent(arguments);
  result.msg = this.msg || '';
  return result;
}, bindComponent: function(comp) {
  var me = this, listeners = {scope: this, resize: me.sizeMask};
  if (me.external) 
  {
    listeners.added = me.onComponentAdded;
    listeners.removed = me.onComponentRemoved;
    if (comp.floating) 
    {
      listeners.move = me.sizeMask;
      me.activeOwner = comp;
    } else if (comp.ownerCt) 
    {
      me.onComponentAdded(comp.ownerCt);
    }
  }
  me.mon(comp, listeners);
  if (me.external) 
  {
    me.mon(me.hierarchyEventSource, {show: me.onContainerShow, hide: me.onContainerHide, expand: me.onContainerExpand, collapse: me.onContainerCollapse, scope: me});
  }
}, onComponentAdded: function(owner) {
  var me = this;
  delete me.activeOwner;
  me.floatParent = owner;
  if (!owner.floating) 
  {
    owner = owner.up('[floating]');
  }
  if (owner) 
  {
    me.activeOwner = owner;
    me.mon(owner, 'move', me.sizeMask, me);
    me.mon(owner, 'tofront', me.onOwnerToFront, me);
  } else {
    me.preventBringToFront = true;
  }
  owner = me.floatParent.ownerCt;
  if (me.rendered && me.isVisible() && owner) 
  {
    me.floatOwner = owner;
    me.mon(owner, 'afterlayout', me.sizeMask, me, {single: true});
  }
}, onComponentRemoved: function(owner) {
  var me = this, activeOwner = me.activeOwner, floatOwner = me.floatOwner;
  if (activeOwner) 
  {
    me.mun(activeOwner, 'move', me.sizeMask, me);
    me.mun(activeOwner, 'tofront', me.onOwnerToFront, me);
  }
  if (floatOwner) 
  {
    me.mun(floatOwner, 'afterlayout', me.sizeMask, me);
  }
  delete me.activeOwner;
  delete me.floatOwner;
}, afterRender: function() {
  this.callParent(arguments);
  this.el.$cache.skipGarbageCollection = true;
  this.maskEl.$cache.skipGarbageCollection = true;
}, onOwnerToFront: function(owner, zIndex) {
  this.maskEl.setStyle('zIndex', zIndex + 1);
  this.el.setStyle('zIndex', zIndex + 2);
}, onContainerShow: function(container) {
  this.onComponentShow();
}, onContainerHide: function(container) {
  this.onComponentHide();
}, onContainerExpand: function(container) {
  this.onComponentShow();
}, onContainerCollapse: function(container) {
  this.onComponentHide();
}, onComponentHide: function() {
  var me = this;
  if (me.rendered && me.isVisible()) 
  {
    me.hide();
    me.showNext = true;
  }
}, onComponentShow: function() {
  if (this.showNext) 
  {
    this.show();
  }
  delete this.showNext;
}, sizeMask: function() {
  var me = this, target = me.target, boxTarget = me.external ? me.getOwner().el : me.getMaskTarget();
  if (me.rendered && me.isVisible()) 
  {
    if (me.external) 
    {
      if (!me.isElement && target.floating) 
      {
        me.onOwnerToFront(target, target.el.getZIndex());
      }
      me.maskEl.setSize(boxTarget.getSize()).alignTo(boxTarget, 'tl-tl');
    }
    me.el.center(me.maskEl);
  }
}, bindStore: function(store, initial) {
  var me = this;
  me.mixins.bindable.bindStore.apply(me, arguments);
  store = me.store;
  if (store && store.isLoading()) 
  {
    me.onBeforeLoad();
  }
}, getStoreListeners: function(store) {
  var load = this.onLoad, beforeLoad = this.onBeforeLoad, result = {cachemiss: beforeLoad, cachefilled: load};
  if (!store.proxy.isSynchronous) 
  {
    result.beforeLoad = beforeLoad;
    result.load = load;
  }
  return result;
}, onDisable: function() {
  this.callParent(arguments);
  if (this.loading) 
  {
    this.onLoad();
  }
}, getOwner: function() {
  return this.ownerCt || this.floatParent;
}, getMaskTarget: function() {
  var owner = this.getOwner();
  if (this.isElement) 
  {
    return this.target;
  }
  return this.useTargetEl ? owner.getTargetEl() : (owner.getMaskTarget() || Ext.getBody());
}, onBeforeLoad: function() {
  var me = this, owner = me.getOwner(), origin;
  if (!me.disabled) 
  {
    me.loading = true;
    if (owner.componentLayoutCounter) 
    {
      me.maybeShow();
    } else {
      origin = owner.afterComponentLayout;
      owner.afterComponentLayout = function() {
  owner.afterComponentLayout = origin;
  origin.apply(owner, arguments);
  me.maybeShow();
};
    }
  }
}, maybeShow: function() {
  var me = this, owner = me.getOwner();
  if (!owner.isVisible(true)) 
  {
    me.showNext = true;
  } else if (me.loading && owner.rendered) 
  {
    me.show();
  }
}, hide: function() {
  if (this.isElement) 
  {
    this.ownerCt.unmask();
    this.fireEvent('hide', this);
    return;
  }
  delete this.showNext;
  this.maskEl.setDisplayed(false);
  return this.callParent(arguments);
}, show: function() {
  if (this.isElement) 
  {
    this.ownerCt.mask(this.useMsg ? this.msg : '', this.msgCls);
    this.fireEvent('show', this);
    return;
  }
  this.maskEl.setDisplayed(true);
  return this.callParent(arguments);
}, afterShow: function() {
  var me = this;
  me.loading = true;
  me.callParent(arguments);
  if (me.hasOwnProperty('maskCls')) 
  {
    me.maskEl.dom.className = me.maskCls;
  }
  if (me.useMsg) 
  {
    me.msgTextEl.update(me.msg);
  } else {
    me.el.hide();
  }
  me.sizeMask();
}, onLoad: function() {
  this.loading = false;
  this.hide();
}, beforeDestroy: function() {
  this.ownerCt = null;
  this.callParent();
}, onDestroy: function() {
  var me = this;
  if (me.isElement) 
  {
    me.ownerCt.unmask();
  }
  Ext.destroy(me.maskEl);
  me.callParent();
}}, 1, ["loadmask"], ["component", "box", "loadmask"], {"component": true, "box": true, "loadmask": true}, ["widget.loadmask"], [['bindable', Ext.util.Bindable]], [Ext, 'LoadMask'], 0));
;

(Ext.cmd.derive('Ext.data.association.Association', Ext.Base, {alternateClassName: 'Ext.data.Association', primaryKey: 'id', associationKeyFunction: null, defaultReaderType: 'json', isAssociation: true, initialConfig: null, statics: {AUTO_ID: 1000, create: function(association) {
  if (Ext.isString(association)) 
  {
    association = {type: association};
  }
  switch (association.type) {
    case 'belongsTo':
      return new Ext.data.association.BelongsTo(association);
    case 'hasMany':
      return new Ext.data.association.HasMany(association);
    case 'hasOne':
      return new Ext.data.association.HasOne(association);
    default:
  }
  return association;
}}, constructor: function(config) {
  Ext.apply(this, config);
  var me = this, types = Ext.ModelManager.types, ownerName = config.ownerModel, associatedName = config.associatedModel, ownerModel = types[ownerName], associatedModel = types[associatedName], associationKey = config.associationKey, keyReIdx;
  if (associationKey) 
  {
    keyReIdx = String(associationKey).search(/[\[\.]/);
    if (keyReIdx >= 0) 
    {
      me.associationKeyFunction = Ext.functionFactory('obj', 'return obj' + (keyReIdx > 0 ? '.' : '') + associationKey);
    }
  }
  me.initialConfig = config;
  me.ownerModel = ownerModel;
  me.associatedModel = associatedModel;
  Ext.applyIf(me, {ownerName: ownerName, associatedName: associatedName});
  me.associationId = 'association' + (++me.statics().AUTO_ID);
}, getReader: function() {
  var me = this, reader = me.reader, model = me.associatedModel;
  if (reader) 
  {
    if (Ext.isString(reader)) 
    {
      reader = {type: reader};
    }
    if (reader.isReader) 
    {
      reader.setModel(model);
    } else {
      Ext.applyIf(reader, {model: model, type: me.defaultReaderType});
    }
    me.reader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  return me.reader || null;
}}, 1, 0, 0, 0, 0, 0, [Ext.data.association, 'Association', Ext.data, 'Association'], 0));
;

(Ext.cmd.derive('Ext.ModelManager', Ext.AbstractManager, {alternateClassName: 'Ext.ModelMgr', singleton: true, typeName: 'mtype', associationStack: [], registerType: function(name, config) {
  var proto = config.prototype, model;
  if (proto && proto.isModel) 
  {
    model = config;
  } else {
    if (!config.extend) 
    {
      config.extend = 'Ext.data.Model';
    }
    model = Ext.define(name, config);
  }
  this.types[name] = model;
  return model;
}, unregisterType: function(name) {
  delete this.types[name];
}, onModelDefined: function(model) {
  var stack = this.associationStack, length = stack.length, create = [], association, i, created;
  for (i = 0; i < length; i++) 
    {
      association = stack[i];
      if (association.associatedModel == model.modelName) 
      {
        create.push(association);
      }
    }
  for (i = 0 , length = create.length; i < length; i++) 
    {
      created = create[i];
      this.types[created.ownerModel].prototype.associations.add(Ext.data.association.Association.create(created));
      Ext.Array.remove(stack, created);
    }
}, registerDeferredAssociation: function(association) {
  this.associationStack.push(association);
}, getModel: function(id) {
  var model = id;
  if (typeof model == 'string') 
  {
    model = this.types[model];
  }
  return model;
}, create: function(config, name, id) {
  var Con = typeof name == 'function' ? name : this.types[name || config.name];
  return new Con(config, id);
}}, 0, 0, 0, 0, 0, 0, [Ext, 'ModelManager', Ext, 'ModelMgr'], function() {
  Ext.regModel = function() {
  return this.ModelManager.registerType.apply(this.ModelManager, arguments);
};
}));
;

(Ext.cmd.derive('Ext.layout.component.Component', Ext.layout.Layout, {type: 'component', isComponentLayout: true, nullBox: {}, usesContentHeight: true, usesContentWidth: true, usesHeight: true, usesWidth: true, beginLayoutCycle: function(ownerContext, firstCycle) {
  var me = this, owner = me.owner, ownerCtContext = ownerContext.ownerCtContext, heightModel = ownerContext.heightModel, widthModel = ownerContext.widthModel, body = owner.el.dom === document.body, lastBox = owner.lastBox || me.nullBox, lastSize = owner.el.lastBox || me.nullBox, dirty = !body, ownerLayout, v, widthName, heightName;
  me.callParent(arguments);
  if (firstCycle) 
  {
    if (me.usesContentWidth) 
    {
      ++ownerContext.consumersContentWidth;
    }
    if (me.usesContentHeight) 
    {
      ++ownerContext.consumersContentHeight;
    }
    if (me.usesWidth) 
    {
      ++ownerContext.consumersWidth;
    }
    if (me.usesHeight) 
    {
      ++ownerContext.consumersHeight;
    }
    if (ownerCtContext && !ownerCtContext.hasRawContent) 
    {
      ownerLayout = owner.ownerLayout;
      if (ownerLayout.usesWidth) 
      {
        ++ownerContext.consumersWidth;
      }
      if (ownerLayout.usesHeight) 
      {
        ++ownerContext.consumersHeight;
      }
    }
  }
  if (widthModel.configured) 
  {
    widthName = widthModel.names.width;
    if (!body) 
    {
      dirty = me.setWidthInDom || (firstCycle ? owner[widthName] !== lastSize.width : widthModel.constrained);
    }
    ownerContext.setWidth(owner[widthName], dirty);
  } else if (ownerContext.isTopLevel) 
  {
    if (widthModel.calculated) 
    {
      v = lastBox.width;
      ownerContext.setWidth(v, v != lastSize.width);
    }
    v = lastBox.x;
    ownerContext.setProp('x', v, v != lastSize.x);
  }
  if (heightModel.configured) 
  {
    heightName = heightModel.names.height;
    if (!body) 
    {
      dirty = firstCycle ? owner[heightName] !== lastSize.height : heightModel.constrained;
    }
    ownerContext.setHeight(owner[heightName], dirty);
  } else if (ownerContext.isTopLevel) 
  {
    if (heightModel.calculated) 
    {
      v = lastBox.height;
      ownerContext.setHeight(v, v != lastSize.height);
    }
    v = lastBox.y;
    ownerContext.setProp('y', v, v != lastSize.y);
  }
}, finishedLayout: function(ownerContext) {
  var me = this, elementChildren = ownerContext.children, owner = me.owner, len, i, elContext, lastBox, props;
  if (elementChildren) 
  {
    len = elementChildren.length;
    for (i = 0; i < len; i++) 
      {
        elContext = elementChildren[i];
        elContext.el.lastBox = elContext.props;
      }
  }
  ownerContext.previousSize = me.lastComponentSize;
  me.lastComponentSize = owner.el.lastBox = props = ownerContext.props;
  lastBox = owner.lastBox || (owner.lastBox = {});
  lastBox.x = props.x;
  lastBox.y = props.y;
  lastBox.width = props.width;
  lastBox.height = props.height;
  lastBox.invalid = false;
  me.callParent(arguments);
}, notifyOwner: function(ownerContext) {
  var me = this, currentSize = me.lastComponentSize, prevSize = ownerContext.previousSize, args = [currentSize.width, currentSize.height];
  if (prevSize) 
  {
    args.push(prevSize.width, prevSize.height);
  }
  me.owner.afterComponentLayout.apply(me.owner, args);
}, getTarget: function() {
  return this.owner.el;
}, getRenderTarget: function() {
  return this.owner.el;
}, cacheTargetInfo: function(ownerContext) {
  var me = this, targetInfo = me.targetInfo, target;
  if (!targetInfo) 
  {
    target = ownerContext.getEl('getTarget', me);
    me.targetInfo = targetInfo = {padding: target.getPaddingInfo(), border: target.getBorderInfo()};
  }
  return targetInfo;
}, measureAutoDimensions: function(ownerContext, dimensions) {
  var me = this, owner = me.owner, containerLayout = owner.layout, heightModel = ownerContext.heightModel, widthModel = ownerContext.widthModel, boxParent = ownerContext.boxParent, isBoxParent = ownerContext.isBoxParent, props = ownerContext.props, isContainer, ret = {gotWidth: false, gotHeight: false, isContainer: (isContainer = !ownerContext.hasRawContent)}, hv = dimensions || 3, zeroWidth, zeroHeight, needed = 0, got = 0, ready, size, temp;
  if (widthModel.shrinkWrap && ownerContext.consumersContentWidth) 
  {
    ++needed;
    zeroWidth = !(hv & 1);
    if (isContainer) 
    {
      if (zeroWidth) 
      {
        ret.contentWidth = 0;
        ret.gotWidth = true;
        ++got;
      } else if ((ret.contentWidth = ownerContext.getProp('contentWidth')) !== undefined) 
      {
        ret.gotWidth = true;
        ++got;
      }
    } else {
      size = props.contentWidth;
      if (typeof size == 'number') 
      {
        ret.contentWidth = size;
        ret.gotWidth = true;
        ++got;
      } else {
        if (zeroWidth) 
        {
          ready = true;
        } else if (!ownerContext.hasDomProp('containerChildrenSizeDone')) 
        {
          ready = false;
        } else if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) 
        {
          ready = true;
        } else {
          ready = boxParent.hasDomProp('width');
        }
        if (ready) 
        {
          if (zeroWidth) 
          {
            temp = 0;
          } else if (containerLayout && containerLayout.measureContentWidth) 
          {
            temp = containerLayout.measureContentWidth(ownerContext);
          } else {
            temp = me.measureContentWidth(ownerContext);
          }
          if (!isNaN(ret.contentWidth = temp)) 
          {
            ownerContext.setContentWidth(temp, true);
            ret.gotWidth = true;
            ++got;
          }
        }
      }
    }
  } else if (widthModel.natural && ownerContext.consumersWidth) 
  {
    ++needed;
    size = props.width;
    if (typeof size == 'number') 
    {
      ret.width = size;
      ret.gotWidth = true;
      ++got;
    } else {
      if (isBoxParent || !boxParent) 
      {
        ready = true;
      } else {
        ready = boxParent.hasDomProp('width');
      }
      if (ready) 
      {
        if (!isNaN(ret.width = me.measureOwnerWidth(ownerContext))) 
        {
          ownerContext.setWidth(ret.width, false);
          ret.gotWidth = true;
          ++got;
        }
      }
    }
  }
  if (heightModel.shrinkWrap && ownerContext.consumersContentHeight) 
  {
    ++needed;
    zeroHeight = !(hv & 2);
    if (isContainer) 
    {
      if (zeroHeight) 
      {
        ret.contentHeight = 0;
        ret.gotHeight = true;
        ++got;
      } else if ((ret.contentHeight = ownerContext.getProp('contentHeight')) !== undefined) 
      {
        ret.gotHeight = true;
        ++got;
      }
    } else {
      size = props.contentHeight;
      if (typeof size == 'number') 
      {
        ret.contentHeight = size;
        ret.gotHeight = true;
        ++got;
      } else {
        if (zeroHeight) 
        {
          ready = true;
        } else if (!ownerContext.hasDomProp('containerChildrenSizeDone')) 
        {
          ready = false;
        } else if (owner.noWrap) 
        {
          ready = true;
        } else if (!widthModel.shrinkWrap) 
        {
          ready = (ownerContext.bodyContext || ownerContext).hasDomProp('width');
        } else if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) 
        {
          ready = true;
        } else {
          ready = boxParent.hasDomProp('width');
        }
        if (ready) 
        {
          if (zeroHeight) 
          {
            temp = 0;
          } else if (containerLayout && containerLayout.measureContentHeight) 
          {
            temp = containerLayout.measureContentHeight(ownerContext);
          } else {
            temp = me.measureContentHeight(ownerContext);
          }
          if (!isNaN(ret.contentHeight = temp)) 
          {
            ownerContext.setContentHeight(temp, true);
            ret.gotHeight = true;
            ++got;
          }
        }
      }
    }
  } else if (heightModel.natural && ownerContext.consumersHeight) 
  {
    ++needed;
    size = props.height;
    if (typeof size == 'number') 
    {
      ret.height = size;
      ret.gotHeight = true;
      ++got;
    } else {
      if (isBoxParent || !boxParent) 
      {
        ready = true;
      } else {
        ready = boxParent.hasDomProp('width');
      }
      if (ready) 
      {
        if (!isNaN(ret.height = me.measureOwnerHeight(ownerContext))) 
        {
          ownerContext.setHeight(ret.height, false);
          ret.gotHeight = true;
          ++got;
        }
      }
    }
  }
  if (boxParent) 
  {
    ownerContext.onBoxMeasured();
  }
  ret.gotAll = got == needed;
  return ret;
}, measureContentWidth: function(ownerContext) {
  return ownerContext.el.getWidth() - ownerContext.getFrameInfo().width;
}, measureContentHeight: function(ownerContext) {
  return ownerContext.el.getHeight() - ownerContext.getFrameInfo().height;
}, measureOwnerHeight: function(ownerContext) {
  return ownerContext.el.getHeight();
}, measureOwnerWidth: function(ownerContext) {
  return ownerContext.el.getWidth();
}}, 0, 0, 0, 0, 0, 0, [Ext.layout.component, 'Component'], 0));
;

(Ext.cmd.derive('Ext.layout.component.Auto', Ext.layout.component.Component, {type: 'autocomponent', setHeightInDom: false, setWidthInDom: false, waitForOuterHeightInDom: false, waitForOuterWidthInDom: false, beginLayoutCycle: function(ownerContext, firstCycle) {
  var me = this, lastWidthModel = me.lastWidthModel, lastHeightModel = me.lastHeightModel, el = me.owner.el;
  me.callParent(arguments);
  if (lastWidthModel && lastWidthModel.fixed && ownerContext.widthModel.shrinkWrap) 
  {
    el.setWidth(null);
  }
  if (lastHeightModel && lastHeightModel.fixed && ownerContext.heightModel.shrinkWrap) 
  {
    el.setHeight(null);
  }
}, calculate: function(ownerContext) {
  var me = this, measurement = me.measureAutoDimensions(ownerContext), heightModel = ownerContext.heightModel, widthModel = ownerContext.widthModel, width, height;
  if (measurement.gotWidth) 
  {
    if (widthModel.shrinkWrap) 
    {
      me.publishOwnerWidth(ownerContext, measurement.contentWidth);
    } else if (me.publishInnerWidth) 
    {
      me.publishInnerWidth(ownerContext, measurement.width);
    }
  } else if (!widthModel.auto && me.publishInnerWidth) 
  {
    width = me.waitForOuterWidthInDom ? ownerContext.getDomProp('width') : ownerContext.getProp('width');
    if (width === undefined) 
    {
      me.done = false;
    } else {
      me.publishInnerWidth(ownerContext, width);
    }
  }
  if (measurement.gotHeight) 
  {
    if (heightModel.shrinkWrap) 
    {
      me.publishOwnerHeight(ownerContext, measurement.contentHeight);
    } else if (me.publishInnerHeight) 
    {
      me.publishInnerHeight(ownerContext, measurement.height);
    }
  } else if (!heightModel.auto && me.publishInnerHeight) 
  {
    height = me.waitForOuterHeightInDom ? ownerContext.getDomProp('height') : ownerContext.getProp('height');
    if (height === undefined) 
    {
      me.done = false;
    } else {
      me.publishInnerHeight(ownerContext, height);
    }
  }
  if (!measurement.gotAll) 
  {
    me.done = false;
  }
}, calculateOwnerHeightFromContentHeight: function(ownerContext, contentHeight) {
  return contentHeight + ownerContext.getFrameInfo().height;
}, calculateOwnerWidthFromContentWidth: function(ownerContext, contentWidth) {
  return contentWidth + ownerContext.getFrameInfo().width;
}, publishOwnerHeight: function(ownerContext, contentHeight) {
  var me = this, owner = me.owner, height = me.calculateOwnerHeightFromContentHeight(ownerContext, contentHeight), constrainedHeight, dirty, heightModel;
  if (isNaN(height)) 
  {
    me.done = false;
  } else {
    constrainedHeight = Ext.Number.constrain(height, owner.minHeight, owner.maxHeight);
    if (constrainedHeight == height) 
    {
      dirty = me.setHeightInDom;
    } else {
      heightModel = me.sizeModels[(constrainedHeight < height) ? 'constrainedMax' : 'constrainedMin'];
      height = constrainedHeight;
      if (ownerContext.heightModel.calculatedFromShrinkWrap) 
      {
        ownerContext.heightModel = heightModel;
      } else {
        ownerContext.invalidate({heightModel: heightModel});
      }
    }
    ownerContext.setHeight(height, dirty);
  }
}, publishOwnerWidth: function(ownerContext, contentWidth) {
  var me = this, owner = me.owner, width = me.calculateOwnerWidthFromContentWidth(ownerContext, contentWidth), constrainedWidth, dirty, widthModel;
  if (isNaN(width)) 
  {
    me.done = false;
  } else {
    constrainedWidth = Ext.Number.constrain(width, owner.minWidth, owner.maxWidth);
    if (constrainedWidth == width) 
    {
      dirty = me.setWidthInDom;
    } else {
      widthModel = me.sizeModels[(constrainedWidth < width) ? 'constrainedMax' : 'constrainedMin'];
      width = constrainedWidth;
      if (ownerContext.widthModel.calculatedFromShrinkWrap) 
      {
        ownerContext.widthModel = widthModel;
      } else {
        ownerContext.invalidate({widthModel: widthModel});
      }
    }
    ownerContext.setWidth(width, dirty);
  }
}}, 0, 0, 0, 0, ["layout.autocomponent"], 0, [Ext.layout.component, 'Auto'], 0));
;

(Ext.cmd.derive('Ext.layout.component.ProgressBar', Ext.layout.component.Auto, {type: 'progressbar', beginLayout: function(ownerContext) {
  var me = this, i, textEls;
  me.callParent(arguments);
  if (!ownerContext.textEls) 
  {
    textEls = me.owner.textEl;
    if (textEls.isComposite) 
    {
      ownerContext.textEls = [];
      textEls = textEls.elements;
      for (i = textEls.length; i--; ) 
        {
          ownerContext.textEls[i] = ownerContext.getEl(Ext.get(textEls[i]));
        }
    } else {
      ownerContext.textEls = [ownerContext.getEl('textEl')];
    }
  }
}, calculate: function(ownerContext) {
  var me = this, i, textEls, width;
  me.callParent(arguments);
  if (Ext.isNumber(width = ownerContext.getProp('width'))) 
  {
    width -= ownerContext.getBorderInfo().width;
    textEls = ownerContext.textEls;
    for (i = textEls.length; i--; ) 
      {
        textEls[i].setWidth(width);
      }
  } else {
    me.done = false;
  }
}}, 0, 0, 0, 0, ["layout.progressbar"], 0, [Ext.layout.component, 'ProgressBar'], 0));
;

(Ext.cmd.derive('Ext.ProgressBar', Ext.Component, {baseCls: Ext.baseCSSPrefix + 'progress', animate: false, text: '', waitTimer: null, childEls: ['bar'], renderTpl: ['<tpl if="internalText">', '<div class="{baseCls}-text {baseCls}-text-back">{text}</div>', '</tpl>', '<div id="{id}-bar" class="{baseCls}-bar {baseCls}-bar-{ui}" role="presentation" style="width:{percentage}%">', '<tpl if="internalText">', '<div class="{baseCls}-text">', '<div>{text}</div>', '</div>', '</tpl>', '</div>'], componentLayout: 'progressbar', ariaRole: 'progressbar', initComponent: function() {
  this.callParent();
  this.addEvents("update");
}, initRenderData: function() {
  var me = this;
  return Ext.apply(me.callParent(), {internalText: !me.hasOwnProperty('textEl'), text: me.text || '&#160;', percentage: me.value ? me.value * 100 : 0});
}, onRender: function() {
  var me = this;
  me.callParent(arguments);
  if (me.textEl) 
  {
    me.textEl = Ext.get(me.textEl);
    me.updateText(me.text);
  } else {
    me.textEl = me.el.select('.' + me.baseCls + '-text');
  }
}, updateProgress: function(value, text, animate) {
  var me = this, oldValue = me.value;
  me.value = value || 0;
  if (text) 
  {
    me.updateText(text);
  }
  if (me.rendered && !me.isDestroyed) 
  {
    if (animate === true || (animate !== false && me.animate)) 
    {
      me.bar.stopAnimation();
      me.bar.animate(Ext.apply({from: {width: (oldValue * 100) + '%'}, to: {width: (me.value * 100) + '%'}}, me.animate));
    } else {
      me.bar.setStyle('width', (me.value * 100) + '%');
    }
  }
  me.fireEvent('update', me, me.value, text);
  return me;
}, updateText: function(text) {
  var me = this;
  me.text = text;
  if (me.rendered) 
  {
    me.textEl.update(me.text);
  }
  return me;
}, applyText: function(text) {
  this.updateText(text);
}, getText: function() {
  return this.text;
}, wait: function(o) {
  var me = this, scope;
  if (!me.waitTimer) 
  {
    scope = me;
    o = o || {};
    me.updateText(o.text);
    me.waitTimer = Ext.TaskManager.start({run: function(i) {
  var inc = o.increment || 10;
  i -= 1;
  me.updateProgress(((((i + inc) % inc) + 1) * (100 / inc)) * 0.01, null, o.animate);
}, interval: o.interval || 1000, duration: o.duration, onStop: function() {
  if (o.fn) 
  {
    o.fn.apply(o.scope || me);
  }
  me.reset();
}, scope: scope});
  }
  return me;
}, isWaiting: function() {
  return this.waitTimer !== null;
}, reset: function(hide) {
  var me = this;
  me.updateProgress(0);
  me.clearTimer();
  if (hide === true) 
  {
    me.hide();
  }
  return me;
}, clearTimer: function() {
  var me = this;
  if (me.waitTimer) 
  {
    me.waitTimer.onStop = null;
    Ext.TaskManager.stop(me.waitTimer);
    me.waitTimer = null;
  }
}, onDestroy: function() {
  var me = this, bar = me.bar;
  me.clearTimer();
  if (me.rendered) 
  {
    if (me.textEl.isComposite) 
    {
      me.textEl.clear();
    }
    Ext.destroyMembers(me, 'textEl', 'progressBar');
    if (bar && me.animate) 
    {
      bar.stopAnimation();
    }
  }
  me.callParent();
}}, 0, ["progressbar"], ["component", "progressbar", "box"], {"component": true, "progressbar": true, "box": true}, ["widget.progressbar"], 0, [Ext, 'ProgressBar'], 0));
;

(Ext.cmd.derive('Ext.ShadowPool', Ext.Base, {singleton: true, markup: (function() {
  return Ext.String.format('<div class="{0}{1}-shadow" role="presentation"></div>', Ext.baseCSSPrefix, Ext.isIE && !Ext.supports.CSS3BoxShadow ? 'ie' : 'css');
}()), shadows: [], pull: function() {
  var sh = this.shadows.shift();
  if (!sh) 
  {
    sh = Ext.get(Ext.DomHelper.insertHtml("afterBegin", document.body, this.markup));
    sh.autoBoxAdjust = false;
  }
  return sh;
}, push: function(sh) {
  this.shadows.push(sh);
}, reset: function() {
  var shadows = [].concat(this.shadows), s, sLen = shadows.length;
  for (s = 0; s < sLen; s++) 
    {
      shadows[s].remove();
    }
  this.shadows = [];
}}, 0, 0, 0, 0, 0, 0, [Ext, 'ShadowPool'], 0));
;

(Ext.cmd.derive('Ext.Shadow', Ext.Base, {localXYNames: {get: 'getLocalXY', set: 'setLocalXY'}, constructor: function(config) {
  var me = this, adjusts, offset, rad;
  Ext.apply(me, config);
  if (!Ext.isString(me.mode)) 
  {
    me.mode = me.defaultMode;
  }
  offset = me.offset;
  rad = Math.floor(offset / 2);
  me.opacity = 50;
  switch (me.mode.toLowerCase()) {
    case "drop":
      if (Ext.supports.CSS3BoxShadow) 
      {
        adjusts = {t: offset, l: offset, h: -offset, w: -offset};
      } else {
        adjusts = {t: -rad, l: -rad, h: -rad, w: -rad};
      }
      break;
    case "sides":
      if (Ext.supports.CSS3BoxShadow) 
      {
        adjusts = {t: offset, l: 0, h: -offset, w: 0};
      } else {
        adjusts = {t: -(1 + rad), l: 1 + rad - 2 * offset, h: -1, w: rad - 1};
      }
      break;
    case "frame":
      if (Ext.supports.CSS3BoxShadow) 
      {
        adjusts = {t: 0, l: 0, h: 0, w: 0};
      } else {
        adjusts = {t: 1 + rad - 2 * offset, l: 1 + rad - 2 * offset, h: offset - rad - 1, w: offset - rad - 1};
      }
      break;
    case "bottom":
      if (Ext.supports.CSS3BoxShadow) 
      {
        adjusts = {t: offset, l: 0, h: -offset, w: 0};
      } else {
        adjusts = {t: offset, l: 0, h: 0, w: 0};
      }
      break;
  }
  me.adjusts = adjusts;
}, getShadowSize: function() {
  var me = this, offset = me.el ? me.offset : 0, result = [offset, offset, offset, offset], mode = me.mode.toLowerCase();
  if (me.el && mode !== 'frame') 
  {
    result[0] = 0;
    if (mode == 'drop') 
    {
      result[3] = 0;
    }
  }
  return result;
}, offset: 4, defaultMode: "drop", boxShadowProperty: (function() {
  var property = 'boxShadow', style = document.documentElement.style;
  if (!('boxShadow' in style)) 
  {
    if ('WebkitBoxShadow' in style) 
    {
      property = 'WebkitBoxShadow';
    } else if ('MozBoxShadow' in style) 
    {
      property = 'MozBoxShadow';
    }
  }
  return property;
}()), show: function(target) {
  var me = this, index, xy;
  target = Ext.get(target);
  index = (parseInt(target.getStyle("z-index"), 10) - 1) || 0;
  xy = target[me.localXYNames.get]();
  if (!me.el) 
  {
    me.el = Ext.ShadowPool.pull();
    if (me.fixed) 
    {
      me.el.dom.style.position = 'fixed';
    } else {
      me.el.dom.style.position = '';
    }
    if (me.el.dom.nextSibling != target.dom) 
    {
      me.el.insertBefore(target);
    }
  }
  me.el.setStyle("z-index", me.zIndex || index);
  if (Ext.isIE && !Ext.supports.CSS3BoxShadow) 
  {
    me.el.dom.style.filter = "progid:DXImageTransform.Microsoft.alpha(opacity=" + me.opacity + ") progid:DXImageTransform.Microsoft.Blur(pixelradius=" + (me.offset) + ")";
  }
  me.realign(xy[0], xy[1], target.dom.offsetWidth, target.dom.offsetHeight);
  me.el.dom.style.display = "block";
}, isVisible: function() {
  return this.el ? true : false;
}, realign: function(l, t, targetWidth, targetHeight) {
  if (!this.el) 
  {
    return;
  }
  var adjusts = this.adjusts, el = this.el, targetStyle = el.dom.style, shadowWidth, shadowHeight, sws, shs;
  el[this.localXYNames.set](l + adjusts.l, t + adjusts.t);
  shadowWidth = Math.max(targetWidth + adjusts.w, 0);
  shadowHeight = Math.max(targetHeight + adjusts.h, 0);
  sws = shadowWidth + "px";
  shs = shadowHeight + "px";
  if (targetStyle.width != sws || targetStyle.height != shs) 
  {
    targetStyle.width = sws;
    targetStyle.height = shs;
    if (Ext.supports.CSS3BoxShadow) 
    {
      targetStyle[this.boxShadowProperty] = '0 0 ' + (this.offset + 2) + 'px #888';
    }
  }
}, hide: function() {
  var me = this;
  if (me.el) 
  {
    me.el.dom.style.display = "none";
    Ext.ShadowPool.push(me.el);
    delete me.el;
  }
}, setZIndex: function(z) {
  this.zIndex = z;
  if (this.el) 
  {
    this.el.setStyle("z-index", z);
  }
}, setOpacity: function(opacity) {
  if (this.el) 
  {
    if (Ext.isIE && !Ext.supports.CSS3BoxShadow) 
    {
      opacity = Math.floor(opacity * 100 / 2) / 100;
    }
    this.opacity = opacity;
    this.el.setOpacity(opacity);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext, 'Shadow'], 0));
;

(Ext.cmd.derive('Ext.app.EventDomain', Ext.Base, {statics: {instances: {}}, isEventDomain: true, constructor: function() {
  var me = this;
  Ext.app.EventDomain.instances[me.type] = me;
  me.bus = {};
  me.monitoredClasses = [];
}, dispatch: function(target, ev, args) {
  var me = this, bus = me.bus, selectors = bus[ev.toLowerCase()], selector, controllers, id, events, event, i, ln;
  if (!selectors) 
  {
    return true;
  }
  for (selector in selectors) 
    {
      if (selectors.hasOwnProperty(selector) && me.match(target, selector)) 
      {
        controllers = selectors[selector];
        for (id in controllers) 
          {
            if (controllers.hasOwnProperty(id)) 
            {
              events = controllers[id];
              for (i = 0 , ln = events.length; i < ln; i++) 
                {
                  event = events[i];
                  if (event.fire.apply(event, args) === false) 
                  {
                    return false;
                  }
                }
            }
          }
      }
    }
  return true;
}, listen: function(selectors, controller) {
  var me = this, bus = me.bus, idProperty = me.idProperty, monitoredClasses = me.monitoredClasses, monitoredClassesCount = monitoredClasses.length, i, tree, list, selector, options, listener, scope, event, listeners, ev;
  for (selector in selectors) 
    {
      if (selectors.hasOwnProperty(selector) && (listeners = selectors[selector])) 
      {
        if (idProperty) 
        {
          selector = selector === '*' ? selector : selector.substring(1);
        }
        for (ev in listeners) 
          {
            if (listeners.hasOwnProperty(ev)) 
            {
              options = null;
              listener = listeners[ev];
              scope = controller;
              ev = ev.toLowerCase();
              event = new Ext.util.Event(controller, ev);
              if (Ext.isObject(listener)) 
              {
                options = listener;
                listener = options.fn;
                scope = options.scope || controller;
                delete options.fn;
                delete options.scope;
              }
              if (typeof listener === 'string') 
              {
                listener = scope[listener];
              }
              event.addListener(listener, scope, options);
              for (i = monitoredClassesCount; i-- > 0; ) 
                {
                  monitoredClasses[i].hasListeners._incr_(ev);
                }
              tree = bus[ev] || (bus[ev] = {});
              tree = tree[selector] || (tree[selector] = {});
              list = tree[controller.id] || (tree[controller.id] = []);
              list.push(event);
            }
          }
      }
    }
}, match: function(target, selector) {
  var idProperty = this.idProperty;
  if (idProperty) 
  {
    return selector === '*' || target[idProperty] === selector;
  }
  return false;
}, monitor: function(observable) {
  var domain = this, prototype = observable.isInstance ? observable : observable.prototype, fireEventArgs = prototype.fireEventArgs;
  domain.monitoredClasses.push(observable);
  prototype.fireEventArgs = function(ev, args) {
  var ret = fireEventArgs.apply(this, arguments);
  if (ret !== false) 
  {
    ret = domain.dispatch(this, ev, args);
  }
  return ret;
};
}, unlisten: function(controllerId) {
  var bus = this.bus, controllers, ev, selector, selectors;
  for (ev in bus) 
    {
      ev = ev.toLowerCase();
      if (bus.hasOwnProperty(ev) && (selectors = bus[ev])) 
      {
        for (selector in selectors) 
          {
            controllers = selectors[selector];
            delete controllers[controllerId];
          }
      }
    }
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'EventDomain'], 0));
;

(Ext.cmd.derive('Ext.app.domain.Component', Ext.app.EventDomain, {singleton: true, type: 'component', constructor: function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.Component);
}, match: function(target, selector) {
  return target.is(selector);
}}, 1, 0, 0, 0, 0, 0, [Ext.app.domain, 'Component'], 0));
;

(Ext.cmd.derive('Ext.app.EventBus', Ext.Base, {singleton: true, constructor: function() {
  var me = this, domains = Ext.app.EventDomain.instances;
  me.callParent();
  me.domains = domains;
  me.bus = domains.component.bus;
}, control: function(selectors, controller) {
  return this.domains.component.listen(selectors, controller);
}, listen: function(to, controller) {
  var domains = this.domains, domain;
  for (domain in to) 
    {
      if (to.hasOwnProperty(domain)) 
      {
        domains[domain].listen(to[domain], controller);
      }
    }
}, unlisten: function(controllerId) {
  var domains = Ext.app.EventDomain.instances, domain;
  for (domain in domains) 
    {
      domains[domain].unlisten(controllerId);
    }
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'EventBus'], 0));
;

(Ext.cmd.derive('Ext.data.ResultSet', Ext.Base, {loaded: true, count: 0, total: 0, success: false, constructor: function(config) {
  Ext.apply(this, config);
  this.totalRecords = this.total;
  if (config.count === undefined) 
  {
    this.count = this.records.length;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'ResultSet'], 0));
;

(Ext.cmd.derive('Ext.data.reader.Reader', Ext.Base, {alternateClassName: ['Ext.data.Reader', 'Ext.data.DataReader'], totalProperty: 'total', successProperty: 'success', root: '', implicitIncludes: true, readRecordsOnFailure: true, isReader: true, applyDefaults: true, lastFieldGeneration: null, constructor: function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  me.model = Ext.ModelManager.getModel(me.model);
  if (me.model && me.model.prototype.fields) 
  {
    me.buildExtractors();
  }
  this.addEvents('exception');
}, setModel: function(model, setOnProxy) {
  var me = this, oldModel = me.model, force = true;
  model = me.model = Ext.ModelManager.getModel(model);
  if (model && oldModel === model) 
  {
    force = me.lastFieldGeneration !== model.prototype.fields.generation;
  }
  if (model) 
  {
    me.buildExtractors(force);
  }
  if (setOnProxy && me.proxy) 
  {
    me.proxy.setModel(model, true);
  }
}, read: function(response) {
  var data;
  if (response) 
  {
    data = response.responseText ? this.getResponseData(response) : this.readRecords(response);
  }
  return data || this.nullResultSet;
}, readRecords: function(data) {
  var me = this, success, recordCount, records, root, total, value, message;
  if (me.lastFieldGeneration !== me.model.prototype.fields.generation) 
  {
    me.buildExtractors(true);
  }
  me.rawData = data;
  data = me.getData(data);
  success = true;
  recordCount = 0;
  records = [];
  if (me.successProperty) 
  {
    value = me.getSuccess(data);
    if (value === false || value === 'false') 
    {
      success = false;
    }
  }
  if (me.messageProperty) 
  {
    message = me.getMessage(data);
  }
  if (me.readRecordsOnFailure || success) 
  {
    root = Ext.isArray(data) ? data : me.getRoot(data);
    if (root) 
    {
      total = root.length;
    }
    if (me.totalProperty) 
    {
      value = parseInt(me.getTotal(data), 10);
      if (!isNaN(value)) 
      {
        total = value;
      }
    }
    if (root) 
    {
      records = me.extractData(root);
      recordCount = records.length;
    }
  }
  return new Ext.data.ResultSet({total: total || recordCount, count: recordCount, records: records, success: success, message: message});
}, extractData: function(root) {
  var me = this, ModelClass = me.model, length = root.length, records = new Array(length), dataConverter, convertedValues, node, record, i;
  if (!root.length && Ext.isObject(root)) 
  {
    root = [root];
    length = 1;
  }
  for (i = 0; i < length; i++) 
    {
      node = root[i];
      if (node.isModel) 
      {
        records[i] = node;
      } else {
        records[i] = record = new ModelClass(undefined, me.getId(node), node, convertedValues = {});
        record.phantom = false;
        me.convertRecordData(convertedValues, node, record);
        if (me.implicitIncludes && record.associations.length) 
        {
          me.readAssociated(record, node);
        }
      }
    }
  return records;
}, readAssociated: function(record, data) {
  var associations = record.associations.items, i = 0, length = associations.length, association, associationData, proxy, reader;
  for (; i < length; i++) 
    {
      association = associations[i];
      associationData = this.getAssociatedDataRoot(data, association.associationKeyFunction || association.associationKey || association.name);
      if (associationData) 
      {
        reader = association.getReader();
        if (!reader) 
        {
          proxy = association.associatedModel.getProxy();
          if (proxy) 
          {
            reader = proxy.getReader();
          } else {
            reader = new this.constructor({model: association.associatedName});
          }
        }
        association.read(record, reader, associationData);
      }
    }
}, getAssociatedDataRoot: function(data, associationName) {
  if (Ext.isFunction(associationName)) 
  {
    return associationName(data);
  }
  return data[associationName];
}, getFields: function() {
  return this.model.prototype.fields.items;
}, getData: Ext.identityFn, getRoot: Ext.identityFn, getResponseData: function(response) {
}, onMetaChange: function(meta) {
  var me = this, fields = meta.fields || me.getFields(), newModel, clientIdProperty;
  me.metaData = meta;
  me.root = meta.root || me.root;
  me.idProperty = meta.idProperty || me.idProperty;
  me.totalProperty = meta.totalProperty || me.totalProperty;
  me.successProperty = meta.successProperty || me.successProperty;
  me.messageProperty = meta.messageProperty || me.messageProperty;
  clientIdProperty = meta.clientIdProperty;
  if (me.model) 
  {
    me.model.setFields(fields, me.idProperty, clientIdProperty);
    me.setModel(me.model, true);
  } else {
    newModel = Ext.define("Ext.data.reader.Json-Model" + Ext.id(), {extend: 'Ext.data.Model', fields: fields, clientIdProperty: clientIdProperty});
    if (me.idProperty) 
    {
      newModel.idProperty = me.idProperty;
    }
    me.setModel(newModel, true);
  }
}, getIdProperty: function() {
  var idField = this.model.prototype.idField, idProperty = this.idProperty;
  if (!idProperty && idField && (idProperty = idField.mapping) == null) 
  {
    idProperty = idField.name;
  }
  return idProperty;
}, buildExtractors: function(force) {
  var me = this, idProp = me.getIdProperty(), totalProp = me.totalProperty, successProp = me.successProperty, messageProp = me.messageProperty, accessor;
  if (force === true) 
  {
    delete me.convertRecordData;
  }
  if (me.convertRecordData) 
  {
    return;
  }
  if (totalProp) 
  {
    me.getTotal = me.createAccessor(totalProp);
  }
  if (successProp) 
  {
    me.getSuccess = me.createAccessor(successProp);
  }
  if (messageProp) 
  {
    me.getMessage = me.createAccessor(messageProp);
  }
  if (idProp) 
  {
    accessor = me.createAccessor(idProp);
    me.getId = function(record) {
  var id = accessor.call(me, record);
  return (id === undefined || id === '') ? null : id;
};
  } else {
    me.getId = function() {
  return null;
};
  }
  me.convertRecordData = me.buildRecordDataExtractor();
  me.lastFieldGeneration = me.model.prototype.fields.generation;
}, recordDataExtractorTemplate: ['var me = this\n', '    ,value\n', '    ,internalId\n', '<tpl for="fields">', '    ,__field{#} = fields.map["{name}"]\n', '</tpl>', ';\n', 'return function(dest, source, record) {\n', '<tpl for="fields">', '{% var fieldAccessExpression =  this.createFieldAccessExpression(values, "__field" + xindex, "source");', '   if (fieldAccessExpression) { %}', '    value = {[ this.createFieldAccessExpression(values, "__field" + xindex, "source") ]};\n', '<tpl if="hasCustomConvert">', '    dest["{name}"] = value === undefined ? __field{#}.convert(__field{#}.defaultValue, record) : __field{#}.convert(value, record);\n', '<tpl elseif="defaultValue !== undefined">', '    if (value === undefined) {\n', '        if (me.applyDefaults) {\n', '<tpl if="convert">', '            dest["{name}"] = __field{#}.convert(__field{#}.defaultValue, record);\n', '<tpl else>', '            dest["{name}"] = __field{#}.defaultValue\n', '</tpl>', '        };\n', '    } else {\n', '<tpl if="convert">', '        dest["{name}"] = __field{#}.convert(value, record);\n', '<tpl else>', '        dest["{name}"] = value;\n', '</tpl>', '    };\n', '<tpl else>', '    if (value !== undefined) {\n', '<tpl if="convert">', '        dest["{name}"] = __field{#}.convert(value, record);\n', '<tpl else>', '        dest["{name}"] = value;\n', '</tpl>', '    }\n', '</tpl>', '{% } else { %}', '<tpl if="defaultValue !== undefined">', '<tpl if="convert">', '    dest["{name}"] = __field{#}.convert(__field{#}.defaultValue, record);\n', '<tpl else>', '    dest["{name}"] = __field{#}.defaultValue\n', '</tpl>', '</tpl>', '{% } %}', '</tpl>', '<tpl if="clientIdProp">', '    if (record && (internalId = {[ this.createFieldAccessExpression({mapping: values.clientIdProp}, null, "source") ]})) {\n', '        record.{["internalId"]} = internalId;\n', '    }\n', '</tpl>', '};'], buildRecordDataExtractor: function() {
  var me = this, modelProto = me.model.prototype, templateData = {clientIdProp: modelProto.clientIdProperty, fields: modelProto.fields.items};
  me.recordDataExtractorTemplate.createFieldAccessExpression = function() {
  return me.createFieldAccessExpression.apply(me, arguments);
};
  return Ext.functionFactory('fields', me.recordDataExtractorTemplate.apply(templateData)).call(me, me.model.prototype.fields);
}, destroyReader: function() {
  var me = this;
  delete me.proxy;
  delete me.model;
  delete me.convertRecordData;
  delete me.getId;
  delete me.getTotal;
  delete me.getSuccess;
  delete me.getMessage;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.data.reader, 'Reader', Ext.data, 'Reader', Ext.data, 'DataReader'], function() {
  var proto = this.prototype;
  Ext.apply(proto, {nullResultSet: new Ext.data.ResultSet({total: 0, count: 0, records: [], success: true, message: ''}), recordDataExtractorTemplate: new Ext.XTemplate(proto.recordDataExtractorTemplate)});
}));
;

(Ext.cmd.derive('Ext.data.reader.Json', Ext.data.reader.Reader, {alternateClassName: 'Ext.data.JsonReader', root: '', metaProperty: 'metaData', useSimpleAccessors: false, readRecords: function(data) {
  var me = this, meta;
  if (me.getMeta) 
  {
    meta = me.getMeta(data);
    if (meta) 
    {
      me.onMetaChange(meta);
    }
  } else if (data.metaData) 
  {
    me.onMetaChange(data.metaData);
  }
  me.jsonData = data;
  return me.callParent([data]);
}, getResponseData: function(response) {
  var data, error;
  try {
    data = Ext.decode(response.responseText);
    return this.readRecords(data);
  }  catch (ex) {
  error = new Ext.data.ResultSet({total: 0, count: 0, records: [], success: false, message: ex.message});
  this.fireEvent('exception', this, response, error);
  Ext.Logger.warn('Unable to parse the JSON returned by the server');
  return error;
}
}, buildExtractors: function() {
  var me = this, metaProp = me.metaProperty;
  me.callParent(arguments);
  if (me.root) 
  {
    me.getRoot = me.createAccessor(me.root);
  } else {
    me.getRoot = Ext.identityFn;
  }
  if (metaProp) 
  {
    me.getMeta = me.createAccessor(metaProp);
  }
}, extractData: function(root) {
  var recordName = this.record, data = [], length, i;
  if (recordName) 
  {
    length = root.length;
    if (!length && Ext.isObject(root)) 
    {
      length = 1;
      root = [root];
    }
    for (i = 0; i < length; i++) 
      {
        data[i] = root[i][recordName];
      }
  } else {
    data = root;
  }
  return this.callParent([data]);
}, createAccessor: (function() {
  var re = /[\[\.]/;
  return function(expr) {
  if (Ext.isEmpty(expr)) 
  {
    return Ext.emptyFn;
  }
  if (Ext.isFunction(expr)) 
  {
    return expr;
  }
  if (this.useSimpleAccessors !== true) 
  {
    var i = String(expr).search(re);
    if (i >= 0) 
    {
      return Ext.functionFactory('obj', 'return obj' + (i > 0 ? '.' : '') + expr);
    }
  }
  return function(obj) {
  return obj[expr];
};
};
}()), createFieldAccessExpression: (function() {
  var re = /[\[\.]/;
  return function(field, fieldVarName, dataName) {
  var mapping = field.mapping, hasMap = mapping || mapping === 0, map = hasMap ? mapping : field.name, result, operatorIndex;
  if (mapping === false) 
  {
    return;
  }
  if (typeof map === 'function') 
  {
    result = fieldVarName + '.mapping(' + dataName + ', this)';
  } else if (this.useSimpleAccessors === true || ((operatorIndex = String(map).search(re)) < 0)) 
  {
    if (!hasMap || isNaN(map)) 
    {
      map = '"' + map + '"';
    }
    result = dataName + "[" + map + "]";
  } else if (operatorIndex === 0) 
  {
    result = dataName + map;
  } else {
    var parts = map.split('.'), len = parts.length, i = 1, tempResult = dataName + '.' + parts[0], buffer = [tempResult];
    for (; i < len; i++) 
      {
        tempResult += '.' + parts[i];
        buffer.push(tempResult);
      }
    result = buffer.join(' && ');
  }
  return result;
};
}())}, 0, 0, 0, 0, ["reader.json"], 0, [Ext.data.reader, 'Json', Ext.data, 'JsonReader'], 0));
;

(Ext.cmd.derive('Ext.data.writer.Writer', Ext.Base, {alternateClassName: ['Ext.data.DataWriter', 'Ext.data.Writer'], writeAllFields: true, nameProperty: 'name', writeRecordId: true, isWriter: true, constructor: function(config) {
  Ext.apply(this, config);
}, write: function(request) {
  var operation = request.operation, records = operation.records || [], len = records.length, i = 0, data = [];
  for (; i < len; i++) 
    {
      data.push(this.getRecordData(records[i], operation));
    }
  return this.writeRecords(request, data);
}, getRecordData: function(record, operation) {
  var isPhantom = record.phantom === true, writeAll = this.writeAllFields || isPhantom, fields = record.fields, fieldItems = fields.items, data = {}, clientIdProperty = record.clientIdProperty, changes, field, key, mappedIdProperty, f, fLen;
  if (writeAll) 
  {
    fLen = fieldItems.length;
    for (f = 0; f < fLen; f++) 
      {
        field = fieldItems[f];
        if (field.persist) 
        {
          this.writeValue(data, field, record);
        }
      }
  } else if (operation && operation.action === 'destroy') 
  {
    this.writeValue(data, record.idField, record);
  } else {
    changes = record.getChanges();
    for (key in changes) 
      {
        if (changes.hasOwnProperty(key)) 
        {
          field = fields.get(key);
          if (field.persist) 
          {
            this.writeValue(data, field, record);
          }
        }
      }
  }
  if (isPhantom) 
  {
    if (clientIdProperty && operation && operation.records.length > 1) 
    {
      data[clientIdProperty] = record.internalId;
    }
  } else if (this.writeRecordId) 
  {
    mappedIdProperty = fields.get(record.idProperty)[this.nameProperty] || record.idProperty;
    data[mappedIdProperty] = record.getId();
  }
  return data;
}, writeValue: function(data, field, record) {
  var name = field[this.nameProperty], dateFormat = this.dateFormat || field.dateWriteFormat || field.dateFormat, value = record.get(field.name);
  if (name == null) 
  {
    name = field.name;
  }
  if (field.serialize) 
  {
    data[name] = field.serialize(value, record);
  } else if (field.type === Ext.data.Types.DATE && dateFormat && Ext.isDate(value)) 
  {
    data[name] = Ext.Date.format(value, dateFormat);
  } else {
    data[name] = value;
  }
}}, 1, 0, 0, 0, ["writer.base"], 0, [Ext.data.writer, 'Writer', Ext.data, 'DataWriter', Ext.data, 'Writer'], 0));
;

(Ext.cmd.derive('Ext.data.writer.Json', Ext.data.writer.Writer, {alternateClassName: 'Ext.data.JsonWriter', root: undefined, encode: false, allowSingle: true, expandData: false, getExpandedData: function(data) {
  var dataLength = data.length, i = 0, item, prop, nameParts, j, tempObj, toObject = function(name, value) {
  var o = {};
  o[name] = value;
  return o;
};
  for (; i < dataLength; i++) 
    {
      item = data[i];
      for (prop in item) 
        {
          if (item.hasOwnProperty(prop)) 
          {
            nameParts = prop.split('.');
            j = nameParts.length - 1;
            if (j > 0) 
            {
              tempObj = item[prop];
              for (; j > 0; j--) 
                {
                  tempObj = toObject(nameParts[j], tempObj);
                }
              item[nameParts[0]] = item[nameParts[0]] || {};
              Ext.Object.merge(item[nameParts[0]], tempObj);
              delete item[prop];
            }
          }
        }
    }
  return data;
}, writeRecords: function(request, data) {
  var root = this.root;
  if (this.expandData) 
  {
    data = this.getExpandedData(data);
  }
  if (this.allowSingle && data.length === 1) 
  {
    data = data[0];
  }
  if (this.encode) 
  {
    if (root) 
    {
      request.params[root] = Ext.encode(data);
    } else {
    }
  } else {
    request.jsonData = request.jsonData || {};
    if (root) 
    {
      request.jsonData[root] = data;
    } else {
      request.jsonData = data;
    }
  }
  return request;
}}, 0, 0, 0, 0, ["writer.json"], 0, [Ext.data.writer, 'Json', Ext.data, 'JsonWriter'], 0));
;

(Ext.cmd.derive('Ext.data.proxy.Proxy', Ext.Base, {alternateClassName: ['Ext.data.DataProxy', 'Ext.data.Proxy'], batchOrder: 'create,update,destroy', batchActions: true, defaultReaderType: 'json', defaultWriterType: 'json', isProxy: true, isSynchronous: false, constructor: function(config) {
  var me = this;
  config = config || {};
  me.proxyConfig = config;
  me.mixins.observable.constructor.call(me, config);
  if (me.model !== undefined && !(me.model instanceof Ext.data.Model)) 
  {
    me.setModel(me.model);
  } else {
    if (me.reader) 
    {
      me.setReader(me.reader);
    }
    if (me.writer) 
    {
      me.setWriter(me.writer);
    }
  }
}, setModel: function(model, setOnStore) {
  var me = this;
  me.model = Ext.ModelManager.getModel(model);
  me.setReader(this.reader);
  me.setWriter(this.writer);
  if (setOnStore && me.store) 
  {
    me.store.setModel(me.model);
  }
}, getModel: function() {
  return this.model;
}, setReader: function(reader) {
  var me = this, needsCopy = true, current = me.reader;
  if (reader === undefined || typeof reader == 'string') 
  {
    reader = {type: reader};
    needsCopy = false;
  }
  if (reader.isReader) 
  {
    reader.setModel(me.model);
  } else {
    if (needsCopy) 
    {
      reader = Ext.apply({}, reader);
    }
    Ext.applyIf(reader, {proxy: me, model: me.model, type: me.defaultReaderType});
    reader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  if (reader !== current && reader.onMetaChange) 
  {
    reader.onMetaChange = Ext.Function.createSequence(reader.onMetaChange, this.onMetaChange, this);
  }
  me.reader = reader;
  return me.reader;
}, getReader: function() {
  return this.reader;
}, onMetaChange: function(meta) {
  this.fireEvent('metachange', this, meta);
}, setWriter: function(writer) {
  var me = this, needsCopy = true;
  if (writer === undefined || typeof writer == 'string') 
  {
    writer = {type: writer};
    needsCopy = false;
  }
  if (!writer.isWriter) 
  {
    if (needsCopy) 
    {
      writer = Ext.apply({}, writer);
    }
    Ext.applyIf(writer, {model: me.model, type: me.defaultWriterType});
    writer = Ext.createByAlias('writer.' + writer.type, writer);
  }
  me.writer = writer;
  return me.writer;
}, getWriter: function() {
  return this.writer;
}, create: Ext.emptyFn, read: Ext.emptyFn, update: Ext.emptyFn, destroy: Ext.emptyFn, batch: function(options, listeners) {
  var me = this, useBatch = me.batchActions, batch, records, actions, aLen, action, a, r, rLen, record;
  if (options.operations === undefined) 
  {
    options = {operations: options, listeners: listeners};
  }
  if (options.batch) 
  {
    if (Ext.isDefined(options.batch.runOperation)) 
    {
      batch = Ext.applyIf(options.batch, {proxy: me, listeners: {}});
    }
  } else {
    options.batch = {proxy: me, listeners: options.listeners || {}};
  }
  if (!batch) 
  {
    batch = new Ext.data.Batch(options.batch);
  }
  batch.on('complete', Ext.bind(me.onBatchComplete, me, [options], 0));
  actions = me.batchOrder.split(',');
  aLen = actions.length;
  for (a = 0; a < aLen; a++) 
    {
      action = actions[a];
      records = options.operations[action];
      if (records) 
      {
        if (useBatch) 
        {
          batch.add(new Ext.data.Operation({action: action, records: records}));
        } else {
          rLen = records.length;
          for (r = 0; r < rLen; r++) 
            {
              record = records[r];
              batch.add(new Ext.data.Operation({action: action, records: [record]}));
            }
        }
      }
    }
  batch.start();
  return batch;
}, onBatchComplete: function(batchOptions, batch) {
  var scope = batchOptions.scope || this;
  if (batch.hasException) 
  {
    if (Ext.isFunction(batchOptions.failure)) 
    {
      Ext.callback(batchOptions.failure, scope, [batch, batchOptions]);
    }
  } else if (Ext.isFunction(batchOptions.success)) 
  {
    Ext.callback(batchOptions.success, scope, [batch, batchOptions]);
  }
  if (Ext.isFunction(batchOptions.callback)) 
  {
    Ext.callback(batchOptions.callback, scope, [batch, batchOptions]);
  }
}, clone: function() {
  return new this.self(this.proxyConfig);
}}, 1, 0, 0, 0, ["proxy.proxy"], [['observable', Ext.util.Observable]], [Ext.data.proxy, 'Proxy', Ext.data, 'DataProxy', Ext.data, 'Proxy'], 0));
;

(Ext.cmd.derive('Ext.data.proxy.Client', Ext.data.proxy.Proxy, {alternateClassName: 'Ext.data.ClientProxy', isSynchronous: true, clear: function() {
}}, 0, 0, 0, 0, 0, 0, [Ext.data.proxy, 'Client', Ext.data, 'ClientProxy'], 0));
;

(Ext.cmd.derive('Ext.data.proxy.Memory', Ext.data.proxy.Client, {alternateClassName: 'Ext.data.MemoryProxy', constructor: function(config) {
  this.callParent([config]);
  this.setReader(this.reader);
}, updateOperation: function(operation, callback, scope) {
  var i = 0, recs = operation.getRecords(), len = recs.length;
  for (i; i < len; i++) 
    {
      recs[i].commit();
    }
  operation.setCompleted();
  operation.setSuccessful();
  Ext.callback(callback, scope || this, [operation]);
}, create: function() {
  this.updateOperation.apply(this, arguments);
}, update: function() {
  this.updateOperation.apply(this, arguments);
}, destroy: function() {
  this.updateOperation.apply(this, arguments);
}, read: function(operation, callback, scope) {
  var me = this, resultSet = operation.resultSet = me.getReader().read(me.data), records = resultSet.records, sorters = operation.sorters, groupers = operation.groupers, filters = operation.filters;
  operation.setCompleted();
  if (resultSet.success) 
  {
    if (filters && filters.length) 
    {
      records = resultSet.records = Ext.Array.filter(records, Ext.util.Filter.createFilterFn(filters));
      resultSet.total = records.length;
    }
    if (groupers && groupers.length) 
    {
      sorters = sorters ? sorters.concat(groupers) : sorters;
    }
    if (sorters && sorters.length) 
    {
      resultSet.records = Ext.Array.sort(records, Ext.util.Sortable.createComparator(sorters));
    }
    if (me.enablePaging && operation.start !== undefined && operation.limit !== undefined) 
    {
      if (operation.start >= resultSet.total) 
      {
        resultSet.success = false;
        resultSet.count = 0;
        resultSet.records = [];
      } else {
        resultSet.records = Ext.Array.slice(resultSet.records, operation.start, operation.start + operation.limit);
        resultSet.count = resultSet.records.length;
      }
    }
  }
  if (resultSet.success) 
  {
    operation.setSuccessful();
  } else {
    me.fireEvent('exception', me, null, operation);
  }
  Ext.callback(callback, scope || me, [operation]);
}, clear: Ext.emptyFn}, 1, 0, 0, 0, ["proxy.memory"], 0, [Ext.data.proxy, 'Memory', Ext.data, 'MemoryProxy'], 0));
;

(Ext.cmd.derive('Ext.data.Operation', Ext.Base, {synchronous: true, action: undefined, filters: undefined, sorters: undefined, groupers: undefined, start: undefined, limit: undefined, batch: undefined, callback: undefined, scope: undefined, started: false, running: false, complete: false, success: undefined, exception: false, error: undefined, actionCommitRecordsRe: /^(?:create|update)$/i, actionSkipSyncRe: /^destroy$/i, constructor: function(config) {
  Ext.apply(this, config || {});
}, commitRecords: function(serverRecords) {
  var me = this, commitRecords = me.actionCommitRecordsRe.test(me.action), mc, index, clientRecords, serverRec, clientRec, i, len, modifiedFields, recordModifiedFields;
  if (!me.actionSkipSyncRe.test(me.action)) 
  {
    clientRecords = me.records;
    if (clientRecords && clientRecords.length) 
    {
      if (commitRecords) 
      {
        recordModifiedFields = [];
      }
      if (clientRecords.length > 1) 
      {
        if (me.action == 'update' || clientRecords[0].clientIdProperty) 
        {
          mc = new Ext.util.MixedCollection();
          mc.addAll(serverRecords);
          for (index = clientRecords.length; index--; ) 
            {
              clientRec = clientRecords[index];
              serverRec = mc.findBy(me.matchClientRec, clientRec);
              modifiedFields = clientRec.copyFrom(serverRec);
              if (commitRecords) 
              {
                recordModifiedFields.push(modifiedFields);
              }
            }
        } else {
          for (i = 0 , len = clientRecords.length; i < len; ++i) 
            {
              clientRec = clientRecords[i];
              serverRec = serverRecords[i];
              if (clientRec && serverRec) 
              {
                modifiedFields = me.updateRecord(clientRec, serverRec);
                if (commitRecords) 
                {
                  recordModifiedFields.push(modifiedFields);
                }
              }
            }
        }
      } else {
        modifiedFields = me.updateRecord(clientRecords[0], serverRecords[0]);
        if (commitRecords) 
        {
          recordModifiedFields[0] = modifiedFields;
        }
      }
      if (commitRecords) 
      {
        for (index = clientRecords.length; index--; ) 
          {
            clientRecords[index].commit(false, recordModifiedFields[index]);
          }
      }
    }
  }
}, updateRecord: function(clientRec, serverRec) {
  if (serverRec && (clientRec.phantom || clientRec.getId() === serverRec.getId())) 
  {
    return clientRec.copyFrom(serverRec);
  }
  return [];
}, matchClientRec: function(record) {
  var clientRec = this, clientRecordId = clientRec.getId();
  if (clientRecordId && record.getId() === clientRecordId) 
  {
    return true;
  }
  return record.internalId === clientRec.internalId;
}, setStarted: function() {
  this.started = true;
  this.running = true;
}, setCompleted: function() {
  this.complete = true;
  this.running = false;
}, setSuccessful: function() {
  this.success = true;
}, setException: function(error) {
  this.exception = true;
  this.success = false;
  this.running = false;
  this.error = error;
}, hasException: function() {
  return this.exception === true;
}, getError: function() {
  return this.error;
}, getRecords: function() {
  var resultSet = this.getResultSet();
  return this.records || (resultSet ? resultSet.records : null);
}, getResultSet: function() {
  return this.resultSet;
}, isStarted: function() {
  return this.started === true;
}, isRunning: function() {
  return this.running === true;
}, isComplete: function() {
  return this.complete === true;
}, wasSuccessful: function() {
  return this.isComplete() && this.success === true;
}, setBatch: function(batch) {
  this.batch = batch;
}, allowWrite: function() {
  return this.action != 'read';
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Operation'], 0));
;

(Ext.cmd.derive('Ext.data.AbstractStore', Ext.Base, {statics: {create: function(store) {
  if (!store.isStore) 
  {
    if (!store.type) 
    {
      store.type = 'store';
    }
    store = Ext.createByAlias('store.' + store.type, store);
  }
  return store;
}}, onClassExtended: function(cls, data, hooks) {
  var model = data.model, onBeforeClassCreated;
  if (typeof model == 'string') 
  {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function() {
  var me = this, args = arguments;
  Ext.require(model, function() {
  onBeforeClassCreated.apply(me, args);
});
};
  }
}, remoteSort: false, remoteFilter: false, autoLoad: undefined, autoSync: false, batchUpdateMode: 'operation', filterOnLoad: true, sortOnLoad: true, implicitModel: false, defaultProxyType: 'memory', isDestroyed: false, isStore: true, sortRoot: 'data', constructor: function(config) {
  var me = this, filters;
  Ext.apply(me, config);
  me.removed = [];
  me.mixins.observable.constructor.apply(me, arguments);
  me.model = Ext.ModelManager.getModel(me.model);
  Ext.applyIf(me, {modelDefaults: null});
  if (!me.model && me.fields) 
  {
    me.model = Ext.define(null, {extend: 'Ext.data.Model', fields: me.fields, proxy: me.proxy || me.defaultProxyType});
    delete me.fields;
    me.implicitModel = true;
  }
  me.setProxy(me.proxy || me.model.getProxy());
  if (me.id && !me.storeId) 
  {
    me.storeId = me.id;
    delete me.id;
  }
  if (me.storeId) 
  {
    Ext.data.StoreManager.register(me);
  }
  me.mixins.sortable.initSortable.call(me);
  filters = me.decodeFilters(me.filters);
  me.filters = new Ext.util.MixedCollection();
  me.filters.addAll(filters);
}, setProxy: function(proxy) {
  var me = this, model = me.model;
  if (proxy instanceof Ext.data.proxy.Proxy) 
  {
    proxy.setModel(model);
  } else {
    if (Ext.isString(proxy)) 
    {
      proxy = {type: proxy, model: model};
    } else if (!proxy.model) 
    {
      proxy = Ext.apply({model: model}, proxy);
    }
    proxy = Ext.createByAlias('proxy.' + proxy.type, proxy);
  }
  if (!me.disableMetaChangeEvent) 
  {
    proxy.on('metachange', me.onMetaChange, me);
  }
  me.proxy = proxy;
  return me.proxy;
}, getProxy: function() {
  return this.proxy;
}, onMetaChange: function(proxy, meta) {
  this.fireEvent('metachange', this, meta);
}, create: function(data, options) {
  var me = this, instance = Ext.ModelManager.create(Ext.applyIf(data, me.modelDefaults), me.model.modelName), operation;
  options = options || {};
  Ext.applyIf(options, {action: 'create', records: [instance]});
  operation = new Ext.data.Operation(options);
  me.proxy.create(operation, me.onProxyWrite, me);
  return instance;
}, read: function() {
  return this.load.apply(this, arguments);
}, update: function(options) {
  var me = this, operation;
  options = options || {};
  Ext.applyIf(options, {action: 'update', records: me.getUpdatedRecords()});
  operation = new Ext.data.Operation(options);
  return me.proxy.update(operation, me.onProxyWrite, me);
}, onProxyWrite: function(operation) {
  var me = this, success = operation.wasSuccessful(), records = operation.getRecords();
  switch (operation.action) {
    case 'create':
      me.onCreateRecords(records, operation, success);
      break;
    case 'update':
      me.onUpdateRecords(records, operation, success);
      break;
    case 'destroy':
      me.onDestroyRecords(records, operation, success);
      break;
  }
  if (success) 
  {
    me.fireEvent('write', me, operation);
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
  Ext.callback(operation.callback, operation.scope || me, [records, operation, success]);
}, onCreateRecords: Ext.emptyFn, onUpdateRecords: Ext.emptyFn, onDestroyRecords: function(records, operation, success) {
  if (success) 
  {
    this.removed = [];
  }
}, destroy: function(options) {
  var me = this, operation;
  options = options || {};
  Ext.applyIf(options, {action: 'destroy', records: me.getRemovedRecords()});
  operation = new Ext.data.Operation(options);
  return me.proxy.destroy(operation, me.onProxyWrite, me);
}, onBatchOperationComplete: function(batch, operation) {
  return this.onProxyWrite(operation);
}, onBatchComplete: function(batch, operation) {
  var me = this, operations = batch.operations, length = operations.length, i;
  me.suspendEvents();
  for (i = 0; i < length; i++) 
    {
      me.onProxyWrite(operations[i]);
    }
  me.resumeEvents();
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
}, onBatchException: function(batch, operation) {
}, filterNew: function(item) {
  return item.phantom === true && item.isValid();
}, getNewRecords: function() {
  return [];
}, getUpdatedRecords: function() {
  return [];
}, getModifiedRecords: function() {
  return [].concat(this.getNewRecords(), this.getUpdatedRecords());
}, filterUpdated: function(item) {
  return item.dirty === true && item.phantom !== true && item.isValid();
}, getRemovedRecords: function() {
  return this.removed;
}, filter: function(filters, value) {
}, decodeFilters: function(filters) {
  if (!Ext.isArray(filters)) 
  {
    if (filters === undefined) 
    {
      filters = [];
    } else {
      filters = [filters];
    }
  }
  var length = filters.length, Filter = Ext.util.Filter, config, i;
  for (i = 0; i < length; i++) 
    {
      config = filters[i];
      if (!(config instanceof Filter)) 
      {
        Ext.apply(config, {root: 'data'});
        if (config.fn) 
        {
          config.filterFn = config.fn;
        }
        if (typeof config == 'function') 
        {
          config = {filterFn: config};
        }
        filters[i] = new Filter(config);
      }
    }
  return filters;
}, clearFilter: function(supressEvent) {
}, isFiltered: function() {
}, filterBy: function(fn, scope) {
}, sync: function(options) {
  var me = this, operations = {}, toCreate = me.getNewRecords(), toUpdate = me.getUpdatedRecords(), toDestroy = me.getRemovedRecords(), needsSync = false;
  if (toCreate.length > 0) 
  {
    operations.create = toCreate;
    needsSync = true;
  }
  if (toUpdate.length > 0) 
  {
    operations.update = toUpdate;
    needsSync = true;
  }
  if (toDestroy.length > 0) 
  {
    operations.destroy = toDestroy;
    needsSync = true;
  }
  if (needsSync && me.fireEvent('beforesync', operations) !== false) 
  {
    options = options || {};
    me.proxy.batch(Ext.apply(options, {operations: operations, listeners: me.getBatchListeners()}));
  }
  return me;
}, getBatchListeners: function() {
  var me = this, listeners = {scope: me, exception: me.onBatchException};
  if (me.batchUpdateMode == 'operation') 
  {
    listeners.operationcomplete = me.onBatchOperationComplete;
  } else {
    listeners.complete = me.onBatchComplete;
  }
  return listeners;
}, save: function() {
  return this.sync.apply(this, arguments);
}, load: function(options) {
  var me = this, operation = {action: 'read'};
  if (me.remoteFilter) 
  {
    operation.filters = me.filters.items;
  }
  if (me.remoteSort) 
  {
    operation.sorters = me.getSorters();
  }
  Ext.apply(operation, options);
  me.lastOptions = operation;
  operation = new Ext.data.Operation(operation);
  if (me.fireEvent('beforeload', me, operation) !== false) 
  {
    me.loading = true;
    me.proxy.read(operation, me.onProxyLoad, me);
  }
  return me;
}, reload: function(options) {
  var o = Ext.apply({}, options, this.lastOptions);
  return this.load(o);
}, afterEdit: function(record, modifiedFieldNames) {
  var me = this, i, shouldSync;
  if (me.autoSync && !me.autoSyncSuspended) 
  {
    for (i = modifiedFieldNames.length; i--; ) 
      {
        if (record.fields.get(modifiedFieldNames[i]).persist) 
        {
          shouldSync = true;
          break;
        }
      }
    if (shouldSync) 
    {
      me.sync();
    }
  }
  me.onUpdate(record, Ext.data.Model.EDIT, modifiedFieldNames);
  me.fireEvent('update', me, record, Ext.data.Model.EDIT, modifiedFieldNames);
}, afterReject: function(record) {
  this.onUpdate(record, Ext.data.Model.REJECT, null);
  this.fireEvent('update', this, record, Ext.data.Model.REJECT, null);
}, afterCommit: function(record, modifiedFieldNames) {
  if (!modifiedFieldNames) 
  {
    modifiedFieldNames = null;
  }
  this.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
  this.fireEvent('update', this, record, Ext.data.Model.COMMIT, modifiedFieldNames);
}, onUpdate: Ext.emptyFn, onIdChanged: function(model, oldId, newId, oldInternalId) {
  this.fireEvent('idchanged', this, model, oldId, newId, oldInternalId);
}, destroyStore: function() {
  var me = this;
  if (!me.isDestroyed) 
  {
    me.clearListeners();
    if (me.storeId) 
    {
      Ext.data.StoreManager.unregister(me);
    }
    me.destroyClear();
    if (me.reader) 
    {
      me.reader.destroyReader();
    }
    me.data = me.tree = me.sorters = me.filters = me.groupers = me.proxy = me.reader = me.writer = me.model = null;
    me.isDestroyed = true;
  }
}, destroyClear: function() {
  this.clearData();
}, getState: function() {
  var me = this, hasState, result, hasGroupers = !!me.groupers, groupers = [], sorters = [], filters = [];
  if (hasGroupers) 
  {
    me.groupers.each(function(g) {
  groupers[groupers.length] = g.serialize();
  hasState = true;
});
  }
  if (me.sorters) 
  {
    me.sorters.each(function(s) {
  if (hasGroupers && !me.groupers.contains(s)) 
  {
    sorters[sorters.length] = s.serialize();
    hasState = true;
  }
});
  }
  if (me.filters && me.statefulFilters) 
  {
    me.filters.each(function(f) {
  filters[filters.length] = f.serialize();
  hasState = true;
});
  }
  if (hasState) 
  {
    result = {};
    if (groupers.length) 
    {
      result.groupers = groupers;
    }
    if (sorters.length) 
    {
      result.sorters = sorters;
    }
    if (filters.length) 
    {
      result.filters = filters;
    }
    return result;
  }
}, applyState: function(state) {
  var me = this, hasSorters = !!me.sorters, hasGroupers = !!me.groupers, hasFilters = !!me.filters, locallySorted;
  if (hasGroupers && state.groupers) 
  {
    me.groupers.clear();
    me.groupers.addAll(me.decodeGroupers(state.groupers));
  }
  if (hasSorters && state.sorters) 
  {
    me.sorters.clear();
    me.sorters.addAll(me.decodeSorters(state.sorters));
  }
  if (hasFilters && state.filters) 
  {
    me.filters.clear();
    me.filters.addAll(me.decodeFilters(state.filters));
  }
  if (hasSorters && hasGroupers) 
  {
    me.sorters.insert(0, me.groupers.getRange());
  }
  if (me.autoLoad && (me.remoteSort || me.remoteGroup || me.remoteFilter)) 
  {
    if (me.autoLoadTask) 
    {
      me.autoLoadTask.cancel();
      delete me.autoLoadTask;
    }
    if (me.autoLoad === true) 
    {
      me.reload();
    } else {
      me.reload(me.autoLoad);
    }
  }
  if (hasFilters && me.filters.length && !me.remoteFilter) 
  {
    me.filter();
    locallySorted = me.sortOnFilter;
  }
  if (hasSorters && me.sorters.length && !me.remoteSort && !locallySorted) 
  {
    me.sort();
  }
}, doSort: function(sorterFn) {
  var me = this;
  if (me.remoteSort) 
  {
    me.load();
  } else {
    me.data.sortBy(sorterFn);
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
  me.fireEvent('sort', me, me.sorters.getRange());
}, clearData: Ext.emptyFn, getCount: Ext.emptyFn, getById: Ext.emptyFn, removeAll: Ext.emptyFn, isLoading: function() {
  return !!this.loading;
}, suspendAutoSync: function() {
  this.autoSyncSuspended = true;
}, resumeAutoSync: function() {
  this.autoSyncSuspended = false;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable], ['sortable', Ext.util.Sortable]], [Ext.data, 'AbstractStore'], 0));
;

(Ext.cmd.derive('Ext.data.StoreManager', Ext.util.MixedCollection, {alternateClassName: ['Ext.StoreMgr', 'Ext.data.StoreMgr', 'Ext.StoreManager'], singleton: true, register: function() {
  for (var i = 0, s; (s = arguments[i]); i++) 
    {
      this.add(s);
    }
}, unregister: function() {
  for (var i = 0, s; (s = arguments[i]); i++) 
    {
      this.remove(this.lookup(s));
    }
}, lookup: function(store) {
  if (Ext.isArray(store)) 
  {
    var fields = ['field1'], expand = !Ext.isArray(store[0]), data = store, i, len;
    if (expand) 
    {
      data = [];
      for (i = 0 , len = store.length; i < len; ++i) 
        {
          data.push([store[i]]);
        }
    } else {
      for (i = 2 , len = store[0].length; i <= len; ++i) 
        {
          fields.push('field' + i);
        }
    }
    return new Ext.data.ArrayStore({data: data, fields: fields, autoDestroy: true, autoCreated: true, expanded: expand});
  }
  if (Ext.isString(store)) 
  {
    return this.get(store);
  } else {
    return Ext.data.AbstractStore.create(store);
  }
}, getKey: function(o) {
  return o.storeId;
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'StoreManager', Ext, 'StoreMgr', Ext.data, 'StoreMgr', Ext, 'StoreManager'], function() {
  Ext.regStore = function(name, config) {
  var store;
  if (Ext.isObject(name)) 
  {
    config = name;
  } else {
    config.storeId = name;
  }
  if (config instanceof Ext.data.Store) 
  {
    store = config;
  } else {
    store = new Ext.data.Store(config);
  }
  return Ext.data.StoreManager.register(store);
};
  Ext.getStore = function(name) {
  return Ext.data.StoreManager.lookup(name);
};
}));
;

(Ext.cmd.derive('Ext.app.domain.Global', Ext.app.EventDomain, {singleton: true, type: 'global', constructor: function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.globalEvents);
}, listen: function(listeners, controller) {
  this.callParent([{global: listeners}, controller]);
}, match: function() {
  return true;
}}, 1, 0, 0, 0, 0, 0, [Ext.app.domain, 'Global'], 0));
;

(Ext.cmd.derive('Ext.app.domain.Store', Ext.app.EventDomain, {singleton: true, type: 'store', idProperty: 'storeId', constructor: function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.data.AbstractStore);
}}, 1, 0, 0, 0, 0, 0, [Ext.app.domain, 'Store'], 0));
;

(Ext.cmd.derive('Ext.app.Controller', Ext.Base, {statics: {strings: {model: {getter: 'getModel', upper: 'Model'}, view: {getter: 'getView', upper: 'View'}, controller: {getter: 'getController', upper: 'Controller'}, store: {getter: 'getStore', upper: 'Store'}}, controllerRegex: /^(.*)\.controller\./, createGetter: function(baseGetter, name) {
  return function() {
  return this[baseGetter](name);
};
}, getGetterName: function(name, kindUpper) {
  var fn = 'get', parts = name.split('.'), numParts = parts.length, index;
  for (index = 0; index < numParts; index++) 
    {
      fn += Ext.String.capitalize(parts[index]);
    }
  fn += kindUpper;
  return fn;
}, processDependencies: function(cls, requires, namespace, kind, names) {
  if (!names || !names.length) 
  {
    return;
  }
  var me = this, strings = me.strings[kind], o, absoluteName, shortName, name, j, subLn, getterName, getter;
  if (!Ext.isArray(names)) 
  {
    names = [names];
  }
  for (j = 0 , subLn = names.length; j < subLn; j++) 
    {
      name = names[j];
      o = me.getFullName(name, kind, namespace);
      absoluteName = o.absoluteName;
      shortName = o.shortName;
      requires.push(absoluteName);
      getterName = me.getGetterName(shortName, strings.upper);
      cls[getterName] = getter = me.createGetter(strings.getter, name);
      if (kind !== 'controller') 
      {
        getter['Ext.app.getter'] = true;
      }
    }
}, getFullName: function(name, kind, namespace) {
  var shortName = name, sep, absoluteName;
  if ((sep = name.indexOf('@')) > 0) 
  {
    shortName = name.substring(0, sep);
    absoluteName = name.substring(sep + 1) + '.' + shortName;
  } else if (name.indexOf('.') > 0 && (Ext.ClassManager.isCreated(name) || Ext.Loader.isAClassNameWithAKnownPrefix(name))) 
  {
    absoluteName = name;
  } else {
    if (namespace) 
    {
      absoluteName = namespace + '.' + kind + '.' + name;
      shortName = name;
    } else {
      absoluteName = name;
    }
  }
  return {absoluteName: absoluteName, shortName: shortName};
}}, application: null, onClassExtended: function(cls, data, hooks) {
  var onBeforeClassCreated = hooks.onBeforeCreated;
  hooks.onBeforeCreated = function(cls, data) {
  var Controller = Ext.app.Controller, ctrlRegex = Controller.controllerRegex, requires = [], className, namespace, requires, proto, match;
  proto = cls.prototype;
  className = Ext.getClassName(cls);
  namespace = data.$namespace || Ext.app.getNamespace(className) || ((match = ctrlRegex.exec(className)) && match[1]);
  if (namespace) 
  {
    proto.$namespace = namespace;
  }
  Controller.processDependencies(proto, requires, namespace, 'model', data.models);
  Controller.processDependencies(proto, requires, namespace, 'view', data.views);
  Controller.processDependencies(proto, requires, namespace, 'store', data.stores);
  Controller.processDependencies(proto, requires, namespace, 'controller', data.controllers);
  Ext.require(requires, Ext.Function.pass(onBeforeClassCreated, arguments, this));
};
}, constructor: function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  if (me.refs) 
  {
    me.ref(me.refs);
  }
  me.eventbus = Ext.app.EventBus;
  me.initAutoGetters();
}, initAutoGetters: function() {
  var proto = this.self.prototype, prop, fn;
  for (prop in proto) 
    {
      fn = proto[prop];
      if (fn && fn['Ext.app.getter']) 
      {
        fn.call(this);
      }
    }
}, doInit: function(app) {
  var me = this;
  if (!me._initialized) 
  {
    me.init(app);
    me._initialized = true;
  }
}, finishInit: function(app) {
  var me = this, controllers = me.controllers, controller, i, l;
  if (me._initialized && controllers && controllers.length) 
  {
    for (i = 0 , l = controllers.length; i < l; i++) 
      {
        controller = me.getController(controllers[i]);
        controller.finishInit(app);
      }
  }
}, init: Ext.emptyFn, onLaunch: Ext.emptyFn, ref: function(refs) {
  var me = this, i = 0, length = refs.length, info, ref, fn;
  refs = Ext.Array.from(refs);
  me.references = me.references || [];
  for (; i < length; i++) 
    {
      info = refs[i];
      ref = info.ref;
      fn = 'get' + Ext.String.capitalize(ref);
      if (!me[fn]) 
      {
        me[fn] = Ext.Function.pass(me.getRef, [ref, info], me);
      }
      me.references.push(ref.toLowerCase());
    }
}, addRef: function(refs) {
  this.ref(refs);
}, getRef: function(ref, info, config) {
  var me = this, refCache = me.refCache || (me.refCache = {}), cached = refCache[ref];
  info = info || {};
  config = config || {};
  Ext.apply(info, config);
  if (info.forceCreate) 
  {
    return Ext.ComponentManager.create(info, 'component');
  }
  if (!cached) 
  {
    if (info.selector) 
    {
      refCache[ref] = cached = Ext.ComponentQuery.query(info.selector)[0];
    }
    if (!cached && info.autoCreate) 
    {
      refCache[ref] = cached = Ext.ComponentManager.create(info, 'component');
    }
    if (cached) 
    {
      cached.on('beforedestroy', function() {
  refCache[ref] = null;
});
    }
  }
  return cached;
}, hasRef: function(ref) {
  var references = this.references;
  return references && Ext.Array.indexOf(references, ref.toLowerCase()) !== -1;
}, control: function(selectors, listeners, controller) {
  var me = this, ctrl = controller, obj;
  if (Ext.isString(selectors)) 
  {
    obj = {};
    obj[selectors] = listeners;
  } else {
    obj = selectors;
    ctrl = listeners;
  }
  me.eventbus.control(obj, ctrl || me);
}, listen: function(to, controller) {
  this.eventbus.listen(to, controller || this);
}, getController: function(id) {
  var me = this, app = me.application;
  if (id === me.id) 
  {
    return me;
  }
  return app && app.getController(id);
}, getStore: function(name) {
  var storeId, store;
  storeId = (name.indexOf('@') == -1) ? name : name.split('@')[0];
  store = Ext.StoreManager.get(storeId);
  if (!store) 
  {
    name = Ext.app.Controller.getFullName(name, 'store', this.$namespace);
    if (name) 
    {
      store = Ext.create(name.absoluteName, {storeId: storeId});
    }
  }
  return store;
}, getModel: function(model) {
  var name = Ext.app.Controller.getFullName(model, 'model', this.$namespace);
  return name && Ext.ModelManager.getModel(name.absoluteName);
}, getView: function(view) {
  var name = Ext.app.Controller.getFullName(view, 'view', this.$namespace);
  return name && Ext.ClassManager.get(name.absoluteName);
}, getApplication: function() {
  return this.application;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.app, 'Controller'], 0));
;

(Ext.cmd.derive('Ext.container.DockingContainer', Ext.Base, {isDockingContainer: true, defaultDockWeights: {top: {render: 1, visual: 1}, left: {render: 3, visual: 5}, right: {render: 5, visual: 7}, bottom: {render: 7, visual: 3}}, dockOrder: {top: -1, left: -1, right: 1, bottom: 1}, horizontalDocks: 0, addDocked: function(items, pos) {
  var me = this, i = 0, item, length;
  items = me.prepareItems(items);
  length = items.length;
  for (; i < length; i++) 
    {
      item = items[i];
      item.dock = item.dock || 'top';
      if (item.dock === 'left' || item.dock === 'right') 
      {
        me.horizontalDocks++;
      }
      if (pos !== undefined) 
      {
        i += pos;
        me.dockedItems.insert(i, item);
      } else {
        me.dockedItems.add(item);
      }
      item.onAdded(me, i);
      if (me.hasListeners.dockedadd) 
      {
        me.fireEvent('dockedadd', me, item, i);
      }
      if (me.onDockedAdd !== Ext.emptyFn) 
      {
        me.onDockedAdd(item);
      }
    }
  if (me.rendered && !me.suspendLayout) 
  {
    me.updateLayout();
  }
  return items;
}, destroyDockedItems: function() {
  var dockedItems = this.dockedItems, c;
  if (dockedItems) 
  {
    while ((c = dockedItems.first())) 
      {
        this.removeDocked(c, true);
      }
  }
}, doRenderDockedItems: function(out, renderData, after) {
  var me = renderData.$comp, layout = me.componentLayout, items, tree;
  if (layout.getDockedItems && !renderData.$skipDockedItems) 
  {
    items = layout.getDockedItems('render', !after);
    tree = items && layout.getItemsRenderTree(items);
    if (tree) 
    {
      Ext.DomHelper.generateMarkup(tree, out);
    }
  }
}, getDockedComponent: function(comp) {
  if (Ext.isObject(comp)) 
  {
    comp = comp.getItemId();
  }
  return this.dockedItems.get(comp);
}, getDockedItems: function(selector, beforeBody) {
  var dockedItems = this.getComponentLayout().getDockedItems('render', beforeBody);
  if (selector && dockedItems.length) 
  {
    dockedItems = Ext.ComponentQuery.query(selector, dockedItems);
  }
  return dockedItems;
}, getDockingRefItems: function(deep, containerItems) {
  var selector = deep && '*,* *', dockedItems = this.getDockedItems(selector, true), items;
  dockedItems.push.apply(dockedItems, containerItems);
  items = this.getDockedItems(selector, false);
  dockedItems.push.apply(dockedItems, items);
  return dockedItems;
}, initDockingItems: function() {
  var me = this, items = me.dockedItems;
  me.dockedItems = new Ext.util.AbstractMixedCollection(false, me.getComponentId);
  if (items) 
  {
    me.addDocked(items);
  }
}, insertDocked: function(pos, items) {
  this.addDocked(items, pos);
}, onDockedAdd: Ext.emptyFn, onDockedRemove: Ext.emptyFn, removeDocked: function(item, autoDestroy) {
  var me = this, layout, hasLayout;
  autoDestroy = autoDestroy === true || (autoDestroy !== false && me.autoDestroy);
  if (!me.dockedItems.contains(item)) 
  {
    return item;
  }
  if (item.dock === 'left' || item.dock === 'right') 
  {
    me.horizontalDocks--;
  }
  layout = me.componentLayout;
  hasLayout = layout && me.rendered;
  if (hasLayout) 
  {
    layout.onRemove(item);
  }
  me.dockedItems.remove(item);
  item.onRemoved(item.destroying || autoDestroy);
  me.onDockedRemove(item);
  if (autoDestroy) 
  {
    item.destroy();
  } else if (hasLayout) 
  {
    layout.afterRemove(item);
  }
  if (me.hasListeners.dockedremove) 
  {
    me.fireEvent('dockedremove', me, item);
  }
  if (!me.destroying && !me.suspendLayout) 
  {
    me.updateLayout();
  }
  return item;
}, setupDockingRenderTpl: function(renderTpl) {
  renderTpl.renderDockedItems = this.doRenderDockedItems;
}}, 0, 0, 0, 0, 0, 0, [Ext.container, 'DockingContainer'], 0));
;

(Ext.cmd.derive('Ext.toolbar.Fill', Ext.Component, {alternateClassName: 'Ext.Toolbar.Fill', ariaRole: 'presentation', isFill: true, flex: 1}, 0, ["tbfill"], ["component", "tbfill", "box"], {"component": true, "tbfill": true, "box": true}, ["widget.tbfill"], 0, [Ext.toolbar, 'Fill', Ext.Toolbar, 'Fill'], 0));
;

(Ext.cmd.derive('Ext.layout.container.boxOverflow.None', Ext.Base, {alternateClassName: 'Ext.layout.boxOverflow.None', constructor: function(layout, config) {
  this.layout = layout;
  Ext.apply(this, config);
}, handleOverflow: Ext.emptyFn, clearOverflow: Ext.emptyFn, beginLayout: Ext.emptyFn, beginLayoutCycle: Ext.emptyFn, calculate: function(ownerContext) {
  var me = this, plan = ownerContext.state.boxPlan, overflow;
  if (plan && plan.tooNarrow) 
  {
    overflow = me.handleOverflow(ownerContext);
    if (overflow) 
    {
      if (overflow.reservedSpace) 
      {
        me.layout.publishInnerCtSize(ownerContext, overflow.reservedSpace);
      }
    }
  } else {
    me.clearOverflow();
  }
}, completeLayout: Ext.emptyFn, finishedLayout: function(ownerContext) {
  var me = this, owner = me.layout.owner, hiddens, hiddenCount;
  if (owner.hasListeners.overflowchange) 
  {
    hiddens = owner.query('>[hidden]');
    hiddenCount = hiddens.length;
    if (hiddenCount !== me.lastHiddenCount) 
    {
      owner.fireEvent('overflowchange', me.lastHiddenCount, hiddenCount, hiddens);
      me.lastHiddenCount = hiddenCount;
    }
  }
}, onRemove: Ext.emptyFn, getItem: function(item) {
  return this.layout.owner.getComponent(item);
}, getOwnerType: function(owner) {
  var type;
  if (owner.isToolbar) 
  {
    type = 'toolbar';
  } else if (owner.isTabBar) 
  {
    type = 'tabbar';
  } else if (owner.isMenu) 
  {
    type = 'menu';
  } else {
    type = owner.getXType();
  }
  return type;
}, getPrefixConfig: Ext.emptyFn, getSuffixConfig: Ext.emptyFn, getOverflowCls: function() {
  return '';
}}, 1, 0, 0, 0, 0, 0, [Ext.layout.container.boxOverflow, 'None', Ext.layout.boxOverflow, 'None'], 0));
;

(Ext.cmd.derive('Ext.toolbar.Item', Ext.Component, {alternateClassName: 'Ext.Toolbar.Item', enable: Ext.emptyFn, disable: Ext.emptyFn, focus: Ext.emptyFn}, 0, ["tbitem"], ["component", "tbitem", "box"], {"component": true, "tbitem": true, "box": true}, ["widget.tbitem"], 0, [Ext.toolbar, 'Item', Ext.Toolbar, 'Item'], 0));
;

(Ext.cmd.derive('Ext.toolbar.Separator', Ext.toolbar.Item, {alternateClassName: 'Ext.Toolbar.Separator', baseCls: Ext.baseCSSPrefix + 'toolbar-separator', focusable: false, ariaRole: 'separator'}, 0, ["tbseparator"], ["tbseparator", "component", "tbitem", "box"], {"tbseparator": true, "component": true, "tbitem": true, "box": true}, ["widget.tbseparator"], 0, [Ext.toolbar, 'Separator', Ext.Toolbar, 'Separator'], 0));
;

(Ext.cmd.derive('Ext.button.Manager', Ext.Base, {singleton: true, alternateClassName: 'Ext.ButtonToggleManager', groups: {}, pressedButton: null, buttonSelector: '.' + Ext.baseCSSPrefix + 'btn', init: function() {
  var me = this;
  if (!me.initialized) 
  {
    Ext.getDoc().on({keydown: me.onDocumentKeyDown, mouseup: me.onDocumentMouseUp, scope: me});
    me.initialized = true;
  }
}, onDocumentKeyDown: function(e) {
  var k = e.getKey(), btn;
  if (k === e.SPACE || k === e.ENTER) 
  {
    btn = e.getTarget(this.buttonSelector);
    if (btn) 
    {
      Ext.getCmp(btn.id).onClick(e);
    }
  }
}, onButtonMousedown: function(button, e) {
  var pressed = this.pressedButton;
  if (pressed) 
  {
    pressed.onMouseUp(e);
  }
  this.pressedButton = button;
}, onDocumentMouseUp: function(e) {
  var pressed = this.pressedButton;
  if (pressed) 
  {
    pressed.onMouseUp(e);
    this.pressedButton = null;
  }
}, toggleGroup: function(btn, state) {
  if (state) 
  {
    var g = this.groups[btn.toggleGroup], length = g.length, i;
    for (i = 0; i < length; i++) 
      {
        if (g[i] !== btn) 
        {
          g[i].toggle(false);
        }
      }
  }
}, register: function(btn) {
  var me = this, groups = this.groups, group = groups[btn.toggleGroup];
  me.init();
  if (!btn.toggleGroup) 
  {
    return;
  }
  if (!group) 
  {
    group = groups[btn.toggleGroup] = [];
  }
  group.push(btn);
  btn.on('toggle', me.toggleGroup, me);
}, unregister: function(btn) {
  if (!btn.toggleGroup) 
  {
    return;
  }
  var me = this, group = me.groups[btn.toggleGroup];
  if (group) 
  {
    Ext.Array.remove(group, btn);
    btn.un('toggle', me.toggleGroup, me);
  }
}, getPressed: function(group) {
  var g = this.groups[group], i = 0, len;
  if (g) 
  {
    for (len = g.length; i < len; i++) 
      {
        if (g[i].pressed === true) 
        {
          return g[i];
        }
      }
  }
  return null;
}}, 0, 0, 0, 0, 0, 0, [Ext.button, 'Manager', Ext, 'ButtonToggleManager'], 0));
;

(Ext.cmd.derive('Ext.layout.component.Dock', Ext.layout.component.Component, {alternateClassName: 'Ext.layout.component.AbstractDock', type: 'dock', horzAxisProps: {name: 'horz', oppositeName: 'vert', dockBegin: 'left', dockEnd: 'right', horizontal: true, marginBegin: 'margin-left', maxSize: 'maxWidth', minSize: 'minWidth', pos: 'x', setSize: 'setWidth', shrinkWrapDock: 'shrinkWrapDockWidth', size: 'width', sizeModel: 'widthModel'}, vertAxisProps: {name: 'vert', oppositeName: 'horz', dockBegin: 'top', dockEnd: 'bottom', horizontal: false, marginBegin: 'margin-top', maxSize: 'maxHeight', minSize: 'minHeight', pos: 'y', setSize: 'setHeight', shrinkWrapDock: 'shrinkWrapDockHeight', size: 'height', sizeModel: 'heightModel'}, initializedBorders: -1, horizontalCollapsePolicy: {width: true, x: true}, verticalCollapsePolicy: {height: true, y: true}, finishRender: function() {
  var me = this, target, items;
  me.callParent();
  target = me.getRenderTarget();
  items = me.getDockedItems();
  me.finishRenderItems(target, items);
}, isItemBoxParent: function(itemContext) {
  return true;
}, isItemShrinkWrap: function(item) {
  return true;
}, noBorderClasses: [Ext.baseCSSPrefix + 'docked-noborder-top', Ext.baseCSSPrefix + 'docked-noborder-right', Ext.baseCSSPrefix + 'docked-noborder-bottom', Ext.baseCSSPrefix + 'docked-noborder-left'], noBorderClassesSides: {top: Ext.baseCSSPrefix + 'docked-noborder-top', right: Ext.baseCSSPrefix + 'docked-noborder-right', bottom: Ext.baseCSSPrefix + 'docked-noborder-bottom', left: Ext.baseCSSPrefix + 'docked-noborder-left'}, borderWidthProps: {top: 'border-top-width', right: 'border-right-width', bottom: 'border-bottom-width', left: 'border-left-width'}, handleItemBorders: function() {
  var me = this, owner = me.owner, borders, docked, lastItems = me.lastDockedItems, oldBorders = me.borders, currentGeneration = owner.dockedItems.generation, noBorderClassesSides = me.noBorderClassesSides, borderWidthProps = me.borderWidthProps, i, ln, item, dock, side, collapsed = me.collapsed;
  if (me.initializedBorders == currentGeneration || (owner.border && !owner.manageBodyBorders)) 
  {
    return;
  }
  me.initializedBorders = currentGeneration;
  me.collapsed = false;
  me.lastDockedItems = docked = me.getLayoutItems();
  me.collapsed = collapsed;
  borders = {top: [], right: [], bottom: [], left: []};
  for (i = 0 , ln = docked.length; i < ln; i++) 
    {
      item = docked[i];
      dock = item.dock;
      if (item.ignoreBorderManagement) 
      {
        continue;
      }
      if (!borders[dock].satisfied) 
      {
        borders[dock].push(item);
        borders[dock].satisfied = true;
      }
      if (!borders.top.satisfied && dock !== 'bottom') 
      {
        borders.top.push(item);
      }
      if (!borders.right.satisfied && dock !== 'left') 
      {
        borders.right.push(item);
      }
      if (!borders.bottom.satisfied && dock !== 'top') 
      {
        borders.bottom.push(item);
      }
      if (!borders.left.satisfied && dock !== 'right') 
      {
        borders.left.push(item);
      }
    }
  if (lastItems) 
  {
    for (i = 0 , ln = lastItems.length; i < ln; i++) 
      {
        item = lastItems[i];
        if (!item.isDestroyed && !item.ignoreBorderManagement && !owner.manageBodyBorders) 
        {
          item.removeCls(me.noBorderClasses);
        }
      }
  }
  if (oldBorders) 
  {
    for (side in oldBorders) 
      {
        if (owner.manageBodyBorders && oldBorders[side].satisfied) 
        {
          owner.setBodyStyle(borderWidthProps[side], '');
        }
      }
  }
  for (side in borders) 
    {
      ln = borders[side].length;
      if (!owner.manageBodyBorders) 
      {
        for (i = 0; i < ln; i++) 
          {
            borders[side][i].addCls(noBorderClassesSides[side]);
          }
        if ((!borders[side].satisfied && !owner.bodyBorder) || owner.bodyBorder === false) 
        {
          owner.addBodyCls(noBorderClassesSides[side]);
        }
      } else if (borders[side].satisfied) 
      {
        owner.setBodyStyle(borderWidthProps[side], '1px');
      }
    }
  me.borders = borders;
}, beforeLayoutCycle: function(ownerContext) {
  var me = this, owner = me.owner, shrinkWrap = me.sizeModels.shrinkWrap, shrinkWrapDock = owner.shrinkWrapDock, collapsedHorz, collapsedVert;
  if (owner.collapsed) 
  {
    if (owner.collapsedVertical()) 
    {
      collapsedVert = true;
      ownerContext.measureDimensions = 1;
    } else {
      collapsedHorz = true;
      ownerContext.measureDimensions = 2;
    }
  }
  ownerContext.collapsedVert = collapsedVert;
  ownerContext.collapsedHorz = collapsedHorz;
  if (collapsedVert) 
  {
    ownerContext.heightModel = shrinkWrap;
  } else if (collapsedHorz) 
  {
    ownerContext.widthModel = shrinkWrap;
  }
  shrinkWrapDock = shrinkWrapDock === true ? 3 : (shrinkWrapDock || 0);
  ownerContext.shrinkWrapDockHeight = (shrinkWrapDock & 1) && ownerContext.heightModel.shrinkWrap;
  ownerContext.shrinkWrapDockWidth = (shrinkWrapDock & 2) && ownerContext.widthModel.shrinkWrap;
}, beginLayout: function(ownerContext) {
  var me = this, owner = me.owner, docked = me.getLayoutItems(), layoutContext = ownerContext.context, dockedItemCount = docked.length, dockedItems, i, item, itemContext, offsets, collapsed, dock;
  me.callParent(arguments);
  collapsed = owner.getCollapsed();
  if (collapsed !== me.lastCollapsedState && Ext.isDefined(me.lastCollapsedState)) 
  {
    if (me.owner.collapsed) 
    {
      ownerContext.isCollapsingOrExpanding = 1;
      owner.addClsWithUI(owner.collapsedCls);
    } else {
      ownerContext.isCollapsingOrExpanding = 2;
      owner.removeClsWithUI(owner.collapsedCls);
      ownerContext.lastCollapsedState = me.lastCollapsedState;
    }
  }
  me.lastCollapsedState = collapsed;
  ownerContext.dockedItems = dockedItems = [];
  for (i = 0; i < dockedItemCount; i++) 
    {
      item = docked[i];
      if (item.rendered) 
      {
        dock = item.dock;
        itemContext = layoutContext.getCmp(item);
        itemContext.dockedAt = {x: 0, y: 0};
        itemContext.offsets = offsets = Ext.Element.parseBox(item.offsets || 0);
        itemContext.horizontal = dock == 'top' || dock == 'bottom';
        offsets.width = offsets.left + offsets.right;
        offsets.height = offsets.top + offsets.bottom;
        dockedItems.push(itemContext);
      }
    }
  ownerContext.bodyContext = ownerContext.getEl('body');
}, beginLayoutCycle: function(ownerContext) {
  var me = this, docked = ownerContext.dockedItems, len = docked.length, owner = me.owner, frameBody = owner.frameBody, lastHeightModel = me.lastHeightModel, i, item, dock;
  me.callParent(arguments);
  if (me.owner.manageHeight) 
  {
    if (me.lastBodyDisplay) 
    {
      owner.body.dom.style.display = me.lastBodyDisplay = '';
    }
  } else {
    if (me.lastBodyDisplay !== 'inline-block') 
    {
      owner.body.dom.style.display = me.lastBodyDisplay = 'inline-block';
    }
    if (lastHeightModel && lastHeightModel.shrinkWrap && !ownerContext.heightModel.shrinkWrap) 
    {
      owner.body.dom.style.marginBottom = '';
    }
  }
  if (ownerContext.widthModel.auto) 
  {
    if (ownerContext.widthModel.shrinkWrap) 
    {
      owner.el.setWidth(null);
    }
    owner.body.setWidth(null);
    if (frameBody) 
    {
      frameBody.setWidth(null);
    }
  }
  if (ownerContext.heightModel.auto) 
  {
    owner.body.setHeight(null);
    if (frameBody) 
    {
      frameBody.setHeight(null);
    }
  }
  if (ownerContext.collapsedVert) 
  {
    ownerContext.setContentHeight(0);
  } else if (ownerContext.collapsedHorz) 
  {
    ownerContext.setContentWidth(0);
  }
  for (i = 0; i < len; i++) 
    {
      item = docked[i].target;
      dock = item.dock;
      if (dock == 'right') 
      {
        item.setLocalX(0);
      } else if (dock != 'left') 
      {
        continue;
      }
    }
}, calculate: function(ownerContext) {
  var me = this, measure = me.measureAutoDimensions(ownerContext, ownerContext.measureDimensions), state = ownerContext.state, horzDone = state.horzDone, vertDone = state.vertDone, bodyContext = ownerContext.bodyContext, framing, horz, vert, forward, backward;
  ownerContext.borderInfo || ownerContext.getBorderInfo();
  ownerContext.paddingInfo || ownerContext.getPaddingInfo();
  ownerContext.frameInfo || ownerContext.getFrameInfo();
  bodyContext.borderInfo || bodyContext.getBorderInfo();
  bodyContext.paddingInfo || bodyContext.getPaddingInfo();
  if (!ownerContext.frameBorder) 
  {
    if (!(framing = ownerContext.framing)) 
    {
      ownerContext.frameBorder = ownerContext.borderInfo;
      ownerContext.framePadding = ownerContext.paddingInfo;
    } else {
      ownerContext.frameBorder = framing.border;
      ownerContext.framePadding = framing.padding;
    }
  }
  horz = !horzDone && me.createAxis(ownerContext, measure.contentWidth, ownerContext.widthModel, me.horzAxisProps, ownerContext.collapsedHorz);
  vert = !vertDone && me.createAxis(ownerContext, measure.contentHeight, ownerContext.heightModel, me.vertAxisProps, ownerContext.collapsedVert);
  for (forward = 0 , backward = ownerContext.dockedItems.length; backward--; ++forward) 
    {
      if (horz) 
      {
        me.dockChild(ownerContext, horz, backward, forward);
      }
      if (vert) 
      {
        me.dockChild(ownerContext, vert, backward, forward);
      }
    }
  if (horz && me.finishAxis(ownerContext, horz)) 
  {
    state.horzDone = horzDone = horz;
  }
  if (vert && me.finishAxis(ownerContext, vert)) 
  {
    state.vertDone = vertDone = vert;
  }
  if (horzDone && vertDone && me.finishConstraints(ownerContext, horzDone, vertDone)) 
  {
    me.finishPositions(ownerContext, horzDone, vertDone);
  } else {
    me.done = false;
  }
}, createAxis: function(ownerContext, contentSize, sizeModel, axisProps, collapsedAxis) {
  var me = this, begin = 0, owner = me.owner, maxSize = owner[axisProps.maxSize], minSize = owner[axisProps.minSize] || 0, dockBegin = axisProps.dockBegin, dockEnd = axisProps.dockEnd, posProp = axisProps.pos, sizeProp = axisProps.size, hasMaxSize = maxSize != null, shrinkWrap = sizeModel.shrinkWrap, bodyContext, framing, padding, end;
  if (shrinkWrap) 
  {
    if (collapsedAxis) 
    {
      end = 0;
    } else {
      bodyContext = ownerContext.bodyContext;
      end = contentSize + bodyContext.borderInfo[sizeProp];
    }
  } else {
    framing = ownerContext.frameBorder;
    padding = ownerContext.framePadding;
    begin = framing[dockBegin] + padding[dockBegin];
    end = ownerContext.getProp(sizeProp) - (framing[dockEnd] + padding[dockEnd]);
  }
  return {shrinkWrap: sizeModel.shrinkWrap, sizeModel: sizeModel, initialBegin: begin, begin: begin, end: end, collapsed: collapsedAxis, horizontal: axisProps.horizontal, ignoreFrameBegin: null, ignoreFrameEnd: null, initialSize: end - begin, maxChildSize: 0, hasMinMaxConstraints: (minSize || hasMaxSize) && sizeModel.shrinkWrap, minSize: minSize, maxSize: hasMaxSize ? maxSize : 1000000000, bodyPosProp: me.owner.manageHeight ? posProp : axisProps.marginBegin, dockBegin: dockBegin, dockEnd: dockEnd, posProp: posProp, sizeProp: sizeProp, setSize: axisProps.setSize, shrinkWrapDock: ownerContext[axisProps.shrinkWrapDock], sizeModelName: axisProps.sizeModel, dockedPixelsEnd: 0};
}, dockChild: function(ownerContext, axis, backward, forward) {
  var me = this, itemContext = ownerContext.dockedItems[axis.shrinkWrap ? backward : forward], item = itemContext.target, dock = item.dock, sizeProp = axis.sizeProp, pos, size;
  if (item.ignoreParentFrame && ownerContext.isCollapsingOrExpanding) 
  {
    itemContext.clearMarginCache();
  }
  itemContext.marginInfo || itemContext.getMarginInfo();
  if (dock == axis.dockBegin) 
  {
    if (axis.shrinkWrap) 
    {
      pos = me.dockOutwardBegin(ownerContext, itemContext, item, axis);
    } else {
      pos = me.dockInwardBegin(ownerContext, itemContext, item, axis);
    }
  } else if (dock == axis.dockEnd) 
  {
    if (axis.shrinkWrap) 
    {
      pos = me.dockOutwardEnd(ownerContext, itemContext, item, axis);
    } else {
      pos = me.dockInwardEnd(ownerContext, itemContext, item, axis);
    }
  } else {
    if (axis.shrinkWrapDock) 
    {
      size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
      axis.maxChildSize = Math.max(axis.maxChildSize, size);
      pos = 0;
    } else {
      pos = me.dockStretch(ownerContext, itemContext, item, axis);
    }
  }
  itemContext.dockedAt[axis.posProp] = pos;
}, dockInwardBegin: function(ownerContext, itemContext, item, axis) {
  var pos = axis.begin, sizeProp = axis.sizeProp, ignoreParentFrame = item.ignoreParentFrame, delta, size, dock;
  if (ignoreParentFrame) 
  {
    axis.ignoreFrameBegin = itemContext;
    dock = item.dock;
    delta = ownerContext.frameBorder[dock];
    pos -= delta + ownerContext.framePadding[dock];
  }
  if (!item.overlay) 
  {
    size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
    axis.begin += size;
    if (ignoreParentFrame) 
    {
      axis.begin -= delta;
    }
  }
  return pos;
}, dockInwardEnd: function(ownerContext, itemContext, item, axis) {
  var sizeProp = axis.sizeProp, size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp], pos = axis.end - size, frameEnd;
  if (!item.overlay) 
  {
    axis.end = pos;
  }
  if (item.ignoreParentFrame) 
  {
    axis.ignoreFrameEnd = itemContext;
    frameEnd = ownerContext.frameBorder[item.dock];
    pos += frameEnd + ownerContext.framePadding[item.dock];
    axis.end += frameEnd;
  }
  return pos;
}, dockOutwardBegin: function(ownerContext, itemContext, item, axis) {
  var pos = axis.begin, sizeProp = axis.sizeProp, size;
  if (axis.collapsed) 
  {
    axis.ignoreFrameBegin = axis.ignoreFrameEnd = itemContext;
  } else if (item.ignoreParentFrame) 
  {
    axis.ignoreFrameBegin = itemContext;
  }
  if (!item.overlay) 
  {
    size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
    pos -= size;
    axis.begin = pos;
  }
  return pos;
}, dockOutwardEnd: function(ownerContext, itemContext, item, axis) {
  var pos = axis.end, sizeProp = axis.sizeProp, size;
  size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
  if (axis.collapsed) 
  {
    axis.ignoreFrameBegin = axis.ignoreFrameEnd = itemContext;
  } else if (item.ignoreParentFrame) 
  {
    axis.ignoreFrameEnd = itemContext;
  }
  if (!item.overlay) 
  {
    axis.end = pos + size;
    axis.dockedPixelsEnd += size;
  }
  return pos;
}, dockStretch: function(ownerContext, itemContext, item, axis) {
  var dock = item.dock, sizeProp = axis.sizeProp, horizontal = dock == 'top' || dock == 'bottom', border = ownerContext.frameBorder, offsets = itemContext.offsets, padding = ownerContext.framePadding, endProp = horizontal ? 'right' : 'bottom', startProp = horizontal ? 'left' : 'top', pos = axis.begin + offsets[startProp], margin, size;
  if (item.stretch !== false) 
  {
    size = axis.end - pos - offsets[endProp];
    if (item.ignoreParentFrame) 
    {
      pos -= padding[startProp] + border[startProp];
      size += padding[sizeProp] + border[sizeProp];
    }
    margin = itemContext.marginInfo;
    size -= margin[sizeProp];
    itemContext[axis.setSize](size);
  }
  return pos;
}, finishAxis: function(ownerContext, axis) {
  if (isNaN(axis.maxChildSize)) 
  {
    return false;
  }
  var axisBegin = axis.begin, size = axis.end - axisBegin, collapsed = axis.collapsed, setSizeMethod = axis.setSize, beginName = axis.dockBegin, endName = axis.dockEnd, padding = ownerContext.framePadding, border = ownerContext.frameBorder, borderBegin = border[beginName], framing = ownerContext.framing, framingBegin = framing && framing[beginName], paddingBegin = collapsed ? 0 : padding[beginName], sizeProp = axis.sizeProp, ignoreFrameBegin = axis.ignoreFrameBegin, ignoreFrameEnd = axis.ignoreFrameEnd, bodyContext = ownerContext.bodyContext, extraPaddingBegin = Math.max(borderBegin + paddingBegin - framingBegin, 0), bodyPos, bodySize, delta, dirty;
  if (axis.shrinkWrap) 
  {
    bodySize = axis.initialSize;
    if (framing) 
    {
      delta = -axisBegin + borderBegin + paddingBegin;
      bodyPos = delta - framingBegin - extraPaddingBegin;
    } else {
      bodyPos = -axisBegin;
      delta = bodyPos + paddingBegin;
    }
    if (!collapsed) 
    {
      size += padding[sizeProp];
    }
    if (ignoreFrameBegin) 
    {
      delta -= borderBegin;
      bodyPos -= borderBegin;
      ignoreFrameBegin.dockedAt[axis.posProp] -= paddingBegin;
    } else {
      size += borderBegin;
    }
    if (collapsed) 
    {
    } else if (ignoreFrameEnd) 
    {
      ignoreFrameEnd.dockedAt[axis.posProp] += padding[endName];
    } else {
      size += border[endName];
    }
    axis.size = size;
    if (!axis.horizontal && !this.owner.manageHeight) 
    {
      dirty = false;
    }
  } else {
    if (framing) 
    {
      delta = 0;
      bodyPos = axisBegin - framingBegin - extraPaddingBegin;
    } else {
      delta = -borderBegin;
      bodyPos = axisBegin - paddingBegin - borderBegin;
    }
    bodySize = size;
  }
  axis.delta = delta;
  bodyContext[setSizeMethod](bodySize, dirty);
  bodyContext.setProp(axis.bodyPosProp, bodyPos);
  return !isNaN(size);
}, beforeInvalidateShrinkWrapDock: function(itemContext, options) {
  var sizeModelName = options.axis.sizeModelName;
  if (!itemContext[sizeModelName].constrainedMin) 
  {
    itemContext[sizeModelName] = Ext.layout.SizeModel.calculated;
  }
}, afterInvalidateShrinkWrapDock: function(itemContext, options) {
  var axis = options.axis, me = options.layout, pos;
  if (itemContext[axis.sizeModelName].calculated) 
  {
    pos = me.dockStretch(options.ownerContext, itemContext, itemContext.target, axis);
    itemContext.setProp(axis.posProp, axis.delta + pos);
  }
}, finishConstraints: function(ownerContext, horz, vert) {
  var me = this, sizeModels = me.sizeModels, publishWidth = horz.shrinkWrap, publishHeight = vert.shrinkWrap, owner = me.owner, dirty, height, width, heightModel, widthModel, size, minSize, maxSize, maxChildSize, desiredSize;
  if (publishWidth) 
  {
    size = horz.size;
    minSize = horz.collapsed ? 0 : horz.minSize;
    maxSize = horz.maxSize;
    maxChildSize = horz.maxChildSize;
    desiredSize = Math.max(size, maxChildSize);
    if (desiredSize > maxSize) 
    {
      widthModel = sizeModels.constrainedMax;
      width = maxSize;
    } else if (desiredSize < minSize) 
    {
      widthModel = sizeModels.constrainedMin;
      width = minSize;
    } else if (size < maxChildSize) 
    {
      widthModel = sizeModels.constrainedDock;
      owner.dockConstrainedWidth = width = maxChildSize;
    } else {
      width = size;
    }
  }
  if (publishHeight) 
  {
    size = vert.size;
    minSize = vert.collapsed ? 0 : vert.minSize;
    maxSize = vert.maxSize;
    maxChildSize = vert.maxChildSize;
    desiredSize = Math.max(size, maxChildSize + size - vert.initialSize);
    if (desiredSize > maxSize) 
    {
      heightModel = sizeModels.constrainedMax;
      height = maxSize;
    } else if (desiredSize < minSize) 
    {
      heightModel = sizeModels.constrainedMin;
      height = minSize;
    } else if (size < maxChildSize) 
    {
      heightModel = sizeModels.constrainedDock;
      owner.dockConstrainedHeight = height = maxChildSize;
    } else {
      if (!ownerContext.collapsedVert && !owner.manageHeight) 
      {
        dirty = false;
        ownerContext.bodyContext.setProp('margin-bottom', vert.dockedPixelsEnd);
      }
      height = size;
    }
  }
  if (widthModel || heightModel) 
  {
    if (widthModel && heightModel && widthModel.constrainedMax && heightModel.constrainedByMin) 
    {
      ownerContext.invalidate({widthModel: widthModel});
      return false;
    }
    if (!ownerContext.widthModel.calculatedFromShrinkWrap && !ownerContext.heightModel.calculatedFromShrinkWrap) 
    {
      ownerContext.invalidate({widthModel: widthModel, heightModel: heightModel});
      return false;
    }
  } else {
    me.invalidateAxes(ownerContext, horz, vert);
  }
  if (publishWidth) 
  {
    ownerContext.setWidth(width);
    if (widthModel) 
    {
      ownerContext.widthModel = widthModel;
    }
  }
  if (publishHeight) 
  {
    ownerContext.setHeight(height, dirty);
    if (heightModel) 
    {
      ownerContext.heightModel = heightModel;
    }
  }
  return true;
}, invalidateAxes: function(ownerContext, horz, vert) {
  var before = this.beforeInvalidateShrinkWrapDock, after = this.afterInvalidateShrinkWrapDock, horzSize = horz.end - horz.begin, vertSize = vert.initialSize, invalidateHorz = horz.shrinkWrapDock && horz.maxChildSize <= horzSize, invalidateVert = vert.shrinkWrapDock && vert.maxChildSize <= vertSize, dockedItems, len, i, itemContext, itemSize, isHorz, axis, sizeProp;
  if (invalidateHorz || invalidateVert) 
  {
    if (invalidateVert) 
    {
      vert.begin = vert.initialBegin;
      vert.end = vert.begin + vert.initialSize;
    }
    dockedItems = ownerContext.dockedItems;
    for (i = 0 , len = dockedItems.length; i < len; ++i) 
      {
        itemContext = dockedItems[i];
        isHorz = itemContext.horizontal;
        axis = null;
        if (invalidateHorz && isHorz) 
        {
          sizeProp = horz.sizeProp;
          itemSize = horzSize;
          axis = horz;
        } else if (invalidateVert && !isHorz) 
        {
          sizeProp = vert.sizeProp;
          itemSize = vertSize;
          axis = vert;
        }
        if (axis) 
        {
          itemSize -= itemContext.getMarginInfo()[sizeProp];
          if (itemSize !== itemContext.props[sizeProp]) 
          {
            itemContext.invalidate({before: before, after: after, axis: axis, ownerContext: ownerContext, layout: this});
          }
        }
      }
  }
}, finishPositions: function(ownerContext, horz, vert) {
  var dockedItems = ownerContext.dockedItems, length = dockedItems.length, deltaX = horz.delta, deltaY = vert.delta, index, itemContext;
  for (index = 0; index < length; ++index) 
    {
      itemContext = dockedItems[index];
      itemContext.setProp('x', deltaX + itemContext.dockedAt.x);
      itemContext.setProp('y', deltaY + itemContext.dockedAt.y);
    }
}, finishedLayout: function(ownerContext) {
  var me = this, target = ownerContext.target;
  me.callParent(arguments);
  if (!ownerContext.animatePolicy) 
  {
    if (ownerContext.isCollapsingOrExpanding === 1) 
    {
      target.afterCollapse(false);
    } else if (ownerContext.isCollapsingOrExpanding === 2) 
    {
      target.afterExpand(false);
    }
  }
}, getAnimatePolicy: function(ownerContext) {
  var me = this, lastCollapsedState, policy;
  if (ownerContext.isCollapsingOrExpanding == 1) 
  {
    lastCollapsedState = me.lastCollapsedState;
  } else if (ownerContext.isCollapsingOrExpanding == 2) 
  {
    lastCollapsedState = ownerContext.lastCollapsedState;
  }
  if (lastCollapsedState == 'left' || lastCollapsedState == 'right') 
  {
    policy = me.horizontalCollapsePolicy;
  } else if (lastCollapsedState == 'top' || lastCollapsedState == 'bottom') 
  {
    policy = me.verticalCollapsePolicy;
  }
  return policy;
}, getDockedItems: function(order, beforeBody) {
  var me = this, renderedOnly = (order === 'visual'), all = renderedOnly ? Ext.ComponentQuery.query('[rendered]', me.owner.dockedItems.items) : me.owner.dockedItems.items, sort = all && all.length && order !== false, renderOrder, dock, dockedItems, i, isBefore, length;
  if (beforeBody == null) 
  {
    dockedItems = sort && !renderedOnly ? all.slice() : all;
  } else {
    dockedItems = [];
    for (i = 0 , length = all.length; i < length; ++i) 
      {
        dock = all[i].dock;
        isBefore = (dock == 'top' || dock == 'left');
        if (beforeBody ? isBefore : !isBefore) 
        {
          dockedItems.push(all[i]);
        }
      }
    sort = sort && dockedItems.length;
  }
  if (sort) 
  {
    renderOrder = (order = order || 'render') == 'render';
    Ext.Array.sort(dockedItems, function(a, b) {
  var aw, bw;
  if (renderOrder && ((aw = me.owner.dockOrder[a.dock]) !== (bw = me.owner.dockOrder[b.dock]))) 
  {
    if (!(aw + bw)) 
    {
      return aw - bw;
    }
  }
  aw = me.getItemWeight(a, order);
  bw = me.getItemWeight(b, order);
  if ((aw !== undefined) && (bw !== undefined)) 
  {
    return aw - bw;
  }
  return 0;
});
  }
  return dockedItems || [];
}, getItemWeight: function(item, order) {
  var weight = item.weight || this.owner.defaultDockWeights[item.dock];
  return weight[order] || weight;
}, getLayoutItems: function() {
  var me = this, items, itemCount, item, i, result;
  if (me.owner.collapsed) 
  {
    result = me.owner.getCollapsedDockedItems();
  } else {
    items = me.getDockedItems('visual');
    itemCount = items.length;
    result = [];
    for (i = 0; i < itemCount; i++) 
      {
        item = items[i];
        if (!item.hidden) 
        {
          result.push(item);
        }
      }
  }
  return result;
}, measureContentWidth: function(ownerContext) {
  var bodyContext = ownerContext.bodyContext;
  return bodyContext.el.getWidth() - bodyContext.getBorderInfo().width;
}, measureContentHeight: function(ownerContext) {
  var bodyContext = ownerContext.bodyContext;
  return bodyContext.el.getHeight() - bodyContext.getBorderInfo().height;
}, redoLayout: function(ownerContext) {
  var me = this, owner = me.owner;
  if (ownerContext.isCollapsingOrExpanding == 1) 
  {
    if (owner.reExpander) 
    {
      owner.reExpander.el.show();
    }
    owner.addClsWithUI(owner.collapsedCls);
    ownerContext.redo(true);
  } else if (ownerContext.isCollapsingOrExpanding == 2) 
  {
    owner.removeClsWithUI(owner.collapsedCls);
    ownerContext.bodyContext.redo();
  }
}, renderChildren: function() {
  var me = this, items = me.getDockedItems(), target = me.getRenderTarget();
  me.handleItemBorders();
  me.renderItems(items, target);
}, renderItems: function(items, target) {
  var me = this, dockedItemCount = items.length, itemIndex = 0, correctPosition = 0, staticNodeCount = 0, targetNodes = me.getRenderTarget().dom.childNodes, targetChildCount = targetNodes.length, i, j, targetChildNode, item;
  for (i = 0 , j = 0; i < targetChildCount; i++) 
    {
      targetChildNode = targetNodes[i];
      if (Ext.fly(targetChildNode).hasCls(Ext.baseCSSPrefix + 'resizable-handle')) 
      {
        break;
      }
      for (j = 0; j < dockedItemCount; j++) 
        {
          item = items[j];
          if (item.rendered && item.el.dom === targetChildNode) 
          {
            break;
          }
        }
      if (j === dockedItemCount) 
      {
        staticNodeCount++;
      }
    }
  for (; itemIndex < dockedItemCount; itemIndex++ , correctPosition++) 
    {
      item = items[itemIndex];
      if (itemIndex === correctPosition && (item.dock === 'right' || item.dock === 'bottom')) 
      {
        correctPosition += staticNodeCount;
      }
      if (item && !item.rendered) 
      {
        me.renderItem(item, target, correctPosition);
      } else if (!me.isValidParent(item, target, correctPosition)) 
      {
        me.moveItem(item, target, correctPosition);
      }
    }
}, undoLayout: function(ownerContext) {
  var me = this, owner = me.owner;
  if (ownerContext.isCollapsingOrExpanding == 1) 
  {
    if (owner.reExpander) 
    {
      owner.reExpander.el.hide();
    }
    owner.removeClsWithUI(owner.collapsedCls);
    ownerContext.undo(true);
  } else if (ownerContext.isCollapsingOrExpanding == 2) 
  {
    owner.addClsWithUI(owner.collapsedCls);
    ownerContext.bodyContext.undo();
  }
}, sizePolicy: {nostretch: {setsWidth: 0, setsHeight: 0}, horz: {shrinkWrap: {setsWidth: 1, setsHeight: 0, readsWidth: 1}, stretch: {setsWidth: 1, setsHeight: 0}}, vert: {shrinkWrap: {setsWidth: 0, setsHeight: 1, readsHeight: 1}, stretch: {setsWidth: 0, setsHeight: 1}}, stretchV: {setsWidth: 0, setsHeight: 1}, autoStretchH: {readsWidth: 1, setsWidth: 1, setsHeight: 0}, autoStretchV: {readsHeight: 1, setsWidth: 0, setsHeight: 1}}, getItemSizePolicy: function(item, ownerSizeModel) {
  var me = this, policy = me.sizePolicy, shrinkWrapDock = me.owner.shrinkWrapDock, dock, vertical;
  if (item.stretch === false) 
  {
    return policy.nostretch;
  }
  dock = item.dock;
  vertical = (dock == 'left' || dock == 'right');
  shrinkWrapDock = shrinkWrapDock === true ? 3 : (shrinkWrapDock || 0);
  if (vertical) 
  {
    policy = policy.vert;
    shrinkWrapDock = shrinkWrapDock & 1;
  } else {
    policy = policy.horz;
    shrinkWrapDock = shrinkWrapDock & 2;
  }
  if (shrinkWrapDock) 
  {
    if (!ownerSizeModel) 
    {
      ownerSizeModel = me.owner.getSizeModel();
    }
    if (ownerSizeModel[vertical ? 'height' : 'width'].shrinkWrap) 
    {
      return policy.shrinkWrap;
    }
  }
  return policy.stretch;
}, configureItem: function(item, pos) {
  this.callParent(arguments);
  item.addCls(Ext.baseCSSPrefix + 'docked');
  item.addClsWithUI(this.getDockCls(item.dock));
}, getDockCls: function(dock) {
  return 'docked-' + dock;
}, afterRemove: function(item) {
  this.callParent(arguments);
  if (this.itemCls) 
  {
    item.el.removeCls(this.itemCls + '-' + item.dock);
  }
  var dom = item.el.dom;
  if (!item.destroying && dom) 
  {
    dom.parentNode.removeChild(dom);
  }
  this.childrenChanged = true;
}, borderCollapseMap: {}, getBorderCollapseTable: function() {
  var me = this, map = me.borderCollapseMap, owner = me.owner, baseCls = owner.baseCls, ui = owner.ui, table;
  map = map[baseCls] || (map[baseCls] = {});
  table = map[ui];
  if (!table) 
  {
    baseCls += '-' + ui + '-outer-border-';
    map[ui] = table = [0, baseCls + 'l', baseCls + 'b', baseCls + 'bl', baseCls + 'r', baseCls + 'rl', baseCls + 'rb', baseCls + 'rbl', baseCls + 't', baseCls + 'tl', baseCls + 'tb', baseCls + 'tbl', baseCls + 'tr', baseCls + 'trl', baseCls + 'trb', baseCls + 'trbl'];
  }
  return table;
}}, 0, 0, 0, 0, ["layout.dock"], 0, [Ext.layout.component, 'Dock', Ext.layout.component, 'AbstractDock'], 0));
;

(Ext.cmd.derive('Ext.menu.Manager', Ext.Base, {singleton: true, alternateClassName: 'Ext.menu.MenuMgr', menuSelector: '.' + Ext.baseCSSPrefix + 'menu', menus: {}, groups: {}, attached: false, lastShow: new Date(), init: function() {
  var me = this;
  me.active = new Ext.util.MixedCollection();
  Ext.getDoc().addKeyListener(27, function() {
  if (me.active.length > 0) 
  {
    me.hideAll();
  }
}, me);
}, hideAll: function() {
  var active = this.active, menus, m, mLen;
  if (active && active.length > 0) 
  {
    menus = Ext.Array.slice(active.items);
    mLen = menus.length;
    for (m = 0; m < mLen; m++) 
      {
        menus[m].hide();
      }
    return true;
  }
  return false;
}, onHide: function(m) {
  var me = this, active = me.active;
  active.remove(m);
  if (active.length < 1) 
  {
    Ext.getDoc().un('mousedown', me.onMouseDown, me);
    me.attached = false;
  }
}, onShow: function(m) {
  var me = this, active = me.active, attached = me.attached;
  me.lastShow = new Date();
  active.add(m);
  if (!attached) 
  {
    Ext.getDoc().on('mousedown', me.onMouseDown, me, {buffer: Ext.isIE9m ? 10 : undefined});
    me.attached = true;
  }
  m.toFront();
}, onBeforeHide: function(m) {
  if (m.activeChild) 
  {
    m.activeChild.hide();
  }
  if (m.autoHideTimer) 
  {
    clearTimeout(m.autoHideTimer);
    delete m.autoHideTimer;
  }
}, onBeforeShow: function(m) {
  var active = this.active, parentMenu = m.parentMenu;
  active.remove(m);
  if (!parentMenu && !m.allowOtherMenus) 
  {
    this.hideAll();
  } else if (parentMenu && parentMenu.activeChild && m != parentMenu.activeChild) 
  {
    parentMenu.activeChild.hide();
  }
}, onMouseDown: function(e) {
  var me = this, active = me.active, activeMenuCount = active.length, lastShow = me.lastShow, i;
  if (Ext.Date.getElapsed(lastShow) > 50 && activeMenuCount) 
  {
    if (Ext.isIE9m && !Ext.getDoc().contains(e.target)) 
    {
      return;
    } else {
      for (i = 0; i < activeMenuCount; i++) 
        {
          if (active.items[i].owns(e.target)) 
          {
            return;
          }
        }
    }
    me.hideAll();
  }
}, register: function(menu) {
  var me = this;
  if (!me.active) 
  {
    me.init();
  }
  if (menu.floating) 
  {
    me.menus[menu.id] = menu;
    menu.on({beforehide: me.onBeforeHide, hide: me.onHide, beforeshow: me.onBeforeShow, show: me.onShow, scope: me});
  }
}, get: function(menu) {
  var menus = this.menus;
  if (typeof menu == 'string') 
  {
    if (!menus) 
    {
      return null;
    }
    return menus[menu];
  } else if (menu.isMenu) 
  {
    return menu;
  } else if (Ext.isArray(menu)) 
  {
    return new Ext.menu.Menu({items: menu});
  } else {
    return Ext.ComponentManager.create(menu, 'menu');
  }
}, unregister: function(menu) {
  var me = this, menus = me.menus, active = me.active;
  delete menus[menu.id];
  active.remove(menu);
  menu.un({beforehide: me.onBeforeHide, hide: me.onHide, beforeshow: me.onBeforeShow, show: me.onShow, scope: me});
}, registerCheckable: function(menuItem) {
  var groups = this.groups, groupId = menuItem.group;
  if (groupId) 
  {
    if (!groups[groupId]) 
    {
      groups[groupId] = [];
    }
    groups[groupId].push(menuItem);
  }
}, unregisterCheckable: function(menuItem) {
  var groups = this.groups, groupId = menuItem.group;
  if (groupId) 
  {
    Ext.Array.remove(groups[groupId], menuItem);
  }
}, onCheckChange: function(menuItem, state) {
  var groups = this.groups, groupId = menuItem.group, i = 0, group, ln, curr;
  if (groupId && state) 
  {
    group = groups[groupId];
    ln = group.length;
    for (; i < ln; i++) 
      {
        curr = group[i];
        if (curr != menuItem) 
        {
          curr.setChecked(false);
        }
      }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.menu, 'Manager', Ext.menu, 'MenuMgr'], 0));
;

(Ext.cmd.derive('Ext.util.ClickRepeater', Ext.util.Observable, {constructor: function(el, config) {
  var me = this;
  me.el = Ext.get(el);
  me.el.unselectable();
  Ext.apply(me, config);
  me.callParent();
  me.addEvents("mousedown", "click", "mouseup");
  if (!me.disabled) 
  {
    me.disabled = true;
    me.enable();
  }
  if (me.handler) 
  {
    me.on("click", me.handler, me.scope || me);
  }
}, interval: 20, delay: 250, preventDefault: true, stopDefault: false, timer: 0, enable: function() {
  if (this.disabled) 
  {
    this.el.on('mousedown', this.handleMouseDown, this);
    if (Ext.isIE && !(Ext.isIE10p || (Ext.isStrict && Ext.isIE9))) 
    {
      this.el.on('dblclick', this.handleDblClick, this);
    }
    if (this.preventDefault || this.stopDefault) 
    {
      this.el.on('click', this.eventOptions, this);
    }
  }
  this.disabled = false;
}, disable: function(force) {
  if (force || !this.disabled) 
  {
    clearTimeout(this.timer);
    if (this.pressedCls) 
    {
      this.el.removeCls(this.pressedCls);
    }
    Ext.getDoc().un('mouseup', this.handleMouseUp, this);
    this.el.removeAllListeners();
  }
  this.disabled = true;
}, setDisabled: function(disabled) {
  this[disabled ? 'disable' : 'enable']();
}, eventOptions: function(e) {
  if (this.preventDefault) 
  {
    e.preventDefault();
  }
  if (this.stopDefault) 
  {
    e.stopEvent();
  }
}, destroy: function() {
  this.disable(true);
  Ext.destroy(this.el);
  this.clearListeners();
}, handleDblClick: function(e) {
  clearTimeout(this.timer);
  this.el.blur();
  this.fireEvent("mousedown", this, e);
  this.fireEvent("click", this, e);
}, handleMouseDown: function(e) {
  clearTimeout(this.timer);
  this.el.blur();
  if (this.pressedCls) 
  {
    this.el.addCls(this.pressedCls);
  }
  this.mousedownTime = new Date();
  Ext.getDoc().on("mouseup", this.handleMouseUp, this);
  this.el.on("mouseout", this.handleMouseOut, this);
  this.fireEvent("mousedown", this, e);
  this.fireEvent("click", this, e);
  if (this.accelerate) 
  {
    this.delay = 400;
  }
  e = new Ext.EventObjectImpl(e);
  this.timer = Ext.defer(this.click, this.delay || this.interval, this, [e]);
}, click: function(e) {
  this.fireEvent("click", this, e);
  this.timer = Ext.defer(this.click, this.accelerate ? this.easeOutExpo(Ext.Date.getElapsed(this.mousedownTime), 400, -390, 12000) : this.interval, this, [e]);
}, easeOutExpo: function(t, b, c, d) {
  return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
}, handleMouseOut: function() {
  clearTimeout(this.timer);
  if (this.pressedCls) 
  {
    this.el.removeCls(this.pressedCls);
  }
  this.el.on("mouseover", this.handleMouseReturn, this);
}, handleMouseReturn: function() {
  this.el.un("mouseover", this.handleMouseReturn, this);
  if (this.pressedCls) 
  {
    this.el.addCls(this.pressedCls);
  }
  this.click();
}, handleMouseUp: function(e) {
  clearTimeout(this.timer);
  this.el.un("mouseover", this.handleMouseReturn, this);
  this.el.un("mouseout", this.handleMouseOut, this);
  Ext.getDoc().un("mouseup", this.handleMouseUp, this);
  if (this.pressedCls) 
  {
    this.el.removeCls(this.pressedCls);
  }
  this.fireEvent("mouseup", this, e);
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'ClickRepeater'], 0));
;

(Ext.cmd.derive('Ext.layout.component.Button', Ext.layout.component.Auto, {type: 'button', htmlRE: /<.*>/, beginLayout: function(ownerContext) {
  var me = this, owner = me.owner, text = owner.text;
  me.callParent(arguments);
  ownerContext.btnWrapContext = ownerContext.getEl('btnWrap');
  ownerContext.btnElContext = ownerContext.getEl('btnEl');
  ownerContext.btnInnerElContext = ownerContext.getEl('btnInnerEl');
  ownerContext.btnIconElContext = ownerContext.getEl('btnIconEl');
  if (text && me.htmlRE.test(text)) 
  {
    ownerContext.isHtmlText = true;
    owner.btnInnerEl.setStyle('line-height', 'normal');
    owner.btnInnerEl.setStyle('padding-top', '');
  }
}, beginLayoutCycle: function(ownerContext) {
  var owner = this.owner, lastWidthModel = this.lastWidthModel, lastHeightModel = this.lastHeightModel, btnInnerEl = owner.btnInnerEl, table = owner.getFrameInfo().table;
  this.callParent(arguments);
  if (lastWidthModel && !lastWidthModel.shrinkWrap && ownerContext.widthModel.shrinkWrap) 
  {
    owner.btnWrap.setStyle('height', '');
    owner.btnEl.setStyle('height', '');
    btnInnerEl.setStyle('line-height', '');
    if (table) 
    {
      btnInnerEl.setStyle('width', '');
    }
  }
  if (table && lastHeightModel && !lastHeightModel.shrinkWrap && ownerContext.heightModel.shrinkWrap) 
  {
    btnInnerEl.setStyle('height', '');
  }
}, calculate: function(ownerContext) {
  var me = this, owner = me.owner, btnElContext = ownerContext.btnElContext, btnInnerElContext = ownerContext.btnInnerElContext, btnWrapContext = ownerContext.btnWrapContext, mmax = Math.max, ownerHeight, contentHeight, btnElHeight, innerElHeight;
  me.callParent(arguments);
  if (ownerContext.heightModel.shrinkWrap) 
  {
    btnElHeight = owner.btnEl.getHeight();
    if (ownerContext.isHtmlText) 
    {
      me.centerInnerEl(ownerContext, btnElHeight);
      me.ieCenterIcon(ownerContext, btnElHeight);
    }
  } else {
    ownerHeight = ownerContext.getProp('height');
    if (ownerHeight) 
    {
      contentHeight = ownerHeight - ownerContext.getFrameInfo().height - ownerContext.getPaddingInfo().height;
      btnElHeight = contentHeight;
      if ((owner.menu || owner.split) && owner.arrowAlign === 'bottom') 
      {
        btnElHeight -= btnWrapContext.getPaddingInfo().bottom;
      }
      innerElHeight = btnElHeight;
      if ((owner.icon || owner.iconCls || owner.glyph) && (owner.iconAlign === 'top' || owner.iconAlign === 'bottom')) 
      {
        innerElHeight -= btnInnerElContext.getPaddingInfo().height;
      }
      btnWrapContext.setProp('height', mmax(0, contentHeight));
      btnElContext.setProp('height', mmax(0, btnElHeight));
      if (ownerContext.isHtmlText) 
      {
        me.centerInnerEl(ownerContext, btnElHeight);
      } else {
        btnInnerElContext.setProp('line-height', mmax(0, innerElHeight) + 'px');
      }
      me.ieCenterIcon(ownerContext, btnElHeight);
    } else if (ownerHeight !== 0) 
    {
      me.done = false;
    }
  }
}, centerInnerEl: function(ownerContext, btnElHeight) {
  var me = this, btnInnerElContext = ownerContext.btnInnerElContext, innerElHeight = me.owner.btnInnerEl.getHeight();
  if (ownerContext.heightModel.shrinkWrap && (btnElHeight < innerElHeight)) 
  {
    ownerContext.btnElContext.setHeight(innerElHeight);
  } else if (btnElHeight > innerElHeight) 
  {
    btnInnerElContext.setProp('padding-top', Math.round((btnElHeight - innerElHeight) / 2) + btnInnerElContext.getPaddingInfo().top);
  }
}, ieCenterIcon: function(ownerContext, btnElHeight) {
  var iconAlign = this.owner.iconAlign;
  if ((Ext.isIEQuirks || Ext.isIE6) && (iconAlign === 'left' || iconAlign === 'right')) 
  {
    ownerContext.btnIconElContext.setHeight(btnElHeight);
  }
}, publishInnerWidth: function(ownerContext, width) {
  if (this.owner.getFrameInfo().table) 
  {
    ownerContext.btnInnerElContext.setWidth(width - ownerContext.getFrameInfo().width - ownerContext.getPaddingInfo().width - ownerContext.btnWrapContext.getPaddingInfo().width);
  }
}}, 0, 0, 0, 0, ["layout.button"], 0, [Ext.layout.component, 'Button'], 0));
;

(Ext.cmd.derive('Ext.util.TextMetrics', Ext.Base, {statics: {shared: null, measure: function(el, text, fixedWidth) {
  var me = this, shared = me.shared;
  if (!shared) 
  {
    shared = me.shared = new me(el, fixedWidth);
  }
  shared.bind(el);
  shared.setFixedWidth(fixedWidth || 'auto');
  return shared.getSize(text);
}, destroy: function() {
  var me = this;
  Ext.destroy(me.shared);
  me.shared = null;
}}, constructor: function(bindTo, fixedWidth) {
  var me = this, measure = Ext.getBody().createChild({role: 'presentation', cls: Ext.baseCSSPrefix + 'textmetrics'});
  me.measure = measure;
  if (bindTo) 
  {
    me.bind(bindTo);
  }
  measure.position('absolute');
  measure.setLocalXY(-1000, -1000);
  measure.hide();
  if (fixedWidth) 
  {
    measure.setWidth(fixedWidth);
  }
}, getSize: function(text) {
  var measure = this.measure, size;
  measure.update(text);
  size = measure.getSize();
  measure.update('');
  return size;
}, bind: function(el) {
  var me = this;
  me.el = Ext.get(el);
  me.measure.setStyle(me.el.getStyles('font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing', 'word-break'));
}, setFixedWidth: function(width) {
  this.measure.setWidth(width);
}, getWidth: function(text) {
  this.measure.dom.style.width = 'auto';
  return this.getSize(text).width;
}, getHeight: function(text) {
  return this.getSize(text).height;
}, destroy: function() {
  var me = this;
  me.measure.remove();
  delete me.el;
  delete me.measure;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'TextMetrics'], function() {
  Ext.Element.addMethods({getTextWidth: function(text, min, max) {
  return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.value(text, this.dom.innerHTML, true)).width, min || 0, max || 1000000);
}});
}));
;

(Ext.cmd.derive('Ext.button.Button', Ext.Component, {alternateClassName: 'Ext.Button', isButton: true, componentLayout: 'button', hidden: false, disabled: false, pressed: false, tabIndex: 0, enableToggle: false, menuAlign: 'tl-bl?', showEmptyMenu: false, textAlign: 'center', clickEvent: 'click', preventDefault: true, handleMouseEvents: true, tooltipType: 'qtip', baseCls: Ext.baseCSSPrefix + 'btn', pressedCls: 'pressed', overCls: 'over', focusCls: 'focus', menuActiveCls: 'menu-active', hrefTarget: '_blank', destroyMenu: true, ariaRole: 'button', childEls: ['btnEl', 'btnWrap', 'btnInnerEl', 'btnIconEl'], renderTpl: ['<span id="{id}-btnWrap" role="presentation" class="{baseCls}-wrap', '<tpl if="splitCls"> {splitCls}</tpl>', '{childElCls}" unselectable="on">', '<span id="{id}-btnEl" class="{baseCls}-button" role="presentation">', '<span id="{id}-btnInnerEl" class="{baseCls}-inner {innerCls}', '{childElCls}" unselectable="on">', '{text}', '</span>', '<span role="presentation" id="{id}-btnIconEl" class="{baseCls}-icon-el {iconCls}', '{childElCls} {glyphCls}" unselectable="on" style="', '<tpl if="iconUrl">background-image:url({iconUrl});</tpl>', '<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">', '<tpl if="glyph">&#{glyph};</tpl><tpl if="iconCls || iconUrl">&#160;</tpl>', '</span>', '</span>', '</span>', '<tpl if="closable">', '<span id="{id}-closeEl" role="presentation"', ' class="{baseCls}-close-btn"', '<tpl if="closeText">', ' title="{closeText}" aria-label="{closeText}"', '</tpl>', '>', '</span>', '</tpl>'], scale: 'small', allowedScales: ['small', 'medium', 'large'], iconAlign: 'left', arrowAlign: 'right', arrowCls: 'arrow', maskOnDisable: false, shrinkWrap: 3, frame: true, autoEl: {tag: 'a', hidefocus: 'on', unselectable: 'on'}, hasFrameTable: function() {
  return this.href && this.frameTable;
}, frameTableListener: function() {
  if (!this.disabled) 
  {
    this.doNavigate();
  }
}, doNavigate: function() {
  if (this.hrefTarget === '_blank') 
  {
    window.open(this.getHref(), this.hrefTarget);
  } else {
    location.href = this.getHref();
  }
}, _triggerRegion: {}, initComponent: function() {
  var me = this;
  me.addCls(Ext.baseCSSPrefix + 'unselectable');
  me.callParent(arguments);
  me.addEvents('click', 'toggle', 'mouseover', 'mouseout', 'menushow', 'menuhide', 'menutriggerover', 'menutriggerout', 'textchange', 'iconchange', 'glyphchange');
  if (me.menu) 
  {
    me.split = true;
    me.setMenu(me.menu, false);
  }
  if (me.url) 
  {
    me.href = me.url;
  }
  if (me.href && !me.hasOwnProperty('preventDefault')) 
  {
    me.preventDefault = false;
  }
  if (Ext.isString(me.toggleGroup) && me.toggleGroup !== '') 
  {
    me.enableToggle = true;
  }
  if (me.html && !me.text) 
  {
    me.text = me.html;
    delete me.html;
  }
  me.glyphCls = me.baseCls + '-glyph';
}, getActionEl: function() {
  return this.el;
}, getFocusEl: function() {
  return this.el;
}, setComponentCls: function() {
  var me = this, cls = me.getComponentCls();
  if (!Ext.isEmpty(me.oldCls)) 
  {
    me.removeClsWithUI(me.oldCls);
    me.removeClsWithUI(me.pressedCls);
  }
  me.oldCls = cls;
  me.addClsWithUI(cls);
}, getComponentCls: function() {
  var me = this, cls;
  if (me.iconCls || me.icon || me.glyph) 
  {
    cls = [me.text ? 'icon-text-' + me.iconAlign : 'icon'];
  } else if (me.text) 
  {
    cls = ['noicon'];
  } else {
    cls = [];
  }
  if (me.pressed) 
  {
    cls[cls.length] = me.pressedCls;
  }
  return cls;
}, getElConfig: function() {
  var me = this, config = me.callParent(), href = me.getHref(), hrefTarget = me.hrefTarget;
  if (config.tag === 'a') 
  {
    if (!me.disabled) 
    {
      config.tabIndex = me.tabIndex;
    }
    if (href) 
    {
      config.href = href;
      if (hrefTarget) 
      {
        config.target = hrefTarget;
      }
    }
  }
  return config;
}, beforeRender: function() {
  var me = this;
  me.callParent();
  me.oldCls = me.getComponentCls();
  me.addClsWithUI(me.oldCls);
  Ext.applyIf(me.renderData, me.getTemplateArgs());
}, setMenu: function(menu, destroyMenu) {
  var me = this, oldMenu = me.menu;
  if (oldMenu && destroyMenu !== false && me.destroyMenu) 
  {
    oldMenu.destroy();
  }
  if (oldMenu) 
  {
    oldMenu.ownerCmp = oldMenu.ownerButton = null;
  }
  if (menu) 
  {
    menu = Ext.menu.Manager.get(menu);
    menu.ownerCmp = menu.ownerButton = me;
    me.mon(menu, {scope: me, show: me.onMenuShow, hide: me.onMenuHide});
    if (!oldMenu) 
    {
      me.split = true;
      if (me.rendered) 
      {
        me.btnWrap.addCls(me.getSplitCls());
        me.updateLayout();
      }
    }
    me.menu = menu;
  } else {
    if (me.rendered) 
    {
      me.btnWrap.removeCls(me.getSplitCls());
      me.updateLayout();
    }
    me.split = false;
    me.menu = null;
  }
}, onRender: function() {
  var me = this, addOnclick, btn, btnListeners;
  me.doc = Ext.getDoc();
  me.callParent(arguments);
  btn = me.el;
  if (me.tooltip) 
  {
    me.setTooltip(me.tooltip, true);
  }
  if (me.handleMouseEvents) 
  {
    btnListeners = {scope: me, mouseover: me.onMouseOver, mouseout: me.onMouseOut, mousedown: me.onMouseDown};
    if (me.split) 
    {
      btnListeners.mousemove = me.onMouseMove;
    }
  } else {
    btnListeners = {scope: me};
  }
  if (me.menu) 
  {
    me.keyMap = new Ext.util.KeyMap({target: me.el, key: Ext.EventObject.DOWN, handler: me.onDownKey, scope: me});
  }
  if (me.repeat) 
  {
    me.mon(new Ext.util.ClickRepeater(btn, Ext.isObject(me.repeat) ? me.repeat : {}), 'click', me.onRepeatClick, me);
  } else {
    if (btnListeners[me.clickEvent]) 
    {
      addOnclick = true;
    } else {
      btnListeners[me.clickEvent] = me.onClick;
    }
  }
  me.mon(btn, btnListeners);
  if (me.hasFrameTable()) 
  {
    me.mon(me.frameTable, 'click', me.frameTableListener, me);
  }
  if (addOnclick) 
  {
    me.mon(btn, me.clickEvent, me.onClick, me);
  }
  Ext.button.Manager.register(me);
}, getTemplateArgs: function() {
  var me = this, glyph = me.glyph, glyphFontFamily = Ext._glyphFontFamily, glyphParts;
  if (typeof glyph === 'string') 
  {
    glyphParts = glyph.split('@');
    glyph = glyphParts[0];
    glyphFontFamily = glyphParts[1];
  }
  return {innerCls: me.getInnerCls(), splitCls: me.getSplitCls(), iconUrl: me.icon, iconCls: me.iconCls, glyph: glyph, glyphCls: glyph ? me.glyphCls : '', glyphFontFamily: glyphFontFamily, text: me.text || '&#160;', closeText: me.closeText};
}, setHref: function(href) {
  this.href = href;
  this.el.dom.href = this.getHref();
}, getHref: function() {
  var me = this, href = me.href;
  return href ? Ext.urlAppend(href, Ext.Object.toQueryString(Ext.apply({}, me.params, me.baseParams))) : false;
}, setParams: function(params) {
  this.params = params;
  this.el.dom.href = this.getHref();
}, getSplitCls: function() {
  var me = this;
  return me.split ? (me.baseCls + '-' + me.arrowCls) + ' ' + (me.baseCls + '-' + me.arrowCls + '-' + me.arrowAlign) : '';
}, getInnerCls: function() {
  return this.textAlign ? this.baseCls + '-inner-' + this.textAlign : '';
}, setIcon: function(icon) {
  icon = icon || '';
  var me = this, btnIconEl = me.btnIconEl, oldIcon = me.icon || '';
  me.icon = icon;
  if (icon != oldIcon) 
  {
    if (btnIconEl) 
    {
      btnIconEl.setStyle('background-image', icon ? 'url(' + icon + ')' : '');
      me.setComponentCls();
      if (me.didIconStateChange(oldIcon, icon)) 
      {
        me.updateLayout();
      }
    }
    me.fireEvent('iconchange', me, oldIcon, icon);
  }
  return me;
}, setIconCls: function(cls) {
  cls = cls || '';
  var me = this, btnIconEl = me.btnIconEl, oldCls = me.iconCls || '';
  me.iconCls = cls;
  if (oldCls != cls) 
  {
    if (btnIconEl) 
    {
      btnIconEl.removeCls(oldCls);
      btnIconEl.addCls(cls);
      me.setComponentCls();
      if (me.didIconStateChange(oldCls, cls)) 
      {
        me.updateLayout();
      }
    }
    me.fireEvent('iconchange', me, oldCls, cls);
  }
  return me;
}, setGlyph: function(glyph) {
  glyph = glyph || 0;
  var me = this, btnIconEl = me.btnIconEl, oldGlyph = me.glyph, fontFamily, glyphParts;
  me.glyph = glyph;
  if (btnIconEl) 
  {
    if (typeof glyph === 'string') 
    {
      glyphParts = glyph.split('@');
      glyph = glyphParts[0];
      fontFamily = glyphParts[1] || Ext._glyphFontFamily;
    }
    if (!glyph) 
    {
      btnIconEl.dom.innerHTML = '';
    } else if (oldGlyph != glyph) 
    {
      btnIconEl.dom.innerHTML = '&#' + glyph + ';';
    }
    if (fontFamily) 
    {
      btnIconEl.setStyle('font-family', fontFamily);
    }
  }
  me.fireEvent('glyphchange', me, me.glyph, oldGlyph);
  return me;
}, setTooltip: function(tooltip, initial) {
  var me = this;
  if (me.rendered) 
  {
    if (!initial || !tooltip) 
    {
      me.clearTip();
    }
    if (tooltip) 
    {
      if (Ext.quickTipsActive && Ext.isObject(tooltip)) 
      {
        Ext.tip.QuickTipManager.register(Ext.apply({target: me.el.id}, tooltip));
        me.tooltip = tooltip;
      } else {
        me.el.dom.setAttribute(me.getTipAttr(), tooltip);
      }
    }
  } else {
    me.tooltip = tooltip;
  }
  return me;
}, setTextAlign: function(align) {
  var me = this, btnEl = me.btnEl;
  if (btnEl) 
  {
    btnEl.removeCls(me.baseCls + '-inner-' + me.textAlign);
    btnEl.addCls(me.baseCls + '-inner-' + align);
  }
  me.textAlign = align;
  return me;
}, getTipAttr: function() {
  return this.tooltipType == 'qtip' ? 'data-qtip' : 'title';
}, getRefItems: function(deep) {
  var menu = this.menu, items;
  if (menu) 
  {
    items = menu.getRefItems(deep);
    items.unshift(menu);
  }
  return items || [];
}, clearTip: function() {
  var me = this, el = me.el;
  if (Ext.quickTipsActive && Ext.isObject(me.tooltip)) 
  {
    Ext.tip.QuickTipManager.unregister(el);
  } else {
    el.dom.removeAttribute(me.getTipAttr());
  }
}, beforeDestroy: function() {
  var me = this;
  if (me.rendered) 
  {
    me.clearTip();
  }
  if (me.menu && me.destroyMenu) 
  {
    me.menu.destroy();
  }
  Ext.destroy(me.btnInnerEl, me.repeater);
  me.callParent();
}, onDestroy: function() {
  var me = this;
  if (me.rendered) 
  {
    me.doc.un('mouseover', me.monitorMouseOver, me);
    delete me.doc;
    Ext.destroy(me.keyMap);
    delete me.keyMap;
  }
  Ext.button.Manager.unregister(me);
  me.callParent();
}, setHandler: function(handler, scope) {
  this.handler = handler;
  this.scope = scope;
  return this;
}, setText: function(text) {
  text = text || '';
  var me = this, oldText = me.text || '';
  if (text != oldText) 
  {
    me.text = text;
    if (me.rendered) 
    {
      me.btnInnerEl.update(text || '&#160;');
      me.setComponentCls();
      if (Ext.isStrict && Ext.isIE8) 
      {
        me.el.repaint();
      }
      me.updateLayout();
    }
    me.fireEvent('textchange', me, oldText, text);
  }
  return me;
}, didIconStateChange: function(old, current) {
  var currentEmpty = Ext.isEmpty(current);
  return Ext.isEmpty(old) ? !currentEmpty : currentEmpty;
}, getText: function() {
  return this.text;
}, toggle: function(state, suppressEvent) {
  var me = this;
  state = state === undefined ? !me.pressed : !!state;
  if (state !== me.pressed) 
  {
    if (me.rendered) 
    {
      me[state ? 'addClsWithUI' : 'removeClsWithUI'](me.pressedCls);
    }
    me.pressed = state;
    if (!suppressEvent) 
    {
      me.fireEvent('toggle', me, state);
      Ext.callback(me.toggleHandler, me.scope || me, [me, state]);
    }
  }
  return me;
}, maybeShowMenu: function() {
  var me = this;
  if (me.menu && !me.hasVisibleMenu() && !me.ignoreNextClick) 
  {
    me.showMenu(true);
  }
}, showMenu: function(fromEvent) {
  var me = this, menu = me.menu;
  if (me.rendered) 
  {
    if (me.tooltip && Ext.quickTipsActive && me.getTipAttr() != 'title') 
    {
      Ext.tip.QuickTipManager.getQuickTip().cancelShow(me.el);
    }
    if (menu.isVisible()) 
    {
      menu.hide();
    }
    if (!fromEvent || me.showEmptyMenu || menu.items.getCount() > 0) 
    {
      menu.showBy(me.el, me.menuAlign);
    }
  }
  return me;
}, hideMenu: function() {
  if (this.hasVisibleMenu()) 
  {
    this.menu.hide();
  }
  return this;
}, hasVisibleMenu: function() {
  var menu = this.menu;
  return menu && menu.rendered && menu.isVisible();
}, onRepeatClick: function(repeat, e) {
  this.onClick(e);
}, onClick: function(e) {
  var me = this;
  me.doPreventDefault(e);
  if (e.type !== 'keydown' && e.button !== 0) 
  {
    return;
  }
  if (!me.disabled) 
  {
    me.doToggle();
    me.maybeShowMenu();
    me.fireHandler(e);
  }
}, doPreventDefault: function(e) {
  if (this.preventDefault || (this.disabled && this.getHref()) && e) 
  {
    e.preventDefault();
  }
}, fireHandler: function(e) {
  var me = this, handler = me.handler;
  if (me.fireEvent('click', me, e) !== false) 
  {
    if (handler) 
    {
      handler.call(me.scope || me, me, e);
    }
  }
}, doToggle: function() {
  var me = this;
  if (me.enableToggle && (me.allowDepress !== false || !me.pressed)) 
  {
    me.toggle();
  }
}, onMouseOver: function(e) {
  var me = this;
  if (!me.disabled && !e.within(me.el, true, true)) 
  {
    me.onMouseEnter(e);
  }
}, onMouseOut: function(e) {
  var me = this;
  if (!e.within(me.el, true, true)) 
  {
    if (me.overMenuTrigger) 
    {
      me.onMenuTriggerOut(e);
    }
    me.onMouseLeave(e);
  }
}, onMouseMove: function(e) {
  var me = this, el = me.el, over = me.overMenuTrigger, overPosition, triggerRegion;
  if (me.split) 
  {
    overPosition = (me.arrowAlign === 'right') ? e.getX() - me.getX() : e.getY() - el.getY();
    triggerRegion = me.getTriggerRegion();
    if (overPosition > triggerRegion.begin && overPosition < triggerRegion.end) 
    {
      if (!over) 
      {
        me.onMenuTriggerOver(e);
      }
    } else {
      if (over) 
      {
        me.onMenuTriggerOut(e);
      }
    }
  }
}, getTriggerRegion: function() {
  var me = this, region = me._triggerRegion, triggerSize = me.getTriggerSize(), btnSize = me.arrowAlign === 'right' ? me.getWidth() : me.getHeight();
  region.begin = btnSize - triggerSize;
  region.end = btnSize;
  return region;
}, getTriggerSize: function() {
  var me = this, size = me.triggerSize, side, sideFirstLetter;
  if (size == null) 
  {
    side = me.arrowAlign;
    sideFirstLetter = side.charAt(0);
    size = me.triggerSize = me.el.getFrameWidth(sideFirstLetter) + me.getBtnWrapFrameWidth(sideFirstLetter);
    if (me.frameSize) 
    {
      size = me.triggerSize += me.frameSize[side];
    }
  }
  return size;
}, getBtnWrapFrameWidth: function(side) {
  return this.btnWrap.getFrameWidth(side);
}, addOverCls: function() {
  if (!this.disabled) 
  {
    this.addClsWithUI(this.overCls);
  }
}, removeOverCls: function() {
  this.removeClsWithUI(this.overCls);
}, onMouseEnter: function(e) {
  this.fireEvent('mouseover', this, e);
}, onMouseLeave: function(e) {
  this.fireEvent('mouseout', this, e);
}, onMenuTriggerOver: function(e) {
  var me = this, arrowTip = me.arrowTooltip;
  me.overMenuTrigger = true;
  if (me.split && arrowTip) 
  {
    me.btnWrap.dom.setAttribute(me.getTipAttr(), arrowTip);
  }
  me.fireEvent('menutriggerover', me, me.menu, e);
}, onMenuTriggerOut: function(e) {
  var me = this;
  delete me.overMenuTrigger;
  if (me.split && me.arrowTooltip) 
  {
    me.btnWrap.dom.setAttribute(me.getTipAttr(), '');
  }
  me.fireEvent('menutriggerout', me, me.menu, e);
}, enable: function(silent) {
  var me = this;
  me.callParent(arguments);
  me.removeClsWithUI('disabled');
  if (me.rendered) 
  {
    me.el.dom.setAttribute('tabIndex', me.tabIndex);
  }
  return me;
}, disable: function(silent) {
  var me = this;
  me.callParent(arguments);
  me.addClsWithUI('disabled');
  me.removeClsWithUI(me.overCls);
  if (me.rendered) 
  {
    me.el.dom.removeAttribute('tabIndex');
  }
  if (me.btnInnerEl && Ext.isIE7m) 
  {
    me.btnInnerEl.repaint();
  }
  return me;
}, setScale: function(scale) {
  var me = this, ui = me.ui.replace('-' + me.scale, '');
  if (!Ext.Array.contains(me.allowedScales, scale)) 
  {
    throw ('#setScale: scale must be an allowed scale (' + me.allowedScales.join(', ') + ')');
  }
  me.scale = scale;
  me.setUI(ui);
}, setUI: function(ui) {
  var me = this;
  if (me.scale && !ui.match(me.scale)) 
  {
    ui = ui + '-' + me.scale;
  }
  me.callParent([ui]);
}, onMouseDown: function(e) {
  var me = this;
  if (Ext.isIE) 
  {
    me.getFocusEl().focus();
  }
  if (!me.disabled && e.button === 0) 
  {
    Ext.button.Manager.onButtonMousedown(me, e);
    me.addClsWithUI(me.pressedCls);
  }
}, onMouseUp: function(e) {
  var me = this;
  if (!me.isDestroyed && e.button === 0) 
  {
    if (!me.pressed) 
    {
      me.removeClsWithUI(me.pressedCls);
    }
  }
}, onMenuShow: function(e) {
  var me = this;
  me.ignoreNextClick = 0;
  me.addClsWithUI(me.menuActiveCls);
  me.fireEvent('menushow', me, me.menu);
}, onMenuHide: function(e) {
  var me = this;
  me.removeClsWithUI(me.menuActiveCls);
  me.ignoreNextClick = Ext.defer(me.restoreClick, 250, me);
  me.fireEvent('menuhide', me, me.menu);
  me.focus();
}, restoreClick: function() {
  this.ignoreNextClick = 0;
}, onDownKey: function(k, e) {
  var me = this;
  if (me.menu && !me.disabled) 
  {
    me.showMenu();
    e.stopEvent();
    return false;
  }
}}, 0, ["button"], ["button", "component", "box"], {"button": true, "component": true, "box": true}, ["widget.button"], [['queryable', Ext.Queryable]], [Ext.button, 'Button', Ext, 'Button'], 0));
;

(Ext.cmd.derive('Ext.layout.container.boxOverflow.Menu', Ext.layout.container.boxOverflow.None, {alternateClassName: 'Ext.layout.boxOverflow.Menu', noItemsMenuText: '<div class="' + Ext.baseCSSPrefix + 'toolbar-no-items" role="menuitem">(None)</div>', constructor: function(layout) {
  var me = this;
  me.callParent(arguments);
  me.triggerButtonCls = me.triggerButtonCls || Ext.baseCSSPrefix + 'box-menu-after';
  me.menuItems = [];
}, beginLayout: function(ownerContext) {
  this.callParent(arguments);
  this.clearOverflow(ownerContext);
}, beginLayoutCycle: function(ownerContext, firstCycle) {
  this.callParent(arguments);
  if (!firstCycle) 
  {
    this.clearOverflow(ownerContext);
    this.layout.cacheChildItems(ownerContext);
  }
}, onRemove: function(comp) {
  Ext.Array.remove(this.menuItems, comp);
}, getSuffixConfig: function() {
  var me = this, layout = me.layout, owner = layout.owner, oid = owner.id;
  me.menu = new Ext.menu.Menu({listeners: {scope: me, beforeshow: me.beforeMenuShow}});
  me.menuTrigger = new Ext.button.Button({id: oid + '-menu-trigger', cls: Ext.layout.container.Box.prototype.innerCls + ' ' + me.triggerButtonCls + ' ' + Ext.baseCSSPrefix + 'toolbar-item', plain: owner.usePlainButtons, ownerCt: owner, ownerLayout: layout, iconCls: Ext.baseCSSPrefix + me.getOwnerType(owner) + '-more-icon', ui: owner instanceof Ext.toolbar.Toolbar ? 'default-toolbar' : 'default', menu: me.menu, showEmptyMenu: true, getSplitCls: function() {
  return '';
}});
  return me.menuTrigger.getRenderTree();
}, getOverflowCls: function() {
  return Ext.baseCSSPrefix + this.layout.direction + '-box-overflow-body';
}, handleOverflow: function(ownerContext) {
  var me = this, layout = me.layout, names = layout.names, plan = ownerContext.state.boxPlan, posArgs = [null, null];
  me.showTrigger(ownerContext);
  if (me.layout.direction !== 'vertical') 
  {
    posArgs[names.heightIndex] = (plan.maxSize - me.menuTrigger[names.getHeight]()) / 2;
    me.menuTrigger.setPosition.apply(me.menuTrigger, posArgs);
  }
  return {reservedSpace: me.triggerTotalWidth};
}, captureChildElements: function() {
  var me = this, menuTrigger = me.menuTrigger, names = me.layout.names;
  if (menuTrigger.rendering) 
  {
    menuTrigger.finishRender();
    me.triggerTotalWidth = menuTrigger[names.getWidth]() + menuTrigger.el.getMargin(names.parallelMargins);
  }
}, _asLayoutRoot: {isRoot: true}, clearOverflow: function(ownerContext) {
  var me = this, items = me.menuItems, item, i = 0, length = items.length, owner = me.layout.owner, asLayoutRoot = me._asLayoutRoot;
  owner.suspendLayouts();
  me.captureChildElements();
  me.hideTrigger();
  owner.resumeLayouts();
  for (; i < length; i++) 
    {
      item = items[i];
      item.suspendLayouts();
      item.show();
      item.resumeLayouts(asLayoutRoot);
    }
  items.length = 0;
}, showTrigger: function(ownerContext) {
  var me = this, layout = me.layout, owner = layout.owner, names = layout.names, startProp = names.x, sizeProp = names.width, plan = ownerContext.state.boxPlan, available = plan.targetSize[sizeProp], childItems = ownerContext.childItems, len = childItems.length, menuTrigger = me.menuTrigger, childContext, comp, i, props;
  menuTrigger.suspendLayouts();
  menuTrigger.show();
  menuTrigger.resumeLayouts(me._asLayoutRoot);
  available -= me.triggerTotalWidth;
  owner.suspendLayouts();
  me.menuItems.length = 0;
  for (i = 0; i < len; i++) 
    {
      childContext = childItems[i];
      props = childContext.props;
      if (props[startProp] + props[sizeProp] > available) 
      {
        comp = childContext.target;
        me.menuItems.push(comp);
        comp.hide();
      }
    }
  owner.resumeLayouts();
}, hideTrigger: function() {
  var menuTrigger = this.menuTrigger;
  if (menuTrigger) 
  {
    menuTrigger.hide();
  }
}, beforeMenuShow: function(menu) {
  var me = this, items = me.menuItems, i = 0, len = items.length, item, prev, needsSep = function(group, prev) {
  return group.isXType('buttongroup') && !(prev instanceof Ext.toolbar.Separator);
};
  menu.suspendLayouts();
  me.clearMenu();
  menu.removeAll();
  for (; i < len; i++) 
    {
      item = items[i];
      if (!i && (item instanceof Ext.toolbar.Separator)) 
      {
        continue;
      }
      if (prev && (needsSep(item, prev) || needsSep(prev, item))) 
      {
        menu.add('-');
      }
      me.addComponentToMenu(menu, item);
      prev = item;
    }
  if (menu.items.length < 1) 
  {
    menu.add(me.noItemsMenuText);
  }
  menu.resumeLayouts();
}, createMenuConfig: function(component, hideOnClick) {
  var config = Ext.apply({}, component.initialConfig), group = component.toggleGroup;
  Ext.copyTo(config, component, ['iconCls', 'icon', 'itemId', 'disabled', 'handler', 'scope', 'menu', 'tabIndex']);
  Ext.applyIf(config, {text: component.overflowText || component.text, hideOnClick: hideOnClick, destroyMenu: false, listeners: {}});
  if (component.isFormField) 
  {
    config.value = component.getValue();
    config.listeners.change = function(c, newVal, oldVal) {
  component.setValue(newVal);
};
  } else if (group || component.enableToggle) 
  {
    Ext.apply(config, {hideOnClick: false, group: group, checked: component.pressed, handler: function(item, e) {
  component.onClick(e);
}});
  }
  if (component.isButton && !component.changeListenersAdded) 
  {
    component.on({textchange: this.onButtonAttrChange, iconchange: this.onButtonAttrChange, toggle: this.onButtonToggle});
    component.changeListenersAdded = true;
  }
  delete config.margin;
  delete config.ownerCt;
  delete config.xtype;
  delete config.id;
  delete config.itemId;
  return config;
}, onButtonAttrChange: function(btn) {
  var clone = btn.overflowClone;
  clone.suspendLayouts();
  clone.setText(btn.text);
  clone.setIcon(btn.icon);
  clone.setIconCls(btn.iconCls);
  clone.resumeLayouts(true);
}, onButtonToggle: function(btn, state) {
  if (btn.overflowClone.checked !== state) 
  {
    btn.overflowClone.setChecked(state);
  }
}, addComponentToMenu: function(menu, component) {
  var me = this, i, items, iLen;
  if (component instanceof Ext.toolbar.Fill) 
  {
    return;
  } else if (component instanceof Ext.toolbar.Separator) 
  {
    menu.add('-');
  } else if (component.isComponent) 
  {
    if (component.isXType('splitbutton')) 
    {
      component.overflowClone = menu.add(me.createMenuConfig(component, true));
    } else if (component.isXType('button')) 
    {
      component.overflowClone = menu.add(me.createMenuConfig(component, !component.menu));
    } else if (component.isXType('buttongroup')) 
    {
      items = component.items.items;
      iLen = items.length;
      for (i = 0; i < iLen; i++) 
        {
          me.addComponentToMenu(menu, items[i]);
        }
    } else {
      component.overflowClone = menu.add(Ext.create(Ext.getClassName(component), me.createMenuConfig(component)));
    }
  }
}, clearMenu: function() {
  var menu = this.menu, items, i, iLen, item;
  if (menu && menu.items) 
  {
    items = menu.items.items;
    iLen = items.length;
    for (i = 0; i < iLen; i++) 
      {
        item = items[i];
        if (item.setMenu) 
        {
          item.setMenu(null);
        }
      }
  }
}, destroy: function() {
  var trigger = this.menuTrigger;
  if (trigger && !this.layout.owner.items.contains(trigger)) 
  {
    delete trigger.ownerCt;
  }
  Ext.destroy(this.menu, trigger);
}}, 1, 0, 0, 0, 0, 0, [Ext.layout.container.boxOverflow, 'Menu', Ext.layout.boxOverflow, 'Menu'], 0));
;

(Ext.cmd.derive('Ext.layout.container.boxOverflow.Scroller', Ext.layout.container.boxOverflow.None, {alternateClassName: 'Ext.layout.boxOverflow.Scroller', animateScroll: false, scrollIncrement: 20, wheelIncrement: 10, scrollRepeatInterval: 60, scrollDuration: 400, scrollerCls: Ext.baseCSSPrefix + 'box-scroller', constructor: function(layout, config) {
  var me = this;
  me.layout = layout;
  Ext.apply(me, config || {});
  me.mixins.observable.constructor.call(me);
  me.addEvents('scroll');
  me.scrollPosition = 0;
  me.scrollSize = 0;
}, getPrefixConfig: function() {
  var me = this, layout = me.layout, owner = layout.owner, cls;
  me.initCSSClasses();
  cls = Ext.layout.container.Box.prototype.innerCls + ' ' + me.beforeCtCls;
  if (owner.plain) 
  {
    cls += ' ' + me.scrollerCls + '-plain';
  }
  return {role: 'presentation', cls: cls, cn: {role: 'presentation', id: owner.id + layout.names.beforeScrollerSuffix, cls: me.scrollerCls + ' ' + me.beforeScrollerCls, style: 'display:none'}};
}, getSuffixConfig: function() {
  var me = this, layout = me.layout, owner = layout.owner, cls = Ext.layout.container.Box.prototype.innerCls + ' ' + me.afterCtCls;
  if (owner.plain) 
  {
    cls += ' ' + me.scrollerCls + '-plain';
  }
  return {role: 'presentation', cls: cls, cn: {role: 'presentation', id: owner.id + layout.names.afterScrollerSuffix, cls: me.scrollerCls + ' ' + me.afterScrollerCls, style: 'display:none'}};
}, getOverflowCls: function() {
  return Ext.baseCSSPrefix + this.layout.direction + '-box-overflow-body';
}, initCSSClasses: function() {
  var me = this, prefix = Ext.baseCSSPrefix, layout = me.layout, names = layout.names, beforeXName = names.beforeX, afterXName = names.afterX, type = me.getOwnerType(layout.owner);
  me.beforeCtCls = me.beforeCtCls || prefix + 'box-scroller-' + beforeXName;
  me.afterCtCls = me.afterCtCls || prefix + 'box-scroller-' + afterXName;
  me.beforeScrollerCls = me.beforeScrollerCls || prefix + type + '-scroll-' + beforeXName;
  me.afterScrollerCls = me.afterScrollerCls || prefix + type + '-scroll-' + afterXName;
}, beginLayout: function(ownerContext) {
  var layout = this.layout;
  ownerContext.innerCtScrollPos = this.getScrollPosition();
  this.callParent(arguments);
}, completeLayout: function(ownerContext) {
  var me = this, plan = ownerContext.state.boxPlan, names = me.layout.names, last;
  if (plan && plan.tooNarrow) 
  {
    last = ownerContext.childItems[ownerContext.childItems.length - 1];
    me.scrollSize = last.props[names.x] + last.props[names.width];
    me.updateScrollButtons();
  }
  this.callParent(arguments);
}, finishedLayout: function(ownerContext) {
  var me = this, layout = me.layout, scrollPos = Math.min(me.getMaxScrollPosition(), ownerContext.innerCtScrollPos);
  layout.innerCt[layout.names.setScrollLeft](scrollPos);
}, handleOverflow: function(ownerContext) {
  var me = this, methodName = me.layout.names.getWidth;
  me.showScrollers();
  return {reservedSpace: me.beforeCt[methodName]() + me.afterCt[methodName]()};
}, captureChildElements: function() {
  var me = this, el = me.layout.owner.el, before, after, hoverCls, pressedSuffix, pressedCls, hoverSuffix;
  if (!me.beforeCt) 
  {
    hoverSuffix = '-hover';
    pressedSuffix = '-pressed';
    hoverCls = me.scrollerCls + hoverSuffix;
    pressedCls = me.scrollerCls + pressedSuffix;
    before = me.beforeScroller = el.getById(me.layout.owner.id + '-before-scroller');
    after = me.afterScroller = el.getById(me.layout.owner.id + '-after-scroller');
    me.beforeCt = before.up('');
    me.afterCt = after.up('');
    me.createWheelListener();
    before.addClsOnOver(hoverCls);
    before.addClsOnOver(me.beforeScrollerCls + hoverSuffix);
    before.addClsOnClick(pressedCls);
    before.addClsOnClick(me.beforeScrollerCls + pressedSuffix);
    after.addClsOnOver(hoverCls);
    after.addClsOnOver(me.afterScrollerCls + hoverSuffix);
    after.addClsOnClick(pressedCls);
    after.addClsOnClick(me.afterScrollerCls + pressedSuffix);
    before.setVisibilityMode(Ext.Element.DISPLAY);
    after.setVisibilityMode(Ext.Element.DISPLAY);
    me.beforeRepeater = new Ext.util.ClickRepeater(before, {interval: me.scrollRepeatInterval, handler: me.scrollLeft, scope: me});
    me.afterRepeater = new Ext.util.ClickRepeater(after, {interval: me.scrollRepeatInterval, handler: me.scrollRight, scope: me});
  }
}, createWheelListener: function() {
  var me = this;
  me.layout.innerCt.on({mousewheel: function(e) {
  me.scrollBy(me.getWheelDelta(e) * me.wheelIncrement * -1, false);
}, stopEvent: true});
}, getWheelDelta: function(e) {
  return e.getWheelDelta();
}, clearOverflow: function() {
  this.hideScrollers();
}, showScrollers: function() {
  var me = this;
  me.captureChildElements();
  me.beforeScroller.show();
  me.afterScroller.show();
  me.layout.owner.addClsWithUI(me.layout.direction === 'vertical' ? 'vertical-scroller' : 'scroller');
}, hideScrollers: function() {
  var me = this;
  if (me.beforeScroller !== undefined) 
  {
    me.beforeScroller.hide();
    me.afterScroller.hide();
    me.layout.owner.removeClsWithUI(me.layout.direction === 'vertical' ? 'vertical-scroller' : 'scroller');
  }
}, destroy: function() {
  var me = this;
  Ext.destroy(me.beforeRepeater, me.afterRepeater, me.beforeScroller, me.afterScroller, me.beforeCt, me.afterCt);
}, scrollBy: function(delta, animate) {
  this.scrollTo(this.getScrollPosition() + delta, animate);
}, getScrollAnim: function() {
  return {duration: this.scrollDuration, callback: this.updateScrollButtons, scope: this};
}, updateScrollButtons: function() {
  var me = this, beforeMeth, afterMeth, beforeCls, afterCls, disabledCls, suffix = '-disabled';
  if (me.beforeScroller == null || me.afterScroller == null) 
  {
    return;
  }
  beforeMeth = me.atExtremeBefore() ? 'addCls' : 'removeCls';
  afterMeth = me.atExtremeAfter() ? 'addCls' : 'removeCls';
  disabledCls = me.scrollerCls + suffix;
  beforeCls = [disabledCls, me.beforeScrollerCls + suffix];
  afterCls = [disabledCls, me.afterScrollerCls + suffix];
  me.beforeScroller[beforeMeth](beforeCls);
  me.afterScroller[afterMeth](afterCls);
  me.scrolling = false;
}, scrollLeft: function() {
  this.scrollBy(-this.scrollIncrement, false);
}, scrollRight: function() {
  this.scrollBy(this.scrollIncrement, false);
}, getScrollPosition: function() {
  var me = this, layout = me.layout, result;
  if (isNaN(me.scrollPosition)) 
  {
    result = layout.innerCt[layout.names.getScrollLeft]();
  } else {
    result = me.scrollPosition;
  }
  return result;
}, getMaxScrollPosition: function() {
  var me = this, layout = me.layout, maxScrollPos = me.scrollSize - layout.innerCt[layout.names.getWidth]();
  return (maxScrollPos < 0) ? 0 : maxScrollPos;
}, atExtremeBefore: function() {
  return !this.getScrollPosition();
}, atExtremeAfter: function() {
  return this.getScrollPosition() >= this.getMaxScrollPosition();
}, scrollTo: function(position, animate) {
  var me = this, layout = me.layout, names = layout.names, oldPosition = me.getScrollPosition(), newPosition = Ext.Number.constrain(position, 0, me.getMaxScrollPosition());
  if (newPosition != oldPosition && !me.scrolling) 
  {
    me.scrollPosition = NaN;
    if (animate === undefined) 
    {
      animate = me.animateScroll;
    }
    layout.innerCt[names.scrollTo](names.beforeScrollX, newPosition, animate ? me.getScrollAnim() : false);
    if (animate) 
    {
      me.scrolling = true;
    } else {
      me.updateScrollButtons();
    }
    me.fireEvent('scroll', me, newPosition, animate ? me.getScrollAnim() : false);
  }
}, scrollToItem: function(item, animate) {
  var me = this, layout = me.layout, owner = layout.owner, names = layout.names, visibility, box, newPos;
  item = me.getItem(item);
  if (item !== undefined) 
  {
    if (item == owner.items.first()) 
    {
      newPos = 0;
    } else if (item === owner.items.last()) 
    {
      newPos = me.getMaxScrollPosition();
    } else {
      visibility = me.getItemVisibility(item);
      if (!visibility.fullyVisible) 
      {
        box = item.getBox(false, true);
        newPos = box[names.x];
        if (visibility.hiddenEnd) 
        {
          newPos -= (me.layout.innerCt[names.getWidth]() - box[names.width]);
        }
      }
    }
    if (newPos !== undefined) 
    {
      me.scrollTo(newPos, animate);
    }
  }
}, getItemVisibility: function(item) {
  var me = this, box = me.getItem(item).getBox(true, true), layout = me.layout, names = layout.names, itemStart = box[names.x], itemEnd = itemStart + box[names.width], scrollStart = me.getScrollPosition(), scrollEnd = scrollStart + layout.innerCt[names.getWidth]();
  return {hiddenStart: itemStart < scrollStart, hiddenEnd: itemEnd > scrollEnd, fullyVisible: itemStart > scrollStart && itemEnd < scrollEnd};
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.layout.container.boxOverflow, 'Scroller', Ext.layout.boxOverflow, 'Scroller'], 0));
;

(Ext.cmd.derive('Ext.util.Offset', Ext.Base, {statics: {fromObject: function(obj) {
  return new this(obj.x, obj.y);
}}, constructor: function(x, y) {
  this.x = (x != null && !isNaN(x)) ? x : 0;
  this.y = (y != null && !isNaN(y)) ? y : 0;
  return this;
}, copy: function() {
  return new Ext.util.Offset(this.x, this.y);
}, copyFrom: function(p) {
  this.x = p.x;
  this.y = p.y;
}, toString: function() {
  return "Offset[" + this.x + "," + this.y + "]";
}, equals: function(offset) {
  return (this.x == offset.x && this.y == offset.y);
}, round: function(to) {
  if (!isNaN(to)) 
  {
    var factor = Math.pow(10, to);
    this.x = Math.round(this.x * factor) / factor;
    this.y = Math.round(this.y * factor) / factor;
  } else {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
  }
}, isZero: function() {
  return this.x == 0 && this.y == 0;
}}, 3, 0, 0, 0, 0, 0, [Ext.util, 'Offset'], 0));
;

(Ext.cmd.derive('Ext.util.Region', Ext.Base, {statics: {getRegion: function(el) {
  return Ext.fly(el).getRegion();
}, from: function(o) {
  return new this(o.top, o.right, o.bottom, o.left);
}}, constructor: function(t, r, b, l) {
  var me = this;
  me.y = me.top = me[1] = t;
  me.right = r;
  me.bottom = b;
  me.x = me.left = me[0] = l;
}, contains: function(region) {
  var me = this;
  return (region.x >= me.x && region.right <= me.right && region.y >= me.y && region.bottom <= me.bottom);
}, intersect: function(region) {
  var me = this, t = Math.max(me.y, region.y), r = Math.min(me.right, region.right), b = Math.min(me.bottom, region.bottom), l = Math.max(me.x, region.x);
  if (b > t && r > l) 
  {
    return new this.self(t, r, b, l);
  } else {
    return false;
  }
}, union: function(region) {
  var me = this, t = Math.min(me.y, region.y), r = Math.max(me.right, region.right), b = Math.max(me.bottom, region.bottom), l = Math.min(me.x, region.x);
  return new this.self(t, r, b, l);
}, constrainTo: function(r) {
  var me = this, constrain = Ext.Number.constrain;
  me.top = me.y = constrain(me.top, r.y, r.bottom);
  me.bottom = constrain(me.bottom, r.y, r.bottom);
  me.left = me.x = constrain(me.left, r.x, r.right);
  me.right = constrain(me.right, r.x, r.right);
  return me;
}, adjust: function(t, r, b, l) {
  var me = this;
  me.top = me.y += t;
  me.left = me.x += l;
  me.right += r;
  me.bottom += b;
  return me;
}, getOutOfBoundOffset: function(axis, p) {
  if (!Ext.isObject(axis)) 
  {
    if (axis == 'x') 
    {
      return this.getOutOfBoundOffsetX(p);
    } else {
      return this.getOutOfBoundOffsetY(p);
    }
  } else {
    p = axis;
    var d = new Ext.util.Offset();
    d.x = this.getOutOfBoundOffsetX(p.x);
    d.y = this.getOutOfBoundOffsetY(p.y);
    return d;
  }
}, getOutOfBoundOffsetX: function(p) {
  if (p <= this.x) 
  {
    return this.x - p;
  } else if (p >= this.right) 
  {
    return this.right - p;
  }
  return 0;
}, getOutOfBoundOffsetY: function(p) {
  if (p <= this.y) 
  {
    return this.y - p;
  } else if (p >= this.bottom) 
  {
    return this.bottom - p;
  }
  return 0;
}, isOutOfBound: function(axis, p) {
  if (!Ext.isObject(axis)) 
  {
    if (axis == 'x') 
    {
      return this.isOutOfBoundX(p);
    } else {
      return this.isOutOfBoundY(p);
    }
  } else {
    p = axis;
    return (this.isOutOfBoundX(p.x) || this.isOutOfBoundY(p.y));
  }
}, isOutOfBoundX: function(p) {
  return (p < this.x || p > this.right);
}, isOutOfBoundY: function(p) {
  return (p < this.y || p > this.bottom);
}, restrict: function(axis, p, factor) {
  if (Ext.isObject(axis)) 
  {
    var newP;
    factor = p;
    p = axis;
    if (p.copy) 
    {
      newP = p.copy();
    } else {
      newP = {x: p.x, y: p.y};
    }
    newP.x = this.restrictX(p.x, factor);
    newP.y = this.restrictY(p.y, factor);
    return newP;
  } else {
    if (axis == 'x') 
    {
      return this.restrictX(p, factor);
    } else {
      return this.restrictY(p, factor);
    }
  }
}, restrictX: function(p, factor) {
  if (!factor) 
  {
    factor = 1;
  }
  if (p <= this.x) 
  {
    p -= (p - this.x) * factor;
  } else if (p >= this.right) 
  {
    p -= (p - this.right) * factor;
  }
  return p;
}, restrictY: function(p, factor) {
  if (!factor) 
  {
    factor = 1;
  }
  if (p <= this.y) 
  {
    p -= (p - this.y) * factor;
  } else if (p >= this.bottom) 
  {
    p -= (p - this.bottom) * factor;
  }
  return p;
}, getSize: function() {
  return {width: this.right - this.x, height: this.bottom - this.y};
}, copy: function() {
  return new this.self(this.y, this.right, this.bottom, this.x);
}, copyFrom: function(p) {
  var me = this;
  me.top = me.y = me[1] = p.y;
  me.right = p.right;
  me.bottom = p.bottom;
  me.left = me.x = me[0] = p.x;
  return this;
}, toString: function() {
  return "Region[" + this.top + "," + this.right + "," + this.bottom + "," + this.left + "]";
}, translateBy: function(x, y) {
  if (arguments.length == 1) 
  {
    y = x.y;
    x = x.x;
  }
  var me = this;
  me.top = me.y += y;
  me.right += x;
  me.bottom += y;
  me.left = me.x += x;
  return me;
}, round: function() {
  var me = this;
  me.top = me.y = Math.round(me.y);
  me.right = Math.round(me.right);
  me.bottom = Math.round(me.bottom);
  me.left = me.x = Math.round(me.x);
  return me;
}, equals: function(region) {
  return (this.top == region.top && this.right == region.right && this.bottom == region.bottom && this.left == region.left);
}}, 3, 0, 0, 0, 0, 0, [Ext.util, 'Region'], 0));
;

(Ext.cmd.derive('Ext.dd.DragDropManager', Ext.Base, {singleton: true, alternateClassName: ['Ext.dd.DragDropMgr', 'Ext.dd.DDM'], ids: {}, handleIds: {}, dragCurrent: null, dragOvers: {}, deltaX: 0, deltaY: 0, preventDefault: true, stopPropagation: true, initialized: false, locked: false, init: function() {
  this.initialized = true;
}, POINT: 0, INTERSECT: 1, mode: 0, notifyOccluded: false, dragCls: Ext.baseCSSPrefix + 'dd-drag-current', _execOnAll: function(sMethod, args) {
  var ids = this.ids, i, j, oDD, item;
  for (i in ids) 
    {
      if (ids.hasOwnProperty(i)) 
      {
        item = ids[i];
        for (j in item) 
          {
            if (item.hasOwnProperty(j)) 
            {
              oDD = item[j];
              if (!this.isTypeOfDD(oDD)) 
              {
                continue;
              }
              oDD[sMethod].apply(oDD, args);
            }
          }
      }
    }
}, _onLoad: function() {
  this.init();
  var Event = Ext.EventManager;
  Event.on(document, "mouseup", this.handleMouseUp, this, true);
  Event.on(document, "mousemove", this.handleMouseMove, this, true);
  Event.on(window, "unload", this._onUnload, this, true);
  Event.on(window, "resize", this._onResize, this, true);
}, _onResize: function(e) {
  this._execOnAll("resetConstraints", []);
}, lock: function() {
  this.locked = true;
}, unlock: function() {
  this.locked = false;
}, isLocked: function() {
  return this.locked;
}, locationCache: {}, useCache: true, clickPixelThresh: 3, clickTimeThresh: 350, dragThreshMet: false, clickTimeout: null, startX: 0, startY: 0, regDragDrop: function(oDD, sGroup) {
  if (!this.initialized) 
  {
    this.init();
  }
  if (!this.ids[sGroup]) 
  {
    this.ids[sGroup] = {};
  }
  this.ids[sGroup][oDD.id] = oDD;
}, removeDDFromGroup: function(oDD, sGroup) {
  if (!this.ids[sGroup]) 
  {
    this.ids[sGroup] = {};
  }
  var obj = this.ids[sGroup];
  if (obj && obj[oDD.id]) 
  {
    delete obj[oDD.id];
  }
}, _remove: function(oDD, clearGroup) {
  var me = this, ids = me.ids, groups = oDD.groups, g;
  if (me.clearingAll) 
  {
    return;
  }
  if (me.dragCurrent === oDD) 
  {
    me.dragCurrent = null;
  }
  for (g in groups) 
    {
      if (groups.hasOwnProperty(g)) 
      {
        if (clearGroup) 
        {
          delete ids[g];
        } else if (ids[g]) 
        {
          delete ids[g][oDD.id];
        }
      }
    }
  delete me.handleIds[oDD.id];
}, regHandle: function(sDDId, sHandleId) {
  if (!this.handleIds[sDDId]) 
  {
    this.handleIds[sDDId] = {};
  }
  this.handleIds[sDDId][sHandleId] = sHandleId;
}, isDragDrop: function(id) {
  return (this.getDDById(id)) ? true : false;
}, getRelated: function(p_oDD, bTargetsOnly) {
  var oDDs = [], i, j, dd;
  for (i in p_oDD.groups) 
    {
      for (j in this.ids[i]) 
        {
          dd = this.ids[i][j];
          if (!this.isTypeOfDD(dd)) 
          {
            continue;
          }
          if (!bTargetsOnly || dd.isTarget) 
          {
            oDDs[oDDs.length] = dd;
          }
        }
    }
  return oDDs;
}, isLegalTarget: function(oDD, oTargetDD) {
  var targets = this.getRelated(oDD, true), i, len;
  for (i = 0 , len = targets.length; i < len; ++i) 
    {
      if (targets[i].id == oTargetDD.id) 
      {
        return true;
      }
    }
  return false;
}, isTypeOfDD: function(oDD) {
  return (oDD && oDD.__ygDragDrop);
}, isHandle: function(sDDId, sHandleId) {
  return (this.handleIds[sDDId] && this.handleIds[sDDId][sHandleId]);
}, getDDById: function(id) {
  var i, dd;
  for (i in this.ids) 
    {
      dd = this.ids[i][id];
      if (dd instanceof Ext.dd.DDTarget) 
      {
        return dd;
      }
    }
  return null;
}, handleMouseDown: function(e, oDD) {
  var me = this, el;
  if (Ext.quickTipsActive) 
  {
    Ext.tip.QuickTipManager.ddDisable();
  }
  if (me.dragCurrent) 
  {
    me.handleMouseUp(e);
  }
  me.mousedownEvent = e.clone();
  me.currentTarget = e.getTarget();
  me.dragCurrent = oDD;
  el = oDD.getEl();
  if (Ext.isIE9m && el.setCapture) 
  {
    el.setCapture();
  }
  me.startX = e.getPageX();
  me.startY = e.getPageY();
  me.deltaX = me.startX - el.offsetLeft;
  me.deltaY = me.startY - el.offsetTop;
  me.dragThreshMet = false;
  me.clickTimeout = setTimeout(function() {
  me.startDrag(me.startX, me.startY);
}, me.clickTimeThresh);
}, startDrag: function(x, y) {
  var me = this, current = me.dragCurrent, dragEl;
  clearTimeout(me.clickTimeout);
  if (current) 
  {
    current.b4StartDrag(x, y);
    current.startDrag(x, y);
    dragEl = current.getDragEl();
    if (dragEl) 
    {
      Ext.fly(dragEl).addCls(me.dragCls);
    }
  }
  me.dragThreshMet = true;
}, handleMouseUp: function(e) {
  var me = this;
  if (Ext.quickTipsActive) 
  {
    Ext.tip.QuickTipManager.ddEnable();
  }
  if (!me.dragCurrent) 
  {
    return;
  }
  if (Ext.isIE && document.releaseCapture) 
  {
    document.releaseCapture();
  }
  clearTimeout(me.clickTimeout);
  if (me.dragThreshMet) 
  {
    me.fireEvents(e, true);
  }
  me.stopDrag(e);
  me.stopEvent(e);
}, stopEvent: function(e) {
  if (this.stopPropagation) 
  {
    e.stopPropagation();
  }
  if (this.preventDefault) 
  {
    e.preventDefault();
  }
}, stopDrag: function(e) {
  var me = this, current = me.dragCurrent, dragEl;
  if (current) 
  {
    if (me.dragThreshMet) 
    {
      dragEl = current.getDragEl();
      if (dragEl) 
      {
        Ext.fly(dragEl).removeCls(me.dragCls);
      }
      current.b4EndDrag(e);
      current.endDrag(e);
    }
    me.dragCurrent.onMouseUp(e);
  }
  me.dragCurrent = null;
  me.dragOvers = {};
}, handleMouseMove: function(e) {
  var me = this, current = me.dragCurrent, diffX, diffY;
  if (!current) 
  {
    return true;
  }
  if (!me.dragThreshMet) 
  {
    diffX = Math.abs(me.startX - e.getPageX());
    diffY = Math.abs(me.startY - e.getPageY());
    if (diffX > me.clickPixelThresh || diffY > me.clickPixelThresh) 
    {
      me.startDrag(me.startX, me.startY);
    }
  }
  if (me.dragThreshMet) 
  {
    current.b4Drag(e);
    current.onDrag(e);
    if (!current.moveOnly) 
    {
      me.fireEvents(e, false);
    }
  }
  me.stopEvent(e);
  return true;
}, fireEvents: function(e, isDrop) {
  var me = this, dragCurrent = me.dragCurrent, dragEl, oldDragElTop, mousePoint = e.getPoint(), overTarget, overTargetEl, allTargets = [], oldOvers = [], outEvts = [], overEvts = [], dropEvts = [], enterEvts = [], xy, needsSort, i, len, sGroup;
  if (!dragCurrent || dragCurrent.isLocked()) 
  {
    return;
  }
  if (!me.notifyOccluded && (!Ext.supports.PointerEvents || Ext.isIE10m || Ext.isOpera) && !(dragCurrent.deltaX < 0 || dragCurrent.deltaY < 0)) 
  {
    dragEl = dragCurrent.getDragEl();
    oldDragElTop = dragEl.style.top;
    dragEl.style.visibility = 'hidden';
    xy = e.getXY();
    e.target = document.elementFromPoint(xy[0], xy[1]);
    dragEl.style.visibility = 'visible';
    dragEl.style.top = oldDragElTop;
  }
  for (i in me.dragOvers) 
    {
      overTarget = me.dragOvers[i];
      delete me.dragOvers[i];
      if (!me.isTypeOfDD(overTarget) || overTarget.isDestroyed) 
      {
        continue;
      }
      if (me.notifyOccluded) 
      {
        if (!this.isOverTarget(mousePoint, overTarget, me.mode)) 
        {
          outEvts.push(overTarget);
        }
      } else {
        if (!e.within(overTarget.getEl())) 
        {
          outEvts.push(overTarget);
        }
      }
      oldOvers[i] = true;
    }
  for (sGroup in dragCurrent.groups) 
    {
      if ("string" != typeof sGroup) 
      {
        continue;
      }
      for (i in me.ids[sGroup]) 
        {
          overTarget = me.ids[sGroup][i];
          if (me.isTypeOfDD(overTarget) && (overTargetEl = overTarget.getEl()) && (overTarget.isTarget) && (!overTarget.isLocked()) && (Ext.fly(overTargetEl).isVisible(true)) && ((overTarget != dragCurrent) || (dragCurrent.ignoreSelf === false))) 
          {
            if (me.notifyOccluded) 
            {
              if ((overTarget.zIndex = me.getZIndex(overTargetEl)) !== -1) 
              {
                needsSort = true;
              }
              allTargets.push(overTarget);
            } else {
              if (e.within(overTarget.getEl())) 
              {
                allTargets.push(overTarget);
                break;
              }
            }
          }
        }
    }
  if (needsSort) 
  {
    Ext.Array.sort(allTargets, me.byZIndex);
  }
  for (i = 0 , len = allTargets.length; i < len; i++) 
    {
      overTarget = allTargets[i];
      if (me.isOverTarget(mousePoint, overTarget, me.mode)) 
      {
        if (isDrop) 
        {
          dropEvts.push(overTarget);
        } else {
          if (!oldOvers[overTarget.id]) 
          {
            enterEvts.push(overTarget);
          } else {
            overEvts.push(overTarget);
          }
          me.dragOvers[overTarget.id] = overTarget;
        }
        if (!me.notifyOccluded) 
        {
          break;
        }
      }
    }
  if (me.mode) 
  {
    if (outEvts.length) 
    {
      dragCurrent.b4DragOut(e, outEvts);
      dragCurrent.onDragOut(e, outEvts);
    }
    if (enterEvts.length) 
    {
      dragCurrent.onDragEnter(e, enterEvts);
    }
    if (overEvts.length) 
    {
      dragCurrent.b4DragOver(e, overEvts);
      dragCurrent.onDragOver(e, overEvts);
    }
    if (dropEvts.length) 
    {
      dragCurrent.b4DragDrop(e, dropEvts);
      dragCurrent.onDragDrop(e, dropEvts);
    }
  } else {
    for (i = 0 , len = outEvts.length; i < len; ++i) 
      {
        dragCurrent.b4DragOut(e, outEvts[i].id);
        dragCurrent.onDragOut(e, outEvts[i].id);
      }
    for (i = 0 , len = enterEvts.length; i < len; ++i) 
      {
        dragCurrent.onDragEnter(e, enterEvts[i].id);
      }
    for (i = 0 , len = overEvts.length; i < len; ++i) 
      {
        dragCurrent.b4DragOver(e, overEvts[i].id);
        dragCurrent.onDragOver(e, overEvts[i].id);
      }
    for (i = 0 , len = dropEvts.length; i < len; ++i) 
      {
        dragCurrent.b4DragDrop(e, dropEvts[i].id);
        dragCurrent.onDragDrop(e, dropEvts[i].id);
      }
  }
  if (isDrop && !dropEvts.length) 
  {
    dragCurrent.onInvalidDrop(e);
  }
}, getZIndex: function(element) {
  var body = document.body, z, zIndex = -1;
  element = Ext.getDom(element);
  while (element !== body) 
    {
      if (!isNaN(z = Number(Ext.fly(element).getStyle('zIndex')))) 
      {
        zIndex = z;
      }
      element = element.parentNode;
    }
  return zIndex;
}, byZIndex: function(d1, d2) {
  return d1.zIndex < d2.zIndex;
}, getBestMatch: function(dds) {
  var winner = null, len = dds.length, i, dd;
  if (len == 1) 
  {
    winner = dds[0];
  } else {
    for (i = 0; i < len; ++i) 
      {
        dd = dds[i];
        if (dd.cursorIsOver) 
        {
          winner = dd;
          break;
        } else {
          if (!winner || winner.overlap.getArea() < dd.overlap.getArea()) 
          {
            winner = dd;
          }
        }
      }
  }
  return winner;
}, refreshCache: function(groups) {
  var sGroup, i, oDD, loc;
  for (sGroup in groups) 
    {
      if ("string" != typeof sGroup) 
      {
        continue;
      }
      for (i in this.ids[sGroup]) 
        {
          oDD = this.ids[sGroup][i];
          if (this.isTypeOfDD(oDD)) 
          {
            loc = this.getLocation(oDD);
            if (loc) 
            {
              this.locationCache[oDD.id] = loc;
            } else {
              delete this.locationCache[oDD.id];
            }
          }
        }
    }
}, verifyEl: function(el) {
  if (el) 
  {
    var parent;
    if (Ext.isIE) 
    {
      try {
        parent = el.offsetParent;
      }      catch (e) {
}
    } else {
      parent = el.offsetParent;
    }
    if (parent) 
    {
      return true;
    }
  }
  return false;
}, getLocation: function(oDD) {
  if (!this.isTypeOfDD(oDD)) 
  {
    return null;
  }
  if (oDD.getRegion) 
  {
    return oDD.getRegion();
  }
  var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;
  try {
    pos = Ext.Element.getXY(el);
  }  catch (e) {
}
  if (!pos) 
  {
    return null;
  }
  x1 = pos[0];
  x2 = x1 + el.offsetWidth;
  y1 = pos[1];
  y2 = y1 + el.offsetHeight;
  t = y1 - oDD.padding[0];
  r = x2 + oDD.padding[1];
  b = y2 + oDD.padding[2];
  l = x1 - oDD.padding[3];
  return new Ext.util.Region(t, r, b, l);
}, isOverTarget: function(pt, oTarget, intersect) {
  var loc = this.locationCache[oTarget.id], dc, pos, el, curRegion, overlap;
  if (!loc || !this.useCache) 
  {
    loc = this.getLocation(oTarget);
    this.locationCache[oTarget.id] = loc;
  }
  if (!loc) 
  {
    return false;
  }
  oTarget.cursorIsOver = loc.contains(pt);
  dc = this.dragCurrent;
  if (!dc || !dc.getTargetCoord || (!intersect && !dc.constrainX && !dc.constrainY)) 
  {
    return oTarget.cursorIsOver;
  }
  oTarget.overlap = null;
  pos = dc.getTargetCoord(pt.x, pt.y);
  el = dc.getDragEl();
  curRegion = new Ext.util.Region(pos.y, pos.x + el.offsetWidth, pos.y + el.offsetHeight, pos.x);
  overlap = curRegion.intersect(loc);
  if (overlap) 
  {
    oTarget.overlap = overlap;
    return (intersect) ? true : oTarget.cursorIsOver;
  } else {
    return false;
  }
}, _onUnload: function(e, me) {
  Ext.dd.DragDropManager.unregAll();
}, unregAll: function() {
  var me = this, cache = me.elementCache, i;
  if (me.dragCurrent) 
  {
    me.stopDrag();
    me.dragCurrent = null;
  }
  me.clearingAll = true;
  me._execOnAll("unreg", []);
  delete me.clearingAll;
  for (i in cache) 
    {
      delete cache[i];
    }
  me.elementCache = {};
  me.ids = {};
  me.handleIds = {};
}, elementCache: {}, getElWrapper: function(id) {
  var oWrapper = this.elementCache[id];
  if (!oWrapper || !oWrapper.el) 
  {
    oWrapper = this.elementCache[id] = new this.ElementWrapper(Ext.getDom(id));
  }
  return oWrapper;
}, getElement: function(id) {
  return Ext.getDom(id);
}, getCss: function(id) {
  var el = Ext.getDom(id);
  return (el) ? el.style : null;
}, ElementWrapper: function(el) {
  this.el = el || null;
  this.id = this.el && el.id;
  this.css = this.el && el.style;
}, getPosX: function(el) {
  return Ext.Element.getX(el);
}, getPosY: function(el) {
  return Ext.Element.getY(el);
}, swapNode: function(n1, n2) {
  if (n1.swapNode) 
  {
    n1.swapNode(n2);
  } else {
    var p = n2.parentNode, s = n2.nextSibling;
    if (s == n1) 
    {
      p.insertBefore(n1, n2);
    } else if (n2 == n1.nextSibling) 
    {
      p.insertBefore(n2, n1);
    } else {
      n1.parentNode.replaceChild(n2, n1);
      p.insertBefore(n1, s);
    }
  }
}, getScroll: function() {
  var doc = window.document, docEl = doc.documentElement, body = doc.body, top = 0, left = 0;
  if (Ext.isGecko4) 
  {
    top = window.scrollYOffset;
    left = window.scrollXOffset;
  } else {
    if (docEl && (docEl.scrollTop || docEl.scrollLeft)) 
    {
      top = docEl.scrollTop;
      left = docEl.scrollLeft;
    } else if (body) 
    {
      top = body.scrollTop;
      left = body.scrollLeft;
    }
  }
  return {top: top, left: left};
}, getStyle: function(el, styleProp) {
  return Ext.fly(el).getStyle(styleProp);
}, getScrollTop: function() {
  return this.getScroll().top;
}, getScrollLeft: function() {
  return this.getScroll().left;
}, moveToEl: function(moveEl, targetEl) {
  var aCoord = Ext.Element.getXY(targetEl);
  Ext.Element.setXY(moveEl, aCoord);
}, numericSort: function(a, b) {
  return (a - b);
}, _timeoutCount: 0, _addListeners: function() {
  if (document) 
  {
    this._onLoad();
  } else {
    if (this._timeoutCount <= 2000) 
    {
      setTimeout(this._addListeners, 10);
      if (document && document.body) 
      {
        this._timeoutCount += 1;
      }
    }
  }
}, handleWasClicked: function(node, id) {
  if (this.isHandle(id, node.id)) 
  {
    return true;
  } else {
    var p = node.parentNode;
    while (p) 
      {
        if (this.isHandle(id, p.id)) 
        {
          return true;
        } else {
          p = p.parentNode;
        }
      }
  }
  return false;
}}, 0, 0, 0, 0, 0, 0, [Ext.dd, 'DragDropManager', Ext.dd, 'DragDropMgr', Ext.dd, 'DDM'], function() {
  this._addListeners();
}));
;

(Ext.cmd.derive('Ext.layout.container.Box', Ext.layout.container.Container, {alternateClassName: 'Ext.layout.BoxLayout', defaultMargins: {top: 0, right: 0, bottom: 0, left: 0}, padding: 0, pack: 'start', flex: undefined, stretchMaxPartner: undefined, alignRoundingMethod: 'round', type: 'box', scrollOffset: 0, itemCls: Ext.baseCSSPrefix + 'box-item', targetCls: Ext.baseCSSPrefix + 'box-layout-ct', targetElCls: Ext.baseCSSPrefix + 'box-target', innerCls: Ext.baseCSSPrefix + 'box-inner', availableSpaceOffset: 0, reserveOffset: true, manageMargins: true, createsInnerCt: true, childEls: ['innerCt', 'targetEl'], renderTpl: ['{%var oc,l=values.$comp.layout,oh=l.overflowHandler;', 'if (oh.getPrefixConfig!==Ext.emptyFn) {', 'if(oc=oh.getPrefixConfig())dh.generateMarkup(oc, out)', '}%}', '<div id="{ownerId}-innerCt" class="{[l.innerCls]} {[oh.getOverflowCls()]}" role="presentation">', '<div id="{ownerId}-targetEl" class="{targetElCls}" role="presentation">', '{%this.renderBody(out, values)%}', '</div>', '</div>', '{%if (oh.getSuffixConfig!==Ext.emptyFn) {', 'if(oc=oh.getSuffixConfig())dh.generateMarkup(oc, out)', '}%}', {disableFormats: true, definitions: 'var dh=Ext.DomHelper;'}], constructor: function(config) {
  var me = this, type;
  me.callParent(arguments);
  me.flexSortFn = Ext.Function.bind(me.flexSort, me);
  me.initOverflowHandler();
  type = typeof me.padding;
  if (type == 'string' || type == 'number') 
  {
    me.padding = Ext.util.Format.parseBox(me.padding);
    me.padding.height = me.padding.top + me.padding.bottom;
    me.padding.width = me.padding.left + me.padding.right;
  }
}, _percentageRe: /^\s*(\d+(?:\.\d*)?)\s*[%]\s*$/, getItemSizePolicy: function(item, ownerSizeModel) {
  var me = this, policy = me.sizePolicy, align = me.align, flex = item.flex, key = align, names = me.names, width = item[names.width], height = item[names.height], percentageRe = me._percentageRe, percentageWidth = percentageRe.test(width), isStretch = (align == 'stretch'), isStretchMax = (align == 'stretchmax'), constrain = me.constrainAlign;
  if (!ownerSizeModel && (isStretch || flex || percentageWidth || (constrain && !isStretchMax))) 
  {
    ownerSizeModel = me.owner.getSizeModel();
  }
  if (isStretch) 
  {
    if (!percentageRe.test(height) && ownerSizeModel[names.height].shrinkWrap) 
    {
      key = 'stretchmax';
    }
  } else if (!isStretchMax) 
  {
    if (percentageRe.test(height)) 
    {
      key = 'stretch';
    } else if (constrain && !ownerSizeModel[names.height].shrinkWrap) 
    {
      key = 'stretchmax';
    } else {
      key = '';
    }
  }
  if (flex || percentageWidth) 
  {
    if (!ownerSizeModel[names.width].shrinkWrap) 
    {
      policy = policy.flex;
    }
  }
  return policy[key];
}, flexSort: function(a, b) {
  var maxWidthName = this.names.maxWidth, minWidthName = this.names.minWidth, infiniteValue = Infinity, aTarget = a.target, bTarget = b.target, aFlex = aTarget.flex, bFlex = bTarget.flex, result = 0, aMin, bMin, aMax, bMax, hasMin, hasMax;
  aMax = aTarget[maxWidthName] || infiniteValue;
  bMax = bTarget[maxWidthName] || infiniteValue;
  aMin = aTarget[minWidthName] || 0;
  bMin = bTarget[minWidthName] || 0;
  hasMin = isFinite(aMin) || isFinite(bMin);
  hasMax = isFinite(aMax) || isFinite(bMax);
  if (hasMin || hasMax) 
  {
    if (hasMax) 
    {
      result = aMax - bMax;
    }
    if (result === 0 && hasMin) 
    {
      result = bMin - aMin;
    }
    if (result === 0) 
    {
      if (hasMax) 
      {
        result = bFlex - aFlex;
      } else {
        result = aFlex - bFlex;
      }
    }
  }
  return result;
}, isItemBoxParent: function(itemContext) {
  return true;
}, isItemShrinkWrap: function(item) {
  return true;
}, roundFlex: function(width) {
  return Math.ceil(width);
}, beginCollapse: function(child) {
  var me = this;
  if (me.direction === 'vertical' && child.collapsedVertical()) 
  {
    child.collapseMemento.capture(['flex']);
    delete child.flex;
  } else if (me.direction === 'horizontal' && child.collapsedHorizontal()) 
  {
    child.collapseMemento.capture(['flex']);
    delete child.flex;
  }
}, beginExpand: function(child) {
  child.collapseMemento.restore(['flex']);
}, beginLayout: function(ownerContext) {
  var me = this, owner = me.owner, smp = owner.stretchMaxPartner, style = me.innerCt.dom.style, names = me.names;
  ownerContext.boxNames = names;
  me.overflowHandler.beginLayout(ownerContext);
  if (typeof smp === 'string') 
  {
    smp = Ext.getCmp(smp) || owner.query(smp)[0];
  }
  ownerContext.stretchMaxPartner = smp && ownerContext.context.getCmp(smp);
  me.callParent(arguments);
  ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);
  me.scrollParallel = owner.scrollFlags[names.x];
  me.scrollPerpendicular = owner.scrollFlags[names.y];
  if (me.scrollParallel) 
  {
    me.scrollPos = owner.getTargetEl().dom[names.scrollLeft];
  }
  style.width = '';
  style.height = '';
}, beginLayoutCycle: function(ownerContext, firstCycle) {
  var me = this, align = me.align, names = ownerContext.boxNames, pack = me.pack, heightModelName = names.heightModel;
  me.overflowHandler.beginLayoutCycle(ownerContext, firstCycle);
  me.callParent(arguments);
  ownerContext.parallelSizeModel = ownerContext[names.widthModel];
  ownerContext.perpendicularSizeModel = ownerContext[heightModelName];
  ownerContext.boxOptions = {align: align = {stretch: align == 'stretch', stretchmax: align == 'stretchmax', center: align == names.center, bottom: align == names.afterY}, pack: pack = {center: pack == 'center', end: pack == 'end'}};
  if (align.stretch && ownerContext.perpendicularSizeModel.shrinkWrap) 
  {
    align.stretchmax = true;
    align.stretch = false;
  }
  align.nostretch = !(align.stretch || align.stretchmax);
  if (ownerContext.parallelSizeModel.shrinkWrap) 
  {
    pack.center = pack.end = false;
  }
  me.cacheFlexes(ownerContext);
  me.targetEl.setWidth(20000);
}, cacheFlexes: function(ownerContext) {
  var me = this, names = ownerContext.boxNames, widthModelName = names.widthModel, heightModelName = names.heightModel, nostretch = ownerContext.boxOptions.align.nostretch, totalFlex = 0, childItems = ownerContext.childItems, i = childItems.length, flexedItems = [], minWidth = 0, minWidthName = names.minWidth, percentageRe = me._percentageRe, percentageWidths = 0, percentageHeights = 0, child, childContext, flex, match;
  while (i--) 
    {
      childContext = childItems[i];
      child = childContext.target;
      if (childContext[widthModelName].calculated) 
      {
        childContext.flex = flex = child.flex;
        if (flex) 
        {
          totalFlex += flex;
          flexedItems.push(childContext);
          minWidth += child[minWidthName] || 0;
        } else {
          match = percentageRe.exec(child[names.width]);
          childContext.percentageParallel = parseFloat(match[1]) / 100;
          ++percentageWidths;
        }
      }
      if (nostretch && childContext[heightModelName].calculated) 
      {
        match = percentageRe.exec(child[names.height]);
        childContext.percentagePerpendicular = parseFloat(match[1]) / 100;
        ++percentageHeights;
      }
    }
  ownerContext.flexedItems = flexedItems;
  ownerContext.flexedMinSize = minWidth;
  ownerContext.totalFlex = totalFlex;
  ownerContext.percentageWidths = percentageWidths;
  ownerContext.percentageHeights = percentageHeights;
  Ext.Array.sort(flexedItems, me.flexSortFn);
}, calculate: function(ownerContext) {
  var me = this, targetSize = me.getContainerSize(ownerContext), names = ownerContext.boxNames, state = ownerContext.state, plan = state.boxPlan || (state.boxPlan = {}), targetContext = ownerContext.targetContext;
  plan.targetSize = targetSize;
  if (!state.parallelDone) 
  {
    state.parallelDone = me.calculateParallel(ownerContext, names, plan);
  }
  if (!state.perpendicularDone) 
  {
    state.perpendicularDone = me.calculatePerpendicular(ownerContext, names, plan);
  }
  if (state.parallelDone && state.perpendicularDone) 
  {
    if (me.owner.dock && (Ext.isIE7m || Ext.isIEQuirks) && !me.owner.width && !me.horizontal) 
    {
      plan.isIEVerticalDock = true;
      plan.calculatedWidth = plan.maxSize + ownerContext.getPaddingInfo().width + ownerContext.getFrameInfo().width;
      if (targetContext !== ownerContext) 
      {
        plan.calculatedWidth += targetContext.getPaddingInfo().width;
      }
    }
    me.publishInnerCtSize(ownerContext, me.reserveOffset ? me.availableSpaceOffset : 0);
    if (me.done && ownerContext.boxOptions.align.stretchmax && !state.stretchMaxDone) 
    {
      me.calculateStretchMax(ownerContext, names, plan);
      state.stretchMaxDone = true;
    }
    me.overflowHandler.calculate(ownerContext);
  } else {
    me.done = false;
  }
}, calculateParallel: function(ownerContext, names, plan) {
  var me = this, widthName = names.width, childItems = ownerContext.childItems, beforeXName = names.beforeX, afterXName = names.afterX, setWidthName = names.setWidth, childItemsLength = childItems.length, flexedItems = ownerContext.flexedItems, flexedItemsLength = flexedItems.length, pack = ownerContext.boxOptions.pack, padding = me.padding, targetSize = plan.targetSize, containerWidth = targetSize[widthName], totalMargin = 0, left = padding[beforeXName], nonFlexWidth = left + padding[afterXName] + me.scrollOffset + (me.reserveOffset ? me.availableSpaceOffset : 0), scrollbarWidth = Ext.getScrollbarSize()[names.width], i, childMargins, remainingWidth, remainingFlex, childContext, flex, flexedWidth, contentWidth, mayNeedScrollbarAdjust, childWidth, percentageSpace;
  if (!ownerContext.parallelSizeModel.shrinkWrap && !targetSize[names.gotWidth]) 
  {
    return false;
  }
  if (scrollbarWidth && me.scrollPerpendicular && ownerContext.parallelSizeModel.shrinkWrap && !ownerContext.boxOptions.align.stretch && !ownerContext.perpendicularSizeModel.shrinkWrap) 
  {
    if (!ownerContext.state.perpendicularDone) 
    {
      return false;
    }
    mayNeedScrollbarAdjust = true;
  }
  for (i = 0; i < childItemsLength; ++i) 
    {
      childContext = childItems[i];
      childMargins = childContext.marginInfo || childContext.getMarginInfo();
      totalMargin += childMargins[widthName];
      if (!childContext[names.widthModel].calculated) 
      {
        childWidth = childContext.getProp(widthName);
        nonFlexWidth += childWidth;
        if (isNaN(nonFlexWidth)) 
        {
          return false;
        }
      }
    }
  nonFlexWidth += totalMargin;
  if (ownerContext.percentageWidths) 
  {
    percentageSpace = containerWidth - totalMargin;
    if (isNaN(percentageSpace)) 
    {
      return false;
    }
    for (i = 0; i < childItemsLength; ++i) 
      {
        childContext = childItems[i];
        if (childContext.percentageParallel) 
        {
          childWidth = Math.ceil(percentageSpace * childContext.percentageParallel);
          childWidth = childContext.setWidth(childWidth);
          nonFlexWidth += childWidth;
        }
      }
  }
  if (ownerContext.parallelSizeModel.shrinkWrap) 
  {
    plan.availableSpace = 0;
    plan.tooNarrow = false;
  } else {
    plan.availableSpace = containerWidth - nonFlexWidth;
    plan.tooNarrow = plan.availableSpace < ownerContext.flexedMinSize;
    if (plan.tooNarrow && Ext.getScrollbarSize()[names.height] && me.scrollParallel && ownerContext.state.perpendicularDone) 
    {
      ownerContext.state.perpendicularDone = false;
      for (i = 0; i < childItemsLength; ++i) 
        {
          childItems[i].invalidate();
        }
    }
  }
  contentWidth = nonFlexWidth;
  remainingWidth = plan.availableSpace;
  remainingFlex = ownerContext.totalFlex;
  for (i = 0; i < flexedItemsLength; i++) 
    {
      childContext = flexedItems[i];
      flex = childContext.flex;
      flexedWidth = me.roundFlex((flex / remainingFlex) * remainingWidth);
      flexedWidth = childContext[setWidthName](flexedWidth);
      contentWidth += flexedWidth;
      remainingWidth = Math.max(0, remainingWidth - flexedWidth);
      remainingFlex -= flex;
    }
  if (pack.center) 
  {
    left += remainingWidth / 2;
    if (left < 0) 
    {
      left = 0;
    }
  } else if (pack.end) 
  {
    left += remainingWidth;
  }
  for (i = 0; i < childItemsLength; ++i) 
    {
      childContext = childItems[i];
      childMargins = childContext.marginInfo;
      left += childMargins[beforeXName];
      childContext.setProp(names.x, left);
      left += childMargins[afterXName] + childContext.props[widthName];
    }
  contentWidth += ownerContext.targetContext.getPaddingInfo()[widthName];
  ownerContext.state.contentWidth = contentWidth;
  if (mayNeedScrollbarAdjust && (ownerContext.peek(names.contentHeight) > plan.targetSize[names.height])) 
  {
    contentWidth += scrollbarWidth;
    ownerContext[names.hasOverflowY] = true;
    ownerContext.target.componentLayout[names.setWidthInDom] = true;
    ownerContext[names.invalidateScrollY] = Ext.isStrict && Ext.isIE8;
  }
  ownerContext[names.setContentWidth](contentWidth);
  return true;
}, calculatePerpendicular: function(ownerContext, names, plan) {
  var me = this, heightShrinkWrap = ownerContext.perpendicularSizeModel.shrinkWrap, targetSize = plan.targetSize, childItems = ownerContext.childItems, childItemsLength = childItems.length, mmax = Math.max, heightName = names.height, setHeightName = names.setHeight, beforeYName = names.beforeY, topPositionName = names.y, padding = me.padding, top = padding[beforeYName], availHeight = targetSize[heightName] - top - padding[names.afterY], align = ownerContext.boxOptions.align, isStretch = align.stretch, isStretchMax = align.stretchmax, isCenter = align.center, isBottom = align.bottom, constrain = me.constrainAlign, maxHeight = 0, hasPercentageSizes = 0, onBeforeInvalidateChild = me.onBeforeConstrainInvalidateChild, onAfterInvalidateChild = me.onAfterConstrainInvalidateChild, scrollbarHeight = Ext.getScrollbarSize().height, childTop, i, childHeight, childMargins, diff, height, childContext, stretchMaxPartner, stretchMaxChildren, shrinkWrapParallelOverflow, percentagePerpendicular;
  if (isStretch || ((isCenter || isBottom) && !heightShrinkWrap)) 
  {
    if (isNaN(availHeight)) 
    {
      return false;
    }
  }
  if (!isStretch && !ownerContext.parallelSizeModel.shrinkWrap && !ownerContext.state.parallelDone && me.scrollParallel) 
  {
    return false;
  }
  if (me.scrollParallel && plan.tooNarrow) 
  {
    if (heightShrinkWrap) 
    {
      shrinkWrapParallelOverflow = true;
    } else {
      availHeight -= scrollbarHeight;
      plan.targetSize[heightName] -= scrollbarHeight;
    }
  }
  if (isStretch) 
  {
    height = availHeight;
  } else {
    for (i = 0; i < childItemsLength; i++) 
      {
        childContext = childItems[i];
        childMargins = (childContext.marginInfo || childContext.getMarginInfo())[heightName];
        if (!(percentagePerpendicular = childContext.percentagePerpendicular)) 
        {
          childHeight = childContext.getProp(heightName);
        } else {
          ++hasPercentageSizes;
          if (heightShrinkWrap) 
          {
            continue;
          } else {
            childHeight = percentagePerpendicular * availHeight - childMargins;
            childHeight = childContext[names.setHeight](childHeight);
          }
        }
        if (!heightShrinkWrap && constrain && childContext[names.heightModel].shrinkWrap && childHeight > availHeight) 
        {
          childContext.invalidate({before: onBeforeInvalidateChild, after: onAfterInvalidateChild, layout: me, childHeight: availHeight, names: names});
          ownerContext.state.parallelDone = false;
        }
        if (isNaN(maxHeight = mmax(maxHeight, childHeight + childMargins, childContext.target[names.minHeight] || 0))) 
        {
          return false;
        }
      }
    if (shrinkWrapParallelOverflow) 
    {
      maxHeight += scrollbarHeight;
      ownerContext[names.hasOverflowX] = true;
      ownerContext.target.componentLayout[names.setHeightInDom] = true;
      ownerContext[names.invalidateScrollX] = Ext.isStrict && Ext.isIE8;
    }
    stretchMaxPartner = ownerContext.stretchMaxPartner;
    if (stretchMaxPartner) 
    {
      ownerContext.setProp('maxChildHeight', maxHeight);
      stretchMaxChildren = stretchMaxPartner.childItems;
      if (stretchMaxChildren && stretchMaxChildren.length) 
      {
        maxHeight = mmax(maxHeight, stretchMaxPartner.getProp('maxChildHeight'));
        if (isNaN(maxHeight)) 
        {
          return false;
        }
      }
    }
    ownerContext[names.setContentHeight](maxHeight + me.padding[heightName] + ownerContext.targetContext.getPaddingInfo()[heightName]);
    if (shrinkWrapParallelOverflow) 
    {
      maxHeight -= scrollbarHeight;
    }
    plan.maxSize = maxHeight;
    if (isStretchMax) 
    {
      height = maxHeight;
    } else if (isCenter || isBottom || hasPercentageSizes) 
    {
      if (constrain) 
      {
        height = heightShrinkWrap ? maxHeight : availHeight;
      } else {
        height = heightShrinkWrap ? maxHeight : mmax(availHeight, maxHeight);
      }
      height -= ownerContext.innerCtContext.getBorderInfo()[heightName];
    }
  }
  for (i = 0; i < childItemsLength; i++) 
    {
      childContext = childItems[i];
      childMargins = childContext.marginInfo || childContext.getMarginInfo();
      childTop = top + childMargins[beforeYName];
      if (isStretch) 
      {
        childContext[setHeightName](height - childMargins[heightName]);
      } else {
        percentagePerpendicular = childContext.percentagePerpendicular;
        if (heightShrinkWrap && percentagePerpendicular) 
        {
          childMargins = childContext.marginInfo || childContext.getMarginInfo();
          childHeight = percentagePerpendicular * height - childMargins[heightName];
          childHeight = childContext.setHeight(childHeight);
        }
        if (isCenter) 
        {
          diff = height - childContext.props[heightName];
          if (diff > 0) 
          {
            childTop = top + Math[me.alignRoundingMethod](diff / 2);
          }
        } else if (isBottom) 
        {
          childTop = mmax(0, height - childTop - childContext.props[heightName]);
        }
      }
      childContext.setProp(topPositionName, childTop);
    }
  return true;
}, onBeforeConstrainInvalidateChild: function(childContext, options) {
  var heightModelName = options.names.heightModel;
  if (!childContext[heightModelName].constrainedMin) 
  {
    childContext[heightModelName] = Ext.layout.SizeModel.calculated;
  }
}, onAfterConstrainInvalidateChild: function(childContext, options) {
  var names = options.names;
  childContext.setProp(names.beforeY, 0);
  if (childContext[names.heightModel].calculated) 
  {
    childContext[names.setHeight](options.childHeight);
  }
}, calculateStretchMax: function(ownerContext, names, plan) {
  var me = this, heightName = names.height, widthName = names.width, childItems = ownerContext.childItems, length = childItems.length, height = plan.maxSize, onBeforeStretchMaxInvalidateChild = me.onBeforeStretchMaxInvalidateChild, onAfterStretchMaxInvalidateChild = me.onAfterStretchMaxInvalidateChild, childContext, props, i, childHeight;
  for (i = 0; i < length; ++i) 
    {
      childContext = childItems[i];
      props = childContext.props;
      childHeight = height - childContext.getMarginInfo()[heightName];
      if (childHeight != props[heightName] || childContext[names.heightModel].constrained) 
      {
        childContext.invalidate({before: onBeforeStretchMaxInvalidateChild, after: onAfterStretchMaxInvalidateChild, layout: me, childWidth: props[widthName], childHeight: childHeight, childX: props.x, childY: props.y, names: names});
      }
    }
}, onBeforeStretchMaxInvalidateChild: function(childContext, options) {
  var heightModelName = options.names.heightModel;
  if (!childContext[heightModelName].constrainedMax) 
  {
    childContext[heightModelName] = Ext.layout.SizeModel.calculated;
  }
}, onAfterStretchMaxInvalidateChild: function(childContext, options) {
  var names = options.names, childHeight = options.childHeight, childWidth = options.childWidth;
  childContext.setProp('x', options.childX);
  childContext.setProp('y', options.childY);
  if (childContext[names.heightModel].calculated) 
  {
    childContext[names.setHeight](childHeight);
  }
  if (childContext[names.widthModel].calculated) 
  {
    childContext[names.setWidth](childWidth);
  }
}, completeLayout: function(ownerContext) {
  var me = this, names = ownerContext.boxNames, invalidateScrollX = ownerContext.invalidateScrollX, invalidateScrollY = ownerContext.invalidateScrollY, dom, el, overflowX, overflowY, styles;
  me.overflowHandler.completeLayout(ownerContext);
  if (invalidateScrollX || invalidateScrollY) 
  {
    el = me.getTarget();
    dom = el.dom;
    styles = dom.style;
    if (invalidateScrollX) 
    {
      overflowX = el.getStyle('overflowX');
      if (overflowX == 'auto') 
      {
        overflowX = styles.overflowX;
        styles.overflowX = 'scroll';
      } else {
        invalidateScrollX = false;
      }
    }
    if (invalidateScrollY) 
    {
      overflowY = el.getStyle('overflowY');
      if (overflowY == 'auto') 
      {
        overflowY = styles.overflowY;
        styles.overflowY = 'scroll';
      } else {
        invalidateScrollY = false;
      }
    }
    if (invalidateScrollX || invalidateScrollY) 
    {
      dom.scrollWidth;
      if (invalidateScrollX) 
      {
        styles.overflowX = overflowX;
      }
      if (invalidateScrollY) 
      {
        styles.overflowY = overflowY;
      }
    }
  }
  if (me.scrollParallel) 
  {
    me.owner.getTargetEl().dom[names.scrollLeft] = me.scrollPos;
  }
}, finishedLayout: function(ownerContext) {
  this.overflowHandler.finishedLayout(ownerContext);
  this.callParent(arguments);
  this.targetEl.setWidth(ownerContext.innerCtContext.props.width);
}, publishInnerCtSize: function(ownerContext, reservedSpace) {
  var me = this, names = ownerContext.boxNames, heightName = names.height, widthName = names.width, align = ownerContext.boxOptions.align, dock = me.owner.dock, padding = me.padding, plan = ownerContext.state.boxPlan, targetSize = plan.targetSize, height = targetSize[heightName], innerCtContext = ownerContext.innerCtContext, innerCtWidth = (ownerContext.parallelSizeModel.shrinkWrap || (plan.tooNarrow && me.scrollParallel) ? ownerContext.state.contentWidth - ownerContext.targetContext.getPaddingInfo()[widthName] : targetSize[widthName]) - (reservedSpace || 0), innerCtHeight;
  if (align.stretch) 
  {
    innerCtHeight = height;
  } else {
    innerCtHeight = plan.maxSize + padding[names.beforeY] + padding[names.afterY] + innerCtContext.getBorderInfo()[heightName];
    if (!ownerContext.perpendicularSizeModel.shrinkWrap && (align.center || align.bottom)) 
    {
      innerCtHeight = Math.max(height, innerCtHeight);
    }
  }
  innerCtContext[names.setWidth](innerCtWidth);
  innerCtContext[names.setHeight](innerCtHeight);
  if (isNaN(innerCtWidth + innerCtHeight)) 
  {
    me.done = false;
  }
  if (plan.calculatedWidth && (dock == 'left' || dock == 'right')) 
  {
    ownerContext.setWidth(plan.calculatedWidth, true, true);
  }
}, onRemove: function(comp, isDestroying) {
  var me = this, names = me.names, el;
  me.callParent(arguments);
  if (me.overflowHandler) 
  {
    me.overflowHandler.onRemove(comp);
  }
  if (comp.layoutMarginCap == me.id) 
  {
    delete comp.layoutMarginCap;
  }
  if (!me.owner.destroying && !isDestroying && comp.rendered) 
  {
    el = comp.getEl();
    el.setStyle(names.beforeY, '');
    el.setStyle(names.beforeX, '');
    el.setStyle('margin', '');
  }
}, initOverflowHandler: function() {
  var me = this, handler = me.overflowHandler, handlerType, constructor;
  if (typeof handler == 'string') 
  {
    handler = {type: handler};
  }
  handlerType = 'None';
  if (handler && handler.type !== undefined) 
  {
    handlerType = handler.type;
  }
  constructor = Ext.layout.container.boxOverflow[handlerType];
  if (constructor[me.type]) 
  {
    constructor = constructor[me.type];
  }
  me.overflowHandler = Ext.create('Ext.layout.container.boxOverflow.' + handlerType, me, handler);
}, getRenderTarget: function() {
  return this.targetEl;
}, getElementTarget: function() {
  return this.innerCt;
}, destroy: function() {
  var me = this;
  Ext.destroy(me.innerCt, me.overflowHandler);
  me.flexSortFn = me.innerCt = null;
  me.callParent(arguments);
}, getRenderData: function() {
  var data = this.callParent();
  data.targetElCls = this.targetElCls;
  return data;
}}, 1, 0, 0, 0, ["layout.box"], 0, [Ext.layout.container, 'Box', Ext.layout, 'BoxLayout'], 0));
;

(Ext.cmd.derive('Ext.layout.container.HBox', Ext.layout.container.Box, {alternateClassName: 'Ext.layout.HBoxLayout', align: 'top', constrainAlign: false, type: 'hbox', direction: 'horizontal', horizontal: true, names: {beforeX: 'left', beforeScrollX: 'left', beforeScrollerSuffix: '-before-scroller', afterScrollerSuffix: '-after-scroller', leftCap: 'Left', afterX: 'right', width: 'width', contentWidth: 'contentWidth', minWidth: 'minWidth', maxWidth: 'maxWidth', widthCap: 'Width', widthModel: 'widthModel', widthIndex: 0, x: 'x', scrollLeft: 'scrollLeft', overflowX: 'overflowX', hasOverflowX: 'hasOverflowX', invalidateScrollX: 'invalidateScrollX', parallelMargins: 'lr', center: 'middle', beforeY: 'top', afterY: 'bottom', height: 'height', contentHeight: 'contentHeight', minHeight: 'minHeight', maxHeight: 'maxHeight', heightCap: 'Height', heightModel: 'heightModel', heightIndex: 1, y: 'y', overflowY: 'overflowY', hasOverflowY: 'hasOverflowY', invalidateScrollY: 'invalidateScrollY', perpendicularMargins: 'tb', getWidth: 'getWidth', getHeight: 'getHeight', setWidth: 'setWidth', setHeight: 'setHeight', gotWidth: 'gotWidth', gotHeight: 'gotHeight', setContentWidth: 'setContentWidth', setContentHeight: 'setContentHeight', setWidthInDom: 'setWidthInDom', setHeightInDom: 'setHeightInDom', getScrollLeft: 'getScrollLeft', setScrollLeft: 'setScrollLeft', scrollTo: 'scrollTo'}, sizePolicy: {flex: {'': {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0}, stretch: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1}, stretchmax: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 1}}, '': {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0}, stretch: {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1}, stretchmax: {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 1}}}, 0, 0, 0, 0, ["layout.hbox"], 0, [Ext.layout.container, 'HBox', Ext.layout, 'HBoxLayout'], 0));
;

(Ext.cmd.derive('Ext.layout.container.VBox', Ext.layout.container.Box, {alternateClassName: 'Ext.layout.VBoxLayout', align: 'left', constrainAlign: false, type: 'vbox', direction: 'vertical', horizontal: false, names: {beforeX: 'top', beforeScrollX: 'top', beforeScrollerSuffix: '-before-scroller', afterScrollerSuffix: '-after-scroller', leftCap: 'Top', afterX: 'bottom', width: 'height', contentWidth: 'contentHeight', minWidth: 'minHeight', maxWidth: 'maxHeight', widthCap: 'Height', widthModel: 'heightModel', widthIndex: 1, x: 'y', scrollLeft: 'scrollTop', overflowX: 'overflowY', hasOverflowX: 'hasOverflowY', invalidateScrollX: 'invalidateScrollY', parallelMargins: 'tb', center: 'center', beforeY: 'left', afterY: 'right', height: 'width', contentHeight: 'contentWidth', minHeight: 'minWidth', maxHeight: 'maxWidth', heightCap: 'Width', heightModel: 'widthModel', heightIndex: 0, y: 'x', overflowY: 'overflowX', hasOverflowY: 'hasOverflowX', invalidateScrollY: 'invalidateScrollX', perpendicularMargins: 'lr', getWidth: 'getHeight', getHeight: 'getWidth', setWidth: 'setHeight', setHeight: 'setWidth', gotWidth: 'gotHeight', gotHeight: 'gotWidth', setContentWidth: 'setContentHeight', setContentHeight: 'setContentWidth', setWidthInDom: 'setHeightInDom', setHeightInDom: 'setWidthInDom', getScrollLeft: 'getScrollTop', setScrollLeft: 'setScrollTop', scrollTo: 'scrollTo'}, sizePolicy: {flex: {'': {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1}, stretch: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1}, stretchmax: {readsWidth: 1, readsHeight: 0, setsWidth: 1, setsHeight: 1}}, '': {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0}, stretch: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0}, stretchmax: {readsWidth: 1, readsHeight: 1, setsWidth: 1, setsHeight: 0}}}, 0, 0, 0, 0, ["layout.vbox"], 0, [Ext.layout.container, 'VBox', Ext.layout, 'VBoxLayout'], 0));
;

(Ext.cmd.derive('Ext.toolbar.Toolbar', Ext.container.Container, {alternateClassName: 'Ext.Toolbar', isToolbar: true, baseCls: Ext.baseCSSPrefix + 'toolbar', ariaRole: 'toolbar', defaultType: 'button', vertical: false, enableOverflow: false, menuTriggerCls: Ext.baseCSSPrefix + 'toolbar-more-icon', trackMenus: true, itemCls: Ext.baseCSSPrefix + 'toolbar-item', statics: {shortcuts: {'-': 'tbseparator', ' ': 'tbspacer'}, shortcutsHV: {0: {'->': {xtype: 'tbfill', height: 0}}, 1: {'->': {xtype: 'tbfill', width: 0}}}}, initComponent: function() {
  var me = this;
  if (!me.layout && me.enableOverflow) 
  {
    me.layout = {overflowHandler: 'Menu'};
  }
  if (me.dock === 'right' || me.dock === 'left') 
  {
    me.vertical = true;
  }
  me.layout = Ext.applyIf(Ext.isString(me.layout) ? {type: me.layout} : me.layout || {}, {type: me.vertical ? 'vbox' : 'hbox', align: me.vertical ? 'stretchmax' : 'middle'});
  if (me.vertical) 
  {
    me.addClsWithUI('vertical');
  }
  if (me.ui === 'footer') 
  {
    me.ignoreBorderManagement = true;
  }
  me.callParent();
  me.addEvents('overflowchange');
}, getRefItems: function(deep) {
  var me = this, items = me.callParent(arguments), layout = me.layout, handler;
  if (deep && me.enableOverflow) 
  {
    handler = layout.overflowHandler;
    if (handler && handler.menu) 
    {
      items = items.concat(handler.menu.getRefItems(deep));
    }
  }
  return items;
}, lookupComponent: function(c) {
  var args = arguments;
  if (typeof c == 'string') 
  {
    var T = Ext.toolbar.Toolbar, shortcut = T.shortcutsHV[this.vertical ? 1 : 0][c] || T.shortcuts[c];
    if (typeof shortcut == 'string') 
    {
      c = {xtype: shortcut};
    } else if (shortcut) 
    {
      c = Ext.apply({}, shortcut);
    } else {
      c = {xtype: 'tbtext', text: c};
    }
    this.applyDefaults(c);
    args = [c];
  }
  return this.callParent(args);
}, applyDefaults: function(c) {
  if (!Ext.isString(c)) 
  {
    c = this.callParent(arguments);
  }
  return c;
}, trackMenu: function(item, remove) {
  if (this.trackMenus && item.menu) 
  {
    var method = remove ? 'mun' : 'mon', me = this;
    me[method](item, 'mouseover', me.onButtonOver, me);
    me[method](item, 'menushow', me.onButtonMenuShow, me);
    me[method](item, 'menuhide', me.onButtonMenuHide, me);
  }
}, onBeforeAdd: function(component) {
  var me = this, isButton = component.isButton;
  if (isButton && me.defaultButtonUI && component.ui === 'default' && !component.hasOwnProperty('ui')) 
  {
    component.ui = me.defaultButtonUI;
  } else if ((isButton || component.isFormField) && me.ui !== 'footer') 
  {
    component.ui = component.ui + '-toolbar';
    component.addCls(component.baseCls + '-toolbar');
  }
  if (component instanceof Ext.toolbar.Separator) 
  {
    component.setUI((me.vertical) ? 'vertical' : 'horizontal');
  }
  me.callParent(arguments);
}, onAdd: function(component) {
  this.callParent(arguments);
  this.trackMenu(component);
}, onRemove: function(c) {
  this.callParent(arguments);
  this.trackMenu(c, true);
}, getChildItemsToDisable: function() {
  return this.items.getRange();
}, onButtonOver: function(btn) {
  if (this.activeMenuBtn && this.activeMenuBtn != btn) 
  {
    this.activeMenuBtn.hideMenu();
    btn.showMenu();
    this.activeMenuBtn = btn;
  }
}, onButtonMenuShow: function(btn) {
  this.activeMenuBtn = btn;
}, onButtonMenuHide: function(btn) {
  delete this.activeMenuBtn;
}}, 0, ["toolbar"], ["container", "toolbar", "component", "box"], {"container": true, "toolbar": true, "component": true, "box": true}, ["widget.toolbar"], 0, [Ext.toolbar, 'Toolbar', Ext, 'Toolbar'], 0));
;

(Ext.cmd.derive('Ext.panel.AbstractPanel', Ext.container.Container, {baseCls: Ext.baseCSSPrefix + 'panel', isPanel: true, contentPaddingProperty: 'bodyPadding', shrinkWrapDock: false, componentLayout: 'dock', childEls: ['body'], renderTpl: ['{% this.renderDockedItems(out,values,0); %}', (Ext.isIE7m || Ext.isIEQuirks) ? '<div style="position:relative;font-size:0;line-height:0;" role="presentation">&nbsp;</div>' : '', '<div id="{id}-body" class="{baseCls}-body<tpl if="bodyCls"> {bodyCls}</tpl>', ' {baseCls}-body-{ui}<tpl if="uiCls">', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>', '</tpl>{childElCls}"', '<tpl if="bodyRole"> role="{bodyRole}"<tpl else> role="presentation"</tpl>', '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>', '{%this.renderContainer(out,values);%}', '</div>', '{% this.renderDockedItems(out,values,1); %}'], bodyPosProps: {x: 'x', y: 'y'}, border: true, emptyArray: [], initComponent: function() {
  this.initBorderProps();
  this.callParent();
}, initBorderProps: function() {
  var me = this;
  if (me.frame && me.border && me.bodyBorder === undefined) 
  {
    me.bodyBorder = false;
  }
  if (me.frame && me.border && (me.bodyBorder === false || me.bodyBorder === 0)) 
  {
    me.manageBodyBorders = true;
  }
}, beforeDestroy: function() {
  this.destroyDockedItems();
  this.callParent();
}, initItems: function() {
  this.callParent();
  this.initDockingItems();
}, initRenderData: function() {
  var me = this, data = me.callParent();
  me.initBodyStyles();
  me.protoBody.writeTo(data);
  delete me.protoBody;
  return data;
}, getComponent: function(comp) {
  var component = this.callParent(arguments);
  if (component === undefined && !Ext.isNumber(comp)) 
  {
    component = this.getDockedComponent(comp);
  }
  return component;
}, getProtoBody: function() {
  var me = this, body = me.protoBody;
  if (!body) 
  {
    me.protoBody = body = new Ext.util.ProtoElement({cls: me.bodyCls, style: me.bodyStyle, clsProp: 'bodyCls', styleProp: 'bodyStyle', styleIsText: true});
  }
  return body;
}, initBodyStyles: function() {
  var me = this, body = me.getProtoBody();
  if (me.bodyPadding !== undefined) 
  {
    if (me.layout.managePadding) 
    {
      body.setStyle('padding', 0);
    } else {
      body.setStyle('padding', this.unitizeBox((me.bodyPadding === true) ? 5 : me.bodyPadding));
    }
  }
  me.initBodyBorder();
}, initBodyBorder: function() {
  var me = this;
  if (me.frame && me.bodyBorder) 
  {
    if (!Ext.isNumber(me.bodyBorder)) 
    {
      me.bodyBorder = 1;
    }
    me.getProtoBody().setStyle('border-width', this.unitizeBox(me.bodyBorder));
  }
}, getCollapsedDockedItems: function() {
  var me = this;
  return me.header === false || me.collapseMode == 'placeholder' ? me.emptyArray : [me.getReExpander()];
}, setBodyStyle: function(style, value) {
  var me = this, body = me.rendered ? me.body : me.getProtoBody();
  if (Ext.isFunction(style)) 
  {
    style = style();
  }
  if (arguments.length == 1) 
  {
    if (Ext.isString(style)) 
    {
      style = Ext.Element.parseStyles(style);
    }
    body.setStyle(style);
  } else {
    body.setStyle(style, value);
  }
  return me;
}, addBodyCls: function(cls) {
  var me = this, body = me.rendered ? me.body : me.getProtoBody();
  body.addCls(cls);
  return me;
}, removeBodyCls: function(cls) {
  var me = this, body = me.rendered ? me.body : me.getProtoBody();
  body.removeCls(cls);
  return me;
}, addUIClsToElement: function(cls) {
  var me = this, result = me.callParent(arguments);
  me.addBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls]);
  return result;
}, removeUIClsFromElement: function(cls) {
  var me = this, result = me.callParent(arguments);
  me.removeBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls]);
  return result;
}, addUIToElement: function() {
  var me = this;
  me.callParent(arguments);
  me.addBodyCls(me.baseCls + '-body-' + me.ui);
}, removeUIFromElement: function() {
  var me = this;
  me.callParent(arguments);
  me.removeBodyCls(me.baseCls + '-body-' + me.ui);
}, getTargetEl: function() {
  return this.body;
}, applyTargetCls: function(targetCls) {
  this.getProtoBody().addCls(targetCls);
}, getRefItems: function(deep) {
  var items = this.callParent(arguments);
  return this.getDockingRefItems(deep, items);
}, setupRenderTpl: function(renderTpl) {
  this.callParent(arguments);
  this.setupDockingRenderTpl(renderTpl);
}}, 0, 0, ["container", "component", "box"], {"container": true, "component": true, "box": true}, 0, [['docking', Ext.container.DockingContainer]], [Ext.panel, 'AbstractPanel'], 0));
;

(Ext.cmd.derive('Ext.panel.Header', Ext.container.Container, {isHeader: true, defaultType: 'tool', indicateDrag: false, weight: -1, componentLayout: 'body', childEls: ['body'], renderTpl: ['<div id="{id}-body" class="{headerCls}-body {baseCls}-body {bodyCls} {bodyTargetCls}', '<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>"', '<tpl if="bodyStyle"> style="{bodyStyle}"</tpl> role="presentation">', '{%this.renderContainer(out,values)%}', '</div>'], headingTpl: ['<span id="{id}-textEl" class="{headerCls}-text {cls}-text {cls}-text-{ui}" unselectable="on"', '<tpl if="headerRole">', ' role="{headerRole}"', '</tpl>', '>{title}</span>'], shrinkWrap: 3, titlePosition: 0, headerCls: Ext.baseCSSPrefix + 'header', initComponent: function() {
  var me = this, hasPosition = me.hasOwnProperty('titlePosition'), items = me.items, titlePosition = hasPosition ? me.titlePosition : (items ? items.length : 0), uiClasses = [me.orientation, me.getDockName()], ownerCt = me.ownerCt;
  me.addEvents('click', 'dblclick');
  me.indicateDragCls = me.headerCls + '-draggable';
  me.title = me.title || '&#160;';
  me.tools = me.tools || [];
  items = me.items = (items ? Ext.Array.slice(items) : []);
  me.orientation = me.orientation || 'horizontal';
  me.dock = (me.dock) ? me.dock : (me.orientation == 'horizontal') ? 'top' : 'left';
  if (ownerCt ? (ownerCt.border === false && !ownerCt.frame) : me.border === false) 
  {
    uiClasses.push(me.orientation + '-noborder');
  }
  me.addClsWithUI(uiClasses);
  me.addCls([me.headerCls, me.headerCls + '-' + me.orientation]);
  if (me.indicateDrag) 
  {
    me.addCls(me.indicateDragCls);
  }
  if (me.iconCls || me.icon || me.glyph) 
  {
    me.initIconCmp();
    if (!hasPosition && !items.length) 
    {
      ++titlePosition;
    }
    items.push(me.iconCmp);
  }
  me.titleCmp = new Ext.Component({ariaRole: 'presentation', focusable: false, noWrap: true, flex: 1, rtl: me.rtl, id: me.id + '_hd', style: me.titleAlign ? ('text-align:' + me.titleAlign) : '', cls: me.headerCls + '-text-container ' + me.baseCls + '-text-container ' + me.baseCls + '-text-container-' + me.ui, renderTpl: me.getTpl('headingTpl'), renderData: {title: me.title, cls: me.baseCls, headerCls: me.headerCls, headerRole: me.headerRole, ui: me.ui}, childEls: ['textEl'], autoEl: {unselectable: 'on'}, listeners: {render: me.onTitleRender, scope: me}});
  me.layout = (me.orientation == 'vertical') ? {type: 'vbox', align: 'center', alignRoundingMethod: 'ceil'} : {type: 'hbox', align: 'middle', alignRoundingMethod: 'floor'};
  Ext.Array.push(items, me.tools);
  me.tools.length = 0;
  me.callParent();
  if (items.length < titlePosition) 
  {
    titlePosition = items.length;
  }
  me.titlePosition = titlePosition;
  me.insert(titlePosition, me.titleCmp);
  me.on({dblclick: me.onDblClick, click: me.onClick, element: 'el', scope: me});
}, setTitlePosition: function(index) {
  var me = this;
  me.titlePosition = index = Math.min(index, me.items.length - 1);
  me.insert(index, me.titleCmp);
}, initIconCmp: function() {
  var me = this, cls = [me.headerCls + '-icon', me.baseCls + '-icon', me.iconCls], cfg;
  if (me.glyph) 
  {
    cls.push(me.baseCls + '-glyph');
  }
  cfg = {focusable: false, src: Ext.BLANK_IMAGE_URL, cls: cls, baseCls: me.baseCls + '-icon', id: me.id + '-iconEl', iconCls: me.iconCls, glyph: me.glyph};
  if (!Ext.isEmpty(me.icon)) 
  {
    delete cfg.iconCls;
    cfg.src = me.icon;
  }
  me.iconCmp = new Ext.Img(cfg);
}, beforeRender: function() {
  this.protoEl.unselectable();
  this.callParent();
}, afterLayout: function() {
  var me = this, frameBR, frameTR, frameTL, xPos;
  if (me.orientation === 'vertical') 
  {
    me.adjustTitlePosition();
    frameTR = me.frameTR;
    if (frameTR) 
    {
      frameBR = me.frameBR;
      frameTL = me.frameTL;
      xPos = (me.getWidth() - frameTR.getPadding('r') - ((frameTL) ? frameTL.getPadding('l') : me.el.getBorderWidth('l'))) + 'px';
      frameBR.setStyle('background-position-x', xPos);
      frameTR.setStyle('background-position-x', xPos);
    }
    if (Ext.isIE7 && Ext.isStrict && me.frame) 
    {
      me.el.repaint();
    }
  }
}, beforeLayout: function() {
  this.callParent();
  this.syncBeforeAfterTitleClasses();
}, adjustTitlePosition: function() {
  var titleCmp = this.titleCmp, titleEl;
  if (!Ext.isIE9m && titleCmp) 
  {
    titleEl = titleCmp.el;
    titleEl.setStyle('left', titleEl.getWidth() + 'px');
  }
}, onTitleRender: function() {
  if (this.orientation === 'vertical') 
  {
    this.titleCmp.el.setVertical(90);
  }
}, addUIClsToElement: function(cls) {
  var me = this, result = me.callParent(arguments), classes = [me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls], array, i;
  if (me.bodyCls) 
  {
    array = me.bodyCls.split(' ');
    for (i = 0; i < classes.length; i++) 
      {
        if (!Ext.Array.contains(array, classes[i])) 
        {
          array.push(classes[i]);
        }
      }
    me.bodyCls = array.join(' ');
  } else {
    me.bodyCls = classes.join(' ');
  }
  return result;
}, removeUIClsFromElement: function(cls) {
  var me = this, result = me.callParent(arguments), classes = [me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls], array, i;
  if (me.bodyCls) 
  {
    array = me.bodyCls.split(' ');
    for (i = 0; i < classes.length; i++) 
      {
        Ext.Array.remove(array, classes[i]);
      }
    me.bodyCls = array.join(' ');
  }
  return result;
}, addUIToElement: function() {
  var me = this, array, cls;
  me.callParent(arguments);
  cls = me.baseCls + '-body-' + me.ui;
  if (me.rendered) 
  {
    if (me.bodyCls) 
    {
      me.body.addCls(me.bodyCls);
    } else {
      me.body.addCls(cls);
    }
  } else {
    if (me.bodyCls) 
    {
      array = me.bodyCls.split(' ');
      if (!Ext.Array.contains(array, cls)) 
      {
        array.push(cls);
      }
      me.bodyCls = array.join(' ');
    } else {
      me.bodyCls = cls;
    }
  }
  if (me.titleCmp && me.titleCmp.rendered) 
  {
    me.titleCmp.addCls(me.baseCls + '-text-container-' + me.ui);
  }
}, removeUIFromElement: function() {
  var me = this, array, cls;
  me.callParent(arguments);
  cls = me.baseCls + '-body-' + me.ui;
  if (me.rendered) 
  {
    if (me.bodyCls) 
    {
      me.body.removeCls(me.bodyCls);
    } else {
      me.body.removeCls(cls);
    }
  } else {
    if (me.bodyCls) 
    {
      array = me.bodyCls.split(' ');
      Ext.Array.remove(array, cls);
      me.bodyCls = array.join(' ');
    } else {
      me.bodyCls = cls;
    }
  }
  if (me.titleCmp && me.titleCmp.rendered) 
  {
    me.titleCmp.removeCls(me.baseCls + '-text-container-' + me.ui);
  }
}, onClick: function(e) {
  this.fireClickEvent('click', e);
}, onDblClick: function(e) {
  this.fireClickEvent('dblclick', e);
}, fireClickEvent: function(type, e) {
  var toolCls = '.' + Ext.panel.Tool.prototype.baseCls;
  if (!e.getTarget(toolCls)) 
  {
    this.fireEvent(type, this, e);
  }
}, getFocusEl: function() {
  return this.el;
}, getTargetEl: function() {
  return this.body || this.frameBody || this.el;
}, applyTargetCls: function(targetCls) {
  this.bodyTargetCls = targetCls;
}, setTitle: function(title) {
  var me = this, titleCmp = me.titleCmp;
  me.title = title;
  if (titleCmp.rendered) 
  {
    titleCmp.textEl.update(me.title || '&#160;');
    titleCmp.updateLayout();
  } else {
    me.titleCmp.on({render: function() {
  me.setTitle(title);
}, single: true});
  }
}, getMinWidth: function() {
  var me = this, textEl = me.titleCmp.textEl.dom, result, tools = me.tools, l, i;
  textEl.style.display = 'inline';
  result = textEl.offsetWidth;
  textEl.style.display = '';
  if (tools && (l = tools.length)) 
  {
    for (i = 0; i < l; i++) 
      {
        if (tools[i].el) 
        {
          result += tools[i].el.dom.offsetWidth;
        }
      }
  }
  if (me.iconCmp) 
  {
    result += me.iconCmp.el.dom.offsetWidth;
  }
  return result + 10;
}, setIconCls: function(cls) {
  var me = this, isEmpty = !cls || !cls.length, iconCmp = me.iconCmp;
  me.iconCls = cls;
  if (!me.iconCmp && !isEmpty) 
  {
    me.initIconCmp();
    me.insert(0, me.iconCmp);
  } else if (iconCmp) 
  {
    if (isEmpty) 
    {
      me.iconCmp.destroy();
      delete me.iconCmp;
    } else {
      iconCmp.removeCls(iconCmp.iconCls);
      iconCmp.addCls(cls);
      iconCmp.iconCls = cls;
    }
  }
}, setIcon: function(icon) {
  var me = this, isEmpty = !icon || !icon.length, iconCmp = me.iconCmp;
  me.icon = icon;
  if (!me.iconCmp && !isEmpty) 
  {
    me.initIconCmp();
    me.insert(0, me.iconCmp);
  } else if (iconCmp) 
  {
    if (isEmpty) 
    {
      me.iconCmp.destroy();
      delete me.iconCmp;
    } else {
      iconCmp.setSrc(me.icon);
    }
  }
}, setGlyph: function(glyph) {
  var me = this, iconCmp = me.iconCmp;
  if (!me.iconCmp) 
  {
    me.initIconCmp();
    me.insert(0, me.iconCmp);
  } else if (iconCmp) 
  {
    if (glyph) 
    {
      me.iconCmp.setGlyph(glyph);
    } else {
      me.iconCmp.destroy();
      delete me.iconCmp;
    }
  }
}, getTools: function() {
  return this.tools.slice();
}, addTool: function(tool) {
  this.add(Ext.ComponentManager.create(tool, 'tool'));
}, syncBeforeAfterTitleClasses: function(force) {
  var me = this, items = me.items, childItems = items.items, titlePosition = me.titlePosition, itemCount = childItems.length, itemGeneration = items.generation, syncGen = me.syncBeforeAfterGen, afterCls, beforeCls, i, item;
  if (!force && (syncGen === itemGeneration)) 
  {
    return;
  }
  me.syncBeforeAfterGen = itemGeneration;
  for (i = 0; i < itemCount; ++i) 
    {
      item = childItems[i];
      afterCls = item.afterTitleCls || (item.afterTitleCls = item.baseCls + '-after-title');
      beforeCls = item.beforeTitleCls || (item.beforeTitleCls = item.baseCls + '-before-title');
      if (!me.title || i < titlePosition) 
      {
        if (syncGen) 
        {
          item.removeCls(afterCls);
        }
        item.addCls(beforeCls);
      } else if (i > titlePosition) 
      {
        if (syncGen) 
        {
          item.removeCls(beforeCls);
        }
        item.addCls(afterCls);
      }
    }
}, onAdd: function(component, index) {
  var tools = this.tools;
  this.callParent(arguments);
  if (component.isTool) 
  {
    tools.push(component);
    tools[component.type] = component;
  }
}, initRenderData: function() {
  return Ext.applyIf(this.callParent(), {bodyCls: this.bodyCls, bodyTargetCls: this.bodyTargetCls, headerCls: this.headerCls});
}, getDockName: function() {
  return this.dock;
}, getFramingInfoCls: function() {
  var me = this, cls = me.callParent(), owner = me.ownerCt;
  if (!me.expanding && owner && (owner.collapsed || me.isCollapsedExpander)) 
  {
    cls += '-' + owner.collapsedCls;
  }
  return cls + '-' + me.dock;
}}, 0, ["header"], ["container", "component", "header", "box"], {"container": true, "component": true, "header": true, "box": true}, ["widget.header"], 0, [Ext.panel, 'Header'], 0));
;

(Ext.cmd.derive('Ext.dd.DragDrop', Ext.Base, {constructor: function(id, sGroup, config) {
  if (id) 
  {
    this.init(id, sGroup, config);
  }
}, id: null, config: null, dragElId: null, handleElId: null, invalidHandleTypes: null, invalidHandleIds: null, invalidHandleClasses: null, startPageX: 0, startPageY: 0, groups: null, locked: false, lock: function() {
  this.locked = true;
}, moveOnly: false, unlock: function() {
  this.locked = false;
}, isTarget: true, padding: null, _domRef: null, __ygDragDrop: true, constrainX: false, constrainY: false, minX: 0, maxX: 0, minY: 0, maxY: 0, maintainOffset: false, xTicks: null, yTicks: null, primaryButtonOnly: true, available: false, hasOuterHandles: false, b4StartDrag: function(x, y) {
}, startDrag: function(x, y) {
}, b4Drag: function(e) {
}, onDrag: function(e) {
}, onDragEnter: function(e, id) {
}, b4DragOver: function(e) {
}, onDragOver: function(e, id) {
}, b4DragOut: function(e) {
}, onDragOut: function(e, id) {
}, b4DragDrop: function(e) {
}, onDragDrop: function(e, id) {
}, onInvalidDrop: function(e) {
}, b4EndDrag: function(e) {
}, endDrag: function(e) {
}, b4MouseDown: function(e) {
}, onMouseDown: function(e) {
}, onMouseUp: function(e) {
}, onAvailable: function() {
}, defaultPadding: {left: 0, right: 0, top: 0, bottom: 0}, constrainTo: function(constrainTo, pad, inContent) {
  if (Ext.isNumber(pad)) 
  {
    pad = {left: pad, right: pad, top: pad, bottom: pad};
  }
  pad = pad || this.defaultPadding;
  var b = Ext.get(this.getEl()).getBox(), ce = Ext.get(constrainTo), s = ce.getScroll(), c, cd = ce.dom, xy, topSpace, leftSpace;
  if (cd == document.body) 
  {
    c = {x: s.left, y: s.top, width: Ext.Element.getViewWidth(), height: Ext.Element.getViewHeight()};
  } else {
    xy = ce.getXY();
    c = {x: xy[0], y: xy[1], width: cd.clientWidth, height: cd.clientHeight};
  }
  topSpace = b.y - c.y;
  leftSpace = b.x - c.x;
  this.resetConstraints();
  this.setXConstraint(leftSpace - (pad.left || 0), c.width - leftSpace - b.width - (pad.right || 0), this.xTickSize);
  this.setYConstraint(topSpace - (pad.top || 0), c.height - topSpace - b.height - (pad.bottom || 0), this.yTickSize);
}, getEl: function() {
  if (!this._domRef) 
  {
    this._domRef = Ext.getDom(this.id);
  }
  return this._domRef;
}, getDragEl: function() {
  return Ext.getDom(this.dragElId);
}, init: function(id, sGroup, config) {
  this.initTarget(id, sGroup, config);
  Ext.EventManager.on(this.id, "mousedown", this.handleMouseDown, this);
}, initTarget: function(id, sGroup, config) {
  this.config = config || {};
  this.DDMInstance = Ext.dd.DragDropManager;
  this.groups = {};
  if (typeof id !== "string") 
  {
    id = Ext.id(id);
  }
  this.id = id;
  this.addToGroup((sGroup) ? sGroup : "default");
  this.handleElId = id;
  this.setDragElId(id);
  this.invalidHandleTypes = {A: "A"};
  this.invalidHandleIds = {};
  this.invalidHandleClasses = [];
  this.applyConfig();
  this.handleOnAvailable();
}, applyConfig: function() {
  this.padding = this.config.padding || [0, 0, 0, 0];
  this.isTarget = (this.config.isTarget !== false);
  this.maintainOffset = (this.config.maintainOffset);
  this.primaryButtonOnly = (this.config.primaryButtonOnly !== false);
}, handleOnAvailable: function() {
  this.available = true;
  this.resetConstraints();
  this.onAvailable();
}, setPadding: function(iTop, iRight, iBot, iLeft) {
  if (!iRight && 0 !== iRight) 
  {
    this.padding = [iTop, iTop, iTop, iTop];
  } else if (!iBot && 0 !== iBot) 
  {
    this.padding = [iTop, iRight, iTop, iRight];
  } else {
    this.padding = [iTop, iRight, iBot, iLeft];
  }
}, setInitPosition: function(diffX, diffY) {
  var el = this.getEl(), dx, dy, p;
  if (!this.DDMInstance.verifyEl(el)) 
  {
    return;
  }
  dx = diffX || 0;
  dy = diffY || 0;
  p = Ext.Element.getXY(el);
  this.initPageX = p[0] - dx;
  this.initPageY = p[1] - dy;
  this.lastPageX = p[0];
  this.lastPageY = p[1];
  this.setStartPosition(p);
}, setStartPosition: function(pos) {
  var p = pos || Ext.Element.getXY(this.getEl());
  this.deltaSetXY = null;
  this.startPageX = p[0];
  this.startPageY = p[1];
}, addToGroup: function(sGroup) {
  this.groups[sGroup] = true;
  this.DDMInstance.regDragDrop(this, sGroup);
}, removeFromGroup: function(sGroup) {
  if (this.groups[sGroup]) 
  {
    delete this.groups[sGroup];
  }
  this.DDMInstance.removeDDFromGroup(this, sGroup);
}, setDragElId: function(id) {
  this.dragElId = id;
}, setHandleElId: function(id) {
  if (typeof id !== "string") 
  {
    id = Ext.id(id);
  }
  this.handleElId = id;
  this.DDMInstance.regHandle(this.id, id);
}, setOuterHandleElId: function(id) {
  if (typeof id !== "string") 
  {
    id = Ext.id(id);
  }
  Ext.EventManager.on(id, "mousedown", this.handleMouseDown, this);
  this.setHandleElId(id);
  this.hasOuterHandles = true;
}, unreg: function() {
  var me = this;
  Ext.EventManager.un(me.id, "mousedown", me.handleMouseDown, me);
  me._domRef = null;
  me.DDMInstance._remove(me, me.autoGroup);
}, destroy: function() {
  this.unreg();
  this.isDestroyed = true;
}, isLocked: function() {
  return (this.DDMInstance.isLocked() || this.locked);
}, handleMouseDown: function(e, oDD) {
  var me = this;
  if ((me.primaryButtonOnly && e.button != 0) || me.isLocked()) 
  {
    return;
  }
  me.DDMInstance.refreshCache(me.groups);
  if (me.hasOuterHandles || me.DDMInstance.isOverTarget(e.getPoint(), me)) 
  {
    if (me.clickValidator(e)) 
    {
      me.setStartPosition();
      me.b4MouseDown(e);
      me.onMouseDown(e);
      me.DDMInstance.handleMouseDown(e, me);
      me.DDMInstance.stopEvent(e);
    }
  }
}, clickValidator: function(e) {
  var target = e.getTarget();
  return (this.isValidHandleChild(target) && (this.id == this.handleElId || this.DDMInstance.handleWasClicked(target, this.id)));
}, addInvalidHandleType: function(tagName) {
  var type = tagName.toUpperCase();
  this.invalidHandleTypes[type] = type;
}, addInvalidHandleId: function(id) {
  if (typeof id !== "string") 
  {
    id = Ext.id(id);
  }
  this.invalidHandleIds[id] = id;
}, addInvalidHandleClass: function(cssClass) {
  this.invalidHandleClasses.push(cssClass);
}, removeInvalidHandleType: function(tagName) {
  var type = tagName.toUpperCase();
  delete this.invalidHandleTypes[type];
}, removeInvalidHandleId: function(id) {
  if (typeof id !== "string") 
  {
    id = Ext.id(id);
  }
  delete this.invalidHandleIds[id];
}, removeInvalidHandleClass: function(cssClass) {
  for (var i = 0, len = this.invalidHandleClasses.length; i < len; ++i) 
    {
      if (this.invalidHandleClasses[i] == cssClass) 
      {
        delete this.invalidHandleClasses[i];
      }
    }
}, isValidHandleChild: function(node) {
  var valid = true, nodeName, i, len;
  try {
    nodeName = node.nodeName.toUpperCase();
  }  catch (e) {
  nodeName = node.nodeName;
}
  valid = valid && !this.invalidHandleTypes[nodeName];
  valid = valid && !this.invalidHandleIds[node.id];
  for (i = 0 , len = this.invalidHandleClasses.length; valid && i < len; ++i) 
    {
      valid = !Ext.fly(node).hasCls(this.invalidHandleClasses[i]);
    }
  return valid;
}, setXTicks: function(iStartX, iTickSize) {
  this.xTicks = [];
  this.xTickSize = iTickSize;
  var tickMap = {}, i;
  for (i = this.initPageX; i >= this.minX; i = i - iTickSize) 
    {
      if (!tickMap[i]) 
      {
        this.xTicks[this.xTicks.length] = i;
        tickMap[i] = true;
      }
    }
  for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) 
    {
      if (!tickMap[i]) 
      {
        this.xTicks[this.xTicks.length] = i;
        tickMap[i] = true;
      }
    }
  Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort);
}, setYTicks: function(iStartY, iTickSize) {
  this.yTicks = [];
  this.yTickSize = iTickSize;
  var tickMap = {}, i;
  for (i = this.initPageY; i >= this.minY; i = i - iTickSize) 
    {
      if (!tickMap[i]) 
      {
        this.yTicks[this.yTicks.length] = i;
        tickMap[i] = true;
      }
    }
  for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) 
    {
      if (!tickMap[i]) 
      {
        this.yTicks[this.yTicks.length] = i;
        tickMap[i] = true;
      }
    }
  Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort);
}, setXConstraint: function(iLeft, iRight, iTickSize) {
  this.leftConstraint = iLeft;
  this.rightConstraint = iRight;
  this.minX = this.initPageX - iLeft;
  this.maxX = this.initPageX + iRight;
  if (iTickSize) 
  {
    this.setXTicks(this.initPageX, iTickSize);
  }
  this.constrainX = true;
}, clearConstraints: function() {
  this.constrainX = false;
  this.constrainY = false;
  this.clearTicks();
}, clearTicks: function() {
  this.xTicks = null;
  this.yTicks = null;
  this.xTickSize = 0;
  this.yTickSize = 0;
}, setYConstraint: function(iUp, iDown, iTickSize) {
  this.topConstraint = iUp;
  this.bottomConstraint = iDown;
  this.minY = this.initPageY - iUp;
  this.maxY = this.initPageY + iDown;
  if (iTickSize) 
  {
    this.setYTicks(this.initPageY, iTickSize);
  }
  this.constrainY = true;
}, resetConstraints: function() {
  if (this.initPageX || this.initPageX === 0) 
  {
    var dx = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0, dy = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;
    this.setInitPosition(dx, dy);
  } else {
    this.setInitPosition();
  }
  if (this.constrainX) 
  {
    this.setXConstraint(this.leftConstraint, this.rightConstraint, this.xTickSize);
  }
  if (this.constrainY) 
  {
    this.setYConstraint(this.topConstraint, this.bottomConstraint, this.yTickSize);
  }
}, getTick: function(val, tickArray) {
  if (!tickArray) 
  {
    return val;
  } else if (tickArray[0] >= val) 
  {
    return tickArray[0];
  } else {
    var i, len, next, diff1, diff2;
    for (i = 0 , len = tickArray.length; i < len; ++i) 
      {
        next = i + 1;
        if (tickArray[next] && tickArray[next] >= val) 
        {
          diff1 = val - tickArray[i];
          diff2 = tickArray[next] - val;
          return (diff2 > diff1) ? tickArray[i] : tickArray[next];
        }
      }
    return tickArray[tickArray.length - 1];
  }
}, toString: function() {
  return ("DragDrop " + this.id);
}}, 3, 0, 0, 0, 0, 0, [Ext.dd, 'DragDrop'], 0));
;

(Ext.cmd.derive('Ext.dd.DD', Ext.dd.DragDrop, {constructor: function(id, sGroup, config) {
  if (id) 
  {
    this.init(id, sGroup, config);
  }
}, scroll: true, autoOffset: function(iPageX, iPageY) {
  var x = iPageX - this.startPageX, y = iPageY - this.startPageY;
  this.setDelta(x, y);
}, setDelta: function(iDeltaX, iDeltaY) {
  this.deltaX = iDeltaX;
  this.deltaY = iDeltaY;
}, setDragElPos: function(iPageX, iPageY) {
  var el = this.getDragEl();
  this.alignElWithMouse(el, iPageX, iPageY);
}, alignElWithMouse: function(el, iPageX, iPageY) {
  var oCoord = this.getTargetCoord(iPageX, iPageY), fly = el.dom ? el : Ext.fly(el, '_dd'), elSize = fly.getSize(), EL = Ext.Element, vpSize, aCoord, newLeft, newTop;
  if (!this.deltaSetXY) 
  {
    vpSize = this.cachedViewportSize = {width: EL.getDocumentWidth(), height: EL.getDocumentHeight()};
    aCoord = [Math.max(0, Math.min(oCoord.x, vpSize.width - elSize.width)), Math.max(0, Math.min(oCoord.y, vpSize.height - elSize.height))];
    fly.setXY(aCoord);
    newLeft = this.getLocalX(fly);
    newTop = fly.getLocalY();
    this.deltaSetXY = [newLeft - oCoord.x, newTop - oCoord.y];
  } else {
    vpSize = this.cachedViewportSize;
    this.setLocalXY(fly, Math.max(0, Math.min(oCoord.x + this.deltaSetXY[0], vpSize.width - elSize.width)), Math.max(0, Math.min(oCoord.y + this.deltaSetXY[1], vpSize.height - elSize.height)));
  }
  this.cachePosition(oCoord.x, oCoord.y);
  this.autoScroll(oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
  return oCoord;
}, cachePosition: function(iPageX, iPageY) {
  if (iPageX) 
  {
    this.lastPageX = iPageX;
    this.lastPageY = iPageY;
  } else {
    var aCoord = Ext.Element.getXY(this.getEl());
    this.lastPageX = aCoord[0];
    this.lastPageY = aCoord[1];
  }
}, autoScroll: function(x, y, h, w) {
  if (this.scroll) 
  {
    var clientH = Ext.Element.getViewHeight(), clientW = Ext.Element.getViewWidth(), st = this.DDMInstance.getScrollTop(), sl = this.DDMInstance.getScrollLeft(), bot = h + y, right = w + x, toBot = (clientH + st - y - this.deltaY), toRight = (clientW + sl - x - this.deltaX), thresh = 40, scrAmt = (document.all) ? 80 : 30;
    if (bot > clientH && toBot < thresh) 
    {
      window.scrollTo(sl, st + scrAmt);
    }
    if (y < st && st > 0 && y - st < thresh) 
    {
      window.scrollTo(sl, st - scrAmt);
    }
    if (right > clientW && toRight < thresh) 
    {
      window.scrollTo(sl + scrAmt, st);
    }
    if (x < sl && sl > 0 && x - sl < thresh) 
    {
      window.scrollTo(sl - scrAmt, st);
    }
  }
}, getTargetCoord: function(iPageX, iPageY) {
  var x = iPageX - this.deltaX, y = iPageY - this.deltaY;
  if (this.constrainX) 
  {
    if (x < this.minX) 
    {
      x = this.minX;
    }
    if (x > this.maxX) 
    {
      x = this.maxX;
    }
  }
  if (this.constrainY) 
  {
    if (y < this.minY) 
    {
      y = this.minY;
    }
    if (y > this.maxY) 
    {
      y = this.maxY;
    }
  }
  x = this.getTick(x, this.xTicks);
  y = this.getTick(y, this.yTicks);
  return {x: x, y: y};
}, applyConfig: function() {
  this.callParent();
  this.scroll = (this.config.scroll !== false);
}, b4MouseDown: function(e) {
  this.autoOffset(e.getPageX(), e.getPageY());
}, b4Drag: function(e) {
  this.setDragElPos(e.getPageX(), e.getPageY());
}, toString: function() {
  return ("DD " + this.id);
}, getLocalX: function(el) {
  return el.getLocalX();
}, setLocalXY: function(el, x, y) {
  el.setLocalXY(x, y);
}}, 3, 0, 0, 0, 0, 0, [Ext.dd, 'DD'], 0));
;

(Ext.cmd.derive('Ext.dd.DDProxy', Ext.dd.DD, {statics: {dragElId: "ygddfdiv"}, constructor: function(id, sGroup, config) {
  if (id) 
  {
    this.init(id, sGroup, config);
    this.initFrame();
  }
}, resizeFrame: true, centerFrame: false, createFrame: function() {
  var self = this, body = document.body, div, s;
  if (!body || !body.firstChild) 
  {
    setTimeout(function() {
  self.createFrame();
}, 50);
    return;
  }
  div = this.getDragEl();
  if (!div) 
  {
    div = document.createElement("div");
    div.id = this.dragElId;
    div.setAttribute('role', 'presentation');
    s = div.style;
    s.position = "absolute";
    s.visibility = "hidden";
    s.cursor = "move";
    s.border = "2px solid #aaa";
    s.zIndex = 999;
    body.insertBefore(div, body.firstChild);
  }
}, initFrame: function() {
  this.createFrame();
}, applyConfig: function() {
  this.callParent();
  this.resizeFrame = (this.config.resizeFrame !== false);
  this.centerFrame = (this.config.centerFrame);
  this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId);
}, showFrame: function(iPageX, iPageY) {
  var el = this.getEl(), dragEl = this.getDragEl(), s = dragEl.style;
  this._resizeProxy();
  if (this.centerFrame) 
  {
    this.setDelta(Math.round(parseInt(s.width, 10) / 2), Math.round(parseInt(s.height, 10) / 2));
  }
  this.setDragElPos(iPageX, iPageY);
  Ext.fly(dragEl).show();
}, _resizeProxy: function() {
  if (this.resizeFrame) 
  {
    var el = this.getEl();
    Ext.fly(this.getDragEl()).setSize(el.offsetWidth, el.offsetHeight);
  }
}, b4MouseDown: function(e) {
  var x = e.getPageX(), y = e.getPageY();
  this.autoOffset(x, y);
  this.setDragElPos(x, y);
}, b4StartDrag: function(x, y) {
  this.showFrame(x, y);
}, b4EndDrag: function(e) {
  Ext.fly(this.getDragEl()).hide();
}, endDrag: function(e) {
  var lel = this.getEl(), del = this.getDragEl();
  del.style.visibility = "";
  this.beforeMove();
  lel.style.visibility = "hidden";
  Ext.dd.DDM.moveToEl(lel, del);
  del.style.visibility = "hidden";
  lel.style.visibility = "";
  this.afterDrag();
}, beforeMove: function() {
}, afterDrag: function() {
}, toString: function() {
  return ("DDProxy " + this.id);
}}, 3, 0, 0, 0, 0, 0, [Ext.dd, 'DDProxy'], 0));
;

(Ext.cmd.derive('Ext.dd.StatusProxy', Ext.Component, {animRepair: false, childEls: ['ghost'], renderTpl: ['<div class="' + Ext.baseCSSPrefix + 'dd-drop-icon" role="presentation"></div>' + '<div id="{id}-ghost" class="' + Ext.baseCSSPrefix + 'dd-drag-ghost" role="presentation"></div>'], repairCls: Ext.baseCSSPrefix + 'dd-drag-repair', ariaRole: 'presentation', constructor: function(config) {
  var me = this;
  config = config || {};
  Ext.apply(me, {hideMode: 'visibility', hidden: true, floating: true, id: me.id || Ext.id(), cls: Ext.baseCSSPrefix + 'dd-drag-proxy ' + this.dropNotAllowed, shadow: config.shadow || false, renderTo: Ext.getDetachedBody()});
  me.callParent(arguments);
  this.dropStatus = this.dropNotAllowed;
}, dropAllowed: Ext.baseCSSPrefix + 'dd-drop-ok', dropNotAllowed: Ext.baseCSSPrefix + 'dd-drop-nodrop', setStatus: function(cssClass) {
  cssClass = cssClass || this.dropNotAllowed;
  if (this.dropStatus != cssClass) 
  {
    this.el.replaceCls(this.dropStatus, cssClass);
    this.dropStatus = cssClass;
  }
}, reset: function(clearGhost) {
  var me = this, clsPrefix = Ext.baseCSSPrefix + 'dd-drag-proxy ';
  me.el.replaceCls(clsPrefix + me.dropAllowed, clsPrefix + me.dropNotAllowed);
  me.dropStatus = me.dropNotAllowed;
  if (clearGhost) 
  {
    me.ghost.update('');
  }
}, update: function(html) {
  if (typeof html == "string") 
  {
    this.ghost.update(html);
  } else {
    this.ghost.update("");
    html.style.margin = "0";
    this.ghost.dom.appendChild(html);
  }
  var el = this.ghost.dom.firstChild;
  if (el) 
  {
    Ext.fly(el).setStyle('float', 'none');
  }
}, getGhost: function() {
  return this.ghost;
}, hide: function(clear) {
  this.callParent();
  if (clear) 
  {
    this.reset(true);
  }
}, stop: function() {
  if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) 
  {
    this.anim.stop();
  }
}, sync: function() {
  this.el.sync();
}, repair: function(xy, callback, scope) {
  var me = this;
  me.callback = callback;
  me.scope = scope;
  if (xy && me.animRepair !== false) 
  {
    me.el.addCls(me.repairCls);
    me.el.hideUnders(true);
    me.anim = me.el.animate({duration: me.repairDuration || 500, easing: 'ease-out', to: {x: xy[0], y: xy[1]}, stopAnimation: true, callback: me.afterRepair, scope: me});
  } else {
    me.afterRepair();
  }
}, afterRepair: function() {
  var me = this;
  me.hide(true);
  me.el.removeCls(me.repairCls);
  if (typeof me.callback == "function") 
  {
    me.callback.call(me.scope || me);
  }
  delete me.callback;
  delete me.scope;
}}, 1, 0, ["component", "box"], {"component": true, "box": true}, 0, 0, [Ext.dd, 'StatusProxy'], 0));
;

(Ext.cmd.derive('Ext.dd.DragSource', Ext.dd.DDProxy, {dropAllowed: Ext.baseCSSPrefix + 'dd-drop-ok', dropNotAllowed: Ext.baseCSSPrefix + 'dd-drop-nodrop', animRepair: true, repairHighlightColor: 'c3daf9', constructor: function(el, config) {
  this.el = Ext.get(el);
  if (!this.dragData) 
  {
    this.dragData = {};
  }
  Ext.apply(this, config);
  if (!this.proxy) 
  {
    this.proxy = new Ext.dd.StatusProxy({id: this.el.id + '-drag-status-proxy', animRepair: this.animRepair});
  }
  this.callParent([this.el.dom, this.ddGroup || this.group, {dragElId: this.proxy.id, resizeFrame: false, isTarget: false, scroll: this.scroll === true}]);
  this.dragging = false;
}, getDragData: function(e) {
  return this.dragData;
}, onDragEnter: function(e, id) {
  var target = Ext.dd.DragDropManager.getDDById(id), status;
  this.cachedTarget = target;
  if (this.beforeDragEnter(target, e, id) !== false) 
  {
    if (target.isNotifyTarget) 
    {
      status = target.notifyEnter(this, e, this.dragData);
      this.proxy.setStatus(status);
    } else {
      this.proxy.setStatus(this.dropAllowed);
    }
    if (this.afterDragEnter) 
    {
      this.afterDragEnter(target, e, id);
    }
  }
}, beforeDragEnter: function(target, e, id) {
  return true;
}, onDragOver: function(e, id) {
  var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id), status;
  if (this.beforeDragOver(target, e, id) !== false) 
  {
    if (target.isNotifyTarget) 
    {
      status = target.notifyOver(this, e, this.dragData);
      this.proxy.setStatus(status);
    }
    if (this.afterDragOver) 
    {
      this.afterDragOver(target, e, id);
    }
  }
}, beforeDragOver: function(target, e, id) {
  return true;
}, onDragOut: function(e, id) {
  var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
  if (this.beforeDragOut(target, e, id) !== false) 
  {
    if (target.isNotifyTarget) 
    {
      target.notifyOut(this, e, this.dragData);
    }
    this.proxy.reset();
    if (this.afterDragOut) 
    {
      this.afterDragOut(target, e, id);
    }
  }
  this.cachedTarget = null;
}, beforeDragOut: function(target, e, id) {
  return true;
}, onDragDrop: function(e, id) {
  var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
  if (this.beforeDragDrop(target, e, id) !== false) 
  {
    if (target.isNotifyTarget) 
    {
      if (target.notifyDrop(this, e, this.dragData) !== false) 
      {
        this.onValidDrop(target, e, id);
      } else {
        this.onInvalidDrop(target, e, id);
      }
    } else {
      this.onValidDrop(target, e, id);
    }
    if (this.afterDragDrop) 
    {
      this.afterDragDrop(target, e, id);
    }
  }
  delete this.cachedTarget;
}, beforeDragDrop: function(target, e, id) {
  return true;
}, onValidDrop: function(target, e, id) {
  this.hideProxy();
  if (this.afterValidDrop) 
  {
    this.afterValidDrop(target, e, id);
  }
}, getRepairXY: function(e, data) {
  return this.el.getXY();
}, onInvalidDrop: function(target, e, id) {
  var me = this;
  if (!e) 
  {
    e = target;
    target = null;
    id = e.getTarget().id;
  }
  if (me.beforeInvalidDrop(target, e, id) !== false) 
  {
    if (me.cachedTarget) 
    {
      if (me.cachedTarget.isNotifyTarget) 
      {
        me.cachedTarget.notifyOut(me, e, me.dragData);
      }
      me.cacheTarget = null;
    }
    me.proxy.repair(me.getRepairXY(e, me.dragData), me.afterRepair, me);
    if (me.afterInvalidDrop) 
    {
      me.afterInvalidDrop(e, id);
    }
  }
}, afterRepair: function() {
  var me = this;
  if (Ext.enableFx) 
  {
    me.el.highlight(me.repairHighlightColor);
  }
  me.dragging = false;
}, beforeInvalidDrop: function(target, e, id) {
  return true;
}, handleMouseDown: function(e) {
  if (this.dragging) 
  {
    return;
  }
  var data = this.getDragData(e);
  if (data && this.onBeforeDrag(data, e) !== false) 
  {
    this.dragData = data;
    this.proxy.stop();
    this.callParent(arguments);
  }
}, onBeforeDrag: function(data, e) {
  return true;
}, onStartDrag: Ext.emptyFn, alignElWithMouse: function() {
  this.proxy.ensureAttachedToBody(true);
  return this.callParent(arguments);
}, startDrag: function(x, y) {
  this.proxy.reset();
  this.proxy.hidden = false;
  this.dragging = true;
  this.proxy.update("");
  this.onInitDrag(x, y);
  this.proxy.show();
}, onInitDrag: function(x, y) {
  var clone = this.el.dom.cloneNode(true);
  clone.id = Ext.id();
  this.proxy.update(clone);
  this.onStartDrag(x, y);
  return true;
}, getProxy: function() {
  return this.proxy;
}, hideProxy: function() {
  this.proxy.hide();
  this.proxy.reset(true);
  this.dragging = false;
}, triggerCacheRefresh: function() {
  Ext.dd.DDM.refreshCache(this.groups);
}, b4EndDrag: function(e) {
}, endDrag: function(e) {
  this.onEndDrag(this.dragData, e);
}, onEndDrag: function(data, e) {
}, autoOffset: function(x, y) {
  this.setDelta(-12, -20);
}, destroy: function() {
  this.callParent();
  Ext.destroy(this.proxy);
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'DragSource'], 0));
;

(Ext.cmd.derive('Ext.panel.Proxy', Ext.Base, {alternateClassName: 'Ext.dd.PanelProxy', moveOnDrag: true, constructor: function(panel, config) {
  var me = this;
  me.panel = panel;
  me.id = me.panel.id + '-ddproxy';
  Ext.apply(me, config);
}, insertProxy: true, setStatus: Ext.emptyFn, reset: Ext.emptyFn, update: Ext.emptyFn, stop: Ext.emptyFn, sync: Ext.emptyFn, getEl: function() {
  return this.ghost.el;
}, getGhost: function() {
  return this.ghost;
}, getProxy: function() {
  return this.proxy;
}, hide: function() {
  var me = this;
  if (me.ghost) 
  {
    if (me.proxy) 
    {
      me.proxy.remove();
      delete me.proxy;
    }
    me.panel.unghost(null, me.moveOnDrag);
    delete me.ghost;
  }
}, show: function() {
  var me = this, panelSize;
  if (!me.ghost) 
  {
    panelSize = me.panel.getSize();
    me.panel.el.setVisibilityMode(Ext.Element.DISPLAY);
    me.ghost = me.panel.ghost();
    if (me.insertProxy) 
    {
      me.proxy = me.panel.el.insertSibling({role: 'presentation', cls: Ext.baseCSSPrefix + 'panel-dd-spacer'});
      me.proxy.setSize(panelSize);
    }
  }
}, repair: function(xy, callback, scope) {
  this.hide();
  Ext.callback(callback, scope || this);
}, moveProxy: function(parentNode, before) {
  if (this.proxy) 
  {
    parentNode.insertBefore(this.proxy.dom, before);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.panel, 'Proxy', Ext.dd, 'PanelProxy'], 0));
;

(Ext.cmd.derive('Ext.panel.DD', Ext.dd.DragSource, {constructor: function(panel, cfg) {
  var me = this;
  me.panel = panel;
  me.dragData = {panel: panel};
  me.panelProxy = new Ext.panel.Proxy(panel, cfg);
  me.proxy = me.panelProxy.proxy;
  me.callParent([panel.el, cfg]);
  me.setupEl(panel);
}, setupEl: function(panel) {
  var me = this, header = panel.header, el = panel.body;
  if (header) 
  {
    me.setHandleElId(header.id);
    el = header.el;
  }
  if (el) 
  {
    el.setStyle('cursor', 'move');
    me.scroll = false;
  } else {
    panel.on('boxready', me.setupEl, me, {single: true});
  }
}, showFrame: Ext.emptyFn, startDrag: Ext.emptyFn, b4StartDrag: function(x, y) {
  this.panelProxy.show();
}, b4MouseDown: function(e) {
  var x = e.getPageX(), y = e.getPageY();
  this.autoOffset(x, y);
}, onInitDrag: function(x, y) {
  this.onStartDrag(x, y);
  return true;
}, createFrame: Ext.emptyFn, getDragEl: function(e) {
  var ghost = this.panelProxy.ghost;
  if (ghost) 
  {
    return ghost.el.dom;
  }
}, endDrag: function(e) {
  this.panelProxy.hide();
  this.panel.saveState();
}, autoOffset: function(x, y) {
  x -= this.startPageX;
  y -= this.startPageY;
  this.setDelta(x, y);
}, onInvalidDrop: function(target, e, id) {
  var me = this;
  if (me.beforeInvalidDrop(target, e, id) !== false) 
  {
    if (me.cachedTarget) 
    {
      if (me.cachedTarget.isNotifyTarget) 
      {
        me.cachedTarget.notifyOut(me, e, me.dragData);
      }
      me.cacheTarget = null;
    }
    if (me.afterInvalidDrop) 
    {
      me.afterInvalidDrop(e, id);
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.panel, 'DD'], 0));
;

(Ext.cmd.derive('Ext.util.Memento', Ext.Base, (function() {
  function captureOne(src, target, prop, prefix) {
    src[prefix ? prefix + prop : prop] = target[prop];
  }
  function removeOne(src, target, prop) {
    delete src[prop];
  }
  function restoreOne(src, target, prop, prefix) {
    var name = prefix ? prefix + prop : prop, value = src[name];
    if (value || src.hasOwnProperty(name)) 
    {
      restoreValue(target, prop, value);
    }
  }
  function restoreValue(target, prop, value) {
    if (Ext.isDefined(value)) 
    {
      target[prop] = value;
    } else {
      delete target[prop];
    }
  }
  function doMany(doOne, src, target, props, prefix) {
    if (src) 
    {
      if (Ext.isArray(props)) 
      {
        var p, pLen = props.length;
        for (p = 0; p < pLen; p++) 
          {
            doOne(src, target, props[p], prefix);
          }
      } else {
        doOne(src, target, props, prefix);
      }
    }
  }
  return {data: null, target: null, constructor: function(target, props) {
  if (target) 
  {
    this.target = target;
    if (props) 
    {
      this.capture(props);
    }
  }
}, capture: function(props, target, prefix) {
  var me = this;
  doMany(captureOne, me.data || (me.data = {}), target || me.target, props, prefix);
}, remove: function(props) {
  doMany(removeOne, this.data, null, props);
}, restore: function(props, clear, target, prefix) {
  doMany(restoreOne, this.data, target || this.target, props, prefix);
  if (clear !== false) 
  {
    this.remove(props);
  }
}, restoreAll: function(clear, target) {
  var me = this, t = target || this.target, data = me.data, prop;
  for (prop in data) 
    {
      if (data.hasOwnProperty(prop)) 
      {
        restoreValue(t, prop, data[prop]);
      }
    }
  if (clear !== false) 
  {
    delete me.data;
  }
}};
}()), 1, 0, 0, 0, 0, 0, [Ext.util, 'Memento'], 0));
;

(Ext.cmd.derive('Ext.layout.component.Body', Ext.layout.component.Auto, {type: 'body', beginLayout: function(ownerContext) {
  this.callParent(arguments);
  ownerContext.bodyContext = ownerContext.getEl('body');
}, beginLayoutCycle: function(ownerContext, firstCycle) {
  var me = this, lastWidthModel = me.lastWidthModel, lastHeightModel = me.lastHeightModel, body = me.owner.body;
  me.callParent(arguments);
  if (lastWidthModel && lastWidthModel.fixed && ownerContext.widthModel.shrinkWrap) 
  {
    body.setWidth(null);
  }
  if (lastHeightModel && lastHeightModel.fixed && ownerContext.heightModel.shrinkWrap) 
  {
    body.setHeight(null);
  }
}, calculateOwnerHeightFromContentHeight: function(ownerContext, contentHeight) {
  var height = this.callParent(arguments);
  if (ownerContext.targetContext != ownerContext) 
  {
    height += ownerContext.getPaddingInfo().height;
  }
  return height;
}, calculateOwnerWidthFromContentWidth: function(ownerContext, contentWidth) {
  var width = this.callParent(arguments);
  if (ownerContext.targetContext != ownerContext) 
  {
    width += ownerContext.getPaddingInfo().width;
  }
  return width;
}, measureContentWidth: function(ownerContext) {
  return ownerContext.bodyContext.setWidth(ownerContext.bodyContext.el.dom.offsetWidth, false);
}, measureContentHeight: function(ownerContext) {
  return ownerContext.bodyContext.setHeight(ownerContext.bodyContext.el.dom.offsetHeight, false);
}, publishInnerHeight: function(ownerContext, height) {
  var innerHeight = height - ownerContext.getFrameInfo().height, targetContext = ownerContext.targetContext;
  if (targetContext != ownerContext) 
  {
    innerHeight -= ownerContext.getPaddingInfo().height;
  }
  return ownerContext.bodyContext.setHeight(innerHeight, !ownerContext.heightModel.natural);
}, publishInnerWidth: function(ownerContext, width) {
  var innerWidth = width - ownerContext.getFrameInfo().width, targetContext = ownerContext.targetContext;
  if (targetContext != ownerContext) 
  {
    innerWidth -= ownerContext.getPaddingInfo().width;
  }
  ownerContext.bodyContext.setWidth(innerWidth, !ownerContext.widthModel.natural);
}}, 0, 0, 0, 0, ["layout.body"], 0, [Ext.layout.component, 'Body'], 0));
;

(Ext.cmd.derive('Ext.panel.Panel', Ext.panel.AbstractPanel, {alternateClassName: 'Ext.Panel', collapsedCls: 'collapsed', animCollapse: Ext.enableFx, minButtonWidth: 75, collapsed: false, collapseFirst: true, hideCollapseTool: false, titleCollapse: undefined, floatable: true, collapsible: undefined, closable: false, closeAction: 'destroy', placeholderCollapseHideMode: Ext.Element.VISIBILITY, preventHeader: false, header: undefined, headerPosition: 'top', frame: false, frameHeader: true, manageHeight: true, constrain: false, constrainHeader: false, maskElement: 'el', initComponent: function() {
  var me = this;
  me.addEvents('beforeclose', 'close', "beforeexpand", "beforecollapse", "expand", "collapse", 'titlechange', 'iconchange', 'iconclschange', 'glyphchange', 'float', 'unfloat');
  if (me.collapsible) 
  {
    me.addStateEvents(['expand', 'collapse']);
  }
  if (me.unstyled) 
  {
    me.setUI('plain');
  }
  if (me.frame) 
  {
    me.setUI(me.ui + '-framed');
  }
  me.bridgeToolbars();
  me.callParent();
  me.collapseDirection = me.collapseDirection || me.headerPosition || Ext.Component.DIRECTION_TOP;
  me.hiddenOnCollapse = new Ext.dom.CompositeElement();
}, beforeDestroy: function() {
  var me = this;
  Ext.destroy(me.placeholder, me.ghostPanel, me.dd);
  me.callParent();
}, getFocusEl: function() {
  return this.el;
}, getHeader: function() {
  return this.header;
}, setTitle: function(newTitle) {
  var me = this, oldTitle = me.title, header = me.header, reExpander = me.reExpander, placeholder = me.placeholder;
  me.title = newTitle;
  if (header) 
  {
    if (header.isHeader) 
    {
      header.setTitle(newTitle);
    } else {
      header.title = newTitle;
    }
  } else if (me.rendered) 
  {
    me.updateHeader();
  }
  if (reExpander) 
  {
    reExpander.setTitle(newTitle);
  }
  if (placeholder && placeholder.setTitle) 
  {
    placeholder.setTitle(newTitle);
  }
  me.fireEvent('titlechange', me, newTitle, oldTitle);
}, setIconCls: function(newIconCls) {
  var me = this, oldIconCls = me.iconCls, header = me.header, placeholder = me.placeholder;
  me.iconCls = newIconCls;
  if (header) 
  {
    if (header.isHeader) 
    {
      header.setIconCls(newIconCls);
    } else {
      header.iconCls = newIconCls;
    }
  } else {
    me.updateHeader();
  }
  if (placeholder && placeholder.setIconCls) 
  {
    placeholder.setIconCls(newIconCls);
  }
  me.fireEvent('iconclschange', me, newIconCls, oldIconCls);
}, setIcon: function(newIcon) {
  var me = this, oldIcon = me.icon, header = me.header, placeholder = me.placeholder;
  me.icon = newIcon;
  if (header) 
  {
    if (header.isHeader) 
    {
      header.setIcon(newIcon);
    } else {
      header.icon = newIcon;
    }
  } else {
    me.updateHeader();
  }
  if (placeholder && placeholder.setIcon) 
  {
    placeholder.setIcon(newIcon);
  }
  me.fireEvent('iconchange', me, newIcon, oldIcon);
}, setGlyph: function(newGlyph) {
  var me = this, oldGlyph = me.glyph, header = me.header, placeholder = me.placeholder;
  me.glyph = newGlyph;
  if (header) 
  {
    if (header.isHeader) 
    {
      header.setGlyph(newGlyph);
    } else {
      header.glyph = newGlyph;
    }
  } else {
    me.updateHeader();
  }
  if (placeholder && placeholder.setGlyph) 
  {
    placeholder.setIcon(newGlyph);
  }
  me.fireEvent('glyphchange', me, newGlyph, oldGlyph);
}, bridgeToolbars: function() {
  var me = this, docked = [], minButtonWidth = me.minButtonWidth, fbar, fbarDefaults;
  function initToolbar(toolbar, pos, useButtonAlign) {
    if (Ext.isArray(toolbar)) 
    {
      toolbar = {xtype: 'toolbar', items: toolbar};
    } else if (!toolbar.xtype) 
    {
      toolbar.xtype = 'toolbar';
    }
    toolbar.dock = pos;
    if (pos == 'left' || pos == 'right') 
    {
      toolbar.vertical = true;
    }
    if (useButtonAlign) 
    {
      toolbar.layout = Ext.applyIf(toolbar.layout || {}, {pack: {left: 'start', center: 'center'}[me.buttonAlign] || 'end'});
    }
    return toolbar;
  }
  if (me.tbar) 
  {
    docked.push(initToolbar(me.tbar, 'top'));
    me.tbar = null;
  }
  if (me.bbar) 
  {
    docked.push(initToolbar(me.bbar, 'bottom'));
    me.bbar = null;
  }
  if (me.buttons) 
  {
    me.fbar = me.buttons;
    me.buttons = null;
  }
  if (me.fbar) 
  {
    fbar = initToolbar(me.fbar, 'bottom', true);
    fbar.ui = 'footer';
    if (minButtonWidth) 
    {
      fbarDefaults = fbar.defaults;
      fbar.defaults = function(config) {
  var defaults = fbarDefaults || {}, isButton = !config.xtype || config.isButton, cls;
  if (!isButton) 
  {
    cls = Ext.ClassManager.getByAlias('widget.' + config.xtype);
    if (cls) 
    {
      isButton = cls.prototype.isButton;
    }
  }
  if (isButton && !('minWidth' in defaults)) 
  {
    defaults = Ext.apply({minWidth: minButtonWidth}, defaults);
  }
  return defaults;
};
    }
    docked.push(fbar);
    me.fbar = null;
  }
  if (me.lbar) 
  {
    docked.push(initToolbar(me.lbar, 'left'));
    me.lbar = null;
  }
  if (me.rbar) 
  {
    docked.push(initToolbar(me.rbar, 'right'));
    me.rbar = null;
  }
  if (me.dockedItems) 
  {
    if (!Ext.isArray(me.dockedItems)) 
    {
      me.dockedItems = [me.dockedItems];
    }
    me.dockedItems = me.dockedItems.concat(docked);
  } else {
    me.dockedItems = docked;
  }
}, isPlaceHolderCollapse: function() {
  return this.collapseMode == 'placeholder';
}, onBoxReady: function() {
  this.callParent(arguments);
  if (this.collapsed) 
  {
    this.setHiddenDocked();
  }
}, beforeRender: function() {
  var me = this, wasCollapsed;
  me.callParent();
  me.initTools();
  if (!(me.preventHeader || (me.header === false))) 
  {
    me.updateHeader();
  }
  if (me.collapsed) 
  {
    if (me.isPlaceHolderCollapse()) 
    {
      if (!me.hidden) 
      {
        me.setHiddenState(true);
        me.preventCollapseFire = true;
        me.placeholderCollapse();
        delete me.preventCollapseFire;
        wasCollapsed = me.collapsed;
        me.collapsed = false;
      }
    } else {
      me.beginCollapse();
      me.addClsWithUI(me.collapsedCls);
    }
  }
  if (wasCollapsed) 
  {
    me.collapsed = wasCollapsed;
  }
}, initTools: function() {
  var me = this, tools = me.tools, i, tool;
  me.tools = [];
  for (i = tools && tools.length; i; ) 
    {
      --i;
      me.tools[i] = tool = tools[i];
      tool.toolOwner = me;
    }
  if (me.collapsible && !(me.hideCollapseTool || me.header === false || me.preventHeader)) 
  {
    me.collapseDirection = me.collapseDirection || me.headerPosition || 'top';
    me.collapseTool = me.expandTool = Ext.widget({xtype: 'tool', handler: me.toggleCollapse, scope: me});
    me.updateCollapseTool();
    if (me.collapseFirst) 
    {
      me.tools.unshift(me.collapseTool);
    }
  }
  me.addTools();
  if (me.closable) 
  {
    me.addClsWithUI('closable');
    me.addTool({xtype: 'tool', type: 'close', scope: me, handler: me.close});
  }
  if (me.collapseTool && !me.collapseFirst) 
  {
    me.addTool(me.collapseTool);
  }
}, addTools: Ext.emptyFn, updateCollapseTool: function() {
  var me = this, collapseTool = me.collapseTool;
  if (collapseTool) 
  {
    if (me.collapsed && !me.isPlaceHolderCollapse()) 
    {
      collapseTool.setType('expand-' + me.getOppositeDirection(me.collapseDirection));
    } else {
      collapseTool.setType('collapse-' + me.collapseDirection);
    }
  }
}, close: function() {
  if (this.fireEvent('beforeclose', this) !== false) 
  {
    this.doClose();
  }
}, doClose: function() {
  this.fireEvent('close', this);
  this[this.closeAction]();
}, updateHeader: function(force) {
  var me = this, header = me.header, title = me.title, tools = me.tools, icon = me.icon || me.iconCls, vertical = me.headerPosition === 'left' || me.headerPosition === 'right';
  if (Ext.isObject(header) || (header !== false && (force || (title || icon) || (tools && tools.length) || (me.collapsible && !me.titleCollapse)))) 
  {
    if (header && header.isHeader) 
    {
      header.show();
    } else {
      header = me.header = Ext.widget(Ext.apply({xtype: 'header', title: title, titleAlign: me.titleAlign, orientation: vertical ? 'vertical' : 'horizontal', dock: me.headerPosition || 'top', textCls: me.headerTextCls, iconCls: me.iconCls, icon: me.icon, glyph: me.glyph, baseCls: me.baseCls + '-header', tools: tools, ui: me.ui, id: me.id + '_header', overCls: me.headerOverCls, indicateDrag: me.draggable, frame: (me.frame || me.alwaysFramed) && me.frameHeader, ignoreParentFrame: me.frame || me.overlapHeader, ignoreBorderManagement: me.frame || me.ignoreHeaderBorderManagement, headerRole: me.headerRole, ownerCt: me, listeners: me.collapsible && me.titleCollapse ? {click: me.toggleCollapse, scope: me} : null}, me.header));
      me.addDocked(header, 0);
    }
  } else if (header) 
  {
    header.hide();
  }
}, setUI: function(ui) {
  var me = this;
  me.callParent(arguments);
  if (me.header && me.header.rendered) 
  {
    me.header.setUI(ui);
  }
}, getDefaultContentTarget: function() {
  return this.body;
}, getTargetEl: function() {
  var me = this;
  return me.body || me.protoBody || me.frameBody || me.el;
}, isVisible: function(deep) {
  var me = this;
  if (me.collapsed && me.placeholder) 
  {
    return me.placeholder.isVisible(deep);
  }
  return me.callParent(arguments);
}, onHide: function() {
  var me = this, dd = me.dd;
  if (me.floatedFromCollapse) 
  {
    me.slideOutFloatedPanel(true);
  }
  if (me.draggable && dd) 
  {
    dd.endDrag();
  }
  if (me.collapsed && me.placeholder) 
  {
    me.placeholder.hide();
  } else {
    me.callParent(arguments);
  }
}, onShow: function() {
  var me = this;
  if (me.collapsed && me.isPlaceHolderCollapse()) 
  {
    me.setHiddenState(true);
    me.placeholderCollapse();
  } else {
    me.callParent(arguments);
  }
}, onRemoved: function(destroying) {
  var me = this;
  if (me.placeholder && !destroying) 
  {
    me.ownerCt.remove(me.placeholder, false);
  }
  me.callParent(arguments);
}, addTool: function(tools) {
  if (!Ext.isArray(tools)) 
  {
    tools = [tools];
  }
  var me = this, header = me.header, t, tLen = tools.length, tool;
  for (t = 0; t < tLen; t++) 
    {
      tool = tools[t];
      tool.toolOwner = me;
      if (header && header.isHeader) 
      {
        header.addTool(tool);
      } else {
        me.tools.push(tool);
      }
    }
  me.updateHeader();
}, getOppositeDirection: function(d) {
  var c = Ext.Component;
  switch (d) {
    case c.DIRECTION_TOP:
      return c.DIRECTION_BOTTOM;
    case c.DIRECTION_RIGHT:
      return c.DIRECTION_LEFT;
    case c.DIRECTION_BOTTOM:
      return c.DIRECTION_TOP;
    case c.DIRECTION_LEFT:
      return c.DIRECTION_RIGHT;
  }
}, getWidthAuthority: function() {
  if (this.collapsed && this.collapsedHorizontal()) 
  {
    return 1;
  }
  return this.callParent();
}, getHeightAuthority: function() {
  if (this.collapsed && this.collapsedVertical()) 
  {
    return 1;
  }
  return this.callParent();
}, collapsedHorizontal: function() {
  var dir = this.getCollapsed();
  return dir === 'left' || dir === 'right';
}, collapsedVertical: function() {
  var dir = this.getCollapsed();
  return dir === 'top' || dir === 'bottom';
}, restoreDimension: function() {
  var dir = this.collapseDirection;
  return (dir === 'top' || dir === 'bottom') ? 'height' : 'width';
}, getCollapsed: function() {
  var me = this;
  if (me.collapsed === true) 
  {
    return me.collapseDirection;
  }
  return me.collapsed;
}, getState: function() {
  var me = this, state = me.callParent(), memento;
  state = me.addPropertyToState(state, 'collapsed');
  if (me.collapsed) 
  {
    memento = me.collapseMemento;
    memento = memento && memento.data;
    if (me.collapsedVertical()) 
    {
      if (state) 
      {
        delete state.height;
      }
      if (memento) 
      {
        state = me.addPropertyToState(state, 'height', memento.height);
      }
    } else {
      if (state) 
      {
        delete state.width;
      }
      if (memento) 
      {
        state = me.addPropertyToState(state, 'width', memento.width);
      }
    }
  }
  return state;
}, findReExpander: function(direction) {
  var me = this, c = Ext.Component, dockedItems = me.dockedItems.items, dockedItemCount = dockedItems.length, comp, i;
  if (me.collapseMode === 'mini') 
  {
    return;
  }
  switch (direction) {
    case c.DIRECTION_TOP:
    case c.DIRECTION_BOTTOM:
      for (i = 0; i < dockedItemCount; i++) 
        {
          comp = dockedItems[i];
          if (!comp.hidden) 
          {
            if (comp.isHeader && (!comp.dock || comp.dock === 'top' || comp.dock === 'bottom')) 
            {
              return comp;
            }
          }
        }
      break;
    case c.DIRECTION_LEFT:
    case c.DIRECTION_RIGHT:
      for (i = 0; i < dockedItemCount; i++) 
        {
          comp = dockedItems[i];
          if (!comp.hidden) 
          {
            if (comp.isHeader && (comp.dock === 'left' || comp.dock === 'right')) 
            {
              return comp;
            }
          }
        }
      break;
    default:
      throw ('Panel#findReExpander must be passed a valid collapseDirection');
  }
}, getReExpander: function(direction) {
  var me = this, collapseDir = direction || me.collapseDirection, reExpander = me.reExpander || me.findReExpander(collapseDir);
  me.expandDirection = me.getOppositeDirection(collapseDir);
  if (!reExpander) 
  {
    me.reExpander = reExpander = me.createReExpander(collapseDir, {dock: collapseDir, cls: Ext.baseCSSPrefix + 'docked ' + me.baseCls + '-' + me.ui + '-collapsed', isCollapsedExpander: true});
    me.dockedItems.insert(0, reExpander);
  }
  return reExpander;
}, createReExpander: function(direction, defaults) {
  var me = this, isLeft = direction === 'left', isRight = direction === 'right', isVertical = isLeft || isRight, ownerCt = me.ownerCt, result = Ext.apply({hideMode: 'offsets', title: me.title || '&#160;', titleAlign: me.titleAlign, orientation: isVertical ? 'vertical' : 'horizontal', textCls: me.headerTextCls, icon: me.icon, iconCls: me.iconCls, glyph: me.glyph, baseCls: me.self.prototype.baseCls + '-header', ui: me.ui, frame: me.frame && me.frameHeader, ignoreParentFrame: me.frame || me.overlapHeader, ignoreBorderManagement: me.frame || me.ignoreHeaderBorderManagement, indicateDrag: me.draggable, collapseImmune: true, headerRole: me.headerRole, ownerCt: (ownerCt && me.collapseMode === 'placeholder') ? ownerCt : me, ownerLayout: me.componentLayout, margin: me.margin}, defaults);
  if (me.collapseMode === 'mini') 
  {
    if (isVertical) 
    {
      result.width = 1;
    } else {
      result.height = 1;
    }
  }
  if (!me.hideCollapseTool) 
  {
    if (isLeft || (isRight && me.isPlaceHolderCollapse())) 
    {
      result.titlePosition = 1;
    }
    result.tools = [{xtype: 'tool', type: 'expand-' + me.getOppositeDirection(direction), uiCls: ['top'], handler: me.toggleCollapse, scope: me}];
  }
  result = new Ext.panel.Header(result);
  result.addClsWithUI(me.getHeaderCollapsedClasses(result));
  return result;
}, getHeaderCollapsedClasses: function(header) {
  var me = this, collapsedCls = me.collapsedCls, collapsedClasses;
  collapsedClasses = [collapsedCls, collapsedCls + '-' + header.getDockName()];
  if (me.border && (!me.frame || (me.frame && Ext.supports.CSS3BorderRadius))) 
  {
    collapsedClasses.push(collapsedCls + '-border-' + header.getDockName());
  }
  return collapsedClasses;
}, beginCollapse: function() {
  var me = this, lastBox = me.lastBox, rendered = me.rendered, collapseMemento = me.collapseMemento || (me.collapseMemento = new Ext.util.Memento(me)), sizeModel = me.getSizeModel(), header = me.header, reExpander;
  collapseMemento.capture(['height', 'minHeight', 'width', 'minWidth']);
  if (lastBox) 
  {
    collapseMemento.capture(me.restoreDimension(), lastBox, 'last.');
  }
  if (me.collapsedVertical()) 
  {
    if (sizeModel.width.shrinkWrap) 
    {
      me.width = rendered ? me.getWidth() : me.width || me.minWidth || 100;
    }
    delete me.height;
    me.minHeight = 0;
  } else if (me.collapsedHorizontal()) 
  {
    if (sizeModel.height.shrinkWrap) 
    {
      me.height = rendered ? me.getHeight() : me.height || me.minHeight || 100;
    }
    delete me.width;
    me.minWidth = 0;
  }
  if (me.ownerCt) 
  {
    me.ownerCt.getLayout().beginCollapse(me);
  }
  if (!me.isPlaceHolderCollapse() && header !== false) 
  {
    if (header === (reExpander = me.getReExpander())) 
    {
      header.collapseImmune = true;
      header.getHierarchyState().collapseImmune = true;
      header.addClsWithUI(me.getHeaderCollapsedClasses(header));
      if (header.rendered) 
      {
        header.updateFrame();
      }
    } else if (reExpander.el) 
    {
      reExpander.el.show();
      reExpander.hidden = false;
    }
  }
  if (me.resizer) 
  {
    me.resizer.disable();
  }
}, beginExpand: function() {
  var me = this, lastBox = me.lastBox, collapseMemento = me.collapseMemento, restoreDimension = me.restoreDimension(), header = me.header, reExpander;
  if (collapseMemento) 
  {
    collapseMemento.restore(['minHeight', 'minWidth', restoreDimension]);
    if (lastBox) 
    {
      collapseMemento.restore(restoreDimension, true, lastBox, 'last.');
    }
  }
  if (me.ownerCt) 
  {
    me.ownerCt.getLayout().beginExpand(me);
  }
  if (!me.isPlaceHolderCollapse() && header !== false) 
  {
    if (header === (reExpander = me.getReExpander())) 
    {
      delete header.collapseImmune;
      delete header.getHierarchyState().collapseImmune;
      header.removeClsWithUI(me.getHeaderCollapsedClasses(header));
      if (header.rendered) 
      {
        header.expanding = true;
        header.updateFrame();
        delete header.expanding;
      }
    } else {
      reExpander.hidden = true;
      reExpander.el.hide();
    }
  }
  if (me.resizer) 
  {
    me.resizer.enable();
  }
}, collapse: function(direction, animate) {
  var me = this, collapseDir = direction || me.collapseDirection, ownerCt = me.ownerCt, layout = me.ownerLayout;
  if (me.isCollapsingOrExpanding) 
  {
    return me;
  }
  if (arguments.length < 2) 
  {
    animate = me.animCollapse;
  }
  if (me.collapsed || me.fireEvent('beforecollapse', me, direction, animate) === false) 
  {
    return me;
  }
  if (layout && layout.onBeforeComponentCollapse) 
  {
    if (layout.onBeforeComponentCollapse(me) === false) 
    {
      return me;
    }
  }
  if (ownerCt && me.isPlaceHolderCollapse()) 
  {
    return me.placeholderCollapse(direction, animate);
  }
  me.collapsed = collapseDir;
  me.beginCollapse();
  me.getHierarchyState().collapsed = true;
  me.fireHierarchyEvent('collapse');
  return me.doCollapseExpand(1, animate);
}, doCollapseExpand: function(flags, animate) {
  var me = this, originalAnimCollapse = me.animCollapse, ownerLayout = me.ownerLayout;
  me.animCollapse = animate;
  me.isCollapsingOrExpanding = flags;
  if (animate) 
  {
    me.addCls(Ext.baseCSSPrefix + 'animating-size');
  }
  if (ownerLayout && !animate) 
  {
    ownerLayout.onContentChange(me);
  } else {
    me.updateLayout({isRoot: true});
  }
  me.animCollapse = originalAnimCollapse;
  return me;
}, afterCollapse: function(animated) {
  var me = this, ownerLayout = me.ownerLayout;
  me.isCollapsingOrExpanding = 0;
  me.updateCollapseTool();
  if (animated) 
  {
    me.removeCls(Ext.baseCSSPrefix + 'animating-size');
  }
  if (ownerLayout && animated) 
  {
    ownerLayout.onContentChange(me);
  }
  me.setHiddenDocked();
  me.fireEvent('collapse', me);
}, setHiddenDocked: function() {
  var me = this, toHide = me.hiddenOnCollapse, items = me.getDockedItems(), len = items.length, i = 0, item, reExpander;
  if (me.header !== false) 
  {
    reExpander = me.getReExpander();
  }
  toHide.add(me.body);
  for (; i < len; i++) 
    {
      item = items[i];
      if (item && item !== reExpander && item.el) 
      {
        toHide.add(item.el);
      }
    }
  toHide.setStyle('visibility', 'hidden');
}, restoreHiddenDocked: function() {
  var toShow = this.hiddenOnCollapse;
  toShow.setStyle('visibility', '');
  toShow.clear();
}, getPlaceholder: function(direction) {
  var me = this, collapseDir = direction || me.collapseDirection, listeners = null, placeholder = me.placeholder, floatable = me.floatable, titleCollapse = me.titleCollapse;
  if (!placeholder) 
  {
    if (floatable || (me.collapsible && titleCollapse)) 
    {
      listeners = {click: {fn: (!titleCollapse && floatable) ? me.floatCollapsedPanel : me.toggleCollapse, element: 'el', scope: me}};
    }
    me.placeholder = placeholder = Ext.widget(me.createReExpander(collapseDir, {id: me.id + '-placeholder', listeners: listeners}));
  }
  if (!placeholder.placeholderFor) 
  {
    if (!placeholder.isComponent) 
    {
      me.placeholder = placeholder = me.lookupComponent(placeholder);
    }
    Ext.applyIf(placeholder, {margins: me.margins, placeholderFor: me});
    placeholder.addCls([Ext.baseCSSPrefix + 'region-collapsed-placeholder', Ext.baseCSSPrefix + 'region-collapsed-' + collapseDir + '-placeholder', me.collapsedCls]);
  }
  return placeholder;
}, placeholderCollapse: function(direction, animate) {
  var me = this, ownerCt = me.ownerCt, collapseDir = direction || me.collapseDirection, floatCls = Ext.baseCSSPrefix + 'border-region-slide-in', placeholder = me.getPlaceholder(collapseDir), slideInDirection;
  me.isCollapsingOrExpanding = 1;
  me.setHiddenState(true);
  me.collapsed = collapseDir;
  if (placeholder.rendered) 
  {
    if (placeholder.el.dom.parentNode !== me.el.dom.parentNode) 
    {
      me.el.dom.parentNode.insertBefore(placeholder.el.dom, me.el.dom);
    }
    placeholder.hidden = false;
    placeholder.setHiddenState(false);
    placeholder.el.show();
    ownerCt.updateLayout();
  } else {
    ownerCt.insert(ownerCt.items.indexOf(me), placeholder);
  }
  if (me.rendered) 
  {
    me.el.setVisibilityMode(me.placeholderCollapseHideMode);
    if (animate) 
    {
      me.el.addCls(floatCls);
      placeholder.el.hide();
      slideInDirection = me.convertCollapseDir(collapseDir);
      me.el.slideOut(slideInDirection, {preserveScroll: true, duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration), listeners: {afteranimate: function() {
  me.el.removeCls(floatCls);
  placeholder.el.show().setStyle('display', 'none').slideIn(slideInDirection, {easing: 'linear', duration: 100, listeners: {afteranimate: function() {
  placeholder.focus();
  placeholder.setHiddenState(false);
  me.isCollapsingOrExpanding = 0;
  me.fireEvent('collapse', me);
}}});
}}});
    } else {
      me.el.hide();
      placeholder.setHiddenState(false);
      me.isCollapsingOrExpanding = 0;
      me.fireEvent('collapse', me);
    }
  } else {
    me.isCollapsingOrExpanding = 0;
    if (!me.preventCollapseFire) 
    {
      me.fireEvent('collapse', me);
    }
  }
  return me;
}, floatCollapsedPanel: function() {
  var me = this, placeholder = me.placeholder, ps = placeholder.getSize(), myBox, floatCls = Ext.baseCSSPrefix + 'border-region-slide-in', collapsed = me.collapsed, layoutOwner = me.ownerCt || me, slideDirection;
  if (me.isSliding) 
  {
    return;
  }
  if (me.el.hasCls(floatCls)) 
  {
    me.slideOutFloatedPanel();
    return;
  }
  me.isSliding = true;
  placeholder.el.hide();
  placeholder.hidden = true;
  me.el.show();
  me.setHiddenState(false);
  me.collapsed = false;
  layoutOwner.updateLayout();
  myBox = me.getBox(false, true);
  placeholder.el.show();
  placeholder.hidden = false;
  me.el.hide();
  me.setHiddenState(true);
  me.collapsed = collapsed;
  layoutOwner.updateLayout();
  me.slideOutTask = me.slideOutTask || new Ext.util.DelayedTask(me.slideOutFloatedPanel, me);
  placeholder.el.on('mouseleave', me.onMouseLeaveFloated, me);
  me.el.on('mouseleave', me.onMouseLeaveFloated, me);
  placeholder.el.on('mouseenter', me.onMouseEnterFloated, me);
  me.el.on('mouseenter', me.onMouseEnterFloated, me);
  me.el.addCls(floatCls);
  me.floated = true;
  if (me.collapseTool) 
  {
    me.collapseTool.el.hide();
  }
  switch (me.collapsed) {
    case 'top':
      me.setLocalXY(myBox.x, myBox.y + ps.height - 1);
      break;
    case 'right':
      me.setLocalXY(myBox.x - ps.width + 1, myBox.y);
      break;
    case 'bottom':
      me.setLocalXY(myBox.x, myBox.y - ps.height + 1);
      break;
    case 'left':
      me.setLocalXY(myBox.x + ps.width - 1, myBox.y);
      break;
  }
  slideDirection = me.convertCollapseDir(me.collapsed);
  me.floatedFromCollapse = me.collapsed;
  me.collapsed = false;
  me.setHiddenState(false);
  me.el.slideIn(slideDirection, {preserveScroll: true, duration: Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration), listeners: {afteranimate: function() {
  me.isSliding = false;
  me.fireEvent('float', me);
}}});
}, onMouseLeaveFloated: function(e) {
  this.slideOutTask.delay(500);
}, onMouseEnterFloated: function(e) {
  this.slideOutTask.cancel();
}, isLayoutRoot: function() {
  if (this.floatedFromCollapse) 
  {
    return true;
  }
  return this.callParent();
}, slideOutFloatedPanel: function(preventAnimate) {
  var me = this, compEl = me.el, collapseDirection;
  if (me.isSliding || me.isDestroyed) 
  {
    return;
  }
  me.isSliding = true;
  me.floated = false;
  me.slideOutFloatedPanelBegin();
  if (typeof me.collapsed == 'string') 
  {
    collapseDirection = me.convertCollapseDir(me.collapsed);
  }
  compEl.slideOut(collapseDirection, {preserveScroll: true, duration: Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration), autoEnd: preventAnimate === true, listeners: {afteranimate: function() {
  me.slideOutFloatedPanelEnd();
  me.el.removeCls(Ext.baseCSSPrefix + 'border-region-slide-in');
}}});
}, slideOutFloatedPanelBegin: function() {
  var me = this, placeholderEl = me.placeholder.el, el = me.el;
  me.collapsed = me.floatedFromCollapse;
  me.setHiddenState(true);
  me.floatedFromCollapse = null;
  placeholderEl.un('mouseleave', me.onMouseLeaveFloated, me);
  el.un('mouseleave', me.onMouseLeaveFloated, me);
  placeholderEl.un('mouseenter', me.onMouseEnterFloated, me);
  el.un('mouseenter', me.onMouseEnterFloated, me);
}, slideOutFloatedPanelEnd: function(suppressEvents) {
  var me = this;
  if (me.collapseTool) 
  {
    me.collapseTool.el.show();
  }
  me.slideOutTask.cancel();
  me.isSliding = false;
  if (!suppressEvents) 
  {
    me.fireEvent('unfloat', me);
  }
}, expand: function(animate) {
  var me = this, layout = me.ownerLayout;
  if (me.isCollapsingOrExpanding) 
  {
    return me;
  }
  if (!arguments.length) 
  {
    animate = me.animCollapse;
  }
  if (!me.collapsed && !me.floatedFromCollapse) 
  {
    return me;
  }
  if (me.fireEvent('beforeexpand', me, animate) === false) 
  {
    return me;
  }
  if (layout && layout.onBeforeComponentExpand) 
  {
    if (layout.onBeforeComponentExpand(me) === false) 
    {
      return me;
    }
  }
  delete me.getHierarchyState().collapsed;
  if (me.isPlaceHolderCollapse()) 
  {
    return me.placeholderExpand(animate);
  }
  me.restoreHiddenDocked();
  me.beginExpand();
  me.collapsed = false;
  return me.doCollapseExpand(2, animate);
}, placeholderExpand: function(animate) {
  var me = this, collapseDir = me.collapsed, floatCls = Ext.baseCSSPrefix + 'border-region-slide-in', finalPos, floatedPos, center = me.ownerLayout ? me.ownerLayout.centerRegion : null;
  if (Ext.AbstractComponent.layoutSuspendCount) 
  {
    animate = false;
  }
  if (me.floatedFromCollapse) 
  {
    floatedPos = me.getPosition(true);
    me.slideOutFloatedPanelBegin();
    me.slideOutFloatedPanelEnd();
    me.floated = false;
  }
  if (animate) 
  {
    Ext.suspendLayouts();
    me.placeholder.hide();
    me.el.show();
    me.collapsed = false;
    me.setHiddenState(false);
    if (center && !floatedPos) 
    {
      center.hidden = true;
    }
    Ext.resumeLayouts(true);
    center.hidden = false;
    me.el.addCls(floatCls);
    me.isCollapsingOrExpanding = 2;
    if (floatedPos) 
    {
      finalPos = me.getXY();
      me.setLocalXY(floatedPos[0], floatedPos[1]);
      me.setXY([finalPos[0], finalPos[1]], {duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration), listeners: {afteranimate: function() {
  me.el.removeCls(floatCls);
  me.isCollapsingOrExpanding = 0;
  me.fireEvent('expand', me);
}}});
    } else {
      me.el.hide();
      me.placeholder.el.show();
      me.placeholder.hidden = false;
      me.setHiddenState(false);
      me.el.slideIn(me.convertCollapseDir(collapseDir), {preserveScroll: true, duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration), listeners: {afteranimate: function() {
  me.el.removeCls(floatCls);
  me.placeholder.hide();
  me.updateLayout();
  me.isCollapsingOrExpanding = 0;
  me.fireEvent('expand', me);
}}});
    }
  } else {
    me.floated = me.collapsed = false;
    me.el.removeCls(floatCls);
    Ext.suspendLayouts();
    me.placeholder.hide();
    me.show();
    Ext.resumeLayouts(true);
    me.fireEvent('expand', me);
  }
  return me;
}, afterExpand: function(animated) {
  var me = this, ownerLayout = me.ownerLayout;
  me.isCollapsingOrExpanding = 0;
  me.updateCollapseTool();
  if (animated) 
  {
    me.removeCls(Ext.baseCSSPrefix + 'animating-size');
  }
  if (ownerLayout && animated) 
  {
    ownerLayout.onContentChange(me);
  }
  me.fireEvent('expand', me);
  me.fireHierarchyEvent('expand');
}, setBorder: function(border, targetEl) {
  if (targetEl) 
  {
    return;
  }
  var me = this, header = me.header;
  if (!border) 
  {
    border = 0;
  } else if (border === true) 
  {
    border = '1px';
  } else {
    border = me.unitizeBox(border);
  }
  if (header) 
  {
    if (header.isHeader) 
    {
      header.setBorder(border);
    } else {
      header.border = border;
    }
  }
  if (me.rendered && me.bodyBorder !== false) 
  {
    me.body.setStyle('border-width', border);
  }
  me.updateLayout();
  me.border = border;
}, toggleCollapse: function() {
  return (this.collapsed || this.floatedFromCollapse) ? this.expand() : this.collapse();
}, getKeyMap: function() {
  return this.keyMap || (this.keyMap = new Ext.util.KeyMap(Ext.apply({target: this.el}, this.keys)));
}, initDraggable: function() {
  var me = this;
  if (me.simpleDrag) 
  {
    me.initSimpleDraggable();
  } else {
    me.dd = new Ext.panel.DD(me, Ext.isBoolean(me.draggable) ? null : me.draggable);
  }
}, initSimpleDraggable: function() {
  var me = this, ddConfig, dd;
  if (!me.header) 
  {
    me.updateHeader(true);
  }
  if (me.header) 
  {
    ddConfig = Ext.applyIf({el: me.el, delegate: '#' + Ext.escapeId(me.header.id)}, me.draggable);
    if (me.constrain || me.constrainHeader) 
    {
      ddConfig.constrain = me.constrain;
      ddConfig.constrainDelegate = me.constrainHeader;
      ddConfig.constrainTo = me.constrainTo || me.container;
    }
    dd = me.dd = new Ext.util.ComponentDragger(me, ddConfig);
    me.relayEvents(dd, ['dragstart', 'drag', 'dragend']);
    if (me.maximized) 
    {
      dd.disable();
    }
  }
}, ghostTools: function() {
  var tools = [], header = this.header, headerTools = header ? header.query('tool[hidden=false]') : [], t, tLen, tool;
  if (headerTools.length) 
  {
    t = 0;
    tLen = headerTools.length;
    for (; t < tLen; t++) 
      {
        tool = headerTools[t];
        tools.push({type: tool.type});
      }
  } else {
    tools = [{type: 'placeholder'}];
  }
  return tools;
}, ghost: function(cls) {
  var me = this, ghostPanel = me.ghostPanel, box = me.getBox(), header = me.header, ghostHeader, tools, i;
  if (!ghostPanel) 
  {
    me.ghostPanel = ghostPanel = Ext.widget(me.createGhost(cls));
  } else {
    ghostPanel.el.show();
  }
  ghostPanel.setHiddenState(false);
  ghostPanel.floatParent = me.floatParent;
  ghostPanel.toFront();
  if (header && !me.preventHeader) 
  {
    ghostHeader = ghostPanel.header;
    ghostHeader.suspendLayouts();
    tools = ghostHeader.query('tool');
    for (i = tools.length; i--; ) 
      {
        ghostHeader.remove(tools[i]);
      }
    ghostPanel.addTool(me.ghostTools());
    ghostPanel.setTitle(me.title);
    ghostHeader.setTitlePosition(header.titlePosition);
    if (me.iconCls) 
    {
      ghostPanel.setIconCls(me.iconCls);
    } else if (me.icon) 
    {
      ghostPanel.setIcon(me.icon);
    } else if (me.glyph) 
    {
      ghostPanel.setGlyph(me.glyph);
    }
    ghostHeader.addCls(Ext.baseCSSPrefix + 'header-ghost');
    ghostHeader.resumeLayouts();
  }
  ghostPanel.setPagePosition(box.x, box.y);
  ghostPanel.setSize(box.width, box.height);
  me.el.hide();
  return ghostPanel;
}, createGhost: function(cls) {
  var me = this, header = me.header, frame = me.frame && !me.alwaysFramed;
  return {xtype: 'panel', hidden: false, header: header ? {titleAlign: header.titleAlign} : null, ui: frame ? me.ui.replace(/-framed$/, '') : me.ui, id: me.id + '-ghost', renderTo: Ext.getBody(), resizable: false, draggable: false, closable: false, floating: {shadow: false}, frame: frame, alwaysFramed: me.alwaysFramed, overlapHeader: me.overlapHeader, headerPosition: me.headerPosition, baseCls: me.baseCls, getRefOwner: function() {
  return me.getRefOwner();
}, cls: me.baseCls + '-ghost ' + (cls || '')};
}, unghost: function(show, matchPosition) {
  var me = this, ghostPanel = me.ghostPanel;
  if (!ghostPanel) 
  {
    return;
  }
  if (show !== false) 
  {
    me.el.show();
    if (matchPosition !== false) 
    {
      me.setPagePosition(ghostPanel.getXY());
      if (me.hideMode == 'offsets') 
      {
        delete me.el.hideModeStyles;
      }
    }
    Ext.defer(me.focus, 10, me);
  }
  ghostPanel.el.hide();
  ghostPanel.setHiddenState(true);
}, beginDrag: function() {
  if (this.floatingDescendants) 
  {
    this.floatingDescendants.hide();
  }
}, endDrag: function() {
  if (this.floatingDescendants) 
  {
    this.floatingDescendants.show();
  }
}, initResizable: function() {
  this.callParent(arguments);
  if (this.collapsed) 
  {
    this.resizer.disable();
  }
}, convertCollapseDir: function(collapseDir) {
  return collapseDir.substr(0, 1);
}, getAnimationProps: function() {
  var me = this, animCollapse = me.animCollapse, props;
  props = me.callParent();
  if (typeof animCollapse === 'number') 
  {
    props.duration = animCollapse;
  }
  return props;
}}, 0, ["panel"], ["container", "component", "box", "panel"], {"container": true, "component": true, "box": true, "panel": true}, ["widget.panel"], 0, [Ext.panel, 'Panel', Ext, 'Panel'], function() {
  this.prototype.animCollapse = Ext.enableFx;
}));
;

(Ext.cmd.derive('Ext.tip.Tip', Ext.panel.Panel, {alternateClassName: 'Ext.Tip', minWidth: 40, maxWidth: 500, shadow: "sides", defaultAlign: "tl-bl?", constrainPosition: true, autoRender: true, hidden: true, baseCls: Ext.baseCSSPrefix + 'tip', floating: {shadow: true, shim: true}, focusOnToFront: false, closeAction: 'hide', alwaysFramed: true, frameHeader: false, initComponent: function() {
  var me = this;
  me.floating = Ext.apply({}, {shadow: me.shadow, constrain: me.constrainPosition}, me.self.prototype.floating);
  me.callParent(arguments);
  me.constrain = me.constrain || me.constrainPosition;
}, showAt: function(xy) {
  var me = this;
  this.callParent(arguments);
  if (me.isVisible()) 
  {
    me.setPagePosition(xy[0], xy[1]);
    if (me.constrainPosition || me.constrain) 
    {
      me.doConstrain();
    }
    me.toFront(true);
  }
}, initDraggable: function() {
  var me = this;
  me.draggable = {el: me.getDragEl(), delegate: me.header.el, constrain: me, constrainTo: me.el.dom.parentNode};
  Ext.Component.prototype.initDraggable.call(me);
}, ghost: undefined, unghost: undefined}, 0, ["tip"], ["container", "component", "box", "tip", "panel"], {"container": true, "component": true, "box": true, "tip": true, "panel": true}, ["widget.tip"], 0, [Ext.tip, 'Tip', Ext, 'Tip'], 0));
;

(Ext.cmd.derive('Ext.tip.ToolTip', Ext.tip.Tip, {alternateClassName: 'Ext.ToolTip', autoHide: true, showDelay: 500, hideDelay: 200, dismissDelay: 5000, trackMouse: false, anchorToTarget: true, anchorOffset: 0, targetCounter: 0, quickShowInterval: 250, ariaRole: 'tooltip', initComponent: function() {
  var me = this;
  me.callParent(arguments);
  me.lastActive = new Date();
  me.setTarget(me.target);
  me.origAnchor = me.anchor;
}, onRender: function(ct, position) {
  var me = this;
  me.callParent(arguments);
  me.anchorCls = Ext.baseCSSPrefix + 'tip-anchor-' + me.getAnchorPosition();
  me.anchorEl = me.el.createChild({role: 'presentation', cls: Ext.baseCSSPrefix + 'tip-anchor ' + me.anchorCls});
}, setTarget: function(target) {
  var me = this, t = Ext.get(target), tg;
  if (me.target) 
  {
    tg = Ext.get(me.target);
    me.mun(tg, 'mouseover', me.onTargetOver, me);
    me.mun(tg, 'mouseout', me.onTargetOut, me);
    me.mun(tg, 'mousemove', me.onMouseMove, me);
  }
  me.target = t;
  if (t) 
  {
    me.mon(t, {freezeEvent: true, mouseover: me.onTargetOver, mouseout: me.onTargetOut, mousemove: me.onMouseMove, scope: me});
  }
  if (me.anchor) 
  {
    me.anchorTarget = me.target;
  }
}, onMouseMove: function(e) {
  var me = this, t = me.delegate ? e.getTarget(me.delegate) : me.triggerElement = true, xy;
  if (t) 
  {
    me.targetXY = e.getXY();
    if (t === me.triggerElement) 
    {
      if (!me.hidden && me.trackMouse) 
      {
        xy = me.getTargetXY();
        if (me.constrainPosition) 
        {
          xy = me.el.adjustForConstraints(xy, me.el.parent());
        }
        me.setPagePosition(xy);
      }
    } else {
      me.hide();
      me.lastActive = new Date(0);
      me.onTargetOver(e);
    }
  } else if ((!me.closable && me.isVisible()) && me.autoHide !== false) 
  {
    me.hide();
  }
}, getTargetXY: function() {
  var me = this, mouseOffset, offsets, xy, dw, dh, de, bd, scrollX, scrollY, axy, sz, constrainPosition;
  if (me.delegate) 
  {
    me.anchorTarget = me.triggerElement;
  }
  if (me.anchor) 
  {
    me.targetCounter++;
    offsets = me.getOffsets();
    xy = (me.anchorToTarget && !me.trackMouse) ? me.getAlignToXY(me.anchorTarget, me.getAnchorAlign()) : me.targetXY;
    dw = Ext.Element.getViewWidth() - 5;
    dh = Ext.Element.getViewHeight() - 5;
    de = document.documentElement;
    bd = document.body;
    scrollX = (de.scrollLeft || bd.scrollLeft || 0) + 5;
    scrollY = (de.scrollTop || bd.scrollTop || 0) + 5;
    axy = [xy[0] + offsets[0], xy[1] + offsets[1]];
    sz = me.getSize();
    constrainPosition = me.constrainPosition;
    me.anchorEl.removeCls(me.anchorCls);
    if (me.targetCounter < 2 && constrainPosition) 
    {
      if (axy[0] < scrollX) 
      {
        if (me.anchorToTarget) 
        {
          me.defaultAlign = 'l-r';
          if (me.mouseOffset) 
          {
            me.mouseOffset[0] *= -1;
          }
        }
        me.anchor = 'left';
        return me.getTargetXY();
      }
      if (axy[0] + sz.width > dw) 
      {
        if (me.anchorToTarget) 
        {
          me.defaultAlign = 'r-l';
          if (me.mouseOffset) 
          {
            me.mouseOffset[0] *= -1;
          }
        }
        me.anchor = 'right';
        return me.getTargetXY();
      }
      if (axy[1] < scrollY) 
      {
        if (me.anchorToTarget) 
        {
          me.defaultAlign = 't-b';
          if (me.mouseOffset) 
          {
            me.mouseOffset[1] *= -1;
          }
        }
        me.anchor = 'top';
        return me.getTargetXY();
      }
      if (axy[1] + sz.height > dh) 
      {
        if (me.anchorToTarget) 
        {
          me.defaultAlign = 'b-t';
          if (me.mouseOffset) 
          {
            me.mouseOffset[1] *= -1;
          }
        }
        me.anchor = 'bottom';
        return me.getTargetXY();
      }
    }
    me.anchorCls = Ext.baseCSSPrefix + 'tip-anchor-' + me.getAnchorPosition();
    me.anchorEl.addCls(me.anchorCls);
    me.targetCounter = 0;
    return axy;
  } else {
    mouseOffset = me.getMouseOffset();
    return (me.targetXY) ? [me.targetXY[0] + mouseOffset[0], me.targetXY[1] + mouseOffset[1]] : mouseOffset;
  }
}, getMouseOffset: function() {
  var me = this, offset = me.anchor ? [0, 0] : [15, 18];
  if (me.mouseOffset) 
  {
    offset[0] += me.mouseOffset[0];
    offset[1] += me.mouseOffset[1];
  }
  return offset;
}, getAnchorPosition: function() {
  var me = this, m;
  if (me.anchor) 
  {
    me.tipAnchor = me.anchor.charAt(0);
  } else {
    m = me.defaultAlign.match(/^([a-z]+)-([a-z]+)(\?)?$/);
    me.tipAnchor = m[1].charAt(0);
  }
  switch (me.tipAnchor) {
    case 't':
      return 'top';
    case 'b':
      return 'bottom';
    case 'r':
      return 'right';
  }
  return 'left';
}, getAnchorAlign: function() {
  switch (this.anchor) {
    case 'top':
      return 'tl-bl';
    case 'left':
      return 'tl-tr';
    case 'right':
      return 'tr-tl';
    default:
      return 'bl-tl';
  }
}, getOffsets: function() {
  var me = this, mouseOffset, offsets, ap = me.getAnchorPosition().charAt(0);
  if (me.anchorToTarget && !me.trackMouse) 
  {
    switch (ap) {
      case 't':
        offsets = [0, 9];
        break;
      case 'b':
        offsets = [0, -13];
        break;
      case 'r':
        offsets = [-13, 0];
        break;
      default:
        offsets = [9, 0];
        break;
    }
  } else {
    switch (ap) {
      case 't':
        offsets = [-15 - me.anchorOffset, 30];
        break;
      case 'b':
        offsets = [-19 - me.anchorOffset, -13 - me.el.dom.offsetHeight];
        break;
      case 'r':
        offsets = [-15 - me.el.dom.offsetWidth, -13 - me.anchorOffset];
        break;
      default:
        offsets = [25, -13 - me.anchorOffset];
        break;
    }
  }
  mouseOffset = me.getMouseOffset();
  offsets[0] += mouseOffset[0];
  offsets[1] += mouseOffset[1];
  return offsets;
}, onTargetOver: function(e) {
  var me = this, delegate = me.delegate, t;
  if (me.disabled || e.within(me.target.dom, true)) 
  {
    return;
  }
  t = delegate ? e.getTarget(delegate) : true;
  if (t) 
  {
    me.triggerElement = t;
    me.triggerEvent = e;
    me.clearTimer('hide');
    me.targetXY = e.getXY();
    me.delayShow();
  }
}, delayShow: function(trackMouse) {
  var me = this, xy = me.el && (trackMouse === false || !me.trackMouse) && me.getTargetXY();
  if (me.hidden && !me.showTimer) 
  {
    if (Ext.Date.getElapsed(me.lastActive) < me.quickShowInterval) 
    {
      me.show();
    } else {
      me.showTimer = Ext.defer(me.showFromDelay, me.showDelay, me, [xy]);
    }
  } else if (!me.hidden && me.autoHide !== false) 
  {
    me.show(xy);
  }
}, showFromDelay: function(xy) {
  this.fromDelayShow = true;
  this.show(xy);
  delete this.fromDelayShow;
}, onShowVeto: function() {
  this.callParent();
  delete this.triggerElement;
  this.clearTimer('show');
}, onTargetOut: function(e) {
  var me = this, triggerEl = me.triggerElement, target = triggerEl === true ? me.target : triggerEl;
  if (me.disabled || !triggerEl || e.within(target, true)) 
  {
    return;
  }
  if (me.showTimer) 
  {
    me.clearTimer('show');
    me.triggerElement = null;
  }
  if (me.autoHide !== false) 
  {
    me.delayHide();
  }
}, delayHide: function() {
  var me = this;
  if (!me.hidden && !me.hideTimer) 
  {
    me.hideTimer = Ext.defer(me.hide, me.hideDelay, me);
  }
}, hide: function() {
  var me = this;
  me.clearTimer('dismiss');
  me.lastActive = new Date();
  if (me.anchorEl) 
  {
    me.anchorEl.hide();
  }
  me.callParent(arguments);
  delete me.triggerElement;
}, show: function(xy) {
  var me = this;
  this.callParent();
  if (this.hidden === false) 
  {
    me.setPagePosition(-10000, -10000);
    if (me.anchor) 
    {
      me.anchor = me.origAnchor;
    }
    if (!me.calledFromShowAt) 
    {
      me.showAt(xy || me.getTargetXY());
    }
    if (me.anchor) 
    {
      me.syncAnchor();
      me.anchorEl.show();
    } else {
      me.anchorEl.hide();
    }
  }
}, showAt: function(xy) {
  var me = this;
  me.lastActive = new Date();
  me.clearTimers();
  me.calledFromShowAt = true;
  if (!me.isVisible()) 
  {
    this.callParent(arguments);
  }
  if (me.isVisible()) 
  {
    me.setPagePosition(xy[0], xy[1]);
    if (me.constrainPosition || me.constrain) 
    {
      me.doConstrain();
    }
    me.toFront(true);
    me.el.sync(true);
    if (me.dismissDelay && me.autoHide !== false) 
    {
      me.dismissTimer = Ext.defer(me.hide, me.dismissDelay, me);
    }
    if (me.anchor) 
    {
      me.syncAnchor();
      if (!me.anchorEl.isVisible()) 
      {
        me.anchorEl.show();
      }
    } else {
      me.anchorEl.hide();
    }
  }
  delete me.calledFromShowAt;
}, syncAnchor: function() {
  var me = this, anchorPos, targetPos, offset;
  switch (me.tipAnchor.charAt(0)) {
    case 't':
      anchorPos = 'b';
      targetPos = 'tl';
      offset = [20 + me.anchorOffset, 1];
      break;
    case 'r':
      anchorPos = 'l';
      targetPos = 'tr';
      offset = [-1, 12 + me.anchorOffset];
      break;
    case 'b':
      anchorPos = 't';
      targetPos = 'bl';
      offset = [20 + me.anchorOffset, -1];
      break;
    default:
      anchorPos = 'r';
      targetPos = 'tl';
      offset = [1, 12 + me.anchorOffset];
      break;
  }
  me.anchorEl.alignTo(me.el, anchorPos + '-' + targetPos, offset);
  me.anchorEl.setStyle('z-index', parseInt(me.el.getZIndex(), 10) || 0 + 1).setVisibilityMode(Ext.Element.DISPLAY);
}, setPagePosition: function(x, y) {
  var me = this;
  me.callParent(arguments);
  if (me.anchor) 
  {
    me.syncAnchor();
  }
}, _timerNames: {}, clearTimer: function(name) {
  var me = this, names = me._timerNames, propName = names[name] || (names[name] = name + 'Timer'), timer = me[propName];
  if (timer) 
  {
    clearTimeout(timer);
    me[propName] = null;
  }
}, clearTimers: function() {
  var me = this;
  me.clearTimer('show');
  me.clearTimer('dismiss');
  me.clearTimer('hide');
}, onShow: function() {
  var me = this;
  me.callParent();
  me.mon(Ext.getDoc(), 'mousedown', me.onDocMouseDown, me);
}, onHide: function() {
  var me = this;
  me.callParent();
  me.mun(Ext.getDoc(), 'mousedown', me.onDocMouseDown, me);
}, onDocMouseDown: function(e) {
  var me = this;
  if (!me.closable && !e.within(me.el.dom)) 
  {
    me.disable();
    Ext.defer(me.doEnable, 100, me);
  }
}, doEnable: function() {
  if (!this.isDestroyed) 
  {
    this.enable();
  }
}, onDisable: function() {
  this.callParent();
  this.clearTimers();
  this.hide();
}, beforeDestroy: function() {
  var me = this;
  me.clearTimers();
  Ext.destroy(me.anchorEl);
  delete me.anchorEl;
  delete me.target;
  delete me.anchorTarget;
  delete me.triggerElement;
  me.callParent();
}, onDestroy: function() {
  Ext.getDoc().un('mousedown', this.onDocMouseDown, this);
  this.callParent();
}}, 0, ["tooltip"], ["container", "component", "tooltip", "box", "tip", "panel"], {"container": true, "component": true, "tooltip": true, "box": true, "tip": true, "panel": true}, ["widget.tooltip"], 0, [Ext.tip, 'ToolTip', Ext, 'ToolTip'], 0));
;

(Ext.cmd.derive('Ext.tip.QuickTip', Ext.tip.ToolTip, {alternateClassName: 'Ext.QuickTip', interceptTitles: false, title: '&#160;', tagConfig: {namespace: 'data-', attribute: 'qtip', width: 'qwidth', target: 'target', title: 'qtitle', hide: 'hide', cls: 'qclass', align: 'qalign', anchor: 'anchor', showDelay: 'qshowDelay'}, shrinkWrapDock: true, initComponent: function() {
  var me = this;
  me.target = me.target || Ext.getDoc();
  me.targets = me.targets || {};
  me.callParent();
}, register: function(config) {
  var configs = Ext.isArray(config) ? config : arguments, i = 0, len = configs.length, target, j, targetLen;
  for (; i < len; i++) 
    {
      config = configs[i];
      target = config.target;
      if (target) 
      {
        if (Ext.isArray(target)) 
        {
          for (j = 0 , targetLen = target.length; j < targetLen; j++) 
            {
              this.targets[Ext.id(target[j])] = config;
            }
        } else {
          this.targets[Ext.id(target)] = config;
        }
      }
    }
}, unregister: function(el) {
  delete this.targets[Ext.id(el)];
}, cancelShow: function(el) {
  var me = this, activeTarget = me.activeTarget;
  el = Ext.get(el).dom;
  if (me.isVisible()) 
  {
    if (activeTarget && activeTarget.el == el) 
    {
      me.hide();
    }
  } else if (activeTarget && activeTarget.el == el) 
  {
    me.clearTimer('show');
  }
}, getTipCfg: function(e) {
  var t = e.getTarget(), titleText = t.title, cfg;
  if (this.interceptTitles && titleText && Ext.isString(titleText)) 
  {
    t.qtip = titleText;
    t.removeAttribute("title");
    e.preventDefault();
    return {text: titleText};
  } else {
    cfg = this.tagConfig;
    t = e.getTarget('[' + cfg.namespace + cfg.attribute + ']');
    if (t) 
    {
      return {target: t, text: t.getAttribute(cfg.namespace + cfg.attribute)};
    }
  }
}, onTargetOver: function(e) {
  var me = this, target = e.getTarget(me.delegate), hasShowDelay, delay, elTarget, cfg, ns, tipConfig, autoHide, targets, targetEl, value, key;
  if (me.disabled) 
  {
    return;
  }
  me.targetXY = e.getXY();
  if (!target || target.nodeType !== 1 || target == document.documentElement || target == document.body) 
  {
    return;
  }
  if (me.activeTarget && ((target == me.activeTarget.el) || Ext.fly(me.activeTarget.el).contains(target))) 
  {
    if (me.targetTextEmpty()) 
    {
      me.onShowVeto();
      delete me.activeTarget;
    } else {
      me.clearTimer('hide');
      me.show();
    }
    return;
  }
  if (target) 
  {
    targets = me.targets;
    for (key in targets) 
      {
        if (targets.hasOwnProperty(key)) 
        {
          value = targets[key];
          targetEl = Ext.fly(value.target);
          if (targetEl && (targetEl.dom === target || targetEl.contains(target))) 
          {
            elTarget = targetEl.dom;
            break;
          }
        }
      }
    if (elTarget) 
    {
      me.activeTarget = me.targets[elTarget.id];
      me.activeTarget.el = target;
      me.anchor = me.activeTarget.anchor;
      if (me.anchor) 
      {
        me.anchorTarget = target;
      }
      hasShowDelay = parseInt(me.activeTarget.showDelay, 10);
      if (hasShowDelay) 
      {
        delay = me.showDelay;
        me.showDelay = hasShowDelay;
      }
      me.delayShow();
      if (hasShowDelay) 
      {
        me.showDelay = delay;
      }
      return;
    }
  }
  elTarget = Ext.fly(target, '_quicktip-target');
  cfg = me.tagConfig;
  ns = cfg.namespace;
  tipConfig = me.getTipCfg(e);
  if (tipConfig) 
  {
    if (tipConfig.target) 
    {
      target = tipConfig.target;
      elTarget = Ext.fly(target, '_quicktip-target');
    }
    autoHide = elTarget.getAttribute(ns + cfg.hide);
    me.activeTarget = {el: target, text: tipConfig.text, width: +elTarget.getAttribute(ns + cfg.width) || null, autoHide: autoHide != "user" && autoHide !== 'false', title: elTarget.getAttribute(ns + cfg.title), cls: elTarget.getAttribute(ns + cfg.cls), align: elTarget.getAttribute(ns + cfg.align), showDelay: parseInt(elTarget.getAttribute(ns + cfg.showDelay), 10)};
    me.anchor = elTarget.getAttribute(ns + cfg.anchor);
    if (me.anchor) 
    {
      me.anchorTarget = target;
    }
    hasShowDelay = parseInt(me.activeTarget.showDelay, 10);
    if (hasShowDelay) 
    {
      delay = me.showDelay;
      me.showDelay = hasShowDelay;
    }
    me.delayShow();
    if (hasShowDelay) 
    {
      me.showDelay = delay;
    }
  }
}, onTargetOut: function(e) {
  var me = this, active = me.activeTarget, hasHideDelay, delay;
  if (active && e.within(me.activeTarget.el) && !me.getTipCfg(e)) 
  {
    return;
  }
  me.clearTimer('show');
  delete me.activeTarget;
  if (me.autoHide !== false) 
  {
    hasHideDelay = active && parseInt(active.hideDelay, 10);
    if (hasHideDelay) 
    {
      delay = me.hideDelay;
      me.hideDelay = hasHideDelay;
    }
    me.delayHide();
    if (hasHideDelay) 
    {
      me.hideDelay = delay;
    }
  }
}, targetTextEmpty: function() {
  var me = this, target = me.activeTarget, cfg = me.tagConfig, el, text;
  if (target) 
  {
    el = target.el;
    if (el) 
    {
      text = el.getAttribute(cfg.namespace + cfg.attribute) || me.interceptTitles;
      if (!text && !me.targets[Ext.id(target.target)]) 
      {
        return true;
      }
    }
  }
  return false;
}, show: function() {
  var me = this, fromDelay = me.fromDelayShow;
  if (fromDelay && me.targetTextEmpty()) 
  {
    me.onShowVeto();
    delete me.activeTarget;
    return;
  }
  me.callParent(arguments);
}, showAt: function(xy) {
  var me = this, target = me.activeTarget, header = me.header, dismiss, cls;
  if (target) 
  {
    if (!me.rendered) 
    {
      me.render(Ext.getBody());
      me.activeTarget = target;
    }
    me.suspendLayouts();
    if (target.title) 
    {
      me.setTitle(target.title);
      header.show();
    } else if (header) 
    {
      header.hide();
    }
    me.update(target.text);
    me.autoHide = target.autoHide;
    dismiss = target.dismissDelay;
    me.dismissDelay = Ext.isNumber(dismiss) ? dismiss : me.dismissDelay;
    if (target.mouseOffset) 
    {
      xy[0] += target.mouseOffset[0];
      xy[1] += target.mouseOffset[1];
    }
    cls = me.lastCls;
    if (cls) 
    {
      me.removeCls(cls);
      delete me.lastCls;
    }
    cls = target.cls;
    if (cls) 
    {
      me.addCls(cls);
      me.lastCls = cls;
    }
    me.setWidth(target.width);
    if (me.anchor) 
    {
      me.constrainPosition = false;
    } else if (target.align) 
    {
      xy = me.getAlignToXY(target.el, target.align);
      me.constrainPosition = false;
    } else {
      me.constrainPosition = true;
    }
    me.resumeLayouts(true);
  }
  me.callParent([xy]);
}, hide: function() {
  delete this.activeTarget;
  this.callParent();
}}, 0, ["quicktip"], ["container", "component", "tooltip", "box", "tip", "panel", "quicktip"], {"container": true, "component": true, "tooltip": true, "box": true, "tip": true, "panel": true, "quicktip": true}, ["widget.quicktip"], 0, [Ext.tip, 'QuickTip', Ext, 'QuickTip'], 0));
;

(Ext.cmd.derive('Ext.tip.QuickTipManager', Ext.Base, {singleton: true, alternateClassName: 'Ext.QuickTips', disabled: false, init: function(autoRender, config) {
  var me = this;
  if (!me.tip) 
  {
    if (!Ext.isReady) 
    {
      Ext.onReady(function() {
  Ext.tip.QuickTipManager.init(autoRender, config);
});
      return false;
    }
    var tipConfig = Ext.apply({disabled: me.disabled, id: 'ext-quicktips-tip'}, config), className = tipConfig.className, xtype = tipConfig.xtype;
    if (className) 
    {
      delete tipConfig.className;
    } else if (xtype) 
    {
      className = 'widget.' + xtype;
      delete tipConfig.xtype;
    }
    if (autoRender !== false) 
    {
      tipConfig.renderTo = document.body;
    }
    me.tip = Ext.create(className || 'Ext.tip.QuickTip', tipConfig);
    Ext.quickTipsActive = true;
  }
}, destroy: function() {
  Ext.destroy(this.tip);
  this.tip = undefined;
}, ddDisable: function() {
  var me = this, tip = me.tip;
  if (tip && !me.disabled) 
  {
    tip.disable();
  }
}, ddEnable: function() {
  var me = this, tip = me.tip;
  if (tip && !me.disabled) 
  {
    tip.enable();
  }
}, enable: function() {
  var me = this, tip = me.tip;
  if (tip) 
  {
    tip.enable();
  }
  me.disabled = false;
}, disable: function() {
  var me = this, tip = me.tip;
  if (tip) 
  {
    tip.disable();
  }
  me.disabled = true;
}, isEnabled: function() {
  var tip = this.tip;
  return tip !== undefined && !tip.disabled;
}, getQuickTip: function() {
  return this.tip;
}, register: function() {
  var tip = this.tip;
  tip.register.apply(tip, arguments);
}, unregister: function() {
  var tip = this.tip;
  tip.unregister.apply(tip, arguments);
}, tips: function() {
  var tip = this.tip;
  tip.register.apply(tip, arguments);
}}, 0, 0, 0, 0, 0, 0, [Ext.tip, 'QuickTipManager', Ext, 'QuickTips'], 0));
;

(Ext.cmd.derive('Ext.app.Application', Ext.app.Controller, {scope: undefined, enableQuickTips: true, appFolder: 'app', appProperty: 'app', namespaces: [], autoCreateViewport: false, paths: null, onClassExtended: function(cls, data, hooks) {
  var Controller = Ext.app.Controller, proto = cls.prototype, requires = [], onBeforeClassCreated, paths, namespace, ns, appFolder;
  namespace = data.name || cls.superclass.name;
  appFolder = data.appFolder || cls.superclass.appFolder;
  if (namespace) 
  {
    data.$namespace = namespace;
    Ext.app.addNamespaces(namespace);
  }
  if (data.namespaces) 
  {
    Ext.app.addNamespaces(data.namespaces);
  }
  if (!data['paths processed']) 
  {
    if (namespace && appFolder) 
    {
      Ext.Loader.setPath(namespace, appFolder);
    }
    paths = data.paths;
    if (paths) 
    {
      for (ns in paths) 
        {
          if (paths.hasOwnProperty(ns)) 
          {
            Ext.Loader.setPath(ns, paths[ns]);
          }
        }
    }
  } else {
    delete data['paths processed'];
  }
  if (data.autoCreateViewport) 
  {
    Controller.processDependencies(proto, requires, namespace, 'view', ['Viewport']);
  }
  if (requires.length) 
  {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function(cls, data) {
  var args = Ext.Array.clone(arguments);
  Ext.require(requires, function() {
  return onBeforeClassCreated.apply(this, args);
});
};
  }
}, constructor: function(config) {
  var me = this;
  me.callParent(arguments);
  me.doInit(me);
  me.initNamespace();
  me.initControllers();
  me.onBeforeLaunch();
  me.finishInitControllers();
}, initNamespace: function() {
  var me = this, appProperty = me.appProperty, ns;
  ns = Ext.namespace(me.name);
  if (ns) 
  {
    ns.getApplication = function() {
  return me;
};
    if (appProperty) 
    {
      if (!ns[appProperty]) 
      {
        ns[appProperty] = me;
      }
    }
  }
}, initControllers: function() {
  var me = this, controllers = Ext.Array.from(me.controllers);
  me.controllers = new Ext.util.MixedCollection();
  for (var i = 0, ln = controllers.length; i < ln; i++) 
    {
      me.getController(controllers[i]);
    }
}, finishInitControllers: function() {
  var me = this, controllers, i, l;
  controllers = me.controllers.getRange();
  for (i = 0 , l = controllers.length; i < l; i++) 
    {
      controllers[i].finishInit(me);
    }
}, launch: Ext.emptyFn, onBeforeLaunch: function() {
  var me = this, controllers, c, cLen, controller;
  if (me.enableQuickTips) 
  {
    me.initQuickTips();
  }
  if (me.autoCreateViewport) 
  {
    me.initViewport();
  }
  me.launch.call(me.scope || me);
  me.launched = true;
  me.fireEvent('launch', me);
  controllers = me.controllers.items;
  cLen = controllers.length;
  for (c = 0; c < cLen; c++) 
    {
      controller = controllers[c];
      controller.onLaunch(me);
    }
}, getModuleClassName: function(name, kind) {
  return Ext.app.Controller.getFullName(name, kind, this.name).absoluteName;
}, initQuickTips: function() {
  Ext.tip.QuickTipManager.init();
}, initViewport: function() {
  var viewport = this.getView('Viewport');
  if (viewport) 
  {
    viewport.create();
  }
}, getController: function(name) {
  var me = this, controllers = me.controllers, className, controller;
  controller = controllers.get(name);
  if (!controller) 
  {
    className = me.getModuleClassName(name, 'controller');
    controller = Ext.create(className, {application: me, id: name});
    controllers.add(controller);
    if (me._initialized) 
    {
      controller.doInit(me);
    }
  }
  return controller;
}, getApplication: function() {
  return this;
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'Application'], 0));
;

(Ext.cmd.derive('Ext.app.domain.Controller', Ext.app.EventDomain, {singleton: true, type: 'controller', idProperty: 'id', constructor: function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.app.Controller);
}}, 1, 0, 0, 0, 0, 0, [Ext.app.domain, 'Controller'], 0));
;

(Ext.cmd.derive('Ext.container.Monitor', Ext.Base, {target: null, selector: '', scope: null, addHandler: null, removeHandler: null, invalidateHandler: null, disabled: 0, constructor: function(config) {
  Ext.apply(this, config);
}, bind: function(target) {
  var me = this;
  me.target = target;
  target.on('beforedestroy', me.disable, me);
  me.onContainerAdd(target);
}, unbind: function() {
  var me = this, target = me.target;
  if (target) 
  {
    target.un('beforedestroy', me.disable, me);
  }
  me.items = null;
}, disable: function() {
  ++this.disabled;
}, enable: function() {
  if (this.disabled > 0) 
  {
    --this.disabled;
  }
}, handleAdd: function(ct, comp) {
  if (!this.disabled) 
  {
    if (comp.is(this.selector)) 
    {
      this.onItemAdd(comp.ownerCt, comp);
    }
    if (comp.isQueryable) 
    {
      this.onContainerAdd(comp);
    }
  }
}, onItemAdd: function(ct, comp) {
  var me = this, items = me.items, handler = me.addHandler;
  if (!me.disabled) 
  {
    if (handler) 
    {
      handler.call(me.scope || comp, comp);
    }
    if (items) 
    {
      items.add(comp);
    }
  }
}, onItemRemove: function(ct, comp) {
  var me = this, items = me.items, handler = me.removeHandler;
  if (!me.disabled) 
  {
    if (handler) 
    {
      handler.call(me.scope || comp, comp);
    }
    if (items) 
    {
      items.remove(comp);
    }
  }
}, onContainerAdd: function(ct, preventChildren) {
  var me = this, items, len, handleAdd = me.handleAdd, handleRemove = me.handleRemove, i, comp;
  if (ct.isContainer) 
  {
    ct.on('add', handleAdd, me);
    ct.on('dockedadd', handleAdd, me);
    ct.on('remove', handleRemove, me);
    ct.on('dockedremove', handleRemove, me);
  }
  if (preventChildren !== true) 
  {
    items = ct.query(me.selector);
    for (i = 0 , len = items.length; i < len; ++i) 
      {
        comp = items[i];
        me.onItemAdd(comp.ownerCt, comp);
      }
  }
  items = ct.query('>container');
  for (i = 0 , len = items.length; i < len; ++i) 
    {
      me.onContainerAdd(items[i], true);
    }
}, handleRemove: function(ct, comp) {
  var me = this;
  if (!me.disabled) 
  {
    if (comp.is(me.selector)) 
    {
      me.onItemRemove(ct, comp);
    }
    if (comp.isQueryable) 
    {
      me.onContainerRemove(ct, comp);
    }
  }
}, onContainerRemove: function(ct, comp) {
  var me = this, items, i, len, item;
  if (!comp.isDestroyed && !comp.destroying && comp.isContainer) 
  {
    me.removeCtListeners(comp);
    items = comp.query(me.selector);
    for (i = 0 , len = items.length; i < len; ++i) 
      {
        item = items[i];
        me.onItemRemove(item.ownerCt, item);
      }
    items = comp.query('container');
    for (i = 0 , len = items.length; i < len; ++i) 
      {
        me.removeCtListeners(items[i]);
      }
  } else {
    me.invalidateItems(true);
  }
}, removeCtListeners: function(comp) {
  var me = this;
  comp.un('add', me.handleAdd, me);
  comp.un('dockedadd', me.handleAdd, me);
  comp.un('remove', me.handleRemove, me);
  comp.un('dockedremove', me.handleRemove, me);
}, getItems: function() {
  var me = this, items = me.items;
  if (!items) 
  {
    items = me.items = new Ext.util.MixedCollection();
    items.addAll(me.target.query(me.selector));
  }
  return items;
}, invalidateItems: function(triggerHandler) {
  var me = this, handler = me.invalidateHandler;
  if (triggerHandler && handler) 
  {
    handler.call(me.scope || me, me);
  }
  me.items = null;
}}, 1, 0, 0, 0, 0, 0, [Ext.container, 'Monitor'], 0));
;

(Ext.cmd.derive('Ext.data.IdGenerator', Ext.Base, {isGenerator: true, constructor: function(config) {
  var me = this;
  Ext.apply(me, config);
  if (me.id) 
  {
    Ext.data.IdGenerator.all[me.id] = me;
  }
}, getRecId: function(rec) {
  return rec.modelName + '-' + rec.internalId;
}, statics: {all: {}, get: function(config) {
  var generator, id, type;
  if (typeof config == 'string') 
  {
    id = type = config;
    config = null;
  } else if (config.isGenerator) 
  {
    return config;
  } else {
    id = config.id || config.type;
    type = config.type;
  }
  generator = this.all[id];
  if (!generator) 
  {
    generator = Ext.create('idgen.' + type, config);
  }
  return generator;
}}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'IdGenerator'], 0));
;

(Ext.cmd.derive('Ext.data.SortTypes', Ext.Base, {singleton: true, none: Ext.identityFn, stripTagsRE: /<\/?[^>]+>/gi, asText: function(s) {
  return String(s).replace(this.stripTagsRE, "");
}, asUCText: function(s) {
  return String(s).toUpperCase().replace(this.stripTagsRE, "");
}, asUCString: function(s) {
  return String(s).toUpperCase();
}, asDate: function(s) {
  if (!s) 
  {
    return 0;
  }
  if (Ext.isDate(s)) 
  {
    return s.getTime();
  }
  return Date.parse(String(s));
}, asFloat: function(s) {
  var val = parseFloat(String(s).replace(/,/g, ""));
  return isNaN(val) ? 0 : val;
}, asInt: function(s) {
  var val = parseInt(String(s).replace(/,/g, ""), 10);
  return isNaN(val) ? 0 : val;
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'SortTypes'], 0));
;

(Ext.cmd.derive('Ext.data.Types', Ext.Base, {singleton: true}, 0, 0, 0, 0, 0, 0, [Ext.data, 'Types'], function(Types) {
  var SortTypes = Ext.data.SortTypes;
  Ext.apply(Types, {stripRe: /[\$,%]/g, AUTO: {sortType: SortTypes.none, type: 'auto'}, STRING: {convert: function(v) {
  var defaultValue = this.useNull ? null : '';
  return (v === undefined || v === null) ? defaultValue : String(v);
}, sortType: SortTypes.asUCString, type: 'string'}, INT: {convert: function(v) {
  if (typeof v == 'number') 
  {
    return parseInt(v);
  }
  return v !== undefined && v !== null && v !== '' ? parseInt(String(v).replace(Types.stripRe, ''), 10) : (this.useNull ? null : 0);
}, sortType: SortTypes.none, type: 'int'}, FLOAT: {convert: function(v) {
  if (typeof v === 'number') 
  {
    return v;
  }
  return v !== undefined && v !== null && v !== '' ? parseFloat(String(v).replace(Types.stripRe, ''), 10) : (this.useNull ? null : 0);
}, sortType: SortTypes.none, type: 'float'}, BOOL: {convert: function(v) {
  if (typeof v === 'boolean') 
  {
    return v;
  }
  if (this.useNull && (v === undefined || v === null || v === '')) 
  {
    return null;
  }
  return v === 'true' || v == 1;
}, sortType: SortTypes.none, type: 'bool'}, DATE: {convert: function(v) {
  var df = this.dateReadFormat || this.dateFormat, parsed;
  if (!v) 
  {
    return null;
  }
  if (v instanceof Date) 
  {
    return v;
  }
  if (df) 
  {
    return Ext.Date.parse(v, df);
  }
  parsed = Date.parse(v);
  return parsed ? new Date(parsed) : null;
}, sortType: SortTypes.asDate, type: 'date'}});
  Types.BOOLEAN = Types.BOOL;
  Types.INTEGER = Types.INT;
  Types.NUMBER = Types.FLOAT;
}));
;

(Ext.cmd.derive('Ext.data.Field', Ext.Base, {isField: true, constructor: function(config) {
  var me = this, types = Ext.data.Types, st;
  if (Ext.isString(config)) 
  {
    config = {name: config};
  }
  Ext.apply(me, config);
  st = me.sortType;
  if (me.type) 
  {
    if (Ext.isString(me.type)) 
    {
      me.type = types[me.type.toUpperCase()] || types.AUTO;
    }
  } else {
    me.type = types.AUTO;
  }
  if (Ext.isString(st)) 
  {
    me.sortType = Ext.data.SortTypes[st];
  } else if (Ext.isEmpty(st)) 
  {
    me.sortType = me.type.sortType;
  }
  if (!config.hasOwnProperty('convert')) 
  {
    me.convert = me.type.convert;
  } else if (!me.convert && me.type.convert && !config.hasOwnProperty('defaultValue')) 
  {
    me.defaultValue = me.type.convert(me.defaultValue);
  }
  if (config.convert) 
  {
    me.hasCustomConvert = true;
  }
}, dateFormat: null, dateReadFormat: null, dateWriteFormat: null, useNull: false, defaultValue: "", mapping: null, sortType: null, sortDir: "ASC", allowBlank: true, persist: true}, 1, 0, 0, 0, ["data.field"], 0, [Ext.data, 'Field'], 0));
;

(Ext.cmd.derive('Ext.data.Errors', Ext.util.MixedCollection, {isValid: function() {
  return this.length === 0;
}, getByField: function(fieldName) {
  var errors = [], error, i;
  for (i = 0; i < this.length; i++) 
    {
      error = this.items[i];
      if (error.field == fieldName) 
      {
        errors.push(error);
      }
    }
  return errors;
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'Errors'], 0));
;

(Ext.cmd.derive('Ext.data.validations', Ext.Base, {singleton: true, presenceMessage: 'must be present', lengthMessage: 'is the wrong length', formatMessage: 'is the wrong format', inclusionMessage: 'is not included in the list of acceptable values', exclusionMessage: 'is not an acceptable value', emailMessage: 'is not a valid email address', emailRe: /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/, presence: function(config, value) {
  if (arguments.length === 1) 
  {
    value = config;
  }
  return !!value || value === 0 || value === false;
}, length: function(config, value) {
  if (value === undefined || value === null) 
  {
    return false;
  }
  var length = value.length, min = config.min, max = config.max;
  if ((min && length < min) || (max && length > max)) 
  {
    return false;
  } else {
    return true;
  }
}, email: function(config, email) {
  return Ext.data.validations.emailRe.test(email);
}, format: function(config, value) {
  return !!(config.matcher && config.matcher.test(value));
}, inclusion: function(config, value) {
  return config.list && Ext.Array.indexOf(config.list, value) != -1;
}, exclusion: function(config, value) {
  return config.list && Ext.Array.indexOf(config.list, value) == -1;
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'validations'], 0));
;

(Ext.cmd.derive('Ext.data.Model', Ext.Base, {alternateClassName: 'Ext.data.Record', compareConvertFields: function(f1, f2) {
  var f1SpecialConvert = f1.convert && f1.type && f1.convert !== f1.type.convert, f2SpecialConvert = f2.convert && f2.type && f2.convert !== f2.type.convert;
  if (f1SpecialConvert && !f2SpecialConvert) 
  {
    return 1;
  }
  if (!f1SpecialConvert && f2SpecialConvert) 
  {
    return -1;
  }
  return 0;
}, itemNameFn: function(item) {
  return item.name;
}, onClassExtended: function(cls, data, hooks) {
  var onBeforeClassCreated = hooks.onBeforeCreated;
  hooks.onBeforeCreated = function(cls, data) {
  var me = this, name = Ext.getClassName(cls), prototype = cls.prototype, superCls = cls.prototype.superclass, validations = data.validations || [], fields = data.fields || [], field, associationsConfigs = data.associations || [], addAssociations = function(items, type) {
  var i = 0, len, item;
  if (items) 
  {
    items = Ext.Array.from(items);
    for (len = items.length; i < len; ++i) 
      {
        item = items[i];
        if (!Ext.isObject(item)) 
        {
          item = {model: item};
        }
        item.type = type;
        associationsConfigs.push(item);
      }
  }
}, idgen = data.idgen, fieldsMixedCollection = new Ext.util.MixedCollection(false, prototype.itemNameFn), associationsMixedCollection = new Ext.util.MixedCollection(false, prototype.itemNameFn), superValidations = superCls.validations, superFields = superCls.fields, superAssociations = superCls.associations, associationConfig, i, ln, dependencies = [], idProperty = 'idProperty' in data ? data.idProperty : prototype.idProperty, idField = idProperty ? (idProperty.isField ? idProperty : new Ext.data.Field(idProperty)) : null, idFieldDefined = false, onFieldAddReplace = function(arg0, arg1, arg2) {
  var newField, pos;
  if (fieldsMixedCollection.events.add.firing) 
  {
    pos = arg0;
    newField = arg1;
  } else {
    newField = arg2;
    pos = arg1.originalIndex;
  }
  newField.originalIndex = pos;
  if (idField && ((newField.mapping && (newField.mapping === idField.mapping)) || (newField.name === idField.name))) 
  {
    prototype.idField = newField;
    idFieldDefined = true;
    newField.defaultValue = undefined;
  }
}, clsProxy = data.proxy, fieldConvertSortFn = function() {
  fieldsMixedCollection.sortBy(prototype.compareConvertFields);
};
  cls.modelName = name;
  prototype.modelName = name;
  if (superValidations) 
  {
    validations = superValidations.concat(validations);
  }
  data.validations = validations;
  if (superFields) 
  {
    fields = superFields.items.concat(fields);
  }
  fieldsMixedCollection.on({add: onFieldAddReplace, replace: onFieldAddReplace});
  for (i = 0 , ln = fields.length; i < ln; ++i) 
    {
      field = fields[i];
      fieldsMixedCollection.add(field.isField ? field : new Ext.data.Field(field));
    }
  if (idField && !idFieldDefined) 
  {
    prototype.idField = idField;
    idField.defaultValue = undefined;
    fieldsMixedCollection.add(idField);
  }
  fieldConvertSortFn();
  fieldsMixedCollection.on({add: fieldConvertSortFn, replace: fieldConvertSortFn});
  data.fields = fieldsMixedCollection;
  if (idgen) 
  {
    data.idgen = Ext.data.IdGenerator.get(idgen);
  }
  addAssociations(data.belongsTo, 'belongsTo');
  delete data.belongsTo;
  addAssociations(data.hasMany, 'hasMany');
  delete data.hasMany;
  addAssociations(data.hasOne, 'hasOne');
  delete data.hasOne;
  if (superAssociations) 
  {
    associationsConfigs = superAssociations.items.concat(associationsConfigs);
  }
  Ext.Array.forEach(Ext.ModelManager.associationStack, function(item) {
  var checkItem = function(item, Cls) {
  Cls = Cls;
  if (item.ownerModel === Cls.modelName) 
  {
    return true;
  } else if (Cls.superclass) 
  {
    return checkItem(item, Cls.superclass);
  }
  return false;
}, newItem;
  if (checkItem(item, superCls)) 
  {
    newItem = Ext.clone(item);
    newItem.ownerModel = this.modelName;
    associationsConfigs.push(newItem);
  }
  ;
}, this);
  for (i = 0 , ln = associationsConfigs.length; i < ln; ++i) 
    {
      dependencies.push('association.' + associationsConfigs[i].type.toLowerCase());
    }
  if (clsProxy) 
  {
    if (!clsProxy.isProxy) 
    {
      dependencies.push('proxy.' + (clsProxy.type || clsProxy));
    }
  } else if (!cls.prototype.proxy) 
  {
    cls.prototype.proxy = cls.prototype.defaultProxyType;
    dependencies.push('proxy.' + cls.prototype.defaultProxyType);
  }
  Ext.require(dependencies, function() {
  if (name) 
  {
    Ext.ModelManager.registerType(name, cls);
    for (i = 0 , ln = associationsConfigs.length; i < ln; ++i) 
      {
        associationConfig = associationsConfigs[i];
        if (associationConfig.isAssociation) 
        {
          associationConfig = Ext.applyIf({ownerModel: name, associatedModel: associationConfig.model}, associationConfig.initialConfig);
        } else {
          Ext.apply(associationConfig, {ownerModel: name, associatedModel: associationConfig.model});
        }
        if (Ext.ModelManager.getModel(associationConfig.model) === undefined) 
        {
          Ext.ModelManager.registerDeferredAssociation(associationConfig);
        } else {
          associationsMixedCollection.add(Ext.data.association.Association.create(associationConfig));
        }
      }
  }
  data.associations = associationsMixedCollection;
  onBeforeClassCreated.call(me, cls, data, hooks);
  if (clsProxy && clsProxy.isProxy) 
  {
    cls.setProxy(clsProxy);
  }
  if (name) 
  {
    Ext.ModelManager.onModelDefined(cls);
  }
});
};
}, inheritableStatics: {setProxy: function(proxy) {
  if (!proxy.isProxy) 
  {
    if (typeof proxy == "string") 
    {
      proxy = {type: proxy};
    }
    proxy = Ext.createByAlias("proxy." + proxy.type, proxy);
  }
  proxy.setModel(this);
  this.proxy = this.prototype.proxy = proxy;
  return proxy;
}, getProxy: function() {
  var proxy = this.proxy;
  if (!proxy) 
  {
    proxy = this.prototype.proxy;
    if (proxy.isProxy) 
    {
      proxy = proxy.clone();
    }
    return this.setProxy(proxy);
  }
  return proxy;
}, setFields: function(fields, idProperty, clientIdProperty) {
  var me = this, newField, idField, idFieldDefined = false, proto = me.prototype, prototypeFields = proto.fields, superFields = proto.superclass.fields, len, i;
  if (idProperty) 
  {
    proto.idProperty = idProperty;
    idField = idProperty.isField ? idProperty : new Ext.data.Field(idProperty);
  }
  if (clientIdProperty) 
  {
    proto.clientIdProperty = clientIdProperty;
  }
  if (prototypeFields) 
  {
    prototypeFields.clear();
  } else {
    prototypeFields = me.prototype.fields = new Ext.util.MixedCollection(false, function(field) {
  return field.name;
});
  }
  if (superFields) 
  {
    fields = superFields.items.concat(fields);
  }
  for (i = 0 , len = fields.length; i < len; i++) 
    {
      newField = new Ext.data.Field(fields[i]);
      if (idField && ((newField.mapping && (newField.mapping === idField.mapping)) || (newField.name === idField.name))) 
      {
        idFieldDefined = true;
        newField.defaultValue = undefined;
      }
      prototypeFields.add(newField);
    }
  if (idField && !idFieldDefined) 
  {
    idField.defaultValue = undefined;
    prototypeFields.add(idField);
  }
  me.fields = prototypeFields;
  return prototypeFields;
}, getFields: function() {
  return this.prototype.fields.items;
}, load: function(id, config) {
  config = Ext.apply({}, config);
  config = Ext.applyIf(config, {action: 'read', id: id});
  var operation = new Ext.data.Operation(config), scope = config.scope || this, callback;
  callback = function(operation) {
  var record = null, success = operation.wasSuccessful();
  if (success) 
  {
    record = operation.getRecords()[0];
    if (!record.hasId()) 
    {
      record.setId(id);
    }
    Ext.callback(config.success, scope, [record, operation]);
  } else {
    Ext.callback(config.failure, scope, [record, operation]);
  }
  Ext.callback(config.callback, scope, [record, operation, success]);
};
  this.getProxy().read(operation, callback, this);
}}, statics: {PREFIX: 'ext-record', AUTO_ID: 1, EDIT: 'edit', REJECT: 'reject', COMMIT: 'commit', id: function(rec) {
  var id = [this.PREFIX, '-', this.AUTO_ID++].join('');
  rec.phantom = true;
  rec.internalId = id;
  return id;
}}, idgen: {isGenerator: true, type: 'default', generate: function() {
  return null;
}, getRecId: function(rec) {
  return rec.modelName + '-' + rec.internalId;
}}, editing: false, dirty: false, persistenceProperty: 'data', evented: false, isModel: true, phantom: false, idProperty: 'id', clientIdProperty: null, defaultProxyType: 'ajax', emptyData: [], constructor: function(data, id, raw, convertedData) {
  var me = this, passedId = (id || id === 0), hasId, fields, length, field, name, value, newId, persistenceProperty, idProperty = me.idProperty, idField = me.idField, i;
  me.raw = raw || data;
  me.modified = {};
  persistenceProperty = me[me.persistenceProperty] = convertedData || {};
  me.data = me[me.persistenceProperty];
  me.mixins.observable.constructor.call(me);
  if (!convertedData) 
  {
    if (data) 
    {
      if (!passedId && idProperty) 
      {
        id = data[idProperty];
        hasId = (id || id === 0);
      }
    } else {
      data = me.emptyData;
    }
    fields = me.fields.items;
    length = fields.length;
    i = 0;
    if (Ext.isArray(data)) 
    {
      for (; i < length; i++) 
        {
          field = fields[i];
          name = field.name;
          value = data[field.originalIndex];
          if (value === undefined) 
          {
            value = field.defaultValue;
          }
          if (field.convert) 
          {
            value = field.convert(value, me);
          }
          if (value !== undefined) 
          {
            persistenceProperty[name] = value;
          }
        }
    } else {
      for (; i < length; i++) 
        {
          field = fields[i];
          name = field.name;
          value = data[name];
          if (value === undefined) 
          {
            value = field.defaultValue;
          }
          if (field.convert) 
          {
            value = field.convert(value, me);
          }
          if (value !== undefined) 
          {
            persistenceProperty[name] = value;
          }
        }
    }
  }
  me.stores = [];
  if (passedId) 
  {
    hasId = true;
    persistenceProperty[idProperty] = idField && idField.convert ? idField.convert(id, me) : id;
  } else if (!hasId) 
  {
    newId = me.idgen.generate();
    if (newId != null) 
    {
      me.preventInternalUpdate = true;
      me.setId(newId);
      delete me.preventInternalUpdate;
    }
  }
  me.internalId = hasId ? id : Ext.data.Model.id(me);
  if (typeof me.init == 'function') 
  {
    me.init();
  }
  me.id = me.idgen.getRecId(me);
}, get: function(field) {
  return this[this.persistenceProperty][field];
}, _singleProp: {}, set: function(fieldName, newValue) {
  var me = this, data = me[me.persistenceProperty], fields = me.fields, modified = me.modified, single = (typeof fieldName == 'string'), currentValue, field, idChanged, key, modifiedFieldNames, name, oldId, newId, value, values;
  if (single) 
  {
    values = me._singleProp;
    values[fieldName] = newValue;
  } else {
    values = fieldName;
  }
  for (name in values) 
    {
      if (values.hasOwnProperty(name)) 
      {
        value = values[name];
        if (fields && (field = fields.get(name)) && field.convert) 
        {
          value = field.convert(value, me);
        }
        currentValue = data[name];
        if (me.isEqual(currentValue, value)) 
        {
          continue;
        }
        data[name] = value;
        (modifiedFieldNames || (modifiedFieldNames = [])).push(name);
        if (field && field.persist) 
        {
          if (modified.hasOwnProperty(name)) 
          {
            if (me.isEqual(modified[name], value)) 
            {
              delete modified[name];
              me.dirty = false;
              for (key in modified) 
                {
                  if (modified.hasOwnProperty(key)) 
                  {
                    me.dirty = true;
                    break;
                  }
                }
            }
          } else {
            me.dirty = true;
            modified[name] = currentValue;
          }
        }
        if (name == me.idProperty) 
        {
          idChanged = true;
          oldId = currentValue;
          newId = value;
        }
      }
    }
  if (single) 
  {
    delete values[fieldName];
  }
  if (idChanged) 
  {
    me.changeId(oldId, newId);
  }
  if (!me.editing && modifiedFieldNames) 
  {
    me.afterEdit(modifiedFieldNames);
  }
  return modifiedFieldNames || null;
}, copyFrom: function(sourceRecord) {
  var me = this, fields = me.fields.items, fieldCount = fields.length, modifiedFieldNames = [], field, i = 0, myData, sourceData, idProperty = me.idProperty, name, value;
  if (sourceRecord) 
  {
    myData = me[me.persistenceProperty];
    sourceData = sourceRecord[sourceRecord.persistenceProperty];
    for (; i < fieldCount; i++) 
      {
        field = fields[i];
        name = field.name;
        if (name != idProperty) 
        {
          value = sourceData[name];
          if (value !== undefined && !me.isEqual(myData[name], value)) 
          {
            myData[name] = value;
            modifiedFieldNames.push(name);
          }
        }
      }
    if (me.phantom && !sourceRecord.phantom) 
    {
      me.beginEdit();
      me.setId(sourceRecord.getId());
      me.endEdit(true);
      me.commit(true);
    }
  }
  return modifiedFieldNames;
}, isEqual: function(a, b) {
  if (a instanceof Date && b instanceof Date) 
  {
    return a.getTime() === b.getTime();
  }
  return a === b;
}, beginEdit: function() {
  var me = this, key, data, o;
  if (!me.editing) 
  {
    me.editing = true;
    me.dirtySave = me.dirty;
    o = me[me.persistenceProperty];
    data = me.dataSave = {};
    for (key in o) 
      {
        if (o.hasOwnProperty(key)) 
        {
          data[key] = o[key];
        }
      }
    o = me.modified;
    data = me.modifiedSave = {};
    for (key in o) 
      {
        if (o.hasOwnProperty(key)) 
        {
          data[key] = o[key];
        }
      }
  }
}, cancelEdit: function() {
  var me = this;
  if (me.editing) 
  {
    me.editing = false;
    me.modified = me.modifiedSave;
    me[me.persistenceProperty] = me.dataSave;
    me.dirty = me.dirtySave;
    me.modifiedSave = me.dataSave = me.dirtySave = null;
  }
}, endEdit: function(silent, modifiedFieldNames) {
  var me = this, dataSave, changed;
  silent = silent === true;
  if (me.editing) 
  {
    me.editing = false;
    dataSave = me.dataSave;
    me.modifiedSave = me.dataSave = me.dirtySave = null;
    if (!silent) 
    {
      if (!modifiedFieldNames) 
      {
        modifiedFieldNames = me.getModifiedFieldNames(dataSave);
      }
      changed = me.dirty || modifiedFieldNames.length > 0;
      if (changed) 
      {
        me.afterEdit(modifiedFieldNames);
      }
    }
  }
}, getModifiedFieldNames: function(saved) {
  var me = this, data = me[me.persistenceProperty], modified = [], key;
  saved = saved || me.dataSave;
  for (key in data) 
    {
      if (data.hasOwnProperty(key)) 
      {
        if (!me.isEqual(data[key], saved[key])) 
        {
          modified.push(key);
        }
      }
    }
  return modified;
}, getChanges: function() {
  var modified = this.modified, changes = {}, field;
  for (field in modified) 
    {
      if (modified.hasOwnProperty(field)) 
      {
        changes[field] = this.get(field);
      }
    }
  return changes;
}, isModified: function(fieldName) {
  return this.modified.hasOwnProperty(fieldName);
}, setDirty: function() {
  var me = this, fields = me.fields.items, fLen = fields.length, field, name, f;
  me.dirty = true;
  for (f = 0; f < fLen; f++) 
    {
      field = fields[f];
      if (field.persist) 
      {
        name = field.name;
        me.modified[name] = me.get(name);
      }
    }
}, reject: function(silent) {
  var me = this, modified = me.modified, field;
  for (field in modified) 
    {
      if (modified.hasOwnProperty(field)) 
      {
        if (typeof modified[field] != "function") 
        {
          me[me.persistenceProperty][field] = modified[field];
        }
      }
    }
  me.dirty = false;
  me.editing = false;
  me.modified = {};
  if (silent !== true) 
  {
    me.afterReject();
  }
}, commit: function(silent, modifiedFieldNames) {
  var me = this;
  me.phantom = me.dirty = me.editing = false;
  me.modified = {};
  if (silent !== true) 
  {
    me.afterCommit(modifiedFieldNames);
  }
}, copy: function(newId) {
  var me = this;
  return new me.self(me.raw, newId, null, Ext.apply({}, me[me.persistenceProperty]));
}, setProxy: function(proxy) {
  if (!proxy.isProxy) 
  {
    if (typeof proxy === "string") 
    {
      proxy = {type: proxy};
    }
    proxy = Ext.createByAlias("proxy." + proxy.type, proxy);
  }
  proxy.setModel(this.self);
  this.proxy = proxy;
  return proxy;
}, getProxy: function() {
  return this.hasOwnProperty('proxy') ? this.proxy : this.self.getProxy();
}, validate: function() {
  var errors = new Ext.data.Errors(), validations = this.validations, validators = Ext.data.validations, length, validation, field, valid, type, i;
  if (validations) 
  {
    length = validations.length;
    for (i = 0; i < length; i++) 
      {
        validation = validations[i];
        field = validation.field || validation.name;
        type = validation.type;
        valid = validators[type](validation, this.get(field));
        if (!valid) 
        {
          errors.add({field: field, message: validation.message || validators[type + 'Message']});
        }
      }
  }
  return errors;
}, isValid: function() {
  return this.validate().isValid();
}, save: function(options) {
  options = Ext.apply({}, options);
  var me = this, action = me.phantom ? 'create' : 'update', scope = options.scope || me, stores = me.stores, i = 0, storeCount, store, operation, callback;
  Ext.apply(options, {records: [me], action: action});
  operation = new Ext.data.Operation(options);
  callback = function(operation) {
  var success = operation.wasSuccessful();
  if (success) 
  {
    for (storeCount = stores.length; i < storeCount; i++) 
      {
        store = stores[i];
        store.fireEvent('write', store, operation);
        store.fireEvent('datachanged', store);
      }
    Ext.callback(options.success, scope, [me, operation]);
  } else {
    Ext.callback(options.failure, scope, [me, operation]);
  }
  Ext.callback(options.callback, scope, [me, operation, success]);
};
  me.getProxy()[action](operation, callback, me);
  return me;
}, destroy: function(options) {
  options = Ext.apply({records: [this], action: 'destroy'}, options);
  var me = this, isNotPhantom = me.phantom !== true, scope = options.scope || me, stores, i = 0, storeCount, store, args, operation, callback;
  operation = new Ext.data.Operation(options);
  callback = function(operation) {
  args = [me, operation];
  stores = Ext.Array.clone(me.stores);
  if (operation.wasSuccessful()) 
  {
    for (storeCount = stores.length; i < storeCount; i++) 
      {
        store = stores[i];
        if (store.remove) 
        {
          store.remove(me, true);
        } else {
          store.fireEvent('bulkremove', store, [me], [store.indexOf(me)], false);
        }
        if (isNotPhantom) 
        {
          store.fireEvent('write', store, operation);
        }
      }
    me.clearListeners();
    Ext.callback(options.success, scope, args);
  } else {
    Ext.callback(options.failure, scope, args);
  }
  Ext.callback(options.callback, scope, args);
};
  if (isNotPhantom) 
  {
    me.getProxy().destroy(operation, callback, me);
  } else {
    operation.complete = operation.success = true;
    operation.resultSet = me.getProxy().reader.nullResultSet;
    callback(operation);
  }
  return me;
}, getId: function() {
  return this.get(this.idField.name);
}, getObservableId: function() {
  return this.id;
}, setId: function(id) {
  this.set(this.idProperty, id);
}, changeId: function(oldId, newId) {
  var me = this, hasOldId, hasId, oldInternalId;
  if (!me.preventInternalUpdate) 
  {
    hasOldId = me.hasId(oldId);
    hasId = me.hasId(newId);
    oldInternalId = me.internalId;
    me.phantom = !hasId;
    if (hasId !== hasOldId || (hasId && hasOldId)) 
    {
      me.internalId = hasId ? newId : Ext.data.Model.id(me);
    }
    me.fireEvent('idchanged', me, oldId, newId, oldInternalId);
    me.callStore('onIdChanged', oldId, newId, oldInternalId);
  }
}, hasId: function(id) {
  if (arguments.length === 0) 
  {
    id = this.getId();
  }
  return !!(id || id === 0);
}, join: function(store) {
  var me = this;
  if (!me.stores.length) 
  {
    me.stores[0] = store;
  } else {
    Ext.Array.include(this.stores, store);
  }
  this.store = this.stores[0];
}, unjoin: function(store) {
  Ext.Array.remove(this.stores, store);
  this.store = this.stores[0] || null;
}, afterEdit: function(modifiedFieldNames) {
  this.callStore('afterEdit', modifiedFieldNames);
}, afterReject: function() {
  this.callStore('afterReject');
}, afterCommit: function(modifiedFieldNames) {
  this.callStore('afterCommit', modifiedFieldNames);
}, callStore: function(fn) {
  var args = Ext.Array.clone(arguments), stores = this.stores, i = 0, len = stores.length, store;
  args[0] = this;
  for (; i < len; ++i) 
    {
      store = stores[i];
      if (store && Ext.isFunction(store[fn])) 
      {
        store[fn].apply(store, args);
      }
    }
}, getData: function(includeAssociated) {
  var me = this, fields = me.fields.items, fLen = fields.length, data = {}, name, f;
  for (f = 0; f < fLen; f++) 
    {
      name = fields[f].name;
      data[name] = me.get(name);
    }
  if (includeAssociated === true) 
  {
    Ext.apply(data, me.getAssociatedData());
  }
  return data;
}, getAssociatedData: function() {
  return this.prepareAssociatedData({}, 1);
}, prepareAssociatedData: function(seenKeys, depth) {
  var me = this, associations = me.associations.items, associationCount = associations.length, associationData = {}, toRead = [], toReadKey = [], toReadIndex = [], associatedStore, associatedRecords, associatedRecord, o, index, result, seenDepth, associationId, associatedRecordCount, association, i, j, type, name;
  for (i = 0; i < associationCount; i++) 
    {
      association = associations[i];
      associationId = association.associationId;
      seenDepth = seenKeys[associationId];
      if (seenDepth && seenDepth !== depth) 
      {
        continue;
      }
      seenKeys[associationId] = depth;
      type = association.type;
      name = association.name;
      if (type == 'hasMany') 
      {
        associatedStore = me[association.storeName];
        associationData[name] = [];
        if (associatedStore && associatedStore.getCount() > 0) 
        {
          associatedRecords = associatedStore.data.items;
          associatedRecordCount = associatedRecords.length;
          for (j = 0; j < associatedRecordCount; j++) 
            {
              associatedRecord = associatedRecords[j];
              associationData[name][j] = associatedRecord.getData();
              toRead.push(associatedRecord);
              toReadKey.push(name);
              toReadIndex.push(j);
            }
        }
      } else if (type == 'belongsTo' || type == 'hasOne') 
      {
        associatedRecord = me[association.instanceName];
        if (associatedRecord !== undefined) 
        {
          associationData[name] = associatedRecord.getData();
          toRead.push(associatedRecord);
          toReadKey.push(name);
          toReadIndex.push(-1);
        }
      }
    }
  for (i = 0 , associatedRecordCount = toRead.length; i < associatedRecordCount; ++i) 
    {
      associatedRecord = toRead[i];
      o = associationData[toReadKey[i]];
      index = toReadIndex[i];
      result = associatedRecord.prepareAssociatedData(seenKeys, depth + 1);
      if (index === -1) 
      {
        Ext.apply(o, result);
      } else {
        Ext.apply(o[index], result);
      }
    }
  return associationData;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.data, 'Model', Ext.data, 'Record'], 0));
;

(Ext.cmd.derive('Ext.data.proxy.Server', Ext.data.proxy.Proxy, {alternateClassName: 'Ext.data.ServerProxy', pageParam: 'page', startParam: 'start', limitParam: 'limit', groupParam: 'group', groupDirectionParam: 'groupDir', sortParam: 'sort', filterParam: 'filter', directionParam: 'dir', idParam: 'id', simpleSortMode: false, simpleGroupMode: false, noCache: true, cacheString: "_dc", timeout: 30000, constructor: function(config) {
  var me = this;
  config = config || {};
  me.callParent([config]);
  me.extraParams = config.extraParams || {};
  me.api = Ext.apply({}, config.api || me.api);
  me.nocache = me.noCache;
}, create: function() {
  return this.doRequest.apply(this, arguments);
}, read: function() {
  return this.doRequest.apply(this, arguments);
}, update: function() {
  return this.doRequest.apply(this, arguments);
}, destroy: function() {
  return this.doRequest.apply(this, arguments);
}, setExtraParam: function(name, value) {
  this.extraParams[name] = value;
}, buildRequest: function(operation) {
  var me = this, params = operation.params = Ext.apply({}, operation.params, me.extraParams), request;
  Ext.applyIf(params, me.getParams(operation));
  if (operation.id !== undefined && params[me.idParam] === undefined) 
  {
    params[me.idParam] = operation.id;
  }
  request = new Ext.data.Request({params: params, action: operation.action, records: operation.records, operation: operation, url: operation.url, proxy: me});
  request.url = me.buildUrl(request);
  operation.request = request;
  return request;
}, processResponse: function(success, operation, request, response, callback, scope) {
  var me = this, reader, result;
  if (success === true) 
  {
    reader = me.getReader();
    reader.applyDefaults = operation.action === 'read';
    result = reader.read(me.extractResponseData(response));
    if (result.success !== false) 
    {
      Ext.apply(operation, {response: response, resultSet: result});
      operation.commitRecords(result.records);
      operation.setCompleted();
      operation.setSuccessful();
    } else {
      operation.setException(result.message);
      me.fireEvent('exception', this, response, operation);
    }
  } else {
    me.setException(operation, response);
    me.fireEvent('exception', this, response, operation);
  }
  if (typeof callback == 'function') 
  {
    callback.call(scope || me, operation);
  }
  me.afterRequest(request, success);
}, setException: function(operation, response) {
  operation.setException({status: response.status, statusText: response.statusText});
}, extractResponseData: Ext.identityFn, applyEncoding: function(value) {
  return Ext.encode(value);
}, encodeSorters: function(sorters) {
  var min = [], length = sorters.length, i = 0;
  for (; i < length; i++) 
    {
      min[i] = {property: sorters[i].property, direction: sorters[i].direction};
    }
  return this.applyEncoding(min);
}, encodeFilters: function(filters) {
  var min = [], length = filters.length, i = 0;
  for (; i < length; i++) 
    {
      min[i] = {property: filters[i].property, value: filters[i].value};
    }
  return this.applyEncoding(min);
}, getParams: function(operation) {
  var me = this, params = {}, isDef = Ext.isDefined, groupers = operation.groupers, sorters = operation.sorters, filters = operation.filters, page = operation.page, start = operation.start, limit = operation.limit, simpleSortMode = me.simpleSortMode, simpleGroupMode = me.simpleGroupMode, pageParam = me.pageParam, startParam = me.startParam, limitParam = me.limitParam, groupParam = me.groupParam, groupDirectionParam = me.groupDirectionParam, sortParam = me.sortParam, filterParam = me.filterParam, directionParam = me.directionParam, hasGroups, index;
  if (pageParam && isDef(page)) 
  {
    params[pageParam] = page;
  }
  if (startParam && isDef(start)) 
  {
    params[startParam] = start;
  }
  if (limitParam && isDef(limit)) 
  {
    params[limitParam] = limit;
  }
  hasGroups = groupParam && groupers && groupers.length > 0;
  if (hasGroups) 
  {
    if (simpleGroupMode) 
    {
      params[groupParam] = groupers[0].property;
      params[groupDirectionParam] = groupers[0].direction || 'ASC';
    } else {
      params[groupParam] = me.encodeSorters(groupers);
    }
  }
  if (sortParam && sorters && sorters.length > 0) 
  {
    if (simpleSortMode) 
    {
      index = 0;
      if (sorters.length > 1 && hasGroups) 
      {
        index = 1;
      }
      params[sortParam] = sorters[index].property;
      params[directionParam] = sorters[index].direction;
    } else {
      params[sortParam] = me.encodeSorters(sorters);
    }
  }
  if (filterParam && filters && filters.length > 0) 
  {
    params[filterParam] = me.encodeFilters(filters);
  }
  return params;
}, buildUrl: function(request) {
  var me = this, url = me.getUrl(request);
  if (me.noCache) 
  {
    url = Ext.urlAppend(url, Ext.String.format("{0}={1}", me.cacheString, Ext.Date.now()));
  }
  return url;
}, getUrl: function(request) {
  return request.url || this.api[request.action] || this.url;
}, doRequest: function(operation, callback, scope) {
}, afterRequest: Ext.emptyFn, onDestroy: function() {
  Ext.destroy(this.reader, this.writer);
}}, 1, 0, 0, 0, ["proxy.server"], 0, [Ext.data.proxy, 'Server', Ext.data, 'ServerProxy'], 0));
;

(Ext.cmd.derive('Ext.data.proxy.Ajax', Ext.data.proxy.Server, {alternateClassName: ['Ext.data.HttpProxy', 'Ext.data.AjaxProxy'], actionMethods: {create: 'POST', read: 'GET', update: 'POST', destroy: 'POST'}, defaultActionMethods: {create: 'POST', read: 'GET', update: 'POST', destroy: 'POST'}, binary: false, paramsAsJson: false, doRequest: function(operation, callback, scope) {
  var me = this, writer = me.getWriter(), request = me.buildRequest(operation), method = me.getMethod(request);
  if (operation.allowWrite()) 
  {
    request = writer.write(request);
  }
  Ext.apply(request, {binary: me.binary, headers: me.headers, timeout: me.timeout, scope: me, callback: me.createRequestCallback(request, operation, callback, scope), method: method, disableCaching: false});
  if (method.toUpperCase() !== 'GET' && me.paramsAsJson) 
  {
    request = Ext.apply({jsonData: request.params}, request);
    delete request.params;
  }
  Ext.Ajax.request(request);
  return request;
}, getMethod: function(request) {
  var actions = this.actionMethods, action = request.action, method;
  if (actions) 
  {
    method = actions[action];
  }
  return method || this.defaultActionMethods[action];
}, createRequestCallback: function(request, operation, callback, scope) {
  var me = this;
  return function(options, success, response) {
  me.processResponse(success, operation, request, response, callback, scope);
};
}}, 0, 0, 0, 0, ["proxy.ajax"], 0, [Ext.data.proxy, 'Ajax', Ext.data, 'HttpProxy', Ext.data, 'AjaxProxy'], 0));
;

(Ext.cmd.derive('Ext.data.PageMap', Ext.util.LruCache, {clear: function(initial) {
  var me = this;
  me.pageMapGeneration = (me.pageMapGeneration || 0) + 1;
  me.callParent(arguments);
}, forEach: function(fn, scope) {
  var me = this, pageNumbers = Ext.Object.getKeys(me.map), pageCount = pageNumbers.length, i, j, pageNumber, page, pageSize;
  for (i = 0; i < pageCount; i++) 
    {
      pageNumbers[i] = +pageNumbers[i];
    }
  Ext.Array.sort(pageNumbers, function(a, b) {
  return a - b;
});
  scope = scope || me;
  for (i = 0; i < pageCount; i++) 
    {
      pageNumber = pageNumbers[i];
      page = me.getPage(pageNumber);
      pageSize = page.length;
      for (j = 0; j < pageSize; j++) 
        {
          if (fn.call(scope, page[j], (pageNumber - 1) * me.pageSize + j) === false) 
          {
            return;
          }
        }
    }
}, findBy: function(fn, scope) {
  var me = this, result = null;
  scope = scope || me;
  me.forEach(function(rec, index) {
  if (fn.call(scope, rec, index)) 
  {
    result = rec;
    return false;
  }
});
  return result;
}, findIndexBy: function(fn, scope) {
  var me = this, result = -1;
  scope = scope || me;
  me.forEach(function(rec, index) {
  if (fn.call(scope, rec)) 
  {
    result = index;
    return false;
  }
});
  return result;
}, getPageFromRecordIndex: function() {
  return Ext.data.Store.prototype.getPageFromRecordIndex.apply(this, arguments);
}, addAll: function(records) {
  this.addPage(1, records);
}, addPage: function(pageNumber, records) {
  var me = this, lastPage = pageNumber + Math.floor((records.length - 1) / me.pageSize), startIdx, page;
  for (startIdx = 0; pageNumber <= lastPage; pageNumber++ , startIdx += me.pageSize) 
    {
      page = Ext.Array.slice(records, startIdx, startIdx + me.pageSize);
      me.add(pageNumber, page);
      me.fireEvent('pageAdded', pageNumber, page);
    }
}, getCount: function() {
  var result = this.callParent();
  if (result) 
  {
    result = (result - 1) * this.pageSize + this.last.value.length;
  }
  return result;
}, indexOf: function(record) {
  return record ? record.index : -1;
}, insert: function() {
}, remove: function() {
}, removeAt: function() {
}, getPage: function(pageNumber) {
  return this.get(pageNumber);
}, hasRange: function(start, end) {
  var pageNumber = this.getPageFromRecordIndex(start), endPageNumber = this.getPageFromRecordIndex(end);
  for (; pageNumber <= endPageNumber; pageNumber++) 
    {
      if (!this.hasPage(pageNumber)) 
      {
        return false;
      }
    }
  return true;
}, hasPage: function(pageNumber) {
  return !!this.get(pageNumber);
}, getAt: function(index) {
  return this.getRange(index, index)[0];
}, getRange: function(start, end) {
  if (!this.hasRange(start, end)) 
  {
    Ext.Error.raise('PageMap asked for range which it does not have');
  }
  var me = this, startPageNumber = me.getPageFromRecordIndex(start), endPageNumber = me.getPageFromRecordIndex(end), dataStart = (startPageNumber - 1) * me.pageSize, dataEnd = (endPageNumber * me.pageSize) - 1, pageNumber = startPageNumber, result = [], sliceBegin, sliceEnd, doSlice, i = 0, len;
  for (; pageNumber <= endPageNumber; pageNumber++) 
    {
      if (pageNumber == startPageNumber) 
      {
        sliceBegin = start - dataStart;
        doSlice = true;
      } else {
        sliceBegin = 0;
        doSlice = false;
      }
      if (pageNumber == endPageNumber) 
      {
        sliceEnd = me.pageSize - (dataEnd - end);
        doSlice = true;
      }
      if (doSlice) 
      {
        Ext.Array.push(result, Ext.Array.slice(me.getPage(pageNumber), sliceBegin, sliceEnd));
      } else {
        Ext.Array.push(result, me.getPage(pageNumber));
      }
    }
  for (len = result.length; i < len; i++) 
    {
      result[i].index = start++;
    }
  return result;
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'PageMap'], 0));
;

(Ext.cmd.derive('Ext.data.Group', Ext.util.Observable, {key: undefined, dirty: true, constructor: function() {
  this.callParent(arguments);
  this.records = [];
}, contains: function(record) {
  return Ext.Array.indexOf(this.records, record) !== -1;
}, add: function(records) {
  Ext.Array.push(this.records, records);
  this.dirty = true;
}, remove: function(records) {
  if (!Ext.isArray(records)) 
  {
    records = [records];
  }
  var len = records.length, i;
  for (i = 0; i < len; ++i) 
    {
      Ext.Array.remove(this.records, records[i]);
    }
  this.dirty = true;
}, isDirty: function() {
  return this.dirty;
}, hasAggregate: function() {
  return !!this.aggregate;
}, setDirty: function() {
  this.dirty = true;
}, commit: function() {
  this.dirty = false;
}, isCollapsed: function() {
  return this.collapsed;
}, getAggregateRecord: function(forceNew) {
  var me = this, Model;
  if (forceNew === true || me.dirty || !me.aggregate) 
  {
    Model = me.store.model;
    me.aggregate = new Model();
    me.aggregate.isSummary = true;
  }
  return me.aggregate;
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Group'], 0));
;

(Ext.cmd.derive('Ext.data.Store', Ext.data.AbstractStore, {remoteSort: false, remoteFilter: false, remoteGroup: false, groupField: undefined, groupDir: 'ASC', trailingBufferZone: 25, leadingBufferZone: 200, pageSize: undefined, currentPage: 1, clearOnPageLoad: true, loading: false, sortOnFilter: true, buffered: false, purgePageCount: 5, clearRemovedOnLoad: true, defaultPageSize: 25, defaultViewSize: 100, addRecordsOptions: {addRecords: true}, statics: {recordIdFn: function(record) {
  return record.internalId;
}, recordIndexFn: function(record) {
  return record.index;
}, grouperIdFn: function(grouper) {
  return grouper.id || grouper.property;
}, groupIdFn: function(group) {
  return group.key;
}}, constructor: function(config) {
  config = Ext.apply({}, config);
  var me = this, groupers = config.groupers || me.groupers, groupField = config.groupField || me.groupField, proxy, data;
  data = config.data || me.data;
  if (data) 
  {
    me.inlineData = data;
    delete config.data;
  }
  if (!groupers && groupField) 
  {
    groupers = [{property: groupField, direction: config.groupDir || me.groupDir}];
    if (config.getGroupString || (me.getGroupString !== Ext.data.Store.prototype.getGroupString)) 
    {
      groupers[0].getGroupString = function(record) {
  return me.getGroupString(record);
};
    }
  }
  delete config.groupers;
  me.groupers = new Ext.util.MixedCollection(false, Ext.data.Store.grouperIdFn);
  me.groupers.addAll(me.decodeGroupers(groupers));
  me.groups = new Ext.util.MixedCollection(false, Ext.data.Store.groupIdFn);
  me.callParent([config]);
  if (me.buffered) 
  {
    me.data = new Ext.data.PageMap({store: me, keyFn: Ext.data.Store.recordIdFn, pageSize: me.pageSize, maxSize: me.purgePageCount, listeners: {clear: me.onPageMapClear, scope: me}});
    me.pageRequests = {};
    me.remoteSort = me.remoteGroup = me.remoteFilter = true;
    me.sortOnLoad = false;
    me.filterOnLoad = false;
  } else {
    me.data = new Ext.util.MixedCollection({getKey: Ext.data.Store.recordIdFn, maintainIndices: true});
  }
  if (me.remoteGroup) 
  {
    me.remoteSort = true;
  }
  proxy = me.proxy;
  data = me.inlineData;
  if (!me.buffered && !me.pageSize) 
  {
    me.pageSize = me.defaultPageSize;
  }
  if (data) 
  {
    if (proxy instanceof Ext.data.proxy.Memory) 
    {
      proxy.data = data;
      me.read();
    } else {
      me.add.apply(me, [data]);
    }
    delete me.inlineData;
  } else if (me.autoLoad) 
  {
    me.autoLoadTask = new Ext.util.DelayedTask(me.load, me, [typeof me.autoLoad === 'object' ? me.autoLoad : undefined]);
    me.autoLoadTask.delay(1);
  }
}, decodeGroupers: function(groupers) {
  if (!Ext.isArray(groupers)) 
  {
    if (groupers === undefined) 
    {
      groupers = [];
    } else {
      groupers = [groupers];
    }
  }
  var length = groupers.length, Grouper = Ext.util.Grouper, config, i, result = [];
  for (i = 0; i < length; i++) 
    {
      config = groupers[i];
      if (!(config instanceof Grouper)) 
      {
        if (Ext.isString(config)) 
        {
          config = {property: config};
        }
        config = Ext.apply({root: 'data', direction: "ASC"}, config);
        if (config.fn) 
        {
          config.sorterFn = config.fn;
        }
        if (typeof config == 'function') 
        {
          config = {sorterFn: config};
        }
        result.push(new Grouper(config));
      } else {
        result.push(config);
      }
    }
  return result;
}, group: function(groupers, direction, suppressEvent) {
  var me = this, grouper, newGroupers;
  if (groupers) 
  {
    me.sorters.removeAll(me.groupers.items);
    if (Ext.isArray(groupers)) 
    {
      newGroupers = groupers;
    } else if (Ext.isObject(groupers)) 
    {
      newGroupers = [groupers];
    } else if (Ext.isString(groupers)) 
    {
      grouper = me.groupers.get(groupers);
      if (!grouper) 
      {
        grouper = {property: groupers, direction: direction || me.groupDir};
        newGroupers = [grouper];
      } else if (direction === undefined) 
      {
        grouper.toggle();
      } else {
        grouper.setDirection(direction);
      }
    }
    if (newGroupers && newGroupers.length) 
    {
      me.groupers.clear();
      me.groupers.addAll(me.decodeGroupers(newGroupers));
    }
    me.sorters.insert(0, me.groupers.items);
  }
  if (me.remoteGroup) 
  {
    if (me.buffered) 
    {
      me.data.clear();
      me.loadPage(1, {groupChange: true});
    } else {
      me.load({scope: me, callback: suppressEvent ? null : me.fireGroupChange});
    }
  } else {
    me.doSort(me.generateComparator());
    me.constructGroups();
    if (!suppressEvent) 
    {
      me.fireGroupChange();
    }
  }
}, getGroupField: function() {
  var first = this.groupers.first(), group;
  if (first) 
  {
    group = first.property;
  }
  return group;
}, constructGroups: function() {
  var me = this, data = this.data.items, len = data.length, groups = me.groups, groupValue, i, group, rec;
  groups.clear();
  if (me.isGrouped()) 
  {
    for (i = 0; i < len; ++i) 
      {
        rec = data[i];
        groupValue = me.getGroupString(rec);
        group = groups.get(groupValue);
        if (!group) 
        {
          group = new Ext.data.Group({key: groupValue, store: me});
          groups.add(group);
        }
        group.add(rec);
      }
  }
}, clearGrouping: function() {
  var me = this, groupers = me.groupers.items, gLen = groupers.length, g;
  for (g = 0; g < gLen; g++) 
    {
      me.sorters.remove(groupers[g]);
    }
  me.groupers.clear();
  if (me.remoteGroup) 
  {
    if (me.buffered) 
    {
      me.data.clear();
      me.loadPage(1, {groupChange: true});
    } else {
      me.load({scope: me, callback: me.fireGroupChange});
    }
  } else {
    me.groups.clear();
    if (me.sorters.length) 
    {
      me.sort();
    } else {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
    me.fireGroupChange();
  }
}, isGrouped: function() {
  return this.groupers.getCount() > 0;
}, fireGroupChange: function() {
  this.fireEvent('groupchange', this, this.groupers);
}, getGroups: function(requestGroupString) {
  var records = this.data.items, length = records.length, groups = [], pointers = {}, record, groupStr, group, i;
  for (i = 0; i < length; i++) 
    {
      record = records[i];
      groupStr = this.getGroupString(record);
      group = pointers[groupStr];
      if (group === undefined) 
      {
        group = {name: groupStr, children: []};
        groups.push(group);
        pointers[groupStr] = group;
      }
      group.children.push(record);
    }
  return requestGroupString ? pointers[requestGroupString] : groups;
}, getGroupsForGrouper: function(records, grouper) {
  var length = records.length, groups = [], oldValue, newValue, record, group, i;
  for (i = 0; i < length; i++) 
    {
      record = records[i];
      newValue = grouper.getGroupString(record);
      if (newValue !== oldValue) 
      {
        group = {name: newValue, grouper: grouper, records: []};
        groups.push(group);
      }
      group.records.push(record);
      oldValue = newValue;
    }
  return groups;
}, getGroupsForGrouperIndex: function(records, grouperIndex) {
  var me = this, groupers = me.groupers, grouper = groupers.getAt(grouperIndex), groups = me.getGroupsForGrouper(records, grouper), length = groups.length, i;
  if (grouperIndex + 1 < groupers.length) 
  {
    for (i = 0; i < length; i++) 
      {
        groups[i].children = me.getGroupsForGrouperIndex(groups[i].records, grouperIndex + 1);
      }
  }
  for (i = 0; i < length; i++) 
    {
      groups[i].depth = grouperIndex;
    }
  return groups;
}, getGroupData: function(sort) {
  var me = this;
  if (sort !== false) 
  {
    me.sort();
  }
  return me.getGroupsForGrouperIndex(me.data.items, 0);
}, getGroupString: function(instance) {
  var group = this.groupers.first();
  if (group) 
  {
    return group.getGroupString(instance);
  }
  return '';
}, insert: function(index, records) {
  var me = this, sync = false, i, len, record, defaults = me.modelDefaults, out;
  if (!Ext.isIterable(records)) 
  {
    out = records = [records];
  } else {
    out = [];
  }
  len = records.length;
  if (len) 
  {
    for (i = 0; i < len; i++) 
      {
        record = records[i];
        if (!record.isModel) 
        {
          record = me.createModel(record);
        }
        out[i] = record;
        if (defaults) 
        {
          record.set(defaults);
        }
        record.join(me);
        sync = sync || record.phantom === true;
      }
    me.data.insert(index, out);
    if (me.snapshot) 
    {
      me.snapshot.addAll(out);
    }
    if (me.requireSort) 
    {
      me.suspendEvents();
      me.sort();
      me.resumeEvents();
    }
    if (me.isGrouped()) 
    {
      me.updateGroupsOnAdd(out);
    }
    me.fireEvent('add', me, out, index);
    me.fireEvent('datachanged', me);
    if (me.autoSync && sync && !me.autoSyncSuspended) 
    {
      me.sync();
    }
  }
  return out;
}, updateGroupsOnAdd: function(records) {
  var me = this, groups = me.groups, len = records.length, i, groupName, group, rec;
  for (i = 0; i < len; ++i) 
    {
      rec = records[i];
      groupName = me.getGroupString(rec);
      group = groups.getByKey(groupName);
      if (!group) 
      {
        group = groups.add(new Ext.data.Group({key: groupName, store: me}));
      }
      group.add(rec);
    }
}, updateGroupsOnRemove: function(records) {
  var me = this, groups = me.groups, len = records.length, i, groupName, group, rec;
  for (i = 0; i < len; ++i) 
    {
      rec = records[i];
      groupName = me.getGroupString(rec);
      group = groups.getByKey(groupName);
      if (group) 
      {
        group.remove(rec);
        if (group.records.length === 0) 
        {
          groups.remove(group);
        }
      }
    }
}, updateGroupsOnUpdate: function(record, modifiedFieldNames) {
  var me = this, groupField = me.getGroupField(), groupName = me.getGroupString(record), groups = me.groups, len, i, items, group;
  if (modifiedFieldNames && Ext.Array.contains(modifiedFieldNames, groupField)) 
  {
    if (me.buffered) 
    {
      Ext.Error.raise({msg: 'Cannot move records between groups in a buffered store record'});
    }
    items = groups.items;
    for (i = 0 , len = items.length; i < len; ++i) 
      {
        group = items[i];
        if (group.contains(record)) 
        {
          group.remove(record);
          break;
        }
      }
    group = groups.getByKey(groupName);
    if (!group) 
    {
      group = groups.add(new Ext.data.Group({key: groupName, store: me}));
    }
    group.add(record);
    me.data.remove(record);
    me.data.insert(me.data.findInsertionIndex(record, me.generateComparator()), record);
  } else {
    groups.getByKey(groupName).setDirty();
  }
}, add: function(arg) {
  var me = this, records, length, isSorted;
  if (Ext.isArray(arg)) 
  {
    records = arg;
  } else {
    records = arguments;
  }
  length = records.length;
  isSorted = !me.remoteSort && me.getSorterCount();
  if (isSorted && length === 1) 
  {
    return [me.addSorted(me.createModel(records[0]))];
  }
  if (isSorted) 
  {
    me.requireSort = true;
  }
  records = me.insert(me.data.length, records);
  delete me.requireSort;
  return records;
}, addSorted: function(record) {
  var me = this, index = me.data.findInsertionIndex(record, me.generateComparator());
  me.insert(index, record);
  return record;
}, createModel: function(record) {
  if (!record.isModel) 
  {
    record = Ext.ModelManager.create(record, this.model);
  }
  return record;
}, onUpdate: function(record, type, modifiedFieldNames) {
  if (this.isGrouped()) 
  {
    this.updateGroupsOnUpdate(record, modifiedFieldNames);
  }
}, each: function(fn, scope) {
  var data = this.data.items, dLen = data.length, record, d;
  for (d = 0; d < dLen; d++) 
    {
      record = data[d];
      if (fn.call(scope || record, record, d, dLen) === false) 
      {
        break;
      }
    }
}, remove: function(records, isMove, silent) {
  isMove = isMove === true;
  var me = this, sync = false, snapshot = me.snapshot, data = me.data, i = 0, length, info = [], allRecords = [], indexes = [], grouped = [], groupsLn = me.groups.length, item, isNotPhantom, index, record, removeRange, removeCount, fireRemoveEvent = !silent && me.hasListeners.remove;
  if (records.isModel) 
  {
    records = [records];
    length = 1;
  } else if (Ext.isIterable(records)) 
  {
    length = records.length;
  } else if (typeof records === 'object') 
  {
    removeRange = true;
    i = records.start;
    length = records.end + 1;
    removeCount = length - i;
  }
  if (!removeRange) 
  {
    for (i = 0; i < length; ++i) 
      {
        record = records[i];
        if (typeof record == 'number') 
        {
          index = record;
          record = data.getAt(index);
        } else {
          index = me.indexOf(record);
        }
        if (record && index > -1) 
        {
          info.push({record: record, index: index});
        }
        if (snapshot) 
        {
          snapshot.remove(record);
        }
      }
    info = Ext.Array.sort(info, function(o1, o2) {
  var index1 = o1.index, index2 = o2.index;
  return index1 === o2.index2 ? 0 : (index1 < index2 ? -1 : 1);
});
    i = 0;
    length = info.length;
  }
  if (!length) 
  {
    return;
  }
  for (; i < length; i++) 
    {
      if (removeRange) 
      {
        record = data.getAt(i);
        index = i;
      } else {
        item = info[i];
        record = item.record;
        index = item.index;
      }
      allRecords.push(record);
      indexes.push(index);
      isNotPhantom = record.phantom !== true;
      if (!isMove && isNotPhantom) 
      {
        record.removedFrom = index;
        me.removed.push(record);
      } else if (groupsLn) 
      {
        grouped.push(record);
      }
      record.unjoin(me);
      index -= i;
      sync = sync || isNotPhantom;
      if (!removeRange) 
      {
        data.removeAt(index);
        if (fireRemoveEvent) 
        {
          me.fireEvent('remove', me, record, index, !!isMove);
        }
      }
    }
  if (groupsLn) 
  {
    me.updateGroupsOnRemove(me.removed.concat(grouped));
  }
  if (removeRange) 
  {
    data.removeRange(records.start, removeCount);
  }
  if (!silent) 
  {
    me.fireEvent('bulkremove', me, allRecords, indexes, !!isMove, removeRange);
    me.fireEvent('datachanged', me);
  }
  if (!isMove && me.autoSync && sync && !me.autoSyncSuspended) 
  {
    me.sync();
  }
}, removeAt: function(index, count) {
  var me = this, storeCount = me.getCount();
  index = Math.max(index, 0);
  if (index <= storeCount) 
  {
    if (arguments.length === 1) 
    {
      me.remove([index]);
    } else if (count) 
    {
      me.remove({start: index, end: Math.min(index + count, storeCount) - 1});
    }
  }
}, removeAll: function(silent) {
  var me = this, snapshot = me.snapshot, data = me.data;
  if (snapshot) 
  {
    snapshot.removeAll(data.getRange());
  }
  if (me.buffered) 
  {
    if (data) 
    {
      if (silent) 
      {
        me.suspendEvent('clear');
      }
      data.clear();
      if (silent) 
      {
        me.resumeEvent('clear');
      }
    }
  } else {
    me.remove({start: 0, end: me.getCount() - 1}, false, silent);
    if (silent !== true) 
    {
      me.fireEvent('clear', me);
    }
  }
}, load: function(options) {
  var me = this;
  if (typeof options == 'function') 
  {
    options = {callback: options};
  } else {
    options = Ext.apply({}, options);
  }
  if (me.remoteGroup && !options.groupers && me.groupers.items.length) 
  {
    options.groupers = me.groupers.items;
  }
  options.page = options.page || me.currentPage;
  options.start = (options.start !== undefined) ? options.start : (options.page - 1) * me.pageSize;
  options.limit = options.limit || me.pageSize;
  options.addRecords = options.addRecords || false;
  if (me.buffered) 
  {
    options.limit = me.viewSize || me.defaultViewSize;
    options.loadCallback = options.callback;
    delete options.callback;
    return me.loadToPrefetch(options);
  }
  return me.callParent([options]);
}, reload: function(options) {
  var me = this, startIdx, endIdx, startPage, endPage, i, waitForReload, bufferZone, records;
  if (!options) 
  {
    options = {};
  }
  if (me.buffered) 
  {
    delete me.totalCount;
    me.data.clear(true);
    waitForReload = function() {
  if (me.rangeCached(startIdx, endIdx)) 
  {
    me.loading = false;
    me.data.un('pageAdded', waitForReload);
    records = me.data.getRange(startIdx, endIdx);
    me.fireEvent('load', me, records, true);
  }
};
    bufferZone = Math.ceil((me.leadingBufferZone + me.trailingBufferZone) / 2);
    if (!me.lastRequestStart) 
    {
      startIdx = options.start || 0;
      endIdx = startIdx + (options.count || me.pageSize) - 1;
    } else {
      startIdx = me.lastRequestStart;
      endIdx = me.lastRequestEnd;
    }
    startPage = me.getPageFromRecordIndex(Math.max(startIdx - bufferZone, 0));
    endPage = me.getPageFromRecordIndex(endIdx + bufferZone);
    if (me.fireEvent('beforeload', me, options) !== false) 
    {
      me.loading = true;
      me.data.on('pageAdded', waitForReload);
      for (i = startPage; i <= endPage; i++) 
        {
          me.prefetchPage(i, options);
        }
    }
  } else {
    return me.callParent(arguments);
  }
}, onProxyLoad: function(operation) {
  var me = this, resultSet = operation.getResultSet(), records = operation.getRecords(), successful = operation.wasSuccessful();
  if (me.isDestroyed) 
  {
    return;
  }
  if (resultSet) 
  {
    me.totalCount = resultSet.total;
  }
  me.loading = false;
  if (successful) 
  {
    me.loadRecords(records, operation);
  }
  if (me.hasListeners.load) 
  {
    me.fireEvent('load', me, records, successful);
  }
  if (me.hasListeners.read) 
  {
    me.fireEvent('read', me, records, successful);
  }
  Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
}, getNewRecords: function() {
  return (this.snapshot || this.data).filterBy(this.filterNew).items;
}, getUpdatedRecords: function() {
  return (this.snapshot || this.data).filterBy(this.filterUpdated).items;
}, filter: function(filters, value) {
  if (Ext.isString(filters)) 
  {
    filters = {property: filters, value: value};
  }
  var me = this, decoded = me.decodeFilters(filters), i, doLocalSort = me.sorters.length && me.sortOnFilter && !me.remoteSort, length = decoded.length;
  for (i = 0; i < length; i++) 
    {
      me.filters.replace(decoded[i]);
    }
  filters = me.filters.items;
  if (filters.length) 
  {
    if (me.remoteFilter) 
    {
      delete me.totalCount;
      if (me.buffered) 
      {
        me.data.clear();
        me.loadPage(1);
      } else {
        me.currentPage = 1;
        me.load();
      }
    } else {
      me.snapshot = me.snapshot || me.data.clone();
      me.data = me.snapshot.filter(filters);
      me.constructGroups();
      if (doLocalSort) 
      {
        me.sort();
      } else {
        me.fireEvent('datachanged', me);
        me.fireEvent('refresh', me);
      }
    }
    me.fireEvent('filterchange', me, filters);
  }
}, clearFilter: function(suppressEvent) {
  var me = this;
  me.filters.clear();
  if (me.remoteFilter) 
  {
    if (suppressEvent) 
    {
      return;
    }
    delete me.totalCount;
    if (me.buffered) 
    {
      me.data.clear();
      me.loadPage(1);
    } else {
      me.currentPage = 1;
      me.load();
    }
  } else if (me.isFiltered()) 
  {
    me.data = me.snapshot;
    delete me.snapshot;
    me.constructGroups();
    if (suppressEvent !== true) 
    {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
  }
  me.fireEvent('filterchange', me, me.filters.items);
}, removeFilter: function(toRemove, applyFilters) {
  var me = this;
  if (!me.remoteFilter && me.isFiltered()) 
  {
    if (toRemove instanceof Ext.util.Filter) 
    {
      me.filters.remove(toRemove);
    } else {
      me.filters.removeAtKey(toRemove);
    }
    if (applyFilters !== false) 
    {
      if (me.filters.length) 
      {
        me.filter();
      } else {
        me.clearFilter();
      }
    } else {
      me.fireEvent('filterchange', me, me.filters.items);
    }
  }
}, addFilter: function(filters, applyFilters) {
  var me = this, decoded, i, length;
  decoded = me.decodeFilters(filters);
  length = decoded.length;
  for (i = 0; i < length; i++) 
    {
      me.filters.replace(decoded[i]);
    }
  if (applyFilters !== false && me.filters.length) 
  {
    me.filter();
  } else {
    me.fireEvent('filterchange', me, me.filters.items);
  }
}, isFiltered: function() {
  var snapshot = this.snapshot;
  return !!(snapshot && snapshot !== this.data);
}, filterBy: function(fn, scope) {
  var me = this;
  me.snapshot = me.snapshot || me.data.clone();
  me.data = me.queryBy(fn, scope || me);
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
}, queryBy: function(fn, scope) {
  var me = this;
  return (me.snapshot || me.data).filterBy(fn, scope || me);
}, query: function(property, value, anyMatch, caseSensitive, exactMatch) {
  var me = this, queryFn = me.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch), results = me.queryBy(queryFn);
  if (!results) 
  {
    results = new Ext.util.MixedCollection();
  }
  return results;
}, loadData: function(data, append) {
  var length = data.length, newData = [], i;
  for (i = 0; i < length; i++) 
    {
      newData.push(this.createModel(data[i]));
    }
  this.loadRecords(newData, append ? this.addRecordsOptions : undefined);
}, loadRawData: function(data, append) {
  var me = this, result = me.proxy.reader.read(data), records = result.records;
  if (result.success) 
  {
    me.totalCount = result.total;
    me.loadRecords(records, append ? me.addRecordsOptions : undefined);
  }
}, loadRecords: function(records, options) {
  var me = this, i = 0, length = records.length, start, addRecords, snapshot = me.snapshot;
  if (options) 
  {
    start = options.start;
    addRecords = options.addRecords;
  }
  if (!addRecords) 
  {
    delete me.snapshot;
    me.clearData(true);
  } else if (snapshot) 
  {
    snapshot.addAll(records);
  }
  me.data.addAll(records);
  if (start !== undefined) 
  {
    for (; i < length; i++) 
      {
        records[i].index = start + i;
        records[i].join(me);
      }
  } else {
    for (; i < length; i++) 
      {
        records[i].join(me);
      }
  }
  me.suspendEvents();
  if (me.filterOnLoad && !me.remoteFilter) 
  {
    me.filter();
  }
  if (me.sortOnLoad && !me.remoteSort) 
  {
    me.sort();
  }
  me.resumeEvents();
  if (me.isGrouped()) 
  {
    me.constructGroups();
  }
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
}, loadPage: function(page, options) {
  var me = this;
  me.currentPage = page;
  options = Ext.apply({page: page, start: (page - 1) * me.pageSize, limit: me.pageSize, addRecords: !me.clearOnPageLoad}, options);
  if (me.buffered) 
  {
    options.limit = me.viewSize || me.defaultViewSize;
    options.loadCallback = options.callback;
    delete options.callback;
    return me.loadToPrefetch(options);
  }
  me.read(options);
}, nextPage: function(options) {
  this.loadPage(this.currentPage + 1, options);
}, previousPage: function(options) {
  this.loadPage(this.currentPage - 1, options);
}, clearData: function(isLoad, data) {
  var me = this, records, i;
  data = data || me.data;
  if (!me.buffered && data) 
  {
    records = data.items;
    i = records.length;
    while (i--) 
      {
        records[i].unjoin(me);
      }
  }
  if (data) 
  {
    data.clear();
  }
  if (isLoad !== true || me.clearRemovedOnLoad) 
  {
    me.removed.length = 0;
  }
}, destroyClear: function() {
  this.clearData(null, this.snapshot);
}, loadToPrefetch: function(options) {
  var me = this, i, records, dataSetSize, prefetchOptions = options, startIdx = options.start, endIdx = options.start + options.limit - 1, loadEndIdx = Math.min(endIdx, options.start + (me.viewSize || options.limit) - 1), startPage = me.getPageFromRecordIndex(Math.max(startIdx - me.trailingBufferZone, 0)), endPage = me.getPageFromRecordIndex(endIdx + me.leadingBufferZone), waitForRequestedRange = function() {
  if (me.rangeCached(startIdx, loadEndIdx)) 
  {
    me.loading = false;
    records = me.data.getRange(startIdx, loadEndIdx);
    me.data.un('pageAdded', waitForRequestedRange);
    if (me.hasListeners.guaranteedrange) 
    {
      me.guaranteeRange(startIdx, loadEndIdx, options.callback, options.scope);
    }
    if (options.loadCallback) 
    {
      options.loadCallback.call(options.scope || me, records, operation, true);
    }
    if (options.callback) 
    {
      options.callback.call(options.scope || me, records, startIdx, endIdx, options);
    }
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
    me.fireEvent('load', me, records, true);
    if (options.groupChange) 
    {
      me.fireGroupChange();
    }
  }
}, operation;
  if (me.purgePageCount) 
  {
    me.data.maxSize = me.purgePageCount = Math.max(me.purgePageCount, endPage - startPage + 1);
  }
  if (me.fireEvent('beforeload', me, options) !== false) 
  {
    delete me.totalCount;
    me.loading = true;
    if (options.callback) 
    {
      prefetchOptions = Ext.apply({}, options);
      delete prefetchOptions.callback;
    }
    me.on('prefetch', function(store, records, successful, op) {
  if (successful) 
  {
    operation = op;
    if ((dataSetSize = me.getTotalCount())) 
    {
      me.data.on('pageAdded', waitForRequestedRange);
      loadEndIdx = Math.min(loadEndIdx, dataSetSize - 1);
      endPage = me.getPageFromRecordIndex(Math.min(loadEndIdx + me.leadingBufferZone, dataSetSize - 1));
      for (i = startPage + 1; i <= endPage; ++i) 
        {
          me.prefetchPage(i, prefetchOptions);
        }
    } else {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
      me.fireEvent('load', me, records, true);
    }
  } else {
    me.fireEvent('load', me, records, false);
  }
}, null, {single: true});
    me.prefetchPage(startPage, prefetchOptions);
  }
}, prefetch: function(options) {
  var me = this, pageSize = me.pageSize, proxy, operation;
  if (pageSize) 
  {
    if (me.lastPageSize && pageSize != me.lastPageSize) 
    {
      Ext.Error.raise("pageSize cannot be dynamically altered");
    }
    if (!me.data.pageSize) 
    {
      me.data.pageSize = pageSize;
    }
  } else {
    me.pageSize = me.data.pageSize = pageSize = options.limit;
  }
  me.lastPageSize = pageSize;
  if (!options.page) 
  {
    options.page = me.getPageFromRecordIndex(options.start);
    options.start = (options.page - 1) * pageSize;
    options.limit = Math.ceil(options.limit / pageSize) * pageSize;
  }
  if (!me.pageRequests[options.page]) 
  {
    options = Ext.apply({action: 'read', filters: me.filters.items, sorters: me.sorters.items, groupers: me.groupers.items, pageMapGeneration: me.data.pageMapGeneration}, options);
    operation = new Ext.data.Operation(options);
    if (me.fireEvent('beforeprefetch', me, operation) !== false) 
    {
      proxy = me.proxy;
      me.pageRequests[options.page] = proxy.read(operation, me.onProxyPrefetch, me);
      if (proxy.isSynchronous) 
      {
        delete me.pageRequests[options.page];
      }
    }
  }
  return me;
}, onPageMapClear: function() {
  var me = this, loadingFlag = me.wasLoading, reqs = me.pageRequests, req, page;
  if (me.data.events.pageadded) 
  {
    me.data.events.pageadded.clearListeners();
  }
  me.loading = true;
  me.totalCount = 0;
  for (page in reqs) 
    {
      if (reqs.hasOwnProperty(page)) 
      {
        req = reqs[page];
        delete reqs[page];
        delete req.callback;
      }
    }
  me.fireEvent('clear', me);
  me.loading = loadingFlag;
}, prefetchPage: function(page, options) {
  var me = this, pageSize = me.pageSize || me.defaultPageSize, start = (page - 1) * me.pageSize, total = me.totalCount;
  if (total !== undefined && me.getCount() === total) 
  {
    return;
  }
  me.prefetch(Ext.applyIf({page: page, start: start, limit: pageSize}, options));
}, onProxyPrefetch: function(operation) {
  var me = this, resultSet = operation.getResultSet(), records = operation.getRecords(), successful = operation.wasSuccessful(), page = operation.page;
  if (operation.pageMapGeneration === me.data.pageMapGeneration) 
  {
    if (resultSet) 
    {
      me.totalCount = resultSet.total;
      me.fireEvent('totalcountchange', me.totalCount);
    }
    if (page !== undefined) 
    {
      delete me.pageRequests[page];
    }
    me.loading = false;
    me.fireEvent('prefetch', me, records, successful, operation);
    if (successful) 
    {
      me.cachePage(records, operation.page);
    }
    Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
  }
}, cachePage: function(records, page) {
  var me = this, len = records.length, i;
  if (!Ext.isDefined(me.totalCount)) 
  {
    me.totalCount = records.length;
    me.fireEvent('totalcountchange', me.totalCount);
  }
  for (i = 0; i < len; i++) 
    {
      records[i].join(me);
    }
  me.data.addPage(page, records);
}, rangeCached: function(start, end) {
  return this.data && this.data.hasRange(start, end);
}, pageCached: function(page) {
  return this.data && this.data.hasPage(page);
}, pagePending: function(page) {
  return !!this.pageRequests[page];
}, rangeSatisfied: function(start, end) {
  return this.rangeCached(start, end);
}, getPageFromRecordIndex: function(index) {
  return Math.floor(index / this.pageSize) + 1;
}, onGuaranteedRange: function(options) {
  var me = this, totalCount = me.getTotalCount(), start = options.prefetchStart, end = (options.prefetchEnd > totalCount - 1) ? totalCount - 1 : options.prefetchEnd, range;
  end = Math.max(0, end);
  range = me.data.getRange(start, end);
  if (options.fireEvent !== false) 
  {
    me.fireEvent('guaranteedrange', range, start, end, options);
  }
  if (options.callback) 
  {
    options.callback.call(options.scope || me, range, start, end, options);
  }
}, guaranteeRange: function(start, end, callback, scope, options) {
  options = Ext.apply({callback: callback, scope: scope}, options);
  this.getRange(start, end, options);
}, prefetchRange: function(start, end) {
  var me = this, startPage, endPage, page;
  if (!me.rangeCached(start, end)) 
  {
    startPage = me.getPageFromRecordIndex(start);
    endPage = me.getPageFromRecordIndex(end);
    me.data.maxSize = me.purgePageCount ? (endPage - startPage + 1) + me.purgePageCount : 0;
    for (page = startPage; page <= endPage; page++) 
      {
        if (!me.pageCached(page)) 
        {
          me.prefetchPage(page);
        }
      }
  }
}, primeCache: function(start, end, direction) {
  var me = this;
  if (direction === -1) 
  {
    start = Math.max(start - me.leadingBufferZone, 0);
    end = Math.min(end + me.trailingBufferZone, me.totalCount - 1);
  } else if (direction === 1) 
  {
    start = Math.max(Math.min(start - me.trailingBufferZone, me.totalCount - me.pageSize), 0);
    end = Math.min(end + me.leadingBufferZone, me.totalCount - 1);
  } else {
    start = Math.min(Math.max(Math.floor(start - ((me.leadingBufferZone + me.trailingBufferZone) / 2)), 0), me.totalCount - me.pageSize);
    end = Math.min(Math.max(Math.ceil(end + ((me.leadingBufferZone + me.trailingBufferZone) / 2)), 0), me.totalCount - 1);
  }
  me.prefetchRange(start, end);
}, sort: function(sorters) {
  var me = this;
  if (sorters && me.buffered && me.remoteSort) 
  {
    me.data.clear();
  }
  return me.callParent(arguments);
}, generateComparator: function() {
  var me = this, sorters = me.sorters.items, numSorters = sorters.length, groupers = numSorters ? me.groupers.getRange() : me.groupers.items, i, sorter, matchingGrouper;
  if (groupers.length) 
  {
    for (i = 0; i < numSorters; i++) 
      {
        sorter = sorters[i];
        if (sorter.property && (matchingGrouper = me.groupers.get(sorter.property))) 
        {
          matchingGrouper.setDirection(sorter.direction);
        } else {
          Ext.Array.push(groupers, sorter);
        }
      }
    sorters = groupers;
  }
  return sorters.length ? this.createComparator(sorters) : this.emptyComparator;
}, getSorterCount: function() {
  return this.groupers.items.length + this.sorters.items.length;
}, doSort: function(sorterFn) {
  var me = this, range, ln, i, afterSort = function() {
  me.fireEvent('sort', me, me.sorters.getRange());
};
  if (me.remoteSort) 
  {
    if (me.buffered) 
    {
      me.data.clear();
      me.loadPage(1, {callback: afterSort});
    } else {
      me.load({callback: afterSort});
    }
  } else {
    me.data.sortBy(sorterFn);
    if (!me.buffered) 
    {
      range = me.getRange();
      ln = range.length;
      for (i = 0; i < ln; i++) 
        {
          range[i].index = i;
        }
    }
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
    afterSort();
  }
}, find: function(property, value, start, anyMatch, caseSensitive, exactMatch) {
  var fn = this.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch);
  return fn ? this.data.findIndexBy(fn, null, start) : -1;
}, findRecord: function() {
  var me = this, index = me.find.apply(me, arguments);
  return index !== -1 ? me.getAt(index) : null;
}, createFilterFn: function(property, value, anyMatch, caseSensitive, exactMatch) {
  if (Ext.isEmpty(value)) 
  {
    return false;
  }
  value = Ext.util.AbstractMixedCollection.prototype.createValueMatcher(value, anyMatch, caseSensitive, exactMatch);
  return function(r) {
  return value.test(r.data[property]);
};
}, findExact: function(property, value, start) {
  return this.data.findIndexBy(function(rec) {
  return rec.isEqual(rec.get(property), value);
}, this, start);
}, findBy: function(fn, scope, start) {
  return this.data.findIndexBy(fn, scope, start);
}, collect: function(dataIndex, allowNull, bypassFilter) {
  var me = this, data = (bypassFilter === true && me.snapshot) ? me.snapshot : me.data;
  return data.collect(dataIndex, 'data', allowNull);
}, getCount: function() {
  return this.data.getCount();
}, getTotalCount: function() {
  return this.totalCount || 0;
}, getAt: function(index) {
  return this.data.getAt(index);
}, getRange: function(start, end, options) {
  var me = this, requiredStart, requiredEnd, maxIndex = me.totalCount - 1, lastRequestStart = me.lastRequestStart, result = [], pageAddHandler;
  options = Ext.apply({prefetchStart: start, prefetchEnd: end}, options);
  if (me.buffered) 
  {
    end = (end >= me.totalCount) ? maxIndex : end;
    requiredStart = start === 0 ? 0 : start - 1;
    requiredEnd = end === maxIndex ? end : end + 1;
    me.lastRequestStart = start;
    me.lastRequestEnd = end;
    if (me.rangeCached(requiredStart, requiredEnd)) 
    {
      me.onGuaranteedRange(options);
      result = me.data.getRange(start, end);
    } else {
      me.fireEvent('cachemiss', me, start, end);
      pageAddHandler = function(page, records) {
  if (me.rangeCached(requiredStart, requiredEnd)) 
  {
    me.fireEvent('cachefilled', me, start, end);
    me.data.un('pageAdded', pageAddHandler);
    me.onGuaranteedRange(options);
  }
};
      me.data.on('pageAdded', pageAddHandler);
      me.prefetchRange(start, end);
    }
    me.primeCache(start, end, start < lastRequestStart ? -1 : 1);
  } else {
    result = me.data.getRange(start, end);
    if (options.callback) 
    {
      options.callback.call(options.scope || me, result, start, end, options);
    }
  }
  return result;
}, getById: function(id) {
  var result = (this.snapshot || this.data).findBy(function(record) {
  return record.getId() === id;
});
  return result;
}, getByInternalId: function(internalId) {
  var result;
  if (this.buffered) 
  {
    result = (this.snapshot || this.data).findBy(function(record) {
  return record.internalId === internalId;
});
  } else {
    result = this.data.get(internalId);
  }
  return result;
}, indexOf: function(record) {
  return this.data.indexOf(record);
}, indexOfTotal: function(record) {
  var index = record.index;
  if (index || index === 0) 
  {
    return index;
  }
  return this.indexOf(record);
}, indexOfId: function(id) {
  return this.indexOf(this.getById(id));
}, first: function(grouped) {
  var me = this;
  if (grouped && me.isGrouped()) 
  {
    return me.aggregate(function(records) {
  return records.length ? records[0] : undefined;
}, me, true);
  } else {
    return me.data.first();
  }
}, last: function(grouped) {
  var me = this;
  if (grouped && me.isGrouped()) 
  {
    return me.aggregate(function(records) {
  var len = records.length;
  return len ? records[len - 1] : undefined;
}, me, true);
  } else {
    return me.data.last();
  }
}, sum: function(field, grouped) {
  var me = this;
  if (grouped && me.isGrouped()) 
  {
    return me.aggregate(me.getSum, me, true, [field]);
  } else {
    return me.getSum(me.data.items, field);
  }
}, getSum: function(records, field) {
  var total = 0, i = 0, len = records.length;
  for (; i < len; ++i) 
    {
      total += records[i].get(field);
    }
  return total;
}, count: function(grouped) {
  var me = this;
  if (grouped && me.isGrouped()) 
  {
    return me.aggregate(function(records) {
  return records.length;
}, me, true);
  } else {
    return me.getCount();
  }
}, min: function(field, grouped) {
  var me = this;
  if (grouped && me.isGrouped()) 
  {
    return me.aggregate(me.getMin, me, true, [field]);
  } else {
    return me.getMin(me.data.items, field);
  }
}, getMin: function(records, field) {
  var i = 1, len = records.length, value, min;
  if (len > 0) 
  {
    min = records[0].get(field);
  }
  for (; i < len; ++i) 
    {
      value = records[i].get(field);
      if (value < min) 
      {
        min = value;
      }
    }
  return min;
}, max: function(field, grouped) {
  var me = this;
  if (grouped && me.isGrouped()) 
  {
    return me.aggregate(me.getMax, me, true, [field]);
  } else {
    return me.getMax(me.data.items, field);
  }
}, getMax: function(records, field) {
  var i = 1, len = records.length, value, max;
  if (len > 0) 
  {
    max = records[0].get(field);
  }
  for (; i < len; ++i) 
    {
      value = records[i].get(field);
      if (value > max) 
      {
        max = value;
      }
    }
  return max;
}, average: function(field, grouped) {
  var me = this;
  if (grouped && me.isGrouped()) 
  {
    return me.aggregate(me.getAverage, me, true, [field]);
  } else {
    return me.getAverage(me.data.items, field);
  }
}, getAverage: function(records, field) {
  var i = 0, len = records.length, sum = 0;
  if (records.length > 0) 
  {
    for (; i < len; ++i) 
      {
        sum += records[i].get(field);
      }
    return sum / len;
  }
  return 0;
}, aggregate: function(fn, scope, grouped, args) {
  args = args || [];
  if (grouped && this.isGrouped()) 
  {
    var groups = this.getGroups(), len = groups.length, out = {}, group, i;
    for (i = 0; i < len; ++i) 
      {
        group = groups[i];
        out[group.name] = this.getAggregate(fn, scope || this, group.children, args);
      }
    return out;
  } else {
    return this.getAggregate(fn, scope, this.data.items, args);
  }
}, getAggregate: function(fn, scope, records, args) {
  args = args || [];
  return fn.apply(scope || this, [records].concat(args));
}, onIdChanged: function(rec, oldId, newId, oldInternalId) {
  var snapshot = this.snapshot;
  if (snapshot) 
  {
    snapshot.updateKey(oldInternalId, newId);
  }
  this.data.updateKey(oldInternalId, newId);
  this.callParent(arguments);
}, commitChanges: function() {
  var me = this, recs = me.getModifiedRecords(), len = recs.length, i = 0;
  for (; i < len; i++) 
    {
      recs[i].commit();
    }
  me.removed.length = 0;
}, filterNewOnly: function(item) {
  return item.phantom === true;
}, getRejectRecords: function() {
  return Ext.Array.push(this.data.filterBy(this.filterNewOnly).items, this.getUpdatedRecords());
}, rejectChanges: function() {
  var me = this, recs = me.getRejectRecords(), len = recs.length, i = 0, rec;
  for (; i < len; i++) 
    {
      rec = recs[i];
      rec.reject();
      if (rec.phantom) 
      {
        me.remove(rec);
      }
    }
  recs = me.removed;
  len = recs.length;
  for (i = len - 1; i >= 0; i--) 
    {
      rec = recs[i];
      me.insert(rec.removedFrom || 0, rec);
      rec.reject();
    }
  me.removed.length = 0;
}}, 1, 0, 0, 0, ["store.store"], 0, [Ext.data, 'Store'], function() {
  Ext.regStore('ext-empty-store', {fields: [], proxy: 'memory'});
}));
;

(Ext.cmd.derive('Ext.data.reader.Array', Ext.data.reader.Json, {alternateClassName: 'Ext.data.ArrayReader', totalProperty: undefined, successProperty: undefined, createFieldAccessExpression: function(field, fieldVarName, dataName) {
  var index = (field.mapping == null) ? field.originalIndex : field.mapping, result;
  if (typeof index === 'function') 
  {
    result = fieldVarName + '.mapping(' + dataName + ', this)';
  } else {
    if (isNaN(index)) 
    {
      index = '"' + index + '"';
    }
    result = dataName + "[" + index + "]";
  }
  return result;
}}, 0, 0, 0, 0, ["reader.array"], 0, [Ext.data.reader, 'Array', Ext.data, 'ArrayReader'], 0));
;

(Ext.cmd.derive('Ext.data.ArrayStore', Ext.data.Store, {constructor: function(config) {
  config = Ext.apply({proxy: {type: 'memory', reader: 'array'}}, config);
  this.callParent([config]);
}, loadData: function(data, append) {
  if (this.expandData === true) 
  {
    var r = [], i = 0, ln = data.length;
    for (; i < ln; i++) 
      {
        r[r.length] = [data[i]];
      }
    data = r;
  }
  this.callParent([data, append]);
}}, 1, 0, 0, 0, ["store.array"], 0, [Ext.data, 'ArrayStore'], function() {
  Ext.data.SimpleStore = Ext.data.ArrayStore;
}));
;

(Ext.cmd.derive('Ext.data.Batch', Ext.Base, {autoStart: false, pauseOnException: false, current: -1, total: 0, isRunning: false, isComplete: false, hasException: false, constructor: function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  me.operations = [];
  me.exceptions = [];
}, add: function(operation) {
  this.total++;
  operation.setBatch(this);
  this.operations.push(operation);
  return this;
}, start: function(index) {
  var me = this;
  if (me.isRunning) 
  {
    return me;
  }
  me.exceptions.length = 0;
  me.hasException = false;
  me.isRunning = true;
  return me.runOperation(Ext.isDefined(index) ? index : me.current + 1);
}, retry: function() {
  return this.start(this.current);
}, runNextOperation: function() {
  return this.runOperation(this.current + 1);
}, pause: function() {
  this.isRunning = false;
  return this;
}, runOperation: function(index) {
  var me = this, operations = me.operations, operation = operations[index], onProxyReturn;
  if (operation === undefined) 
  {
    me.isRunning = false;
    me.isComplete = true;
    me.fireEvent('complete', me, operations[operations.length - 1]);
  } else {
    me.current = index;
    onProxyReturn = function(operation) {
  var hasException = operation.hasException();
  if (hasException) 
  {
    me.hasException = true;
    me.exceptions.push(operation);
    me.fireEvent('exception', me, operation);
  }
  if (hasException && me.pauseOnException) 
  {
    me.pause();
  } else {
    operation.setCompleted();
    me.fireEvent('operationcomplete', me, operation);
    me.runNextOperation();
  }
};
    operation.setStarted();
    me.proxy[operation.action](operation, onProxyReturn, me);
  }
  return me;
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.data, 'Batch'], 0));
;

(Ext.cmd.derive('Ext.data.NodeInterface', Ext.Base, {statics: {decorate: function(modelClass) {
  var idName, idField, idType;
  if (typeof modelClass == 'string') 
  {
    modelClass = Ext.ModelManager.getModel(modelClass);
  } else if (modelClass.isModel) 
  {
    modelClass = Ext.ModelManager.getModel(modelClass.modelName);
  }
  if (modelClass.prototype.isNode) 
  {
    return;
  }
  idName = modelClass.prototype.idProperty;
  idField = modelClass.prototype.fields.get(idName);
  idType = modelClass.prototype.fields.get(idName).type.type;
  modelClass.override(this.getPrototypeBody());
  this.applyFields(modelClass, [{name: 'parentId', type: idType, defaultValue: null, useNull: idField.useNull}, {name: 'index', type: 'int', defaultValue: -1, persist: false, convert: null}, {name: 'depth', type: 'int', defaultValue: 0, persist: false, convert: null}, {name: 'expanded', type: 'bool', defaultValue: false, persist: false, convert: null}, {name: 'expandable', type: 'bool', defaultValue: true, persist: false, convert: null}, {name: 'checked', type: 'auto', defaultValue: null, persist: false, convert: null}, {name: 'leaf', type: 'bool', defaultValue: false}, {name: 'cls', type: 'string', defaultValue: '', persist: false, convert: null}, {name: 'iconCls', type: 'string', defaultValue: '', persist: false, convert: null}, {name: 'icon', type: 'string', defaultValue: '', persist: false, convert: null}, {name: 'root', type: 'boolean', defaultValue: false, persist: false, convert: null}, {name: 'isLast', type: 'boolean', defaultValue: false, persist: false, convert: null}, {name: 'isFirst', type: 'boolean', defaultValue: false, persist: false, convert: null}, {name: 'allowDrop', type: 'boolean', defaultValue: true, persist: false, convert: null}, {name: 'allowDrag', type: 'boolean', defaultValue: true, persist: false, convert: null}, {name: 'loaded', type: 'boolean', defaultValue: false, persist: false, convert: null}, {name: 'loading', type: 'boolean', defaultValue: false, persist: false, convert: null}, {name: 'href', type: 'string', defaultValue: '', persist: false, convert: null}, {name: 'hrefTarget', type: 'string', defaultValue: '', persist: false, convert: null}, {name: 'qtip', type: 'string', defaultValue: '', persist: false, convert: null}, {name: 'qtitle', type: 'string', defaultValue: '', persist: false, convert: null}, {name: 'qshowDelay', type: 'int', defaultValue: 0, persist: false, convert: null}, {name: 'children', type: 'auto', defaultValue: null, persist: false, convert: null}, {name: 'visible', type: 'boolean', defaultValue: true, persist: false, convert: null}]);
}, applyFields: function(modelClass, addFields) {
  var modelPrototype = modelClass.prototype, fields = modelPrototype.fields, keys = fields.keys, ln = addFields.length, addField, i;
  for (i = 0; i < ln; i++) 
    {
      addField = addFields[i];
      if (!Ext.Array.contains(keys, addField.name)) 
      {
        fields.add(new Ext.data.Field(addField));
      }
    }
}, getPrototypeBody: function() {
  var bubbledEvents = {idchanged: true, append: true, remove: true, bulkremove: true, move: true, insert: true, beforeappend: true, beforeremove: true, beforemove: true, beforeinsert: true, expand: true, collapse: true, beforeexpand: true, beforecollapse: true, sort: true, rootchange: true};
  return {isNode: true, constructor: function() {
  var me = this;
  me.callParent(arguments);
  me.firstChild = me.lastChild = me.parentNode = me.previousSibling = me.nextSibling = null;
  me.childNodes = [];
  return me;
}, createNode: function(node) {
  var me = this;
  if (!node.isModel) 
  {
    node = new this.self(node);
  }
  if (!node.childNodes) 
  {
    node.firstChild = node.lastChild = node.parentNode = node.previousSibling = node.nextSibling = null;
    node.childNodes = [];
  }
  return node;
}, isLeaf: function() {
  return this.get('leaf') === true;
}, setFirstChild: function(node) {
  this.firstChild = node;
}, setLastChild: function(node) {
  this.lastChild = node;
}, updateInfo: function(commit, info) {
  var me = this, oldDepth = me.data.depth, childInfo = {}, children = me.childNodes, childCount = children.length, i, phantom = me.phantom, dataObject = me[me.persistenceProperty], fields = me.fields, modified = me.modified, propName, newValue, field, currentValue, key, newParentId = info.parentId, settingIndexInNewParent, persistentField;
  if (!info) 
  {
    Ext.Error.raise('NodeInterface expects update info to be passed');
  }
  for (propName in info) 
    {
      field = fields.get(propName);
      newValue = info[propName];
      persistentField = field && field.persist;
      currentValue = dataObject[propName];
      settingIndexInNewParent = persistentField && (propName === 'index') && (currentValue !== -1) && (newParentId && newParentId !== modified.parentId);
      if (!settingIndexInNewParent && me.isEqual(currentValue, newValue)) 
      {
        continue;
      }
      dataObject[propName] = newValue;
      if (persistentField) 
      {
        if (!settingIndexInNewParent && modified.hasOwnProperty(propName)) 
        {
          if (me.isEqual(modified[propName], newValue)) 
          {
            delete modified[propName];
            me.dirty = false;
            for (key in modified) 
              {
                if (modified.hasOwnProperty(key)) 
                {
                  me.dirty = true;
                  break;
                }
              }
          }
        } else {
          me.dirty = true;
          modified[propName] = currentValue;
        }
      }
    }
  if (commit) 
  {
    me.commit();
    me.phantom = phantom;
  }
  if (me.data.depth !== oldDepth) 
  {
    childInfo = {depth: me.data.depth + 1};
    for (i = 0; i < childCount; i++) 
      {
        children[i].updateInfo(commit, childInfo);
      }
  }
}, isLast: function() {
  return this.get('isLast');
}, isFirst: function() {
  return this.get('isFirst');
}, hasChildNodes: function() {
  return !this.isLeaf() && this.childNodes.length > 0;
}, isExpandable: function() {
  var me = this;
  if (me.get('expandable')) 
  {
    return !(me.isLeaf() || (me.isLoaded() && !me.phantom && !me.hasChildNodes()));
  }
  return false;
}, triggerUIUpdate: function() {
  this.afterEdit([]);
}, appendChild: function(node, suppressEvents, commit) {
  var me = this, i, ln, index, oldParent, previousSibling, childInfo = {isLast: true, parentId: me.getId(), depth: (me.data.depth || 0) + 1};
  if (Ext.isArray(node)) 
  {
    me.callStore('suspendAutoSync');
    for (i = 0 , ln = node.length - 1; i < ln; i++) 
      {
        me.appendChild(node[i], suppressEvents, commit);
      }
    me.callStore('resumeAutoSync');
    me.appendChild(node[ln], suppressEvents, commit);
  } else {
    node = me.createNode(node);
    if (suppressEvents !== true && me.fireEventArgs('beforeappend', [me, node]) === false) 
    {
      return false;
    }
    index = me.childNodes.length;
    oldParent = node.parentNode;
    if (oldParent) 
    {
      if (suppressEvents !== true && node.fireEventArgs('beforemove', [node, oldParent, me, index]) === false) 
      {
        return false;
      }
      oldParent.removeChild(node, false, false, true);
    }
    if (Ext.suspendLayouts) 
    {
      Ext.suspendLayouts();
    }
    index = me.childNodes.length;
    if (index === 0) 
    {
      me.setFirstChild(node);
    }
    me.childNodes[index] = node;
    node.parentNode = me;
    node.nextSibling = null;
    me.setLastChild(node);
    previousSibling = me.childNodes[index - 1];
    if (previousSibling) 
    {
      node.previousSibling = previousSibling;
      previousSibling.nextSibling = node;
      previousSibling.updateInfo(commit, {isLast: false});
      previousSibling.triggerUIUpdate();
    } else {
      node.previousSibling = null;
    }
    childInfo.isFirst = index === 0;
    childInfo.index = index;
    node.updateInfo(commit, childInfo);
    if (me.isLeaf()) 
    {
      me.set('leaf', false);
    }
    if (!me.isLoaded()) 
    {
      me.set('loaded', true);
    } else if (me.childNodes.length === 1) 
    {
      me.triggerUIUpdate();
    }
    if (index && me.childNodes[index - 1].isExpanded()) 
    {
      me.childNodes[index - 1].cascadeBy(me.triggerUIUpdate);
    }
    if (Ext.resumeLayouts) 
    {
      Ext.resumeLayouts(true);
    }
    if (suppressEvents !== true) 
    {
      me.fireEventArgs('append', [me, node, index]);
      if (oldParent) 
      {
        node.fireEventArgs('move', [node, oldParent, me, index]);
      }
    }
    me.callStore('onNodeAdded', node, index);
    return node;
  }
}, getOwnerTree: function() {
  var node = this, store;
  while (node.parentNode) 
    {
      node = node.parentNode;
    }
  store = node.store;
  if (store) 
  {
    if (store.treeStore) 
    {
      store = store.treeStore;
    }
    if (store.tree) 
    {
      return store.ownerTree;
    }
  }
  return undefined;
}, getTreeStore: function() {
  var store = this.stores[0];
  return store.treeStore || store;
}, removeChild: function(node, destroy, suppressEvents, isMove) {
  var me = this, index = me.indexOf(node), i, childCount, previousSibling;
  if (index === -1 || (suppressEvents !== true && me.fireEventArgs('beforeremove', [me, node, !!isMove]) === false)) 
  {
    return false;
  }
  if (Ext.suspendLayouts) 
  {
    Ext.suspendLayouts();
  }
  Ext.Array.erase(me.childNodes, index, 1);
  if (me.firstChild === node) 
  {
    me.setFirstChild(node.nextSibling);
  }
  if (me.lastChild === node) 
  {
    me.setLastChild(node.previousSibling);
  }
  previousSibling = node.previousSibling;
  if (previousSibling) 
  {
    node.previousSibling.nextSibling = node.nextSibling;
  }
  if (node.nextSibling) 
  {
    node.nextSibling.previousSibling = node.previousSibling;
    if (index === 0) 
    {
      node.nextSibling.updateInfo(false, {isFirst: true});
    }
    for (i = index , childCount = me.childNodes.length; i < childCount; i++) 
      {
        me.childNodes[i].updateInfo(false, {index: i});
      }
  } else if (previousSibling) 
  {
    previousSibling.updateInfo(false, {isLast: true});
    if (previousSibling.isExpanded()) 
    {
      previousSibling.cascadeBy(me.triggerUIUpdate);
    } else {
      previousSibling.triggerUIUpdate();
    }
  }
  if (!me.childNodes.length) 
  {
    me.triggerUIUpdate();
  }
  if (Ext.resumeLayouts) 
  {
    Ext.resumeLayouts(true);
  }
  if (suppressEvents !== true) 
  {
    node.removeContext = {parentNode: node.parentNode, previousSibling: node.previousSibling, nextSibling: node.nextSibling};
    node.previousSibling = node.nextSibling = node.parentNode = null;
    me.fireEventArgs('remove', [me, node, !!isMove]);
    me.callStore('onNodeRemove', node, !!isMove);
    node.removeContext = null;
  }
  if (destroy) 
  {
    node.destroy(true);
  } else {
    node.clear();
  }
  return node;
}, copy: function(newId, deep) {
  var me = this, result = me.callParent(arguments), len = me.childNodes ? me.childNodes.length : 0, i;
  if (deep) 
  {
    for (i = 0; i < len; i++) 
      {
        result.appendChild(me.childNodes[i].copy(undefined, true));
      }
  }
  return result;
}, clear: function(destroy) {
  var me = this;
  me.parentNode = me.previousSibling = me.nextSibling = null;
  if (destroy) 
  {
    me.firstChild = me.lastChild = null;
  }
}, destroy: function(silent) {
  var me = this, options = me.destroyOptions, nodes = me.childNodes, nLen = nodes.length, n;
  if (silent === true) 
  {
    me.clear(true);
    for (n = 0; n < nLen; n++) 
      {
        nodes[n].destroy(true);
      }
    me.childNodes = null;
    delete me.destroyOptions;
    me.callParent([options]);
  } else {
    me.destroyOptions = silent;
    me.remove(true);
  }
}, insertBefore: function(node, refNode, suppressEvents) {
  var me = this, index = me.indexOf(refNode), oldParent = node.parentNode, refIndex = index, childCount, previousSibling, i;
  if (!refNode) 
  {
    return me.appendChild(node);
  }
  if (node === refNode) 
  {
    return false;
  }
  node = me.createNode(node);
  if (suppressEvents !== true && me.fireEventArgs('beforeinsert', [me, node, refNode]) === false) 
  {
    return false;
  }
  if (oldParent === me && me.indexOf(node) < index) 
  {
    refIndex--;
  }
  if (oldParent) 
  {
    if (suppressEvents !== true && node.fireEventArgs('beforemove', [node, oldParent, me, index, refNode]) === false) 
    {
      return false;
    }
    oldParent.removeChild(node, false, false, true);
  }
  if (refIndex === 0) 
  {
    me.setFirstChild(node);
  }
  Ext.Array.splice(me.childNodes, refIndex, 0, node);
  node.parentNode = me;
  node.nextSibling = refNode;
  refNode.previousSibling = node;
  previousSibling = me.childNodes[refIndex - 1];
  if (previousSibling) 
  {
    node.previousSibling = previousSibling;
    previousSibling.nextSibling = node;
  } else {
    node.previousSibling = null;
  }
  node.updateInfo(false, {parentId: me.getId(), index: refIndex, isFirst: refIndex === 0, isLast: false, depth: (me.data.depth || 0) + 1});
  for (i = refIndex + 1 , childCount = me.childNodes.length; i < childCount; i++) 
    {
      me.childNodes[i].updateInfo(false, {index: i});
    }
  if (!me.isLoaded()) 
  {
    me.set('loaded', true);
  } else if (me.childNodes.length === 1) 
  {
    me.triggerUIUpdate();
  }
  if (suppressEvents !== true) 
  {
    me.fireEventArgs('insert', [me, node, refNode]);
    if (oldParent) 
    {
      node.fireEventArgs('move', [node, oldParent, me, refIndex, refNode]);
    }
  }
  me.callStore('onNodeAdded', node, refNode);
  return node;
}, insertChild: function(index, node) {
  var sibling = this.childNodes[index];
  if (sibling) 
  {
    return this.insertBefore(node, sibling);
  } else {
    return this.appendChild(node);
  }
}, remove: function(destroy, suppressEvents) {
  var me = this, parentNode = me.parentNode;
  if (parentNode) 
  {
    parentNode.removeChild(me, destroy, suppressEvents);
  } else if (destroy) 
  {
    me.destroy(true);
  }
  return me;
}, removeAll: function(destroy, suppressEvents, fromParent) {
  var me = this, childNodes = me.childNodes, i = 0, len = childNodes.length, node;
  if (!len) 
  {
    return;
  }
  me.fireEventArgs('bulkremove', [me, childNodes, false]);
  for (; i < len; ++i) 
    {
      node = childNodes[i];
      node.removeContext = {parentNode: node.parentNode, previousSibling: node.previousSibling, nextSibling: node.nextSibling};
      node.previousSibling = node.nextSibling = node.parentNode = null;
      me.fireEventArgs('remove', [me, node, false]);
      me.callStore('onNodeRemove', node, false);
      node.removeContext = null;
      if (destroy) 
      {
        node.destroy(true);
      } else {
        node.removeAll(false, suppressEvents, true);
      }
    }
  me.firstChild = me.lastChild = null;
  if (fromParent) 
  {
    me.childNodes = null;
  } else {
    me.childNodes.length = 0;
    me.triggerUIUpdate();
  }
  return me;
}, getChildAt: function(index) {
  return this.childNodes[index];
}, replaceChild: function(newChild, oldChild, suppressEvents) {
  var s = oldChild ? oldChild.nextSibling : null;
  this.removeChild(oldChild, false, suppressEvents);
  this.insertBefore(newChild, s, suppressEvents);
  return oldChild;
}, indexOf: function(child) {
  return Ext.Array.indexOf(this.childNodes, child);
}, indexOfId: function(id) {
  var childNodes = this.childNodes, len = childNodes.length, i = 0;
  for (; i < len; ++i) 
    {
      if (childNodes[i].getId() === id) 
      {
        return i;
      }
    }
  return -1;
}, getPath: function(field, separator) {
  field = field || this.idProperty;
  separator = separator || '/';
  var path = [this.get(field)], parent = this.parentNode;
  while (parent) 
    {
      path.unshift(parent.get(field));
      parent = parent.parentNode;
    }
  return separator + path.join(separator);
}, getDepth: function() {
  return this.get('depth');
}, bubble: function(fn, scope, args) {
  var p = this;
  while (p) 
    {
      if (fn.apply(scope || p, args || [p]) === false) 
      {
        break;
      }
      p = p.parentNode;
    }
}, cascadeBy: function(before, scope, args, after) {
  var me = this;
  if (arguments.length === 1 && !Ext.isFunction(before)) 
  {
    after = before.after;
    scope = before.scope;
    args = before.args;
    before = before.before;
  }
  if (!before || before.apply(scope || me, args || [me]) !== false) 
  {
    var childNodes = me.childNodes, length = childNodes.length, i;
    for (i = 0; i < length; i++) 
      {
        childNodes[i].cascadeBy.call(childNodes[i], before, scope, args, after);
      }
    if (after) 
    {
      after.apply(scope || me, args || [me]);
    }
  }
}, eachChild: function(fn, scope, args) {
  var childNodes = this.childNodes, length = childNodes.length, i;
  for (i = 0; i < length; i++) 
    {
      if (fn.apply(scope || this, args || [childNodes[i]]) === false) 
      {
        break;
      }
    }
}, findChild: function(attribute, value, deep) {
  return this.findChildBy(function() {
  return this.get(attribute) == value;
}, null, deep);
}, findChildBy: function(fn, scope, deep) {
  var cs = this.childNodes, len = cs.length, i = 0, n, res;
  for (; i < len; i++) 
    {
      n = cs[i];
      if (fn.call(scope || n, n) === true) 
      {
        return n;
      } else if (deep) 
      {
        res = n.findChildBy(fn, scope, deep);
        if (res !== null) 
        {
          return res;
        }
      }
    }
  return null;
}, contains: function(node) {
  return node.isAncestor(this);
}, isAncestor: function(node) {
  var p = this.parentNode;
  while (p) 
    {
      if (p === node) 
      {
        return true;
      }
      p = p.parentNode;
    }
  return false;
}, sort: function(sortFn, recursive, suppressEvent) {
  var me = this, childNodes = me.childNodes, ln = childNodes.length, i, n, info = {isFirst: true};
  if (ln > 0) 
  {
    if (!sortFn) 
    {
      sortFn = me.getTreeStore().generateComparator();
    }
    Ext.Array.sort(childNodes, sortFn);
    me.setFirstChild(childNodes[0]);
    me.setLastChild(childNodes[ln - 1]);
    for (i = 0; i < ln; i++) 
      {
        n = childNodes[i];
        n.previousSibling = childNodes[i - 1];
        n.nextSibling = childNodes[i + 1];
        info.isLast = (i === ln - 1);
        info.index = i;
        n.updateInfo(false, info);
        info.isFirst = false;
        if (recursive && !n.isLeaf()) 
        {
          n.sort(sortFn, true, true);
        }
      }
    if (suppressEvent !== true) 
    {
      me.fireEventArgs('sort', [me, childNodes]);
      me.callStore('onNodeSort', childNodes);
    }
  }
}, isExpanded: function() {
  return this.get('expanded');
}, isLoaded: function() {
  return this.get('loaded');
}, isLoading: function() {
  return this.get('loading');
}, isRoot: function() {
  return !this.parentNode;
}, isVisible: function() {
  var parent = this.parentNode;
  while (parent) 
    {
      if (!parent.isExpanded()) 
      {
        return false;
      }
      parent = parent.parentNode;
    }
  return true;
}, expand: function(recursive, callback, scope) {
  var me = this;
  if (!me.isLeaf()) 
  {
    if (me.isLoading()) 
    {
      me.on('expand', function() {
  me.expand(recursive, callback, scope);
}, me, {single: true});
    } else {
      if (!me.isExpanded()) 
      {
        me.fireEventArgs('beforeexpand', [me]);
        me.callStore('onBeforeNodeExpand', me.onChildNodesAvailable, me, [recursive, callback, scope]);
      } else if (recursive) 
      {
        me.expandChildren(true, callback, scope);
      } else {
        Ext.callback(callback, scope || me, [me.childNodes]);
      }
    }
  } else {
    Ext.callback(callback, scope || me);
  }
}, onChildNodesAvailable: function(records, recursive, callback, scope) {
  var me = this;
  if (Ext.suspendLayouts) 
  {
    Ext.suspendLayouts();
  }
  me.set('expanded', true);
  me.fireEventArgs('expand', [me, me.childNodes, false]);
  if (recursive) 
  {
    me.expandChildren(true, callback, scope);
  } else {
    Ext.callback(callback, scope || me, [me.childNodes]);
  }
  if (Ext.resumeLayouts) 
  {
    Ext.resumeLayouts(true);
  }
}, expandChildren: function(recursive, callback, scope, singleExpand) {
  var me = this, origCallback, i, allNodes, expandNodes, ln, node;
  if (Ext.isBoolean(callback)) 
  {
    origCallback = callback;
    callback = scope;
    scope = singleExpand;
    singleExpand = origCallback;
  }
  if (singleExpand === undefined) 
  {
    singleExpand = me.getTreeStore().singleExpand;
  }
  allNodes = me.childNodes;
  expandNodes = [];
  ln = singleExpand ? Math.min(allNodes.length, 1) : allNodes.length;
  for (i = 0; i < ln; ++i) 
    {
      node = allNodes[i];
      if (!node.isLeaf()) 
      {
        expandNodes[expandNodes.length] = node;
      }
    }
  ln = expandNodes.length;
  for (i = 0; i < ln; ++i) 
    {
      expandNodes[i].expand(recursive);
    }
  if (callback) 
  {
    Ext.callback(callback, scope || me, [me.childNodes]);
  }
}, collapse: function(recursive, callback, scope) {
  var me = this, expanded = me.isExpanded(), len = me.childNodes.length, i, collapseChildren;
  if (!me.isLeaf() && ((!expanded && recursive) || me.fireEventArgs('beforecollapse', [me]) !== false)) 
  {
    if (Ext.suspendLayouts) 
    {
      Ext.suspendLayouts();
    }
    if (me.isExpanded()) 
    {
      if (recursive) 
      {
        collapseChildren = function() {
  for (i = 0; i < len; i++) 
    {
      me.childNodes[i].setCollapsed(true);
    }
};
        if (callback) 
        {
          callback = Ext.Function.createSequence(collapseChildren, callback);
        } else {
          callback = collapseChildren;
        }
      }
      me.set('expanded', false);
      me.fireEventArgs('collapse', [me, me.childNodes, false, callback ? Ext.Function.bind(callback, scope, [me.childNodes]) : null, null]);
      callback = null;
    } else if (recursive) 
    {
      for (i = 0; i < len; i++) 
        {
          me.childNodes[i].setCollapsed(true);
        }
    }
    if (Ext.resumeLayouts) 
    {
      Ext.resumeLayouts(true);
    }
  }
  Ext.callback(callback, scope || me, [me.childNodes]);
}, setCollapsed: function(recursive) {
  var me = this, len = me.childNodes.length, i;
  if (!me.isLeaf() && me.fireEventArgs('beforecollapse', [me, Ext.emptyFn]) !== false) 
  {
    me.data.expanded = false;
    me.fireEventArgs('collapse', [me, me.childNodes, false, null, null]);
    if (recursive) 
    {
      for (i = 0; i < len; i++) 
        {
          me.childNodes[i].setCollapsed(true);
        }
    }
  }
}, collapseChildren: function(recursive, callback, scope) {
  var me = this, i, allNodes = me.childNodes, ln = allNodes.length, collapseNodes = [], node;
  for (i = 0; i < ln; ++i) 
    {
      node = allNodes[i];
      if (!node.isLeaf() && node.isLoaded() && node.isExpanded()) 
      {
        collapseNodes.push(node);
      }
    }
  ln = collapseNodes.length;
  if (ln) 
  {
    for (i = 0; i < ln; ++i) 
      {
        node = collapseNodes[i];
        if (i === ln - 1) 
        {
          node.collapse(recursive, callback, scope);
        } else {
          node.collapse(recursive);
        }
      }
  } else {
    Ext.callback(callback, scope);
  }
}, fireEventArgs: function(eventName, args) {
  var fireEventArgs = Ext.data.Model.prototype.fireEventArgs, result, eventSource, tree, treeStore, rootNode;
  if (bubbledEvents[eventName]) 
  {
    for (eventSource = this; result !== false && eventSource; eventSource = (rootNode = eventSource).parentNode) 
      {
        if (eventSource.hasListeners[eventName]) 
        {
          result = fireEventArgs.call(eventSource, eventName, args);
        }
      }
    tree = rootNode.rootOf;
    if (result !== false && tree) 
    {
      treeStore = tree.treeStore;
      if (treeStore && treeStore.hasListeners[eventName]) 
      {
        result = treeStore.fireEventArgs.call(treeStore, eventName, args);
      }
      if (result !== false && tree.hasListeners[eventName]) 
      {
        result = tree.fireEventArgs.call(tree, eventName, args);
      }
    }
    return result;
  } else {
    return fireEventArgs.apply(this, arguments);
  }
}, serialize: function() {
  var result = Ext.data.writer.Json.prototype.getRecordData(this), childNodes = this.childNodes, len = childNodes.length, children, i;
  if (len > 0) 
  {
    children = [];
    for (i = 0; i < len; i++) 
      {
        children.push(childNodes[i].serialize());
      }
    result.children = children;
  }
  return result;
}};
}}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'NodeInterface'], 0));
;

(Ext.cmd.derive('Ext.data.Request', Ext.Base, {action: undefined, params: undefined, method: 'GET', url: undefined, constructor: function(config) {
  Ext.apply(this, config);
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Request'], 0));
;

(Ext.cmd.derive('Ext.data.Tree', Ext.Base, {root: null, constructor: function(root) {
  var me = this;
  me.mixins.observable.constructor.call(me);
  if (root) 
  {
    me.setRootNode(root);
  }
  me.on({scope: me, idchanged: me.onNodeIdChanged, insert: me.onNodeInsert, append: me.onNodeAppend, remove: me.onNodeRemove});
}, getRootNode: function() {
  return this.root;
}, setRootNode: function(node) {
  var me = this;
  me.root = node;
  if (node.rootOf) 
  {
    node.rootOf.removeRootNode();
  } else if (node.parentNode) 
  {
    node.parentNode.removeChild(node);
  }
  node.rootOf = me;
  if (node.fireEventArgs('beforeappend', [null, node]) !== false) 
  {
    node.set('root', true);
    node.updateInfo(true, {isFirst: true, isLast: true, depth: 0, index: 0, parentId: null});
    me.nodeHash = {};
    node.fireEvent('append', null, node);
    node.fireEvent('rootchange', node);
  }
  return node;
}, removeRootNode: function() {
  var me = this, root = me.root;
  root.set('root', false);
  root.fireEvent('remove', null, root, false);
  root.fireEvent('rootchange', null);
  root.rootOf = me.root = null;
  return root;
}, flatten: function() {
  return Ext.Object.getValues(this.nodeHash);
}, onNodeInsert: function(parent, node) {
  this.registerNode(node, true);
}, onNodeAppend: function(parent, node) {
  this.registerNode(node, true);
}, onNodeRemove: function(parent, node) {
  this.unregisterNode(node, true);
}, onNodeIdChanged: function(node, oldId, newId, oldInternalId) {
  var nodeHash = this.nodeHash;
  delete nodeHash[oldId || oldInternalId];
  nodeHash[newId] = node;
}, getNodeById: function(id) {
  return this.nodeHash[id];
}, registerNode: function(node, includeChildren) {
  var me = this, children, length, i;
  me.nodeHash[node.getId() || node.internalId] = node;
  if (includeChildren === true) 
  {
    children = node.childNodes;
    length = children.length;
    for (i = 0; i < length; i++) 
      {
        me.registerNode(children[i], true);
      }
  }
}, unregisterNode: function(node, includeChildren) {
  var me = this, children, length, i;
  delete me.nodeHash[node.getId() || node.internalId];
  if (includeChildren === true) 
  {
    children = node.childNodes;
    length = children.length;
    for (i = 0; i < length; i++) 
      {
        me.unregisterNode(children[i], true);
      }
  }
}, sort: function(sorterFn, recursive) {
  this.getRootNode().sort(sorterFn, recursive);
}, filter: function(filters, recursive) {
  this.getRootNode().filter(filters, recursive);
}}, 1, 0, 0, 0, ["data.tree"], [['observable', Ext.util.Observable]], [Ext.data, 'Tree'], 0));
;

(Ext.cmd.derive('Ext.data.TreeModel', Ext.data.Model, {getRefItems: function() {
  return this.childNodes;
}, getRefOwner: function() {
  return this.parentNode;
}}, 0, 0, 0, 0, 0, [['queryable', Ext.Queryable]], [Ext.data, 'TreeModel'], function() {
  Ext.data.NodeInterface.decorate(this);
}));
;

(Ext.cmd.derive('Ext.data.TreeStore', Ext.data.AbstractStore, {clearOnLoad: true, clearRemovedOnLoad: true, nodeParam: 'node', defaultRootId: 'root', defaultRootText: 'Root', defaultRootProperty: 'children', fillCount: 0, folderSort: false, constructor: function(config) {
  var me = this, root, fields, model;
  config = Ext.apply({}, config);
  fields = config.fields || me.fields;
  model = config.model || me.model;
  if (!model) 
  {
    if (!fields) 
    {
      fields = [{name: 'text', type: 'string'}];
    }
    if (me.defaultRootProperty !== me.self.prototype.defaultRootProperty) 
    {
      fields.push({name: me.defaultRootProperty, type: 'auto', defaultValue: null, persist: false});
    }
    config.model = Ext.define(null, {extend: 'Ext.data.TreeModel', fields: fields, proxy: me.proxy || me.defaultProxyType});
    delete me.fields;
    me.implicitModel = true;
  }
  me.callParent([config]);
  me.tree = new Ext.data.Tree();
  me.tree.treeStore = me;
  me.onBeforeSort();
  root = me.root;
  if (root) 
  {
    delete me.root;
    me.setRootNode(root);
  }
}, setProxy: function(proxy) {
  var reader, needsRoot;
  if (proxy instanceof Ext.data.proxy.Proxy) 
  {
    needsRoot = Ext.isEmpty(proxy.getReader().root);
  } else if (Ext.isString(proxy)) 
  {
    needsRoot = true;
  } else {
    reader = proxy.reader;
    needsRoot = !(reader && !Ext.isEmpty(reader.root));
  }
  proxy = this.callParent(arguments);
  proxy.idParam = this.nodeParam;
  if (needsRoot) 
  {
    reader = proxy.getReader();
    reader.root = this.defaultRootProperty;
    reader.buildExtractors(true);
  }
  return proxy;
}, filter: function(filters, value) {
  if (Ext.isString(filters)) 
  {
    filters = {property: filters, value: value};
  }
  var me = this, decoded = me.decodeFilters(filters), i, length = decoded.length, root = me.getRootNode(), filteredNodes;
  for (i = 0; i < length; i++) 
    {
      me.filters.replace(decoded[i]);
    }
  filters = me.filters.items;
  if (filters.length) 
  {
    filteredNodes = [];
    me.filterFn = Ext.util.Filter.createFilterFn(filters);
    root.cascadeBy({after: function(node) {
  node.set('visible', me.filterFn(node));
}});
    for (i = 0 , length = root.childNodes.length; i < length; i++) 
      {
        if (root.childNodes[i].get('visible')) 
        {
          filteredNodes.push(root.childNodes[i]);
        }
      }
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  } else {
    filteredNodes = root.childNodes;
  }
  root.fireEvent('filterchange', root, filteredNodes);
  me.fireEvent('filterchange', me, filters);
}, clearFilter: function() {
  var me = this, root = me.getRootNode();
  me.filters.clear();
  me.filterFn = null;
  root.cascadeBy(function(node) {
  node.set('visible', true);
});
  root.fireEvent('filterchange', root, root.childNodes);
  me.fireEvent('filterchange', me, []);
}, onBeforeSort: function() {
  if (this.folderSort) 
  {
    this.sort({property: 'leaf', direction: 'ASC'}, 'prepend', false);
  }
}, onBeforeNodeExpand: function(node, callback, scope, args) {
  var me = this, reader = me.proxy.getReader(), children, callbackArgs;
  if (node.isLoaded()) 
  {
    callbackArgs = [node.childNodes];
    if (args) 
    {
      callbackArgs.push.apply(callbackArgs, args);
    }
    Ext.callback(callback, scope || node, callbackArgs);
  } else if (node.isLoading()) 
  {
    me.on('load', function() {
  callbackArgs = [node.childNodes];
  if (args) 
  {
    callbackArgs.push.apply(callbackArgs, args);
  }
  Ext.callback(callback, scope || node, callbackArgs);
}, me, {single: true, priority: 1001});
  } else {
    children = reader.getRoot(node.raw || node[node.persistenceProperty]);
    if (children || node.phantom) 
    {
      if (children) 
      {
        me.fillNode(node, reader.extractData(children));
      }
      callbackArgs = [node.childNodes];
      if (args) 
      {
        callbackArgs.push.apply(callbackArgs, args);
      }
      Ext.callback(callback, scope || node, callbackArgs);
    } else {
      me.read({node: node, internalCallback: function() {
  delete me.lastOptions.internalCallback;
  callbackArgs = [node.childNodes];
  if (args) 
  {
    callbackArgs.push.apply(callbackArgs, args);
  }
  Ext.callback(callback, scope || node, callbackArgs);
}});
    }
  }
}, getNewRecords: function() {
  return Ext.Array.filter(this.tree.flatten(), this.filterNew);
}, getUpdatedRecords: function() {
  return Ext.Array.filter(this.tree.flatten(), this.filterUpdated);
}, onNodeRemove: function(parent, node, isMove) {
  var me = this;
  node.unjoin(me);
  if (!node.phantom && !isMove && !me.loading) 
  {
    Ext.Array.include(me.removed, node);
  }
  if (me.autoSync && !me.autoSyncSuspended && !isMove) 
  {
    me.sync();
  }
}, onNodeAdded: function(parent, node) {
  var me = this, reader = me.proxy.getReader(), data = node.raw || node[node.persistenceProperty], dataRoot, isVisible;
  if (me.filterFn) 
  {
    isVisible = me.filterFn(node);
    node.set('visible', isVisible);
    if (isVisible) 
    {
      parent.set('visible', me.filterFn(parent));
    }
  }
  Ext.Array.remove(me.removed, node);
  node.join(me);
  if (!node.isLeaf() && !node.isLoaded() && !me.lazyFill) 
  {
    dataRoot = reader.getRoot(data);
    if (dataRoot) 
    {
      me.fillNode(node, reader.extractData(dataRoot));
    }
  }
  if (me.autoSync && !me.autoSyncSuspended && (node.phantom || node.dirty)) 
  {
    me.sync();
  }
}, onNodeSort: function() {
  if (this.autoSync && !this.autoSyncSuspended) 
  {
    this.sync();
  }
}, setRootNode: function(root, preventLoad) {
  var me = this, model = me.model, idProperty = model.prototype.idProperty;
  if (!model.prototype.isNode) 
  {
    Ext.data.NodeInterface.decorate(model);
  }
  if (!root || !root.isNode) 
  {
    root = Ext.apply({id: me.defaultRootId, text: me.defaultRootText, allowDrag: false}, root);
    if (root[idProperty] === undefined) 
    {
      root[idProperty] = me.defaultRootId;
    }
    root = Ext.ModelManager.create(root, model);
  }
  me.getProxy().getReader().buildExtractors(true);
  me.onNodeAdded(null, root);
  me.tree.setRootNode(root);
  if (preventLoad !== true && !root.isLoaded() && (me.autoLoad === true || root.isExpanded())) 
  {
    root.data.expanded = false;
    root.expand();
  }
  return root;
}, getRootNode: function() {
  return this.tree.getRootNode();
}, getNodeById: function(id) {
  return this.tree.getNodeById(id);
}, getById: function(id) {
  return this.getNodeById(id);
}, load: function(options) {
  options = options || {};
  options.params = options.params || {};
  var me = this, node = options.node || me.tree.getRootNode(), callback = options.callback, scope = options.scope, operation;
  if (!node) 
  {
    node = me.setRootNode({expanded: true}, true);
  }
  if (node.data.expanded) 
  {
    node.data.loaded = false;
    if (me.clearOnLoad) 
    {
      node.data.expanded = false;
    }
    options.callback = function() {
  if (!me.clearOnLoad) 
  {
    node.collapse();
  }
  node.expand();
  Ext.callback(callback, scope, arguments);
};
  }
  options.id = node.getId();
  options = Ext.apply({action: 'read', filters: me.filters.items, sorters: me.getSorters(), node: options.node || node}, options);
  me.lastOptions = options;
  operation = new Ext.data.Operation(options);
  if (me.fireEvent('beforeload', me, operation) !== false) 
  {
    me.loading = true;
    if (me.clearOnLoad) 
    {
      if (me.clearRemovedOnLoad) 
      {
        me.clearRemoved(node);
      }
      node.removeAll(false);
    }
    me.proxy.read(operation, me.onProxyLoad, me);
  }
  if (me.loading && node) 
  {
    node.set('loading', true);
  }
  return me;
}, clearRemoved: function(node) {
  var me = this, removed = me.removed, id = node.getId(), removedLength = removed.length, i = removedLength, recordsToClear = {}, newRemoved = [], removedHash = {}, removedNode, targetNode, targetId;
  if (node === me.getRootNode()) 
  {
    me.removed = [];
    return;
  }
  for (; i--; ) 
    {
      removedNode = removed[i];
      removedHash[removedNode.getId()] = removedNode;
    }
  for (i = removedLength; i--; ) 
    {
      removedNode = removed[i];
      targetNode = removedNode;
      while (targetNode && targetNode.getId() !== id) 
        {
          targetId = targetNode.get('parentId');
          targetNode = targetNode.parentNode || me.getNodeById(targetId) || removedHash[targetId];
        }
      if (targetNode) 
      {
        recordsToClear[removedNode.getId()] = removedNode;
      }
    }
  for (i = 0; i < removedLength; i++) 
    {
      removedNode = removed[i];
      if (!recordsToClear[removedNode.getId()]) 
      {
        newRemoved.push(removedNode);
      }
    }
  me.removed = newRemoved;
}, fillNode: function(node, newNodes) {
  var me = this, newNodeCount = newNodes ? newNodes.length : 0, sorters = me.sorters, i, sortCollection, needsIndexSort = false, performLocalSort = me.sortOnLoad && !me.remoteSort && sorters && sorters.items && sorters.items.length, node1, node2, rootFill;
  if (newNodeCount) 
  {
    if (me.filterFn) 
    {
      newNodes[0].set('visible', me.filterFn(newNodes[0]));
    }
    for (i = 1; !needsIndexSort && i < newNodeCount; i++) 
      {
        node1 = newNodes[i];
        node2 = newNodes[i - 1];
        if (me.filterFn) 
        {
          node1.set('visible', me.filterFn(node1));
        }
        needsIndexSort = node1[node1.persistenceProperty].index !== node2[node2.persistenceProperty].index;
      }
    if (performLocalSort) 
    {
      if (needsIndexSort) 
      {
        me.sorters.insert(0, me.indexSorter);
      }
      sortCollection = new Ext.util.MixedCollection();
      sortCollection.addAll(newNodes);
      sortCollection.sort(me.sorters.items);
      newNodes = sortCollection.items;
      me.sorters.remove(me.indexSorter);
    } else if (needsIndexSort) 
    {
      Ext.Array.sort(newNodes, me.sortByIndex);
    }
  }
  node.set('loaded', true);
  rootFill = me.fillCount === 0;
  if (rootFill) 
  {
    me.fireEvent('beforefill', me, node, newNodes);
  }
  ++me.fillCount;
  if (newNodes.length) 
  {
    node.appendChild(newNodes, undefined, true);
  }
  if (rootFill) 
  {
    me.fireEvent('fillcomplete', me, node, newNodes);
  }
  --me.fillCount;
  return newNodes;
}, sortByIndex: function(node1, node2) {
  return node1[node1.persistenceProperty].index - node2[node2.persistenceProperty].index;
}, onIdChanged: function(model, oldId, newId, oldInternalId) {
  this.tree.onNodeIdChanged(model, oldId, newId, oldInternalId);
  this.callParent(arguments);
}, onProxyLoad: function(operation) {
  var me = this, successful = operation.wasSuccessful(), records = operation.getRecords(), node = operation.node, scope = operation.scope || me, args = [records, operation, successful];
  me.loading = false;
  node.set('loading', false);
  if (successful) 
  {
    if (!me.clearOnLoad) 
    {
      records = me.cleanRecords(node, records);
    }
    records = me.fillNode(node, records);
  }
  Ext.callback(operation.internalCallback, scope, args);
  me.fireEvent('read', me, operation.node, records, successful);
  me.fireEvent('load', me, operation.node, records, successful);
  Ext.callback(operation.callback, scope, args);
}, cleanRecords: function(node, records) {
  var nodeHash = {}, childNodes = node.childNodes, i = 0, len = childNodes.length, out = [], rec;
  for (; i < len; ++i) 
    {
      nodeHash[childNodes[i].getId()] = true;
    }
  for (i = 0 , len = records.length; i < len; ++i) 
    {
      rec = records[i];
      if (!nodeHash[rec.getId()]) 
      {
        out.push(rec);
      }
    }
  return out;
}, removeAll: function() {
  var root = this.getRootNode();
  if (root) 
  {
    root.destroy(true);
  }
  this.fireEvent('clear', this);
}, doSort: function(sorterFn) {
  var me = this;
  if (me.remoteSort) 
  {
    me.load();
  } else {
    me.tree.sort(sorterFn, true);
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
  me.fireEvent('sort', me, me.sorters.getRange());
}}, 1, 0, 0, 0, ["store.tree"], 0, [Ext.data, 'TreeStore'], function() {
  var proto = this.prototype;
  proto.indexSorter = new Ext.util.Sorter({sorterFn: proto.sortByIndex});
}));
;

(Ext.cmd.derive('Ext.data.association.BelongsTo', Ext.data.association.Association, {alternateClassName: 'Ext.data.BelongsToAssociation', constructor: function(config) {
  this.callParent(arguments);
  var me = this, ownerProto = me.ownerModel.prototype, associatedName = me.associatedName, getterName = me.getterName || 'get' + associatedName, setterName = me.setterName || 'set' + associatedName;
  Ext.applyIf(me, {name: associatedName, foreignKey: associatedName.toLowerCase() + "_id", instanceName: associatedName + 'BelongsToInstance', associationKey: associatedName.toLowerCase()});
  ownerProto[getterName] = me.createGetter();
  ownerProto[setterName] = me.createSetter();
}, createSetter: function() {
  var me = this, foreignKey = me.foreignKey, instanceName = me.instanceName;
  return function(value, options, scope) {
  var setByRecord = value && value.isModel, valueToSet = setByRecord ? value.getId() : value;
  if (setByRecord) 
  {
    this[instanceName] = value;
  } else if (this[instanceName] instanceof Ext.data.Model && !this.isEqual(this.get(foreignKey), valueToSet)) 
  {
    delete this[instanceName];
  }
  this.set(foreignKey, valueToSet);
  if (Ext.isFunction(options)) 
  {
    options = {callback: options, scope: scope || this};
  }
  if (Ext.isObject(options)) 
  {
    return this.save(options);
  }
};
}, createGetter: function() {
  var me = this, associatedName = me.associatedName, associatedModel = me.associatedModel, foreignKey = me.foreignKey, primaryKey = me.primaryKey, instanceName = me.instanceName;
  return function(options, scope) {
  options = options || {};
  var model = this, foreignKeyId = model.get(foreignKey), success, instance, args;
  if (options.reload === true || model[instanceName] === undefined) 
  {
    if (Ext.isEmpty(foreignKeyId)) 
    {
      return null;
    }
    instance = Ext.ModelManager.create({}, associatedName);
    instance.set(primaryKey, foreignKeyId);
    if (typeof options == 'function') 
    {
      options = {callback: options, scope: scope || model};
    }
    success = options.success;
    options.success = function(rec) {
  model[instanceName] = rec;
  if (success) 
  {
    success.apply(this, arguments);
  }
};
    associatedModel.load(foreignKeyId, options);
    model[instanceName] = instance;
    return instance;
  } else {
    instance = model[instanceName];
    args = [instance];
    scope = scope || options.scope || model;
    if (options) 
    {
      Ext.callback(options, scope, args);
      Ext.callback(options.success, scope, args);
      Ext.callback(options.callback, scope, args);
    }
    return instance;
  }
};
}, read: function(record, reader, associationData) {
  record[this.instanceName] = reader.read([associationData]).records[0];
}}, 1, 0, 0, 0, ["association.belongsto"], 0, [Ext.data.association, 'BelongsTo', Ext.data, 'BelongsToAssociation'], 0));
;

(Ext.cmd.derive('Ext.util.Inflector', Ext.Base, {singleton: true, plurals: [[(/(quiz)$/i), "$1zes"], [(/^(ox)$/i), "$1en"], [(/([m|l])ouse$/i), "$1ice"], [(/(matr|vert|ind)ix|ex$/i), "$1ices"], [(/(x|ch|ss|sh)$/i), "$1es"], [(/([^aeiouy]|qu)y$/i), "$1ies"], [(/(hive)$/i), "$1s"], [(/(?:([^f])fe|([lr])f)$/i), "$1$2ves"], [(/sis$/i), "ses"], [(/([ti])um$/i), "$1a"], [(/(buffal|tomat|potat)o$/i), "$1oes"], [(/(bu)s$/i), "$1ses"], [(/(alias|status|sex)$/i), "$1es"], [(/(octop|vir)us$/i), "$1i"], [(/(ax|test)is$/i), "$1es"], [(/^person$/), "people"], [(/^man$/), "men"], [(/^(child)$/), "$1ren"], [(/s$/i), "s"], [(/$/), "s"]], singulars: [[(/(quiz)zes$/i), "$1"], [(/(matr)ices$/i), "$1ix"], [(/(vert|ind)ices$/i), "$1ex"], [(/^(ox)en/i), "$1"], [(/(alias|status)es$/i), "$1"], [(/(octop|vir)i$/i), "$1us"], [(/(cris|ax|test)es$/i), "$1is"], [(/(shoe)s$/i), "$1"], [(/(o)es$/i), "$1"], [(/(bus)es$/i), "$1"], [(/([m|l])ice$/i), "$1ouse"], [(/(x|ch|ss|sh)es$/i), "$1"], [(/(m)ovies$/i), "$1ovie"], [(/(s)eries$/i), "$1eries"], [(/([^aeiouy]|qu)ies$/i), "$1y"], [(/([lr])ves$/i), "$1f"], [(/(tive)s$/i), "$1"], [(/(hive)s$/i), "$1"], [(/([^f])ves$/i), "$1fe"], [(/(^analy)ses$/i), "$1sis"], [(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i), "$1$2sis"], [(/([ti])a$/i), "$1um"], [(/(n)ews$/i), "$1ews"], [(/people$/i), "person"], [(/s$/i), ""]], uncountable: ["sheep", "fish", "series", "species", "money", "rice", "information", "equipment", "grass", "mud", "offspring", "deer", "means"], singular: function(matcher, replacer) {
  this.singulars.unshift([matcher, replacer]);
}, plural: function(matcher, replacer) {
  this.plurals.unshift([matcher, replacer]);
}, clearSingulars: function() {
  this.singulars = [];
}, clearPlurals: function() {
  this.plurals = [];
}, isTransnumeral: function(word) {
  return Ext.Array.indexOf(this.uncountable, word) != -1;
}, pluralize: function(word) {
  if (this.isTransnumeral(word)) 
  {
    return word;
  }
  var plurals = this.plurals, length = plurals.length, tuple, regex, i;
  for (i = 0; i < length; i++) 
    {
      tuple = plurals[i];
      regex = tuple[0];
      if (regex == word || (regex.test && regex.test(word))) 
      {
        return word.replace(regex, tuple[1]);
      }
    }
  return word;
}, singularize: function(word) {
  if (this.isTransnumeral(word)) 
  {
    return word;
  }
  var singulars = this.singulars, length = singulars.length, tuple, regex, i;
  for (i = 0; i < length; i++) 
    {
      tuple = singulars[i];
      regex = tuple[0];
      if (regex == word || (regex.test && regex.test(word))) 
      {
        return word.replace(regex, tuple[1]);
      }
    }
  return word;
}, classify: function(word) {
  return Ext.String.capitalize(this.singularize(word));
}, ordinalize: function(number) {
  var parsed = parseInt(number, 10), mod10 = parsed % 10, mod100 = parsed % 100;
  if (11 <= mod100 && mod100 <= 13) 
  {
    return number + "th";
  } else {
    switch (mod10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
      default:
        return number + "th";
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Inflector'], function() {
  var irregulars = {alumnus: 'alumni', cactus: 'cacti', focus: 'foci', nucleus: 'nuclei', radius: 'radii', stimulus: 'stimuli', ellipsis: 'ellipses', paralysis: 'paralyses', oasis: 'oases', appendix: 'appendices', index: 'indexes', beau: 'beaux', bureau: 'bureaux', tableau: 'tableaux', woman: 'women', child: 'children', man: 'men', corpus: 'corpora', criterion: 'criteria', curriculum: 'curricula', genus: 'genera', memorandum: 'memoranda', phenomenon: 'phenomena', foot: 'feet', goose: 'geese', tooth: 'teeth', antenna: 'antennae', formula: 'formulae', nebula: 'nebulae', vertebra: 'vertebrae', vita: 'vitae'}, singular;
  for (singular in irregulars) 
    {
      this.plural(singular, irregulars[singular]);
      this.singular(irregulars[singular], singular);
    }
}));
;

(Ext.cmd.derive('Ext.data.association.HasMany', Ext.data.association.Association, {alternateClassName: 'Ext.data.HasManyAssociation', constructor: function(config) {
  var me = this, ownerProto, name;
  me.callParent(arguments);
  me.name = me.name || Ext.util.Inflector.pluralize(me.associatedName.toLowerCase());
  ownerProto = me.ownerModel.prototype;
  name = me.name;
  Ext.applyIf(me, {storeName: name + "Store", foreignKey: me.ownerName.toLowerCase() + "_id"});
  ownerProto[name] = me.createStore();
}, createStore: function() {
  var that = this, associatedModel = that.associatedModel, storeName = that.storeName, foreignKey = that.foreignKey, primaryKey = that.primaryKey, filterProperty = that.filterProperty, autoLoad = that.autoLoad, remoteFilter = that.remoteFilter, storeConfig = that.storeConfig || {};
  return function() {
  var me = this, config, filter, modelDefaults = {}, id;
  if (me[storeName] === undefined) 
  {
    id = me.get(primaryKey);
    if (filterProperty) 
    {
      filter = {property: filterProperty, value: me.get(filterProperty), exactMatch: true};
    } else if (me.hasId(id)) 
    {
      filter = {property: foreignKey, value: id, exactMatch: true};
    }
    modelDefaults[foreignKey] = me.get(primaryKey);
    config = Ext.apply({}, storeConfig, {model: associatedModel, filters: filter ? [filter] : undefined, remoteFilter: remoteFilter === true, modelDefaults: modelDefaults, disableMetaChangeEvent: true});
    me[storeName] = Ext.data.AbstractStore.create(config);
    if (autoLoad) 
    {
      me[storeName].load();
    }
  }
  return me[storeName];
};
}, read: function(record, reader, associationData) {
  var store = record[this.name](), inverse, items, iLen, i;
  store.add(reader.read(associationData).records);
  inverse = this.associatedModel.prototype.associations.findBy(function(assoc) {
  return assoc.type === 'belongsTo' && assoc.associatedName === record.$className;
});
  if (inverse) 
  {
    items = store.data.items;
    iLen = items.length;
    for (i = 0; i < iLen; i++) 
      {
        items[i][inverse.instanceName] = record;
      }
  }
}}, 1, 0, 0, 0, ["association.hasmany"], 0, [Ext.data.association, 'HasMany', Ext.data, 'HasManyAssociation'], 0));
;

(Ext.cmd.derive('Ext.data.association.HasOne', Ext.data.association.Association, {alternateClassName: 'Ext.data.HasOneAssociation', constructor: function(config) {
  this.callParent(arguments);
  var me = this, ownerProto = me.ownerModel.prototype, associatedName = me.associatedName, getterName = me.getterName || 'get' + associatedName, setterName = me.setterName || 'set' + associatedName;
  Ext.applyIf(me, {name: associatedName, foreignKey: associatedName.toLowerCase() + "_id", instanceName: associatedName + 'HasOneInstance', associationKey: associatedName.toLowerCase()});
  ownerProto[getterName] = me.createGetter();
  ownerProto[setterName] = me.createSetter();
}, createSetter: function() {
  var me = this, foreignKey = me.foreignKey, instanceName = me.instanceName;
  return function(value, options, scope) {
  var setByRecord = value && value.isModel, valueToSet = setByRecord ? value.getId() : value;
  if (setByRecord) 
  {
    this[instanceName] = value;
  } else if (this[instanceName] instanceof Ext.data.Model && !this.isEqual(this.get(foreignKey), valueToSet)) 
  {
    delete this[instanceName];
  }
  this.set(foreignKey, valueToSet);
  if (Ext.isFunction(options)) 
  {
    options = {callback: options, scope: scope || this};
  }
  if (Ext.isObject(options)) 
  {
    return this.save(options);
  }
};
}, createGetter: function() {
  var me = this, ownerModel = me.ownerModel, associatedName = me.associatedName, associatedModel = me.associatedModel, foreignKey = me.foreignKey, primaryKey = me.primaryKey, instanceName = me.instanceName;
  return function(options, scope) {
  options = options || {};
  var model = this, foreignKeyId = model.get(foreignKey), success, instance, args;
  if (options.reload === true || model[instanceName] === undefined) 
  {
    if (Ext.isEmpty(foreignKeyId)) 
    {
      return null;
    }
    instance = Ext.ModelManager.create({}, associatedName);
    instance.set(primaryKey, foreignKeyId);
    if (typeof options == 'function') 
    {
      options = {callback: options, scope: scope || model};
    }
    success = options.success;
    options.success = function(rec) {
  model[instanceName] = rec;
  if (success) 
  {
    success.apply(this, arguments);
  }
};
    associatedModel.load(foreignKeyId, options);
    model[instanceName] = instance;
    return instance;
  } else {
    instance = model[instanceName];
    args = [instance];
    scope = scope || options.scope || model;
    if (options) 
    {
      Ext.callback(options, scope, args);
      Ext.callback(options.success, scope, args);
      Ext.callback(options.callback, scope, args);
    }
    return instance;
  }
};
}, read: function(record, reader, associationData) {
  var inverse = this.associatedModel.prototype.associations.findBy(function(assoc) {
  return assoc.type === 'belongsTo' && assoc.associatedName === record.$className;
}), newRecord = reader.read([associationData]).records[0];
  record[this.instanceName] = newRecord;
  if (inverse) 
  {
    newRecord[inverse.instanceName] = record;
  }
}}, 1, 0, 0, 0, ["association.hasone"], 0, [Ext.data.association, 'HasOne', Ext.data, 'HasOneAssociation'], 0));
;

(Ext.cmd.derive('Ext.dd.DDTarget', Ext.dd.DragDrop, {constructor: function(id, sGroup, config) {
  if (id) 
  {
    this.initTarget(id, sGroup, config);
  }
}, getDragEl: Ext.emptyFn, isValidHandleChild: Ext.emptyFn, startDrag: Ext.emptyFn, endDrag: Ext.emptyFn, onDrag: Ext.emptyFn, onDragDrop: Ext.emptyFn, onDragEnter: Ext.emptyFn, onDragOut: Ext.emptyFn, onDragOver: Ext.emptyFn, onInvalidDrop: Ext.emptyFn, onMouseDown: Ext.emptyFn, onMouseUp: Ext.emptyFn, setXConstraint: Ext.emptyFn, setYConstraint: Ext.emptyFn, resetConstraints: Ext.emptyFn, clearConstraints: Ext.emptyFn, clearTicks: Ext.emptyFn, setInitPosition: Ext.emptyFn, setDragElId: Ext.emptyFn, setHandleElId: Ext.emptyFn, setOuterHandleElId: Ext.emptyFn, addInvalidHandleClass: Ext.emptyFn, addInvalidHandleId: Ext.emptyFn, addInvalidHandleType: Ext.emptyFn, removeInvalidHandleClass: Ext.emptyFn, removeInvalidHandleId: Ext.emptyFn, removeInvalidHandleType: Ext.emptyFn, toString: function() {
  return ("DDTarget " + this.id);
}}, 3, 0, 0, 0, 0, 0, [Ext.dd, 'DDTarget'], 0));
;

(Ext.cmd.derive('Ext.dd.DragTracker', Ext.Base, {active: false, trackOver: false, tolerance: 5, autoStart: false, constructor: function(config) {
  var me = this;
  Ext.apply(me, config);
  me.addEvents('mouseover', 'mouseout', 'mousedown', 'mouseup', 'mousemove', 'beforedragstart', 'dragstart', 'dragend', 'drag');
  me.dragRegion = new Ext.util.Region(0, 0, 0, 0);
  if (me.el) 
  {
    me.initEl(me.el);
  }
  me.mixins.observable.constructor.call(me);
  if (me.disabled) 
  {
    me.disable();
  }
}, initEl: function(el) {
  var me = this;
  me.el = Ext.get(el);
  me.handle = Ext.get(me.delegate);
  me.delegate = me.handle ? undefined : me.delegate;
  if (!me.handle) 
  {
    me.handle = me.el;
  }
  me.handleListeners = {scope: me, delegate: me.delegate, mousedown: me.onMouseDown};
  if (me.trackOver || me.overCls) 
  {
    Ext.apply(me.handleListeners, {mouseover: me.onMouseOver, mouseout: me.onMouseOut});
  }
  me.mon(me.handle, me.handleListeners);
}, disable: function() {
  this.disabled = true;
}, enable: function() {
  this.disabled = false;
}, destroy: function() {
  var me = this;
  if (me.active) 
  {
    me.endDrag({});
  }
  me.clearListeners();
  me.mun(me.handle, me.handleListeners);
  me.el = me.handle = null;
}, onMouseOver: function(e, target) {
  var me = this, handleCls, el, i, len, cls;
  if (!me.disabled) 
  {
    if (e.within(target, true, true) || me.delegate) 
    {
      handleCls = me.handleCls;
      me.mouseIsOut = false;
      if (handleCls) 
      {
        for (i = 0 , len = me.handleEls.length; i < len; i++) 
          {
            el = me.handleEls[i];
            cls = el.delegateCls;
            if (!cls) 
            {
              cls = el.delegateCls = [handleCls, '-', el.region, '-over'].join('');
            }
            el.addCls([cls, me.overCls]);
          }
      }
      me.fireEvent('mouseover', me, e, me.delegate ? e.getTarget(me.delegate, target) : me.handle);
    }
  }
}, onMouseOut: function(e) {
  var me = this, el, i, len;
  if (me.mouseIsDown) 
  {
    me.mouseIsOut = true;
  } else {
    if (me.handleCls) 
    {
      for (i = 0 , len = me.handleEls.length; i < len; i++) 
        {
          el = me.handleEls[i];
          el.removeCls([el.delegateCls, me.overCls]);
        }
    }
    me.fireEvent('mouseout', me, e);
  }
}, onMouseDown: function(e, target) {
  var me = this, el;
  if (me.disabled || e.dragTracked) 
  {
    return;
  }
  me.dragTarget = me.delegate ? target : me.handle.dom;
  me.startXY = me.lastXY = e.getXY();
  me.startRegion = Ext.fly(me.dragTarget).getRegion();
  if (me.fireEvent('mousedown', me, e) === false || me.fireEvent('beforedragstart', me, e) === false || me.onBeforeStart(e) === false) 
  {
    return;
  }
  me.mouseIsDown = true;
  e.dragTracked = true;
  el = me.el.dom;
  if (Ext.isIE && el.setCapture) 
  {
    el.setCapture();
  }
  if (me.preventDefault !== false) 
  {
    e.preventDefault();
  }
  Ext.getDoc().on({scope: me, mouseup: me.onMouseUp, mousemove: me.onMouseMove, selectstart: me.stopSelect});
  me.dragEnded = false;
  if (!me.tolerance) 
  {
    me.triggerStart();
  } else if (me.autoStart) 
  {
    me.timer = Ext.defer(me.triggerStart, me.autoStart === true ? 1000 : me.autoStart, me, [e]);
  }
}, onMouseMove: function(e, target) {
  var me = this, xy = e.getXY(), s = me.startXY;
  if (me.dragEnded) 
  {
    return;
  }
  me.lastXY = xy;
  if (!me.active) 
  {
    if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > me.tolerance) 
    {
      me.triggerStart(e);
    } else {
      return;
    }
  }
  if (me.fireEvent('mousemove', me, e) === false) 
  {
    me.onMouseUp(e);
  } else {
    me.onDrag(e);
    me.fireEvent('drag', me, e);
  }
}, onMouseUp: function(e) {
  var me = this;
  me.mouseIsDown = false;
  if (me.mouseIsOut) 
  {
    me.mouseIsOut = false;
    me.onMouseOut(e);
  }
  e.preventDefault();
  if (Ext.isIE && document.releaseCapture) 
  {
    document.releaseCapture();
  }
  me.fireEvent('mouseup', me, e);
  me.endDrag(e);
}, endDrag: function(e) {
  var me = this, wasActive = me.active;
  Ext.getDoc().un({mousemove: me.onMouseMove, mouseup: me.onMouseUp, selectstart: me.stopSelect, scope: me});
  me.clearStart();
  me.active = false;
  if (wasActive) 
  {
    me.dragEnded = true;
    me.onEnd(e);
    me.fireEvent('dragend', me, e);
  }
  me._constrainRegion = Ext.EventObject.dragTracked = null;
}, triggerStart: function(e) {
  var me = this;
  me.clearStart();
  me.active = true;
  me.onStart(e);
  me.fireEvent('dragstart', me, e);
}, clearStart: function() {
  var timer = this.timer;
  if (timer) 
  {
    clearTimeout(timer);
    this.timer = null;
  }
}, stopSelect: function(e) {
  e.stopEvent();
  return false;
}, onBeforeStart: function(e) {
}, onStart: function(xy) {
}, onDrag: function(e) {
}, onEnd: function(e) {
}, getDragTarget: function() {
  return this.dragTarget;
}, getDragCt: function() {
  return this.el;
}, getConstrainRegion: function() {
  var me = this;
  if (me.constrainTo) 
  {
    if (me.constrainTo instanceof Ext.util.Region) 
    {
      return me.constrainTo;
    }
    if (!me._constrainRegion) 
    {
      me._constrainRegion = Ext.fly(me.constrainTo).getViewRegion();
    }
  } else {
    if (!me._constrainRegion) 
    {
      me._constrainRegion = me.getDragCt().getViewRegion();
    }
  }
  return me._constrainRegion;
}, getXY: function(constrain) {
  return constrain ? this.constrainModes[constrain](this, this.lastXY) : this.lastXY;
}, getOffset: function(constrain) {
  var xy = this.getXY(constrain), s = this.startXY;
  return [xy[0] - s[0], xy[1] - s[1]];
}, constrainModes: {point: function(me, xy) {
  var dr = me.dragRegion, constrainTo = me.getConstrainRegion();
  if (!constrainTo) 
  {
    return xy;
  }
  dr.x = dr.left = dr[0] = dr.right = xy[0];
  dr.y = dr.top = dr[1] = dr.bottom = xy[1];
  dr.constrainTo(constrainTo);
  return [dr.left, dr.top];
}, dragTarget: function(me, xy) {
  var s = me.startXY, dr = me.startRegion.copy(), constrainTo = me.getConstrainRegion(), adjust;
  if (!constrainTo) 
  {
    return xy;
  }
  dr.translateBy(xy[0] - s[0], xy[1] - s[1]);
  if (dr.right > constrainTo.right) 
  {
    xy[0] += adjust = (constrainTo.right - dr.right);
    dr.left += adjust;
  }
  if (dr.left < constrainTo.left) 
  {
    xy[0] += (constrainTo.left - dr.left);
  }
  if (dr.bottom > constrainTo.bottom) 
  {
    xy[1] += adjust = (constrainTo.bottom - dr.bottom);
    dr.top += adjust;
  }
  if (dr.top < constrainTo.top) 
  {
    xy[1] += (constrainTo.top - dr.top);
  }
  return xy;
}}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.dd, 'DragTracker'], 0));
;

(Ext.cmd.derive('Ext.dd.DragZone', Ext.dd.DragSource, {constructor: function(el, config) {
  var me = this, scroll = me.containerScroll;
  me.callParent([el, config]);
  if (scroll) 
  {
    el = me.scrollEl || el;
    el = Ext.get(el);
    if (Ext.isObject(scroll)) 
    {
      el.ddScrollConfig = scroll;
    }
    Ext.dd.ScrollManager.register(el);
  }
}, getDragData: function(e) {
  return Ext.dd.Registry.getHandleFromEvent(e);
}, onInitDrag: function(x, y) {
  this.proxy.update(this.dragData.ddel.cloneNode(true));
  this.onStartDrag(x, y);
  return true;
}, getRepairXY: function(e) {
  return Ext.fly(this.dragData.ddel).getXY();
}, destroy: function() {
  this.callParent();
  if (this.containerScroll) 
  {
    Ext.dd.ScrollManager.unregister(this.scrollEl || this.el);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'DragZone'], 0));
;

(Ext.cmd.derive('Ext.dd.ScrollManager', Ext.Base, {singleton: true, constructor: function() {
  var ddm = Ext.dd.DragDropManager;
  ddm.fireEvents = Ext.Function.createSequence(ddm.fireEvents, this.onFire, this);
  ddm.stopDrag = Ext.Function.createSequence(ddm.stopDrag, this.onStop, this);
  this.doScroll = Ext.Function.bind(this.doScroll, this);
  this.ddmInstance = ddm;
  this.els = {};
  this.dragEl = null;
  this.proc = {};
}, onStop: function(e) {
  var sm = Ext.dd.ScrollManager;
  sm.dragEl = null;
  sm.clearProc();
}, triggerRefresh: function() {
  if (this.ddmInstance.dragCurrent) 
  {
    this.ddmInstance.refreshCache(this.ddmInstance.dragCurrent.groups);
  }
}, doScroll: function() {
  if (this.ddmInstance.dragCurrent) 
  {
    var proc = this.proc, procEl = proc.el, ddScrollConfig = proc.el.ddScrollConfig, inc = ddScrollConfig && ddScrollConfig.increment ? ddScrollConfig.increment : this.increment, animate = ddScrollConfig && 'animate' in ddScrollConfig ? ddScrollConfig.animate : this.animate;
    if (!animate) 
    {
      if (procEl.scroll(proc.dir, inc)) 
      {
        this.triggerRefresh();
      }
    } else {
      procEl.scroll(proc.dir, inc, true, this.animDuration, this.triggerRefresh);
    }
  }
}, clearProc: function() {
  var proc = this.proc;
  if (proc.id) 
  {
    clearInterval(proc.id);
  }
  proc.id = 0;
  proc.el = null;
  proc.dir = "";
}, startProc: function(el, dir) {
  this.clearProc();
  this.proc.el = el;
  this.proc.dir = dir;
  var group = el.ddScrollConfig ? el.ddScrollConfig.ddGroup : undefined, freq = (el.ddScrollConfig && el.ddScrollConfig.frequency) ? el.ddScrollConfig.frequency : this.frequency;
  if (group === undefined || this.ddmInstance.dragCurrent.ddGroup == group) 
  {
    this.proc.id = setInterval(this.doScroll, freq);
  }
}, onFire: function(e, isDrop) {
  if (isDrop || !this.ddmInstance.dragCurrent) 
  {
    return;
  }
  if (!this.dragEl || this.dragEl != this.ddmInstance.dragCurrent) 
  {
    this.dragEl = this.ddmInstance.dragCurrent;
    this.refreshCache();
  }
  var pt = e.getPoint(), proc = this.proc, els = this.els, id, el, r, c;
  for (id in els) 
    {
      el = els[id];
      r = el._region;
      c = el.ddScrollConfig ? el.ddScrollConfig : this;
      if (r && r.contains(pt) && el.isScrollable()) 
      {
        if (r.bottom - pt.y <= c.vthresh) 
        {
          if (proc.el != el) 
          {
            this.startProc(el, "down");
          }
          return;
        } else if (r.right - pt.x <= c.hthresh) 
        {
          if (proc.el != el) 
          {
            this.startProc(el, "right");
          }
          return;
        } else if (pt.y - r.top <= c.vthresh) 
        {
          if (proc.el != el) 
          {
            this.startProc(el, "up");
          }
          return;
        } else if (pt.x - r.left <= c.hthresh) 
        {
          if (proc.el != el) 
          {
            this.startProc(el, "left");
          }
          return;
        }
      }
    }
  this.clearProc();
}, register: function(el) {
  if (Ext.isArray(el)) 
  {
    for (var i = 0, len = el.length; i < len; i++) 
      {
        this.register(el[i]);
      }
  } else {
    el = Ext.get(el);
    this.els[el.id] = el;
  }
}, unregister: function(el) {
  if (Ext.isArray(el)) 
  {
    for (var i = 0, len = el.length; i < len; i++) 
      {
        this.unregister(el[i]);
      }
  } else {
    el = Ext.get(el);
    delete this.els[el.id];
  }
}, vthresh: 25, hthresh: 25, increment: 100, frequency: 500, animate: true, animDuration: 0.4, ddGroup: undefined, refreshCache: function() {
  var els = this.els, id;
  for (id in els) 
    {
      if (typeof els[id] == 'object') 
      {
        els[id]._region = els[id].getRegion();
      }
    }
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'ScrollManager'], 0));
;

(Ext.cmd.derive('Ext.dd.DropTarget', Ext.dd.DDTarget, {constructor: function(el, config) {
  this.el = Ext.get(el);
  Ext.apply(this, config);
  if (this.containerScroll) 
  {
    Ext.dd.ScrollManager.register(this.el);
  }
  this.callParent([this.el.dom, this.ddGroup || this.group, {isTarget: true}]);
}, dropAllowed: Ext.baseCSSPrefix + 'dd-drop-ok', dropNotAllowed: Ext.baseCSSPrefix + 'dd-drop-nodrop', isTarget: true, isNotifyTarget: true, notifyEnter: function(dd, e, data) {
  if (this.overClass) 
  {
    this.el.addCls(this.overClass);
  }
  return this.dropAllowed;
}, notifyOver: function(dd, e, data) {
  return this.dropAllowed;
}, notifyOut: function(dd, e, data) {
  if (this.overClass) 
  {
    this.el.removeCls(this.overClass);
  }
}, notifyDrop: function(dd, e, data) {
  return false;
}, destroy: function() {
  this.callParent();
  if (this.containerScroll) 
  {
    Ext.dd.ScrollManager.unregister(this.el);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'DropTarget'], 0));
;

(Ext.cmd.derive('Ext.dd.Registry', Ext.Base, {singleton: true, constructor: function() {
  this.elements = {};
  this.handles = {};
  this.autoIdSeed = 0;
}, getId: function(el, autogen) {
  if (typeof el == "string") 
  {
    return el;
  }
  var id = el.id;
  if (!id && autogen !== false) 
  {
    id = "extdd-" + (++this.autoIdSeed);
    el.id = id;
  }
  return id;
}, register: function(el, data) {
  data = data || {};
  if (typeof el == "string") 
  {
    el = document.getElementById(el);
  }
  data.ddel = el;
  this.elements[this.getId(el)] = data;
  if (data.isHandle !== false) 
  {
    this.handles[data.ddel.id] = data;
  }
  if (data.handles) 
  {
    var hs = data.handles, i, len;
    for (i = 0 , len = hs.length; i < len; i++) 
      {
        this.handles[this.getId(hs[i])] = data;
      }
  }
}, unregister: function(el) {
  var id = this.getId(el, false), data = this.elements[id], hs, i, len;
  if (data) 
  {
    delete this.elements[id];
    if (data.handles) 
    {
      hs = data.handles;
      for (i = 0 , len = hs.length; i < len; i++) 
        {
          delete this.handles[this.getId(hs[i], false)];
        }
    }
  }
}, getHandle: function(id) {
  if (typeof id != "string") 
  {
    id = id.id;
  }
  return this.handles[id];
}, getHandleFromEvent: function(e) {
  var t = e.getTarget();
  return t ? this.handles[t.id] : null;
}, getTarget: function(id) {
  if (typeof id != "string") 
  {
    id = id.id;
  }
  return this.elements[id];
}, getTargetFromEvent: function(e) {
  var t = e.getTarget();
  return t ? this.elements[t.id] || this.handles[t.id] : null;
}}, 1, 0, 0, 0, 0, 0, [Ext.dd, 'Registry'], 0));
;

(Ext.cmd.derive('Ext.dd.DropZone', Ext.dd.DropTarget, {getTargetFromEvent: function(e) {
  return Ext.dd.Registry.getTargetFromEvent(e);
}, onNodeEnter: function(n, dd, e, data) {
}, onNodeOver: function(n, dd, e, data) {
  return this.dropAllowed;
}, onNodeOut: function(n, dd, e, data) {
}, onNodeDrop: function(n, dd, e, data) {
  return false;
}, onContainerOver: function(dd, e, data) {
  return this.dropNotAllowed;
}, onContainerDrop: function(dd, e, data) {
  return false;
}, notifyEnter: function(dd, e, data) {
  return this.dropNotAllowed;
}, notifyOver: function(dd, e, data) {
  var n = this.getTargetFromEvent(e);
  if (!n) 
  {
    if (this.lastOverNode) 
    {
      this.onNodeOut(this.lastOverNode, dd, e, data);
      this.lastOverNode = null;
    }
    return this.onContainerOver(dd, e, data);
  }
  if (this.lastOverNode != n) 
  {
    if (this.lastOverNode) 
    {
      this.onNodeOut(this.lastOverNode, dd, e, data);
    }
    this.onNodeEnter(n, dd, e, data);
    this.lastOverNode = n;
  }
  return this.onNodeOver(n, dd, e, data);
}, notifyOut: function(dd, e, data) {
  if (this.lastOverNode) 
  {
    this.onNodeOut(this.lastOverNode, dd, e, data);
    this.lastOverNode = null;
  }
}, notifyDrop: function(dd, e, data) {
  var me = this, n = me.getTargetFromEvent(e), result = n ? me.onNodeDrop(n, dd, e, data) : me.onContainerDrop(dd, e, data);
  if (me.lastOverNode) 
  {
    me.onNodeOut(me.lastOverNode, dd, e, data);
    me.lastOverNode = null;
  }
  return result;
}, triggerCacheRefresh: function() {
  Ext.dd.DDM.refreshCache(this.groups);
}}, 0, 0, 0, 0, 0, 0, [Ext.dd, 'DropZone'], 0));
;

(Ext.cmd.derive('Ext.util.Queue', Ext.Base, {constructor: function() {
  this.clear();
}, add: function(obj) {
  var me = this, key = me.getKey(obj);
  if (!me.map[key]) 
  {
    ++me.length;
    me.items.push(obj);
    me.map[key] = obj;
  }
  return obj;
}, clear: function() {
  var me = this, items = me.items;
  me.items = [];
  me.map = {};
  me.length = 0;
  return items;
}, contains: function(obj) {
  var key = this.getKey(obj);
  return this.map.hasOwnProperty(key);
}, getCount: function() {
  return this.length;
}, getKey: function(obj) {
  return obj.id;
}, remove: function(obj) {
  var me = this, key = me.getKey(obj), items = me.items, index;
  if (me.map[key]) 
  {
    index = Ext.Array.indexOf(items, obj);
    Ext.Array.erase(items, index, 1);
    delete me.map[key];
    --me.length;
  }
  return obj;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Queue'], 0));
;

(Ext.cmd.derive('Ext.layout.ClassList', Ext.Base, (function() {
  var splitWords = Ext.String.splitWords, toMap = Ext.Array.toMap;
  return {dirty: false, constructor: function(owner) {
  this.owner = owner;
  this.map = toMap(this.classes = splitWords(owner.el.className));
}, add: function(cls) {
  var me = this;
  if (!me.map[cls]) 
  {
    me.map[cls] = true;
    me.classes.push(cls);
    if (!me.dirty) 
    {
      me.dirty = true;
      me.owner.markDirty();
    }
  }
}, addMany: function(classes) {
  Ext.each(splitWords(classes), this.add, this);
}, contains: function(cls) {
  return this.map[cls];
}, flush: function() {
  this.owner.el.className = this.classes.join(' ');
  this.dirty = false;
}, remove: function(cls) {
  var me = this;
  if (me.map[cls]) 
  {
    delete me.map[cls];
    me.classes = Ext.Array.filter(me.classes, function(c) {
  return c != cls;
});
    if (!me.dirty) 
    {
      me.dirty = true;
      me.owner.markDirty();
    }
  }
}, removeMany: function(classes) {
  var me = this, remove = toMap(splitWords(classes));
  me.classes = Ext.Array.filter(me.classes, function(c) {
  if (!remove[c]) 
  {
    return true;
  }
  delete me.map[c];
  if (!me.dirty) 
  {
    me.dirty = true;
    me.owner.markDirty();
  }
  return false;
});
}};
}()), 1, 0, 0, 0, 0, 0, [Ext.layout, 'ClassList'], 0));
;

(Ext.cmd.derive('Ext.layout.ContextItem', Ext.Base, {heightModel: null, widthModel: null, sizeModel: null, optOut: false, ownerSizePolicy: null, boxChildren: null, boxParent: null, isBorderBoxValue: null, children: [], dirty: null, dirtyCount: 0, hasRawContent: true, isContextItem: true, isTopLevel: false, consumersContentHeight: 0, consumersContentWidth: 0, consumersContainerHeight: 0, consumersContainerWidth: 0, consumersHeight: 0, consumersWidth: 0, ownerCtContext: null, remainingChildDimensions: 0, props: null, state: null, wrapsComponent: false, constructor: function(config) {
  var me = this, sizeModels = Ext.layout.SizeModel.sizeModels, configured = sizeModels.configured, shrinkWrap = sizeModels.shrinkWrap, el, lastBox, ownerCt, ownerCtContext, props, sizeModel, target, lastWidth, lastHeight, sameWidth, sameHeight, widthModel, heightModel, optOut;
  Ext.apply(me, config);
  el = me.el;
  me.id = el.id;
  me.flushedProps = {};
  me.props = props = {};
  me.styles = {};
  target = me.target;
  if (!target.isComponent) 
  {
    lastBox = el.lastBox;
  } else {
    me.wrapsComponent = true;
    me.framing = target.frameSize || null;
    me.isComponentChild = target.ownerLayout && target.ownerLayout.isComponentLayout;
    lastBox = target.lastBox;
    ownerCt = target.ownerCt;
    if (ownerCt && (ownerCtContext = ownerCt.el && me.context.items[ownerCt.el.id])) 
    {
      me.ownerCtContext = ownerCtContext;
    }
    me.sizeModel = sizeModel = target.getSizeModel(ownerCtContext && ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
    me.widthModel = widthModel = sizeModel.width;
    me.heightModel = heightModel = sizeModel.height;
    if (lastBox && lastBox.invalid === false) 
    {
      sameWidth = (target.width === (lastWidth = lastBox.width));
      sameHeight = (target.height === (lastHeight = lastBox.height));
      if (widthModel === shrinkWrap && heightModel === shrinkWrap) 
      {
        optOut = true;
      } else if (widthModel === configured && sameWidth) 
      {
        optOut = heightModel === shrinkWrap || (heightModel === configured && sameHeight);
      }
      if (optOut) 
      {
        me.optOut = true;
        props.width = lastWidth;
        props.height = lastHeight;
      }
    }
  }
  me.lastBox = lastBox;
}, init: function(full, options) {
  var me = this, oldProps = me.props, oldDirty = me.dirty, ownerCtContext = me.ownerCtContext, ownerLayout = me.target.ownerLayout, firstTime = !me.state, ret = full || firstTime, children, i, n, ownerCt, sizeModel, target, oldHeightModel = me.heightModel, oldWidthModel = me.widthModel, newHeightModel, newWidthModel, remainingCount = 0;
  me.dirty = me.invalid = false;
  me.props = {};
  me.remainingChildDimensions = 0;
  if (me.boxChildren) 
  {
    me.boxChildren.length = 0;
  }
  if (!firstTime) 
  {
    me.clearAllBlocks('blocks');
    me.clearAllBlocks('domBlocks');
  }
  if (!me.wrapsComponent) 
  {
    return ret;
  }
  target = me.target;
  me.state = {};
  if (firstTime) 
  {
    if (target.beforeLayout && target.beforeLayout !== Ext.emptyFn) 
    {
      target.beforeLayout();
    }
    if (!ownerCtContext && (ownerCt = target.ownerCt)) 
    {
      ownerCtContext = me.context.items[ownerCt.el.id];
    }
    if (ownerCtContext) 
    {
      me.ownerCtContext = ownerCtContext;
      me.isBoxParent = target.ownerLayout.isItemBoxParent(me);
    } else {
      me.isTopLevel = true;
    }
    me.frameBodyContext = me.getEl('frameBody');
  } else {
    ownerCtContext = me.ownerCtContext;
    me.isTopLevel = !ownerCtContext;
    children = me.children;
    for (i = 0 , n = children.length; i < n; ++i) 
      {
        children[i].init(true);
      }
  }
  me.hasRawContent = !(target.isContainer && target.items.items.length > 0);
  if (full) 
  {
    me.widthModel = me.heightModel = null;
    sizeModel = target.getSizeModel(ownerCtContext && ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
    if (firstTime) 
    {
      me.sizeModel = sizeModel;
    }
    me.widthModel = sizeModel.width;
    me.heightModel = sizeModel.height;
    if (ownerCtContext && !me.isComponentChild) 
    {
      ownerCtContext.remainingChildDimensions += 2;
    }
  } else if (oldProps) 
  {
    me.recoverProp('x', oldProps, oldDirty);
    me.recoverProp('y', oldProps, oldDirty);
    if (me.widthModel.calculated) 
    {
      me.recoverProp('width', oldProps, oldDirty);
    } else if ('width' in oldProps) 
    {
      ++remainingCount;
    }
    if (me.heightModel.calculated) 
    {
      me.recoverProp('height', oldProps, oldDirty);
    } else if ('height' in oldProps) 
    {
      ++remainingCount;
    }
    if (ownerCtContext && !me.isComponentChild) 
    {
      ownerCtContext.remainingChildDimensions += remainingCount;
    }
  }
  if (oldProps && ownerLayout && ownerLayout.manageMargins) 
  {
    me.recoverProp('margin-top', oldProps, oldDirty);
    me.recoverProp('margin-right', oldProps, oldDirty);
    me.recoverProp('margin-bottom', oldProps, oldDirty);
    me.recoverProp('margin-left', oldProps, oldDirty);
  }
  if (options) 
  {
    newHeightModel = options.heightModel;
    newWidthModel = options.widthModel;
    if (newWidthModel && newHeightModel && oldWidthModel && oldHeightModel) 
    {
      if (oldWidthModel.shrinkWrap && oldHeightModel.shrinkWrap) 
      {
        if (newWidthModel.constrainedMax && newHeightModel.constrainedMin) 
        {
          newHeightModel = null;
        }
      }
    }
    if (newWidthModel) 
    {
      me.widthModel = newWidthModel;
    }
    if (newHeightModel) 
    {
      me.heightModel = newHeightModel;
    }
    if (options.state) 
    {
      Ext.apply(me.state, options.state);
    }
  }
  return ret;
}, initContinue: function(full) {
  var me = this, ownerCtContext = me.ownerCtContext, comp = me.target, widthModel = me.widthModel, hierarchyState = comp.getHierarchyState(), boxParent;
  if (widthModel.fixed) 
  {
    hierarchyState.inShrinkWrapTable = false;
  } else {
    delete hierarchyState.inShrinkWrapTable;
  }
  if (full) 
  {
    if (ownerCtContext && widthModel.shrinkWrap) 
    {
      boxParent = ownerCtContext.isBoxParent ? ownerCtContext : ownerCtContext.boxParent;
      if (boxParent) 
      {
        boxParent.addBoxChild(me);
      }
    } else if (widthModel.natural) 
    {
      me.boxParent = ownerCtContext;
    }
  }
  return full;
}, initDone: function(containerLayoutDone) {
  var me = this, props = me.props, state = me.state;
  if (me.remainingChildDimensions === 0) 
  {
    props.containerChildrenSizeDone = true;
  }
  if (containerLayoutDone) 
  {
    props.containerLayoutDone = true;
  }
  if (me.boxChildren && me.boxChildren.length && me.widthModel.shrinkWrap) 
  {
    me.el.setWidth(10000);
    state.blocks = (state.blocks || 0) + 1;
  }
}, initAnimation: function() {
  var me = this, target = me.target, ownerCtContext = me.ownerCtContext;
  if (ownerCtContext && ownerCtContext.isTopLevel) 
  {
    me.animatePolicy = target.ownerLayout.getAnimatePolicy(me);
  } else if (!ownerCtContext && target.isCollapsingOrExpanding && target.animCollapse) 
  {
    me.animatePolicy = target.componentLayout.getAnimatePolicy(me);
  }
  if (me.animatePolicy) 
  {
    me.context.queueAnimation(me);
  }
}, addCls: function(newCls) {
  this.getClassList().addMany(newCls);
}, removeCls: function(removeCls) {
  this.getClassList().removeMany(removeCls);
}, addBlock: function(name, layout, propName) {
  var me = this, collection = me[name] || (me[name] = {}), blockedLayouts = collection[propName] || (collection[propName] = {});
  if (!blockedLayouts[layout.id]) 
  {
    blockedLayouts[layout.id] = layout;
    ++layout.blockCount;
    ++me.context.blockCount;
  }
}, addBoxChild: function(boxChildItem) {
  var me = this, children, widthModel = boxChildItem.widthModel;
  boxChildItem.boxParent = this;
  boxChildItem.measuresBox = widthModel.shrinkWrap ? boxChildItem.hasRawContent : widthModel.natural;
  if (boxChildItem.measuresBox) 
  {
    children = me.boxChildren;
    if (children) 
    {
      children.push(boxChildItem);
    } else {
      me.boxChildren = [boxChildItem];
    }
  }
}, addPositionStyles: function(styles, props) {
  var x = props.x, y = props.y, count = 0;
  if (x !== undefined) 
  {
    styles.left = x + 'px';
    ++count;
  }
  if (y !== undefined) 
  {
    styles.top = y + 'px';
    ++count;
  }
  return count;
}, addTrigger: function(propName, inDom) {
  var me = this, name = inDom ? 'domTriggers' : 'triggers', collection = me[name] || (me[name] = {}), context = me.context, layout = context.currentLayout, triggers = collection[propName] || (collection[propName] = {});
  if (!triggers[layout.id]) 
  {
    triggers[layout.id] = layout;
    ++layout.triggerCount;
    triggers = context.triggers[inDom ? 'dom' : 'data'];
    (triggers[layout.id] || (triggers[layout.id] = [])).push({item: this, prop: propName});
    if (me.props[propName] !== undefined) 
    {
      if (!inDom || !(me.dirty && (propName in me.dirty))) 
      {
        ++layout.firedTriggers;
      }
    }
  }
}, boxChildMeasured: function() {
  var me = this, state = me.state, count = (state.boxesMeasured = (state.boxesMeasured || 0) + 1);
  if (count == me.boxChildren.length) 
  {
    state.clearBoxWidth = 1;
    ++me.context.progressCount;
    me.markDirty();
  }
}, borderNames: ['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'], marginNames: ['margin-top', 'margin-right', 'margin-bottom', 'margin-left'], paddingNames: ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'], trblNames: ['top', 'right', 'bottom', 'left'], cacheMissHandlers: {borderInfo: function(me) {
  var info = me.getStyles(me.borderNames, me.trblNames);
  info.width = info.left + info.right;
  info.height = info.top + info.bottom;
  return info;
}, marginInfo: function(me) {
  var info = me.getStyles(me.marginNames, me.trblNames);
  info.width = info.left + info.right;
  info.height = info.top + info.bottom;
  return info;
}, paddingInfo: function(me) {
  var item = me.frameBodyContext || me, info = item.getStyles(me.paddingNames, me.trblNames);
  info.width = info.left + info.right;
  info.height = info.top + info.bottom;
  return info;
}}, checkCache: function(entry) {
  return this.cacheMissHandlers[entry](this);
}, clearAllBlocks: function(name) {
  var collection = this[name], propName;
  if (collection) 
  {
    for (propName in collection) 
      {
        this.clearBlocks(name, propName);
      }
  }
}, clearBlocks: function(name, propName) {
  var collection = this[name], blockedLayouts = collection && collection[propName], context, layout, layoutId;
  if (blockedLayouts) 
  {
    delete collection[propName];
    context = this.context;
    for (layoutId in blockedLayouts) 
      {
        layout = blockedLayouts[layoutId];
        --context.blockCount;
        if (!--layout.blockCount && !layout.pending && !layout.done) 
        {
          context.queueLayout(layout);
        }
      }
  }
}, block: function(layout, propName) {
  this.addBlock('blocks', layout, propName);
}, domBlock: function(layout, propName) {
  this.addBlock('domBlocks', layout, propName);
}, fireTriggers: function(name, propName) {
  var collection = this[name], triggers = collection && collection[propName], context = this.context, layout, layoutId;
  if (triggers) 
  {
    for (layoutId in triggers) 
      {
        layout = triggers[layoutId];
        ++layout.firedTriggers;
        if (!layout.done && !layout.blockCount && !layout.pending) 
        {
          context.queueLayout(layout);
        }
      }
  }
}, flush: function() {
  var me = this, dirty = me.dirty, state = me.state, targetEl = me.el;
  me.dirtyCount = 0;
  if (me.classList && me.classList.dirty) 
  {
    me.classList.flush();
  }
  if ('attributes' in me) 
  {
    targetEl.set(me.attributes);
    delete me.attributes;
  }
  if ('innerHTML' in me) 
  {
    targetEl.innerHTML = me.innerHTML;
    delete me.innerHTML;
  }
  if (state && state.clearBoxWidth) 
  {
    state.clearBoxWidth = 0;
    me.el.setStyle('width', null);
    if (!--state.blocks) 
    {
      me.context.queueItemLayouts(me);
    }
  }
  if (dirty) 
  {
    delete me.dirty;
    me.writeProps(dirty, true);
  }
}, flushAnimations: function() {
  var me = this, animateFrom = me.previousSize, target, targetAnim, duration, animateProps, anim, changeCount, j, propsLen, propName, oldValue, newValue;
  if (animateFrom) 
  {
    target = me.target;
    targetAnim = target.getAnimationProps();
    duration = targetAnim.duration;
    animateProps = Ext.Object.getKeys(me.animatePolicy);
    anim = Ext.apply({}, {from: {}, to: {}, duration: duration || Ext.fx.Anim.prototype.duration}, targetAnim);
    for (changeCount = 0 , j = 0 , propsLen = animateProps.length; j < propsLen; j++) 
      {
        propName = animateProps[j];
        oldValue = animateFrom[propName];
        newValue = me.peek(propName);
        if (oldValue != newValue) 
        {
          propName = me.translateProps[propName] || propName;
          anim.from[propName] = oldValue;
          anim.to[propName] = newValue;
          ++changeCount;
        }
      }
    if (changeCount) 
    {
      if (me.isCollapsingOrExpanding === 1) 
      {
        target.componentLayout.undoLayout(me);
      } else {
        me.writeProps(anim.from);
      }
      me.el.animate(anim);
      Ext.fx.Manager.getFxQueue(me.el.id)[0].on({afteranimate: function() {
  if (me.isCollapsingOrExpanding === 1) 
  {
    target.componentLayout.redoLayout(me);
    target.afterCollapse(true);
  } else if (me.isCollapsingOrExpanding === 2) 
  {
    target.afterExpand(true);
  }
}});
    }
  }
}, getBorderInfo: function() {
  var me = this, info = me.borderInfo;
  if (!info) 
  {
    me.borderInfo = info = me.checkCache('borderInfo');
  }
  return info;
}, getClassList: function() {
  return this.classList || (this.classList = new Ext.layout.ClassList(this));
}, getEl: function(nameOrEl, owner) {
  var me = this, src, el, elContext;
  if (nameOrEl) 
  {
    if (nameOrEl.dom) 
    {
      el = nameOrEl;
    } else {
      src = me.target;
      if (owner) 
      {
        src = owner;
      }
      el = src[nameOrEl];
      if (typeof el == 'function') 
      {
        el = el.call(src);
        if (el === me.el) 
        {
          return this;
        }
      }
    }
    if (el) 
    {
      elContext = me.context.getEl(me, el);
    }
  }
  return elContext || null;
}, getFrameInfo: function() {
  var me = this, info = me.frameInfo, framing, border;
  if (!info) 
  {
    framing = me.framing;
    border = me.getBorderInfo();
    me.frameInfo = info = framing ? {top: framing.top + border.top, right: framing.right + border.right, bottom: framing.bottom + border.bottom, left: framing.left + border.left, width: framing.width + border.width, height: framing.height + border.height} : border;
  }
  return info;
}, getMarginInfo: function() {
  var me = this, info = me.marginInfo, comp, manageMargins, margins, ownerLayout, ownerLayoutId;
  if (!info) 
  {
    if (!me.wrapsComponent) 
    {
      info = me.checkCache('marginInfo');
    } else {
      comp = me.target;
      ownerLayout = comp.ownerLayout;
      ownerLayoutId = ownerLayout ? ownerLayout.id : null;
      manageMargins = ownerLayout && ownerLayout.manageMargins;
      info = comp.margin$;
      if (info && info.ownerId !== ownerLayoutId) 
      {
        info = null;
      }
      if (!info) 
      {
        info = me.parseMargins(comp, comp.margin) || me.checkCache('marginInfo');
        if (manageMargins) 
        {
          margins = me.parseMargins(comp, comp.margins, ownerLayout.defaultMargins);
          if (margins) 
          {
            info = {top: info.top + margins.top, right: info.right + margins.right, bottom: info.bottom + margins.bottom, left: info.left + margins.left};
          }
          me.setProp('margin-top', 0);
          me.setProp('margin-right', 0);
          me.setProp('margin-bottom', 0);
          me.setProp('margin-left', 0);
        }
        info.ownerId = ownerLayoutId;
        comp.margin$ = info;
      }
      info.width = info.left + info.right;
      info.height = info.top + info.bottom;
    }
    me.marginInfo = info;
  }
  return info;
}, clearMarginCache: function() {
  delete this.marginInfo;
  delete this.target.margin$;
}, getPaddingInfo: function() {
  var me = this, info = me.paddingInfo;
  if (!info) 
  {
    me.paddingInfo = info = me.checkCache('paddingInfo');
  }
  return info;
}, getProp: function(propName) {
  var me = this, result = me.props[propName];
  me.addTrigger(propName);
  return result;
}, getDomProp: function(propName) {
  var me = this, result = (me.dirty && (propName in me.dirty)) ? undefined : me.props[propName];
  me.addTrigger(propName, true);
  return result;
}, getStyle: function(styleName) {
  var me = this, styles = me.styles, info, value;
  if (styleName in styles) 
  {
    value = styles[styleName];
  } else {
    info = me.styleInfo[styleName];
    value = me.el.getStyle(styleName);
    if (info && info.parseInt) 
    {
      value = parseInt(value, 10) || 0;
    }
    styles[styleName] = value;
  }
  return value;
}, getStyles: function(styleNames, altNames) {
  var me = this, styleCache = me.styles, values = {}, hits = 0, n = styleNames.length, i, missing, missingAltNames, name, info, styleInfo, styles, value;
  altNames = altNames || styleNames;
  for (i = 0; i < n; ++i) 
    {
      name = styleNames[i];
      if (name in styleCache) 
      {
        values[altNames[i]] = styleCache[name];
        ++hits;
        if (i && hits == 1) 
        {
          missing = styleNames.slice(0, i);
          missingAltNames = altNames.slice(0, i);
        }
      } else if (hits) 
      {
        (missing || (missing = [])).push(name);
        (missingAltNames || (missingAltNames = [])).push(altNames[i]);
      }
    }
  if (hits < n) 
  {
    missing = missing || styleNames;
    missingAltNames = missingAltNames || altNames;
    styleInfo = me.styleInfo;
    styles = me.el.getStyle(missing);
    for (i = missing.length; i--; ) 
      {
        name = missing[i];
        info = styleInfo[name];
        value = styles[name];
        if (info && info.parseInt) 
        {
          value = parseInt(value, 10) || 0;
        }
        values[missingAltNames[i]] = value;
        styleCache[name] = value;
      }
  }
  return values;
}, hasProp: function(propName) {
  return this.getProp(propName) != null;
}, hasDomProp: function(propName) {
  return this.getDomProp(propName) != null;
}, invalidate: function(options) {
  this.context.queueInvalidate(this, options);
}, markDirty: function() {
  if (++this.dirtyCount == 1) 
  {
    this.context.queueFlush(this);
  }
}, onBoxMeasured: function() {
  var boxParent = this.boxParent, state = this.state;
  if (boxParent && boxParent.widthModel.shrinkWrap && !state.boxMeasured && this.measuresBox) 
  {
    state.boxMeasured = 1;
    boxParent.boxChildMeasured();
  }
}, parseMargins: function(comp, margins, defaultMargins) {
  if (margins === true) 
  {
    margins = 5;
  }
  var type = typeof margins, ret;
  if (type == 'string' || type == 'number') 
  {
    ret = comp.parseBox(margins);
  } else if (margins || defaultMargins) 
  {
    ret = {top: 0, right: 0, bottom: 0, left: 0};
    if (defaultMargins) 
    {
      Ext.apply(ret, this.parseMargins(comp, defaultMargins));
    }
    if (margins) 
    {
      margins = Ext.apply(ret, comp.parseBox(margins));
    }
  }
  return ret;
}, peek: function(propName) {
  return this.props[propName];
}, recoverProp: function(propName, oldProps, oldDirty) {
  var me = this, props = me.props, dirty;
  if (propName in oldProps) 
  {
    props[propName] = oldProps[propName];
    if (oldDirty && propName in oldDirty) 
    {
      dirty = me.dirty || (me.dirty = {});
      dirty[propName] = oldDirty[propName];
    }
  }
}, redo: function(deep) {
  var me = this, items, len, i;
  me.revertProps(me.props);
  if (deep && me.wrapsComponent) 
  {
    if (me.childItems) 
    {
      for (i = 0 , items = me.childItems , len = items.length; i < len; i++) 
        {
          items[i].redo(deep);
        }
    }
    for (i = 0 , items = me.children , len = items.length; i < len; i++) 
      {
        items[i].redo();
      }
  }
}, removeEl: function(nameOrEl, owner) {
  var me = this, src, el;
  if (nameOrEl) 
  {
    if (nameOrEl.dom) 
    {
      el = nameOrEl;
    } else {
      src = me.target;
      if (owner) 
      {
        src = owner;
      }
      el = src[nameOrEl];
      if (typeof el == 'function') 
      {
        el = el.call(src);
        if (el === me.el) 
        {
          return this;
        }
      }
    }
    if (el) 
    {
      me.context.removeEl(me, el);
    }
  }
}, revertProps: function(props) {
  var name, flushed = this.flushedProps, reverted = {};
  for (name in props) 
    {
      if (flushed.hasOwnProperty(name)) 
      {
        reverted[name] = props[name];
      }
    }
  this.writeProps(reverted);
}, setAttribute: function(name, value) {
  var me = this;
  if (!me.attributes) 
  {
    me.attributes = {};
  }
  me.attributes[name] = value;
  me.markDirty();
}, setBox: function(box) {
  var me = this;
  if ('left' in box) 
  {
    me.setProp('x', box.left);
  }
  if ('top' in box) 
  {
    me.setProp('y', box.top);
  }
  me.setSize(box.width, box.height);
}, setContentHeight: function(height, measured) {
  if (!measured && this.hasRawContent) 
  {
    return 1;
  }
  return this.setProp('contentHeight', height);
}, setContentWidth: function(width, measured) {
  if (!measured && this.hasRawContent) 
  {
    return 1;
  }
  return this.setProp('contentWidth', width);
}, setContentSize: function(width, height, measured) {
  return this.setContentWidth(width, measured) + this.setContentHeight(height, measured) == 2;
}, setProp: function(propName, value, dirty) {
  var me = this, valueType = typeof value, borderBox, info;
  if (valueType == 'undefined' || (valueType === 'number' && isNaN(value))) 
  {
    return 0;
  }
  if (me.props[propName] === value) 
  {
    return 1;
  }
  me.props[propName] = value;
  ++me.context.progressCount;
  if (dirty === false) 
  {
    me.fireTriggers('domTriggers', propName);
    me.clearBlocks('domBlocks', propName);
  } else {
    info = me.styleInfo[propName];
    if (info) 
    {
      if (!me.dirty) 
      {
        me.dirty = {};
      }
      if (propName == 'width' || propName == 'height') 
      {
        borderBox = me.isBorderBoxValue;
        if (borderBox === null) 
        {
          me.isBorderBoxValue = borderBox = !!me.el.isBorderBox();
        }
        if (!borderBox) 
        {
          me.borderInfo || me.getBorderInfo();
          me.paddingInfo || me.getPaddingInfo();
        }
      }
      me.dirty[propName] = value;
      me.markDirty();
    }
  }
  me.fireTriggers('triggers', propName);
  me.clearBlocks('blocks', propName);
  return 1;
}, setHeight: function(height, dirty) {
  var me = this, comp = me.target, ownerCtContext = me.ownerCtContext, frameBody, frameInfo, min, oldHeight, rem;
  if (height < 0) 
  {
    height = 0;
  }
  if (!me.wrapsComponent) 
  {
    if (!me.setProp('height', height, dirty)) 
    {
      return NaN;
    }
  } else {
    min = me.collapsedVert ? 0 : (comp.minHeight || 0);
    height = Ext.Number.constrain(height, min, comp.maxHeight);
    oldHeight = me.props.height;
    if (!me.setProp('height', height, dirty)) 
    {
      return NaN;
    }
    if (ownerCtContext && !me.isComponentChild && isNaN(oldHeight)) 
    {
      rem = --ownerCtContext.remainingChildDimensions;
      if (!rem) 
      {
        ownerCtContext.setProp('containerChildrenSizeDone', true);
      }
    }
    frameBody = me.frameBodyContext;
    if (frameBody) 
    {
      frameInfo = me.getFrameInfo();
      frameBody.setHeight(height - frameInfo.height, dirty);
    }
  }
  return height;
}, setWidth: function(width, dirty) {
  var me = this, comp = me.target, ownerCtContext = me.ownerCtContext, frameBody, frameInfo, min, oldWidth, rem;
  if (width < 0) 
  {
    width = 0;
  }
  if (!me.wrapsComponent) 
  {
    if (!me.setProp('width', width, dirty)) 
    {
      return NaN;
    }
  } else {
    min = me.collapsedHorz ? 0 : (comp.minWidth || 0);
    width = Ext.Number.constrain(width, min, comp.maxWidth);
    oldWidth = me.props.width;
    if (!me.setProp('width', width, dirty)) 
    {
      return NaN;
    }
    if (ownerCtContext && !me.isComponentChild && isNaN(oldWidth)) 
    {
      rem = --ownerCtContext.remainingChildDimensions;
      if (!rem) 
      {
        ownerCtContext.setProp('containerChildrenSizeDone', true);
      }
    }
    frameBody = me.frameBodyContext;
    if (frameBody) 
    {
      frameInfo = me.getFrameInfo();
      frameBody.setWidth(width - frameInfo.width, dirty);
    }
  }
  return width;
}, setSize: function(width, height, dirty) {
  this.setWidth(width, dirty);
  this.setHeight(height, dirty);
}, translateProps: {x: 'left', y: 'top'}, undo: function(deep) {
  var me = this, items, len, i;
  me.revertProps(me.lastBox);
  if (deep && me.wrapsComponent) 
  {
    if (me.childItems) 
    {
      for (i = 0 , items = me.childItems , len = items.length; i < len; i++) 
        {
          items[i].undo(deep);
        }
    }
    for (i = 0 , items = me.children , len = items.length; i < len; i++) 
      {
        items[i].undo();
      }
  }
}, unsetProp: function(propName) {
  var dirty = this.dirty;
  delete this.props[propName];
  if (dirty) 
  {
    delete dirty[propName];
  }
}, writeProps: function(dirtyProps, flushing) {
  if (!(dirtyProps && typeof dirtyProps == 'object')) 
  {
    return;
  }
  var me = this, el = me.el, styles = {}, styleCount = 0, styleInfo = me.styleInfo, info, propName, numericValue, width = dirtyProps.width, height = dirtyProps.height, isBorderBox = me.isBorderBoxValue, target = me.target, max = Math.max, paddingWidth = 0, paddingHeight = 0, hasWidth, hasHeight, isAbsolute, scrollbarSize, style, targetEl;
  if ('displayed' in dirtyProps) 
  {
    el.setDisplayed(dirtyProps.displayed);
  }
  for (propName in dirtyProps) 
    {
      if (flushing) 
      {
        me.fireTriggers('domTriggers', propName);
        me.clearBlocks('domBlocks', propName);
        me.flushedProps[propName] = 1;
      }
      info = styleInfo[propName];
      if (info && info.dom) 
      {
        if (info.suffix && (numericValue = parseInt(dirtyProps[propName], 10))) 
        {
          styles[propName] = numericValue + info.suffix;
        } else {
          styles[propName] = dirtyProps[propName];
        }
        ++styleCount;
      }
    }
  if ('x' in dirtyProps || 'y' in dirtyProps) 
  {
    if (target.isComponent) 
    {
      target.setPosition(dirtyProps.x, dirtyProps.y);
    } else {
      styleCount += me.addPositionStyles(styles, dirtyProps);
    }
  }
  if (!isBorderBox && (width > 0 || height > 0)) 
  {
    if (!me.frameBodyContext) 
    {
      paddingWidth = me.paddingInfo.width;
      paddingHeight = me.paddingInfo.height;
    }
    if (width) 
    {
      width = max(parseInt(width, 10) - (me.borderInfo.width + paddingWidth), 0);
      styles.width = width + 'px';
      ++styleCount;
    }
    if (height) 
    {
      height = max(parseInt(height, 10) - (me.borderInfo.height + paddingHeight), 0);
      styles.height = height + 'px';
      ++styleCount;
    }
  }
  if (me.wrapsComponent && Ext.isIE9 && Ext.isStrict) 
  {
    if ((hasWidth = width !== undefined && me.hasOverflowY) || (hasHeight = height !== undefined && me.hasOverflowX)) 
    {
      isAbsolute = me.isAbsolute;
      if (isAbsolute === undefined) 
      {
        isAbsolute = false;
        targetEl = me.target.getTargetEl();
        style = targetEl.getStyle('position');
        if (style == 'absolute') 
        {
          style = targetEl.getStyle('box-sizing');
          isAbsolute = (style == 'border-box');
        }
        me.isAbsolute = isAbsolute;
      }
      if (isAbsolute) 
      {
        scrollbarSize = Ext.getScrollbarSize();
        if (hasWidth) 
        {
          width = parseInt(width, 10) + scrollbarSize.width;
          styles.width = width + 'px';
          ++styleCount;
        }
        if (hasHeight) 
        {
          height = parseInt(height, 10) + scrollbarSize.height;
          styles.height = height + 'px';
          ++styleCount;
        }
      }
    }
  }
  if (styleCount) 
  {
    el.setStyle(styles);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.layout, 'ContextItem'], function() {
  var px = {dom: true, parseInt: true, suffix: 'px'}, isDom = {dom: true}, faux = {dom: false};
  this.prototype.styleInfo = {containerChildrenSizeDone: faux, containerLayoutDone: faux, displayed: faux, done: faux, x: faux, y: faux, columnWidthsDone: faux, left: px, top: px, right: px, bottom: px, width: px, height: px, 'border-top-width': px, 'border-right-width': px, 'border-bottom-width': px, 'border-left-width': px, 'margin-top': px, 'margin-right': px, 'margin-bottom': px, 'margin-left': px, 'padding-top': px, 'padding-right': px, 'padding-bottom': px, 'padding-left': px, 'line-height': isDom, display: isDom};
}));
;

(Ext.cmd.derive('Ext.layout.Context', Ext.Base, {remainingLayouts: 0, state: 0, constructor: function(config) {
  var me = this;
  Ext.apply(me, config);
  me.items = {};
  me.layouts = {};
  me.blockCount = 0;
  me.cycleCount = 0;
  me.flushCount = 0;
  me.calcCount = 0;
  me.animateQueue = me.newQueue();
  me.completionQueue = me.newQueue();
  me.finalizeQueue = me.newQueue();
  me.finishQueue = me.newQueue();
  me.flushQueue = me.newQueue();
  me.invalidateData = {};
  me.layoutQueue = me.newQueue();
  me.invalidQueue = [];
  me.triggers = {data: {}, dom: {}};
}, callLayout: function(layout, methodName) {
  this.currentLayout = layout;
  layout[methodName](this.getCmp(layout.owner));
}, cancelComponent: function(comp, isChild, isDestroying) {
  var me = this, components = comp, isArray = !comp.isComponent, length = isArray ? components.length : 1, i, k, klen, items, layout, newQueue, oldQueue, entry, temp, ownerCtContext;
  for (i = 0; i < length; ++i) 
    {
      if (isArray) 
      {
        comp = components[i];
      }
      if (isDestroying && comp.ownerCt) 
      {
        ownerCtContext = this.items[comp.ownerCt.el.id];
        if (ownerCtContext) 
        {
          Ext.Array.remove(ownerCtContext.childItems, me.getCmp(comp));
        }
      }
      if (!isChild) 
      {
        oldQueue = me.invalidQueue;
        klen = oldQueue.length;
        if (klen) 
        {
          me.invalidQueue = newQueue = [];
          for (k = 0; k < klen; ++k) 
            {
              entry = oldQueue[k];
              temp = entry.item.target;
              if (temp != comp && !temp.isDescendant(comp)) 
              {
                newQueue.push(entry);
              }
            }
        }
      }
      layout = comp.componentLayout;
      me.cancelLayout(layout);
      if (layout.getLayoutItems) 
      {
        items = layout.getLayoutItems();
        if (items.length) 
        {
          me.cancelComponent(items, true);
        }
      }
      if (comp.isContainer && !comp.collapsed) 
      {
        layout = comp.layout;
        me.cancelLayout(layout);
        items = layout.getVisibleItems();
        if (items.length) 
        {
          me.cancelComponent(items, true);
        }
      }
    }
}, cancelLayout: function(layout) {
  var me = this;
  me.completionQueue.remove(layout);
  me.finalizeQueue.remove(layout);
  me.finishQueue.remove(layout);
  me.layoutQueue.remove(layout);
  if (layout.running) 
  {
    me.layoutDone(layout);
  }
  layout.ownerContext = null;
}, clearTriggers: function(layout, inDom) {
  var id = layout.id, collection = this.triggers[inDom ? 'dom' : 'data'], triggers = collection && collection[id], length = (triggers && triggers.length) || 0, i, item, trigger;
  for (i = 0; i < length; ++i) 
    {
      trigger = triggers[i];
      item = trigger.item;
      collection = inDom ? item.domTriggers : item.triggers;
      delete collection[trigger.prop][id];
    }
}, flush: function() {
  var me = this, items = me.flushQueue.clear(), length = items.length, i;
  if (length) 
  {
    ++me.flushCount;
    for (i = 0; i < length; ++i) 
      {
        items[i].flush();
      }
  }
}, flushAnimations: function() {
  var me = this, items = me.animateQueue.clear(), len = items.length, i;
  if (len) 
  {
    for (i = 0; i < len; i++) 
      {
        if (items[i].target.animate !== false) 
        {
          items[i].flushAnimations();
        }
      }
    Ext.fx.Manager.runner();
  }
}, flushInvalidates: function() {
  var me = this, queue = me.invalidQueue, length = queue && queue.length, comp, components, entry, i;
  me.invalidQueue = [];
  if (length) 
  {
    components = [];
    for (i = 0; i < length; ++i) 
      {
        comp = (entry = queue[i]).item.target;
        if (!comp.container.isDetachedBody) 
        {
          components.push(comp);
          if (entry.options) 
          {
            me.invalidateData[comp.id] = entry.options;
          }
        }
      }
    me.invalidate(components, null);
  }
}, flushLayouts: function(queueName, methodName, dontClear) {
  var me = this, layouts = dontClear ? me[queueName].items : me[queueName].clear(), length = layouts.length, i, layout;
  if (length) 
  {
    for (i = 0; i < length; ++i) 
      {
        layout = layouts[i];
        if (!layout.running) 
        {
          me.callLayout(layout, methodName);
        }
      }
    me.currentLayout = null;
  }
}, getCmp: function(cmp) {
  return this.getItem(cmp, cmp.el);
}, getEl: function(parent, el) {
  var item = this.getItem(el, el);
  if (!item.parent) 
  {
    item.parent = parent;
    if (parent.children.length) 
    {
      parent.children.push(item);
    } else {
      parent.children = [item];
    }
  }
  return item;
}, getItem: function(target, el) {
  var id = el.id, items = this.items, item = items[id] || (items[id] = new Ext.layout.ContextItem({context: this, target: target, el: el}));
  return item;
}, handleFailure: function() {
  var layouts = this.layouts, layout, key;
  Ext.failedLayouts = (Ext.failedLayouts || 0) + 1;
  for (key in layouts) 
    {
      layout = layouts[key];
      if (layouts.hasOwnProperty(key)) 
      {
        layout.running = false;
        layout.ownerContext = null;
      }
    }
}, invalidate: function(components, full) {
  var me = this, isArray = !components.isComponent, containerLayoutDone, firstTime, i, comp, item, items, length, componentLayout, layout, invalidateOptions, token;
  for (i = 0 , length = isArray ? components.length : 1; i < length; ++i) 
    {
      comp = isArray ? components[i] : components;
      if (comp.rendered && !comp.hidden) 
      {
        item = me.getCmp(comp);
        componentLayout = comp.componentLayout;
        firstTime = !componentLayout.ownerContext;
        layout = (comp.isContainer && !comp.collapsed) ? comp.layout : null;
        invalidateOptions = me.invalidateData[item.id];
        delete me.invalidateData[item.id];
        token = item.init(full, invalidateOptions);
        if (invalidateOptions) 
        {
          me.processInvalidate(invalidateOptions, item, 'before');
        }
        if (componentLayout.beforeLayoutCycle) 
        {
          componentLayout.beforeLayoutCycle(item);
        }
        if (layout && layout.beforeLayoutCycle) 
        {
          layout.beforeLayoutCycle(item);
        }
        token = item.initContinue(token);
        containerLayoutDone = true;
        if (componentLayout.getLayoutItems) 
        {
          componentLayout.renderChildren();
          items = componentLayout.getLayoutItems();
          if (items.length) 
          {
            me.invalidate(items, true);
          }
        }
        if (layout) 
        {
          containerLayoutDone = false;
          layout.renderChildren();
          items = layout.getVisibleItems();
          if (items.length) 
          {
            me.invalidate(items, true);
          }
        }
        item.initDone(containerLayoutDone);
        me.resetLayout(componentLayout, item, firstTime);
        if (layout) 
        {
          me.resetLayout(layout, item, firstTime);
        }
        item.initAnimation();
        if (invalidateOptions) 
        {
          me.processInvalidate(invalidateOptions, item, 'after');
        }
      }
    }
  me.currentLayout = null;
}, layoutDone: function(layout) {
  var ownerContext = layout.ownerContext;
  layout.running = false;
  if (layout.isComponentLayout) 
  {
    if (ownerContext.measuresBox) 
    {
      ownerContext.onBoxMeasured();
    }
    ownerContext.setProp('done', true);
  } else {
    ownerContext.setProp('containerLayoutDone', true);
  }
  --this.remainingLayouts;
  ++this.progressCount;
}, newQueue: function() {
  return new Ext.util.Queue();
}, processInvalidate: function(options, item, name) {
  if (options[name]) 
  {
    var me = this, currentLayout = me.currentLayout;
    me.currentLayout = options.layout || null;
    options[name](item, options);
    me.currentLayout = currentLayout;
  }
}, queueAnimation: function(item) {
  this.animateQueue.add(item);
}, queueCompletion: function(layout) {
  this.completionQueue.add(layout);
}, queueFinalize: function(layout) {
  this.finalizeQueue.add(layout);
}, queueFlush: function(item) {
  this.flushQueue.add(item);
}, chainFns: function(oldOptions, newOptions, funcName) {
  var me = this, oldLayout = oldOptions.layout, newLayout = newOptions.layout, oldFn = oldOptions[funcName], newFn = newOptions[funcName];
  return function(contextItem) {
  var prev = me.currentLayout;
  if (oldFn) 
  {
    me.currentLayout = oldLayout;
    oldFn.call(oldOptions.scope || oldOptions, contextItem, oldOptions);
  }
  me.currentLayout = newLayout;
  newFn.call(newOptions.scope || newOptions, contextItem, newOptions);
  me.currentLayout = prev;
};
}, queueInvalidate: function(item, options) {
  var me = this, newQueue = [], oldQueue = me.invalidQueue, index = oldQueue.length, comp, old, oldComp, oldOptions, oldState;
  if (item.isComponent) 
  {
    item = me.getCmp(comp = item);
  } else {
    comp = item.target;
  }
  item.invalid = true;
  while (index--) 
    {
      old = oldQueue[index];
      oldComp = old.item.target;
      if (comp.isDescendant(oldComp)) 
      {
        return;
      }
      if (oldComp == comp) 
      {
        if (!(oldOptions = old.options)) 
        {
          old.options = options;
        } else if (options) 
        {
          if (options.widthModel) 
          {
            oldOptions.widthModel = options.widthModel;
          }
          if (options.heightModel) 
          {
            oldOptions.heightModel = options.heightModel;
          }
          if (!(oldState = oldOptions.state)) 
          {
            oldOptions.state = options.state;
          } else if (options.state) 
          {
            Ext.apply(oldState, options.state);
          }
          if (options.before) 
          {
            oldOptions.before = me.chainFns(oldOptions, options, 'before');
          }
          if (options.after) 
          {
            oldOptions.after = me.chainFns(oldOptions, options, 'after');
          }
        }
        return;
      }
      if (!oldComp.isDescendant(comp)) 
      {
        newQueue.push(old);
      }
    }
  newQueue.push({item: item, options: options});
  me.invalidQueue = newQueue;
}, queueItemLayouts: function(item) {
  var comp = item.isComponent ? item : item.target, layout = comp.componentLayout;
  if (!layout.pending && !layout.invalid && !layout.done) 
  {
    this.queueLayout(layout);
  }
  layout = comp.layout;
  if (layout && !layout.pending && !layout.invalid && !layout.done) 
  {
    this.queueLayout(layout);
  }
}, queueLayout: function(layout) {
  this.layoutQueue.add(layout);
  layout.pending = true;
}, removeEl: function(parent, el) {
  var id = el.id, children = parent.children, items = this.items;
  if (children) 
  {
    Ext.Array.remove(children, items[id]);
  }
  delete items[id];
}, resetLayout: function(layout, ownerContext, firstTime) {
  var me = this;
  me.currentLayout = layout;
  layout.done = false;
  layout.pending = true;
  layout.firedTriggers = 0;
  me.layoutQueue.add(layout);
  if (firstTime) 
  {
    me.layouts[layout.id] = layout;
    layout.running = true;
    if (layout.finishedLayout) 
    {
      me.finishQueue.add(layout);
    }
    ++me.remainingLayouts;
    ++layout.layoutCount;
    layout.ownerContext = ownerContext;
    layout.beginCount = 0;
    layout.blockCount = 0;
    layout.calcCount = 0;
    layout.triggerCount = 0;
    if (!layout.initialized) 
    {
      layout.initLayout();
    }
    layout.beginLayout(ownerContext);
  } else {
    ++layout.beginCount;
    if (!layout.running) 
    {
      ++me.remainingLayouts;
      layout.running = true;
      if (layout.isComponentLayout) 
      {
        ownerContext.unsetProp('done');
      }
      me.completionQueue.remove(layout);
      me.finalizeQueue.remove(layout);
    }
  }
  layout.beginLayoutCycle(ownerContext, firstTime);
}, run: function() {
  var me = this, flushed = false, watchDog = 100;
  me.flushInvalidates();
  me.state = 1;
  me.totalCount = me.layoutQueue.getCount();
  me.flush();
  while ((me.remainingLayouts || me.invalidQueue.length) && watchDog--) 
    {
      if (me.invalidQueue.length) 
      {
        me.flushInvalidates();
      }
      if (me.runCycle()) 
      {
        flushed = false;
      } else if (!flushed) 
      {
        me.flush();
        flushed = true;
        me.flushLayouts('completionQueue', 'completeLayout');
      } else if (!me.invalidQueue.length) 
      {
        me.state = 2;
        break;
      }
      if (!(me.remainingLayouts || me.invalidQueue.length)) 
      {
        me.flush();
        me.flushLayouts('completionQueue', 'completeLayout');
        me.flushLayouts('finalizeQueue', 'finalizeLayout');
      }
    }
  return me.runComplete();
}, runComplete: function() {
  var me = this;
  me.state = 2;
  if (me.remainingLayouts) 
  {
    me.handleFailure();
    return false;
  }
  me.flush();
  me.flushLayouts('finishQueue', 'finishedLayout', true);
  me.flushLayouts('finishQueue', 'notifyOwner');
  me.flush();
  me.flushAnimations();
  return true;
}, runCycle: function() {
  var me = this, layouts = me.layoutQueue.clear(), length = layouts.length, i;
  ++me.cycleCount;
  me.progressCount = 0;
  for (i = 0; i < length; ++i) 
    {
      me.runLayout(me.currentLayout = layouts[i]);
    }
  me.currentLayout = null;
  return me.progressCount > 0;
}, runLayout: function(layout) {
  var me = this, ownerContext = me.getCmp(layout.owner);
  layout.pending = false;
  if (ownerContext.state.blocks) 
  {
    return;
  }
  layout.done = true;
  ++layout.calcCount;
  ++me.calcCount;
  layout.calculate(ownerContext);
  if (layout.done) 
  {
    me.layoutDone(layout);
    if (layout.completeLayout) 
    {
      me.queueCompletion(layout);
    }
    if (layout.finalizeLayout) 
    {
      me.queueFinalize(layout);
    }
  } else if (!layout.pending && !layout.invalid && !(layout.blockCount + layout.triggerCount - layout.firedTriggers)) 
  {
    me.queueLayout(layout);
  }
}, setItemSize: function(item, width, height) {
  var items = item, len = 1, contextItem, i;
  if (item.isComposite) 
  {
    items = item.elements;
    len = items.length;
    item = items[0];
  } else if (!item.dom && !item.el) 
  {
    len = items.length;
    item = items[0];
  }
  for (i = 0; i < len; ) 
    {
      contextItem = this.get(item);
      contextItem.setSize(width, height);
      item = items[++i];
    }
}}, 1, 0, 0, 0, 0, 0, [Ext.layout, 'Context'], 0));
;

(Ext.cmd.derive('Ext.dom.Layer', Ext.Element, {alternateClassName: 'Ext.Layer', statics: {shims: []}, isLayer: true, localXYNames: {get: 'getLocalXY', set: 'setLocalXY'}, constructor: function(config, existingEl) {
  config = config || {};
  var me = this, dh = Ext.DomHelper, cp = config.parentEl, pel = cp ? Ext.getDom(cp) : document.body, hm = config.hideMode, cls = Ext.baseCSSPrefix + (config.fixed && !(Ext.isIE6 || Ext.isIEQuirks) ? 'fixed-layer' : 'layer');
  me.el = me;
  if (existingEl) 
  {
    me.dom = Ext.getDom(existingEl);
  }
  if (!me.dom) 
  {
    me.dom = dh.append(pel, config.dh || {tag: 'div', cls: cls});
  } else {
    me.addCls(cls);
    if (!me.dom.parentNode) 
    {
      pel.appendChild(me.dom);
    }
  }
  if (config.preventSync) 
  {
    me.preventSync = true;
  }
  if (config.id) 
  {
    me.id = me.dom.id = config.id;
  } else {
    me.id = Ext.id(me.dom);
  }
  Ext.Element.addToCache(me);
  if (config.cls) 
  {
    me.addCls(config.cls);
  }
  me.constrain = config.constrain !== false;
  if (hm) 
  {
    me.setVisibilityMode(Ext.Element[hm.toUpperCase()]);
    if (me.visibilityMode == Ext.Element.ASCLASS) 
    {
      me.visibilityCls = config.visibilityCls;
    }
  } else if (config.useDisplay) 
  {
    me.setVisibilityMode(Ext.Element.DISPLAY);
  } else {
    me.setVisibilityMode(Ext.Element.VISIBILITY);
  }
  if (config.shadow) 
  {
    me.shadowOffset = config.shadowOffset || 4;
    me.shadow = new Ext.Shadow({offset: me.shadowOffset, mode: config.shadow, fixed: config.fixed});
    me.disableShadow();
  } else {
    me.shadowOffset = 0;
  }
  me.useShim = config.shim !== false && Ext.useShims;
  if (config.hidden === true) 
  {
    me.hide();
  } else if (config.hidden === false) 
  {
    me.show();
  }
}, getZIndex: function() {
  return parseInt((this.getShim() || this).getStyle('z-index'), 10);
}, getShim: function() {
  var me = this, shim, pn;
  if (!me.useShim) 
  {
    return null;
  }
  if (!me.shim) 
  {
    shim = me.self.shims.shift();
    if (!shim) 
    {
      shim = me.createShim();
      shim.enableDisplayMode('block');
      shim.hide();
    }
    pn = me.dom.parentNode;
    if (shim.dom.parentNode != pn) 
    {
      pn.insertBefore(shim.dom, me.dom);
    }
    me.shim = shim;
  }
  return me.shim;
}, hideShim: function() {
  var me = this;
  if (me.shim) 
  {
    me.shim.setDisplayed(false);
    me.self.shims.push(me.shim);
    delete me.shim;
  }
}, disableShadow: function() {
  var me = this;
  if (me.shadow && !me.shadowDisabled) 
  {
    me.shadowDisabled = true;
    me.shadow.hide();
    me.lastShadowOffset = me.shadowOffset;
    me.shadowOffset = 0;
  }
}, enableShadow: function(show) {
  var me = this;
  if (me.shadow && me.shadowDisabled) 
  {
    me.shadowDisabled = false;
    me.shadowOffset = me.lastShadowOffset;
    delete me.lastShadowOffset;
    if (show) 
    {
      me.sync(true);
    }
  }
}, sync: function(doShow) {
  var me = this, shadow = me.shadow, shadowPos, shimStyle, shadowSize, shim, xy, x, y, w, h, shimIndex;
  if (me.preventSync) 
  {
    return;
  }
  if (!me.updating && me.isVisible() && (shadow || me.useShim)) 
  {
    shim = me.getShim();
    xy = me[me.localXYNames.get]();
    x = xy[0];
    y = xy[1];
    w = me.dom.offsetWidth;
    h = me.dom.offsetHeight;
    if (shadow && !me.shadowDisabled) 
    {
      if (doShow && !shadow.isVisible()) 
      {
        shadow.show(me);
      } else {
        shadow.realign(x, y, w, h);
      }
      if (shim) 
      {
        shimIndex = shim.getStyle('z-index');
        if (shimIndex > me.zindex) 
        {
          me.shim.setStyle('z-index', me.zindex - 2);
        }
        shim.show();
        if (shadow.isVisible()) 
        {
          shadowPos = shadow.el.getXY();
          shimStyle = shim.dom.style;
          shadowSize = shadow.el.getSize();
          if (Ext.supports.CSS3BoxShadow) 
          {
            shadowSize.height += 6;
            shadowSize.width += 4;
            shadowPos[0] -= 2;
            shadowPos[1] -= 4;
          }
          shimStyle.left = (shadowPos[0]) + 'px';
          shimStyle.top = (shadowPos[1]) + 'px';
          shimStyle.width = (shadowSize.width) + 'px';
          shimStyle.height = (shadowSize.height) + 'px';
        } else {
          shim.setSize(w, h);
          shim[me.localXYNames.set](x, y);
        }
      }
    } else if (shim) 
    {
      shimIndex = shim.getStyle('z-index');
      if (shimIndex > me.zindex) 
      {
        me.shim.setStyle('z-index', me.zindex - 2);
      }
      shim.show();
      shim.setSize(w, h);
      shim[me.localXYNames.set](x, y);
    }
  }
  return me;
}, remove: function() {
  this.hideUnders();
  this.callParent();
}, beginUpdate: function() {
  this.updating = true;
}, endUpdate: function() {
  this.updating = false;
  this.sync(true);
}, hideUnders: function() {
  if (this.shadow) 
  {
    this.shadow.hide();
  }
  this.hideShim();
}, constrainXY: function() {
  if (this.constrain) 
  {
    var vw = Ext.Element.getViewWidth(), vh = Ext.Element.getViewHeight(), s = Ext.getDoc().getScroll(), xy = this.getXY(), x = xy[0], y = xy[1], so = this.shadowOffset, w = this.dom.offsetWidth + so, h = this.dom.offsetHeight + so, moved = false;
    if ((x + w) > vw + s.left) 
    {
      x = vw - w - so;
      moved = true;
    }
    if ((y + h) > vh + s.top) 
    {
      y = vh - h - so;
      moved = true;
    }
    if (x < s.left) 
    {
      x = s.left;
      moved = true;
    }
    if (y < s.top) 
    {
      y = s.top;
      moved = true;
    }
    if (moved) 
    {
      Ext.Layer.superclass.setXY.call(this, [x, y]);
      this.sync();
    }
  }
  return this;
}, getConstrainOffset: function() {
  return this.shadowOffset;
}, setVisible: function(visible, animate, duration, callback, easing) {
  var me = this, cb;
  cb = function() {
  if (visible) 
  {
    me.sync(true);
  }
  if (callback) 
  {
    callback();
  }
};
  if (!visible) 
  {
    me.hideUnders(true);
  }
  me.callParent([visible, animate, duration, callback, easing]);
  if (!animate) 
  {
    cb();
  }
  return me;
}, beforeFx: function() {
  this.beforeAction();
  return this.callParent(arguments);
}, afterFx: function() {
  this.callParent(arguments);
  this.sync(this.isVisible());
}, beforeAction: function() {
  if (!this.updating && this.shadow) 
  {
    this.shadow.hide();
  }
}, setLeft: function(left) {
  this.callParent(arguments);
  return this.sync();
}, setTop: function(top) {
  this.callParent(arguments);
  return this.sync();
}, setLeftTop: function(left, top) {
  this.callParent(arguments);
  return this.sync();
}, setLocalX: function() {
  this.callParent(arguments);
  return this.sync();
}, setLocalXY: function() {
  this.callParent(arguments);
  return this.sync();
}, setLocalY: function() {
  this.callParent(arguments);
  return this.sync();
}, setXY: function(xy, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.fixDisplay();
  me.beforeAction();
  me.callParent([xy, animate, duration, callback, easing]);
  if (!animate) 
  {
    callback();
  }
  return me;
}, createCB: function(callback) {
  var me = this, showShadow = me.shadow && me.shadow.isVisible();
  return function() {
  me.constrainXY();
  me.sync(showShadow);
  if (callback) 
  {
    callback();
  }
};
}, setX: function(x, animate, duration, callback, easing) {
  this.setXY([x, this.getY()], animate, duration, callback, easing);
  return this;
}, setY: function(y, animate, duration, callback, easing) {
  this.setXY([this.getX(), y], animate, duration, callback, easing);
  return this;
}, setSize: function(w, h, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.beforeAction();
  me.callParent([w, h, animate, duration, callback, easing]);
  if (!animate) 
  {
    callback();
  }
  return me;
}, setWidth: function(w, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.beforeAction();
  me.callParent([w, animate, duration, callback, easing]);
  if (!animate) 
  {
    callback();
  }
  return me;
}, setHeight: function(h, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.beforeAction();
  me.callParent([h, animate, duration, callback, easing]);
  if (!animate) 
  {
    callback();
  }
  return me;
}, setBounds: function(x, y, width, height, animate, duration, callback, easing) {
  var me = this;
  callback = me.createCB(callback);
  me.beforeAction();
  if (!animate) 
  {
    Ext.Layer.superclass.setXY.call(me, [x, y]);
    Ext.Layer.superclass.setSize.call(me, width, height);
    callback();
  } else {
    me.callParent([x, y, width, height, animate, duration, callback, easing]);
  }
  return me;
}, setZIndex: function(zindex) {
  var me = this;
  me.zindex = zindex;
  if (me.getShim()) 
  {
    me.shim.setStyle('z-index', zindex++);
  }
  if (me.shadow) 
  {
    me.shadow.setZIndex(zindex++);
  }
  return me.setStyle('z-index', zindex);
}, onOpacitySet: function(opacity) {
  var shadow = this.shadow;
  if (shadow) 
  {
    shadow.setOpacity(opacity);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'Layer', Ext, 'Layer'], 0));
;

(Ext.cmd.derive('Ext.form.action.Action', Ext.Base, {alternateClassName: 'Ext.form.Action', submitEmptyText: true, constructor: function(config) {
  if (config) 
  {
    Ext.apply(this, config);
  }
  var params = config.params;
  if (Ext.isString(params)) 
  {
    this.params = Ext.Object.fromQueryString(params);
  }
}, run: Ext.emptyFn, onFailure: function(response) {
  this.response = response;
  this.failureType = Ext.form.action.Action.CONNECT_FAILURE;
  this.form.afterAction(this, false);
}, processResponse: function(response) {
  this.response = response;
  if (!response.responseText && !response.responseXML) 
  {
    return true;
  }
  return (this.result = this.handleResponse(response));
}, getUrl: function() {
  return this.url || this.form.url;
}, getMethod: function() {
  return (this.method || this.form.method || 'POST').toUpperCase();
}, getParams: function() {
  return Ext.apply({}, this.params, this.form.baseParams);
}, createCallback: function() {
  var me = this, undef, form = me.form;
  return {success: me.onSuccess, failure: me.onFailure, scope: me, timeout: (this.timeout * 1000) || (form.timeout * 1000), upload: form.fileUpload ? me.onSuccess : undef};
}, statics: {CLIENT_INVALID: 'client', SERVER_INVALID: 'server', CONNECT_FAILURE: 'connect', LOAD_FAILURE: 'load'}}, 1, 0, 0, 0, 0, 0, [Ext.form.action, 'Action', Ext.form, 'Action'], 0));
;

(Ext.cmd.derive('Ext.form.action.Load', Ext.form.action.Action, {alternateClassName: 'Ext.form.Action.Load', type: 'load', run: function() {
  Ext.Ajax.request(Ext.apply(this.createCallback(), {method: this.getMethod(), url: this.getUrl(), headers: this.headers, params: this.getParams()}));
}, onSuccess: function(response) {
  var result = this.processResponse(response), form = this.form;
  if (result === true || !result.success || !result.data) 
  {
    this.failureType = Ext.form.action.Action.LOAD_FAILURE;
    form.afterAction(this, false);
    return;
  }
  form.clearInvalid();
  form.setValues(result.data);
  form.afterAction(this, true);
}, handleResponse: function(response) {
  var reader = this.form.reader, rs, data;
  if (reader) 
  {
    rs = reader.read(response);
    data = rs.records && rs.records[0] ? rs.records[0].data : null;
    return {success: rs.success, data: data};
  }
  return Ext.decode(response.responseText);
}}, 0, 0, 0, 0, ["formaction.load"], 0, [Ext.form.action, 'Load', Ext.form.Action, 'Load'], 0));
;

(Ext.cmd.derive('Ext.form.action.Submit', Ext.form.action.Action, {alternateClassName: 'Ext.form.Action.Submit', type: 'submit', run: function() {
  var me = this, form = me.form;
  if (me.clientValidation === false || form.isValid()) 
  {
    me.doSubmit();
  } else {
    me.failureType = Ext.form.action.Action.CLIENT_INVALID;
    form.afterAction(me, false);
  }
}, doSubmit: function() {
  var me = this, ajaxOptions = Ext.apply(me.createCallback(), {url: me.getUrl(), method: me.getMethod(), headers: me.headers}), form = me.form, jsonSubmit = me.jsonSubmit || form.jsonSubmit, paramsProp = jsonSubmit ? 'jsonData' : 'params', formInfo;
  if (form.hasUpload()) 
  {
    formInfo = me.buildForm();
    ajaxOptions.form = formInfo.formEl;
    ajaxOptions.isUpload = true;
  } else {
    ajaxOptions[paramsProp] = me.getParams(jsonSubmit);
  }
  Ext.Ajax.request(ajaxOptions);
  if (formInfo) 
  {
    me.cleanup(formInfo);
  }
}, cleanup: function(formInfo) {
  var formEl = formInfo.formEl, uploadEls = formInfo.uploadEls, uploadFields = formInfo.uploadFields, len = uploadFields.length, i, field;
  for (i = 0; i < len; ++i) 
    {
      field = uploadFields[i];
      if (!field.clearOnSubmit) 
      {
        field.restoreInput(uploadEls[i]);
      }
    }
  if (formEl) 
  {
    Ext.removeNode(formEl);
  }
}, getParams: function(useModelValues) {
  var falseVal = false, configParams = this.callParent(), fieldParams = this.form.getValues(falseVal, falseVal, this.submitEmptyText !== falseVal, useModelValues, true);
  return Ext.apply({}, fieldParams, configParams);
}, buildForm: function() {
  var me = this, fieldsSpec = [], formSpec, formEl, basicForm = me.form, params = me.getParams(), uploadFields = [], uploadEls = [], fields = basicForm.getFields().items, i, len = fields.length, field, key, value, v, vLen, el;
  for (i = 0; i < len; ++i) 
    {
      field = fields[i];
      if (field.isFileUpload()) 
      {
        uploadFields.push(field);
      }
    }
  for (key in params) 
    {
      if (params.hasOwnProperty(key)) 
      {
        value = params[key];
        if (Ext.isArray(value)) 
        {
          vLen = value.length;
          for (v = 0; v < vLen; v++) 
            {
              fieldsSpec.push(me.getFieldConfig(key, value[v]));
            }
        } else {
          fieldsSpec.push(me.getFieldConfig(key, value));
        }
      }
    }
  formSpec = {tag: 'form', role: 'presentation', action: me.getUrl(), method: me.getMethod(), target: me.target || '_self', style: 'display:none', cn: fieldsSpec};
  if (uploadFields.length) 
  {
    formSpec.encoding = formSpec.enctype = 'multipart/form-data';
  }
  formEl = Ext.DomHelper.append(Ext.getBody(), formSpec);
  len = uploadFields.length;
  for (i = 0; i < len; ++i) 
    {
      el = uploadFields[i].extractFileInput();
      formEl.appendChild(el);
      uploadEls.push(el);
    }
  return {formEl: formEl, uploadFields: uploadFields, uploadEls: uploadEls};
}, getFieldConfig: function(name, value) {
  return {tag: 'input', type: 'hidden', name: name, value: Ext.String.htmlEncode(value)};
}, onSuccess: function(response) {
  var form = this.form, success = true, result = this.processResponse(response);
  if (result !== true && !result.success) 
  {
    if (result.errors) 
    {
      form.markInvalid(result.errors);
    }
    this.failureType = Ext.form.action.Action.SERVER_INVALID;
    success = false;
  }
  form.afterAction(this, success);
}, handleResponse: function(response) {
  var form = this.form, errorReader = form.errorReader, rs, errors, i, len, records, result;
  if (errorReader) 
  {
    rs = errorReader.read(response);
    records = rs.records;
    errors = [];
    if (records) 
    {
      for (i = 0 , len = records.length; i < len; i++) 
        {
          errors[i] = records[i].data;
        }
    }
    if (errors.length < 1) 
    {
      errors = null;
    }
    result = {success: rs.success, errors: errors};
  } else {
    try {
      result = Ext.decode(response.responseText);
    }    catch (e) {
  result = {success: false, errors: []};
}
  }
  return result;
}}, 0, 0, 0, 0, ["formaction.submit"], 0, [Ext.form.action, 'Submit', Ext.form.Action, 'Submit'], 0));
;

(Ext.cmd.derive('Ext.util.ComponentDragger', Ext.dd.DragTracker, {autoStart: 500, constructor: function(comp, config) {
  this.comp = comp;
  this.initialConstrainTo = config.constrainTo;
  this.callParent([config]);
}, onStart: function(e) {
  var me = this, comp = me.comp;
  me.startPosition = comp.getXY();
  if (comp.ghost && !comp.liveDrag) 
  {
    me.proxy = comp.ghost();
    me.dragTarget = me.proxy.header.el;
  }
  if (me.constrain || me.constrainDelegate) 
  {
    me.constrainTo = me.calculateConstrainRegion();
  }
  if (comp.beginDrag) 
  {
    comp.beginDrag();
  }
}, calculateConstrainRegion: function() {
  var me = this, comp = me.comp, constrainTo = me.initialConstrainTo, constraintInsets = comp.constraintInsets, constrainEl, delegateRegion, elRegion, dragEl = me.proxy ? me.proxy.el : comp.el, shadowSize = (!me.constrainDelegate && dragEl.shadow && comp.constrainShadow && !dragEl.shadowDisabled) ? dragEl.shadow.getShadowSize() : 0;
  if (!(constrainTo instanceof Ext.util.Region)) 
  {
    constrainEl = Ext.fly(constrainTo);
    constrainTo = constrainEl.getViewRegion();
    constrainTo.right = constrainTo.left + constrainEl.dom.clientWidth;
  } else {
    constrainTo = constrainTo.copy();
  }
  if (constraintInsets) 
  {
    constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
    constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.length);
  }
  if (shadowSize) 
  {
    constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
  }
  if (!me.constrainDelegate) 
  {
    delegateRegion = Ext.fly(me.dragTarget).getRegion();
    elRegion = dragEl.getRegion();
    constrainTo.adjust(delegateRegion.top - elRegion.top, delegateRegion.right - elRegion.right, delegateRegion.bottom - elRegion.bottom, delegateRegion.left - elRegion.left);
  }
  return constrainTo;
}, onDrag: function(e) {
  var me = this, comp = (me.proxy && !me.comp.liveDrag) ? me.proxy : me.comp, offset = me.getOffset(me.constrain || me.constrainDelegate ? 'dragTarget' : null);
  comp.setPagePosition(me.startPosition[0] + offset[0], me.startPosition[1] + offset[1]);
}, onEnd: function(e) {
  var comp = this.comp;
  if (comp.isDestroyed || comp.destroying) 
  {
    return;
  }
  if (this.proxy && !comp.liveDrag) 
  {
    comp.unghost();
  }
  if (comp.endDrag) 
  {
    comp.endDrag();
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'ComponentDragger'], 0));
;

(Ext.cmd.derive('Ext.window.Window', Ext.panel.Panel, {alternateClassName: 'Ext.Window', baseCls: Ext.baseCSSPrefix + 'window', resizable: true, draggable: true, constrain: false, constrainHeader: false, plain: false, minimizable: false, maximizable: false, minHeight: 50, minWidth: 50, expandOnShow: true, collapsible: false, closable: true, hidden: true, autoRender: true, hideMode: 'offsets', floating: true, itemCls: Ext.baseCSSPrefix + 'window-item', initialAlphaNum: /^[a-z0-9]/, overlapHeader: true, ignoreHeaderBorderManagement: true, alwaysFramed: true, isRootCfg: {isRoot: true}, isWindow: true, ariaRole: 'dialog', initComponent: function() {
  var me = this;
  me.frame = false;
  me.callParent();
  me.addEvents('resize', 'maximize', 'minimize', 'restore');
  if (me.plain) 
  {
    me.addClsWithUI('plain');
  }
  me.addStateEvents(['maximize', 'restore', 'resize', 'dragend']);
}, getElConfig: function() {
  var me = this, elConfig;
  elConfig = me.callParent();
  elConfig.tabIndex = -1;
  return elConfig;
}, getState: function() {
  var me = this, state = me.callParent() || {}, maximized = !!me.maximized, ghostBox = me.ghostBox, pos;
  state.maximized = maximized;
  if (maximized) 
  {
    pos = me.restorePos;
  } else if (ghostBox) 
  {
    pos = [ghostBox.x, ghostBox.y];
  } else {
    pos = me.getPosition();
  }
  Ext.apply(state, {size: maximized ? me.restoreSize : me.getSize(), pos: pos});
  return state;
}, applyState: function(state) {
  var me = this;
  if (state) 
  {
    me.maximized = state.maximized;
    if (me.maximized) 
    {
      me.hasSavedRestore = true;
      me.restoreSize = state.size;
      me.restorePos = state.pos;
    } else {
      Ext.apply(me, {width: state.size.width, height: state.size.height, x: state.pos[0], y: state.pos[1]});
    }
  }
}, onRender: function(ct, position) {
  var me = this;
  me.callParent(arguments);
  me.focusEl = me.el;
  if (me.maximizable) 
  {
    me.header.on({scope: me, dblclick: me.toggleMaximize});
  }
}, afterRender: function() {
  var me = this, header = me.header, keyMap;
  me.callParent();
  if (me.maximized) 
  {
    me.maximized = false;
    me.maximize();
    if (header) 
    {
      header.removeCls(header.indicateDragCls);
    }
  }
  if (me.closable) 
  {
    keyMap = me.getKeyMap();
    keyMap.on(27, me.onEsc, me);
  } else {
    keyMap = me.keyMap;
  }
  if (keyMap && me.hidden) 
  {
    keyMap.disable();
  }
}, initDraggable: function() {
  this.initSimpleDraggable();
}, initResizable: function() {
  this.callParent(arguments);
  if (this.maximized) 
  {
    this.resizer.disable();
  }
}, onEsc: function(k, e) {
  var mgr = Ext['FocusManager'];
  if (!Ext.enableFocusManager || mgr.focusedCmp === this) 
  {
    e.stopEvent();
    this.close();
  }
}, beforeDestroy: function() {
  var me = this;
  if (me.rendered) 
  {
    delete me.animateTarget;
    me.hide();
    Ext.destroy(me.keyMap);
  }
  me.callParent();
}, addTools: function() {
  var me = this, tools = me.tools, noArgs = [];
  me.callParent();
  if (me.minimizable) 
  {
    tools.push({type: 'minimize', handler: Ext.Function.bind(me.minimize, me, noArgs)});
  }
  if (me.maximizable) 
  {
    tools.push({type: 'maximize', handler: Ext.Function.bind(me.toggleMaximize, me, noArgs)});
  }
}, getFocusEl: function() {
  return this.getDefaultFocus();
}, getDefaultFocus: function() {
  var me = this, result, defaultComp = me.defaultButton || me.defaultFocus, selector;
  if (defaultComp !== undefined) 
  {
    if (Ext.isNumber(defaultComp)) 
    {
      result = me.query('button')[defaultComp];
    } else if (Ext.isString(defaultComp)) 
    {
      selector = defaultComp;
      if (selector.match(me.initialAlphaNum)) 
      {
        result = me.down('#' + selector);
      }
      if (!result) 
      {
        result = me.down(selector);
      }
    } else if (defaultComp.focus) 
    {
      result = defaultComp;
    }
  }
  return result || me.el;
}, onFocus: function() {
  var me = this, focusDescendant;
  if (Ext.enableFocusManager || ((focusDescendant = me.getDefaultFocus()) === me)) 
  {
    me.callParent(arguments);
  } else {
    focusDescendant.focus();
  }
}, onShow: function() {
  var me = this;
  me.callParent(arguments);
  if (me.expandOnShow) 
  {
    me.expand(false);
  }
  me.syncMonitorWindowResize();
  if (me.keyMap) 
  {
    me.keyMap.enable();
  }
}, doClose: function() {
  var me = this;
  if (me.hidden) 
  {
    me.fireEvent('close', me);
    if (me.closeAction == 'destroy') 
    {
      me.destroy();
    }
  } else {
    me.hide(me.animateTarget, me.doClose, me);
  }
}, afterHide: function() {
  var me = this;
  me.syncMonitorWindowResize();
  if (me.keyMap) 
  {
    me.keyMap.disable();
  }
  me.callParent(arguments);
}, onWindowResize: function() {
  var me = this, sizeModel;
  if (me.maximized) 
  {
    me.fitContainer();
  } else {
    sizeModel = me.getSizeModel();
    if (sizeModel.width.natural || sizeModel.height.natural) 
    {
      me.updateLayout();
    }
    me.doConstrain();
  }
}, minimize: function() {
  this.fireEvent('minimize', this);
  return this;
}, resumeHeaderLayout: function(changed) {
  this.header.resumeLayouts(changed ? this.isRootCfg : null);
}, afterCollapse: function() {
  var me = this, header = me.header, tools = me.tools;
  if (header && me.maximizable) 
  {
    header.suspendLayouts();
    tools.maximize.hide();
    this.resumeHeaderLayout(true);
  }
  if (me.resizer) 
  {
    me.resizer.disable();
  }
  me.callParent(arguments);
}, afterExpand: function() {
  var me = this, header = me.header, tools = me.tools, changed;
  if (header) 
  {
    header.suspendLayouts();
    if (me.maximizable) 
    {
      tools.maximize.show();
      changed = true;
    }
    this.resumeHeaderLayout(changed);
  }
  if (me.resizer) 
  {
    me.resizer.enable();
  }
  me.callParent(arguments);
}, maximize: function(animate) {
  var me = this, header = me.header, tools = me.tools, width = me.width, height = me.height, restore, changed;
  if (!me.maximized) 
  {
    me.expand(false);
    if (!me.hasSavedRestore) 
    {
      restore = me.restoreSize = {width: Ext.isNumber(width) ? width : null, height: Ext.isNumber(height) ? height : null};
      me.restorePos = me.getPosition(true);
    }
    if (header) 
    {
      header.suspendLayouts();
      if (tools.maximize) 
      {
        tools.maximize.setType('restore');
      }
      if (me.collapseTool) 
      {
        me.collapseTool.hide();
        changed = true;
      }
      me.resumeHeaderLayout(changed);
    }
    me.el.disableShadow();
    if (me.dd) 
    {
      me.dd.disable();
      if (header) 
      {
        header.removeCls(header.indicateDragCls);
      }
    }
    if (me.resizer) 
    {
      me.resizer.disable();
    }
    me.el.addCls(Ext.baseCSSPrefix + 'window-maximized');
    me.container.addCls(Ext.baseCSSPrefix + 'window-maximized-ct');
    me.syncMonitorWindowResize();
    me.fitContainer(animate = (animate || !!me.animateTarget) ? {callback: function() {
  me.maximized = true;
  me.fireEvent('maximize', me);
}} : null);
    if (!animate) 
    {
      me.maximized = true;
      me.fireEvent('maximize', me);
    }
  }
  return me;
}, restore: function(animate) {
  var me = this, tools = me.tools, header = me.header, newBox = me.restoreSize, changed;
  if (me.maximized) 
  {
    me.hasSavedRestore = null;
    me.removeCls(Ext.baseCSSPrefix + 'window-maximized');
    if (header) 
    {
      header.suspendLayouts();
      if (tools.maximize) 
      {
        tools.maximize.setType('maximize');
      }
      if (me.collapseTool) 
      {
        me.collapseTool.show();
        changed = true;
      }
      me.resumeHeaderLayout(changed);
    }
    newBox.x = me.restorePos[0];
    newBox.y = me.restorePos[1];
    me.setBox(newBox, animate = (animate || !!me.animateTarget) ? {callback: function() {
  me.el.enableShadow(true);
  me.maximized = false;
  me.fireEvent('restore', me);
}} : null);
    me.restorePos = me.restoreSize = null;
    if (me.dd) 
    {
      me.dd.enable();
      if (header) 
      {
        header.addCls(header.indicateDragCls);
      }
    }
    if (me.resizer) 
    {
      me.resizer.enable();
    }
    me.container.removeCls(Ext.baseCSSPrefix + 'window-maximized-ct');
    me.syncMonitorWindowResize();
    if (!animate) 
    {
      me.el.enableShadow(true);
      me.maximized = false;
      me.fireEvent('restore', me);
    }
  }
  return me;
}, syncMonitorWindowResize: function() {
  var me = this, currentlyMonitoring = me._monitoringResize, yes = me.monitorResize || me.constrain || me.constrainHeader || me.maximized, veto = me.hidden || me.destroying || me.isDestroyed;
  if (yes && !veto) 
  {
    if (!currentlyMonitoring) 
    {
      Ext.EventManager.onWindowResize(me.onWindowResize, me, {buffer: 1});
      me._monitoringResize = true;
    }
  } else if (currentlyMonitoring) 
  {
    Ext.EventManager.removeResizeListener(me.onWindowResize, me);
    me._monitoringResize = false;
  }
}, toggleMaximize: function() {
  return this[this.maximized ? 'restore' : 'maximize']();
}, createGhost: function() {
  var ghost = this.callParent(arguments);
  ghost.xtype = 'window';
  return ghost;
}}, 0, ["window"], ["container", "component", "box", "window", "panel"], {"container": true, "component": true, "box": true, "window": true, "panel": true}, ["widget.window"], 0, [Ext.window, 'Window', Ext, 'Window'], 0));
;

(Ext.cmd.derive('Ext.form.Labelable', Ext.Base, {isLabelable: true, autoEl: {tag: 'table', cellpadding: 0, role: 'presentation'}, childEls: ['labelCell', 'labelEl', 'bodyEl', 'sideErrorCell', 'errorEl', 'inputRow'], labelableRenderTpl: ['<tr role="presentation" id="{id}-inputRow" <tpl if="inFormLayout">id="{id}"</tpl> class="{inputRowCls}">', '<tpl if="labelOnLeft">', '<td role="presentation" id="{id}-labelCell" style="{labelCellStyle}" {labelCellAttrs}>', '{beforeLabelTpl}', '<label id="{id}-labelEl" {labelAttrTpl}', '<tpl if="inputId && !(boxLabel && !fieldLabel)"> for="{inputId}"</tpl>', ' class="{labelCls}"', '<tpl if="labelStyle"> style="{labelStyle}"</tpl>', ' unselectable="on"', '>', '{beforeLabelTextTpl}', '<tpl if="fieldLabel">{fieldLabel}', '<tpl if="labelSeparator">', '<span role="separator">{labelSeparator}</span>', '</tpl>', '</tpl>', '{afterLabelTextTpl}', '</label>', '{afterLabelTpl}', '</td>', '</tpl>', '<td role="presentation" class="{baseBodyCls} {fieldBodyCls} {extraFieldBodyCls}" id="{id}-bodyEl" colspan="{bodyColspan}" role="presentation">', '{beforeBodyEl}', '<tpl if="labelAlign==\'top\'">', '{beforeLabelTpl}', '<div role="presentation" id="{id}-labelCell" style="{labelCellStyle}">', '<label id="{id}-labelEl" {labelAttrTpl}<tpl if="inputId"> for="{inputId}"</tpl> class="{labelCls}"', '<tpl if="labelStyle"> style="{labelStyle}"</tpl>', ' unselectable="on"', '>', '{beforeLabelTextTpl}', '<tpl if="fieldLabel">{fieldLabel}', '<tpl if="labelSeparator">', '<span role="separator">{labelSeparator}</span>', '</tpl>', '</tpl>', '{afterLabelTextTpl}', '</label>', '</div>', '{afterLabelTpl}', '</tpl>', '{beforeSubTpl}', '{[values.$comp.getSubTplMarkup(values)]}', '{afterSubTpl}', '<tpl if="msgTarget===\'side\'">', '{afterBodyEl}', '</td>', '<td role="presentation" id="{id}-sideErrorCell" vAlign="{[values.labelAlign===\'top\' && !values.hideLabel ? \'bottom\' : \'middle\']}" style="{[values.autoFitErrors ? \'display:none\' : \'\']}" width="{errorIconWidth}">', '<div role="alert" aria-live="polite" id="{id}-errorEl" class="{errorMsgCls}" style="display:none"></div>', '</td>', '<tpl elseif="msgTarget==\'under\'">', '<div role="alert" aria-live="polite" id="{id}-errorEl" class="{errorMsgClass}" colspan="2" style="display:none"></div>', '{afterBodyEl}', '</td>', '</tpl>', '</tr>', {disableFormats: true}], activeErrorsTpl: undefined, htmlActiveErrorsTpl: ['<tpl if="errors && errors.length">', '<ul class="{listCls}">', '<tpl if="Ext.enableAria">', '<tpl if="fieldLabel"><div>{fieldLabel}</div></tpl>', '</tpl>', '<tpl for="errors"><li>{.}</li></tpl>', '</ul>', '</tpl>'], plaintextActiveErrorsTpl: ['<tpl if="errors && errors.length">', '<tpl if="Ext.enableAria">', '<tpl if="fieldLabel">{fieldLabel}\n</tpl>', '</tpl>', '<tpl for="errors"><tpl if="xindex &gt; 1">\n</tpl>{.}</tpl>', '</tpl>'], isFieldLabelable: true, formItemCls: Ext.baseCSSPrefix + 'form-item', labelCls: Ext.baseCSSPrefix + 'form-item-label', errorMsgCls: Ext.baseCSSPrefix + 'form-error-msg', baseBodyCls: Ext.baseCSSPrefix + 'form-item-body', inputRowCls: Ext.baseCSSPrefix + 'form-item-input-row', fieldBodyCls: '', clearCls: Ext.baseCSSPrefix + 'clear', invalidCls: Ext.baseCSSPrefix + 'form-invalid', fieldLabel: undefined, labelAlign: 'left', labelWidth: 100, labelPad: 5, labelSeparator: ':', hideLabel: false, hideEmptyLabel: true, preventMark: false, autoFitErrors: true, msgTarget: 'qtip', noWrap: true, labelableInsertions: ['beforeBodyEl', 'afterBodyEl', 'beforeLabelTpl', 'afterLabelTpl', 'beforeSubTpl', 'afterSubTpl', 'beforeLabelTextTpl', 'afterLabelTextTpl', 'labelAttrTpl'], labelableRenderProps: ['allowBlank', 'id', 'labelAlign', 'fieldBodyCls', 'extraFieldBodyCls', 'baseBodyCls', 'clearCls', 'labelSeparator', 'msgTarget', 'inputRowCls'], initLabelable: function() {
  var me = this, padding = me.padding;
  if (padding) 
  {
    me.padding = undefined;
    me.extraMargins = Ext.Element.parseBox(padding);
  }
  if (!me.activeErrorsTpl) 
  {
    if (me.msgTarget == 'title') 
    {
      me.activeErrorsTpl = me.plaintextActiveErrorsTpl;
    } else {
      me.activeErrorsTpl = me.htmlActiveErrorsTpl;
    }
  }
  me.addCls(Ext.plainTableCls);
  me.addCls(me.formItemCls);
  me.lastActiveError = '';
  me.addEvents('errorchange');
  me.enableBubble('errorchange');
}, trimLabelSeparator: function() {
  var me = this, separator = me.labelSeparator, label = me.fieldLabel || '', lastChar = label.substr(label.length - 1);
  return lastChar === separator ? label.slice(0, -1) : label;
}, getFieldLabel: function() {
  return this.trimLabelSeparator();
}, setFieldLabel: function(label) {
  label = label || '';
  var me = this, separator = me.labelSeparator, labelEl = me.labelEl;
  me.fieldLabel = label;
  if (me.rendered) 
  {
    if (Ext.isEmpty(label) && me.hideEmptyLabel) 
    {
      labelEl.parent().setDisplayed('none');
    } else {
      if (separator) 
      {
        label = me.trimLabelSeparator() + separator;
      }
      labelEl.update(label);
      labelEl.parent().setDisplayed('');
    }
    me.updateLayout();
  }
}, getInsertionRenderData: function(data, names) {
  var i = names.length, name, value;
  while (i--) 
    {
      name = names[i];
      value = this[name];
      if (value) 
      {
        if (typeof value != 'string') 
        {
          if (!value.isTemplate) 
          {
            value = Ext.XTemplate.getTpl(this, name);
          }
          value = value.apply(data);
        }
      }
      data[name] = value || '';
    }
  return data;
}, getLabelableRenderData: function() {
  var me = this, data, tempEl, topLabel = me.labelAlign === 'top';
  if (!Ext.form.Labelable.errorIconWidth) 
  {
    tempEl = Ext.getBody().createChild({style: 'position:absolute', cls: Ext.baseCSSPrefix + 'form-invalid-icon'});
    Ext.form.Labelable.errorIconWidth = tempEl.getWidth() + tempEl.getMargin('l');
    tempEl.remove();
  }
  data = Ext.copyTo({inFormLayout: me.ownerLayout && me.ownerLayout.type === 'form', inputId: me.getInputId(), labelOnLeft: !topLabel, hideLabel: !me.hasVisibleLabel(), fieldLabel: me.getFieldLabel(), labelCellStyle: me.getLabelCellStyle(), labelCellAttrs: me.getLabelCellAttrs(), labelCls: me.getLabelCls(), labelStyle: me.getLabelStyle(), bodyColspan: me.getBodyColspan(), externalError: !me.autoFitErrors, errorMsgCls: me.getErrorMsgCls(), errorIconWidth: Ext.form.Labelable.errorIconWidth, boxLabel: me.boxLabel}, me, me.labelableRenderProps, true);
  me.getInsertionRenderData(data, me.labelableInsertions);
  return data;
}, xhooks: {beforeRender: function() {
  var me = this;
  me.setFieldDefaults(me.getHierarchyState().fieldDefaults);
  if (me.ownerLayout) 
  {
    me.addCls(Ext.baseCSSPrefix + me.ownerLayout.type + '-form-item');
  }
}, onRender: function() {
  var me = this, margins, side, style = {};
  if (me.extraMargins) 
  {
    margins = me.el.getMargin();
    for (side in margins) 
      {
        if (margins.hasOwnProperty(side)) 
        {
          style['margin-' + side] = (margins[side] + me.extraMargins[side]) + 'px';
        }
      }
    me.el.setStyle(style);
  }
}}, hasVisibleLabel: function() {
  if (this.hideLabel) 
  {
    return false;
  }
  return !(this.hideEmptyLabel && !this.getFieldLabel());
}, getLabelWidth: function() {
  var me = this;
  if (!me.hasVisibleLabel()) 
  {
    return 0;
  }
  return me.labelWidth + me.labelPad;
}, getBodyColspan: function() {
  var me = this, result;
  if (me.msgTarget === 'side' && (!me.autoFitErrors || me.hasActiveError())) 
  {
    result = 1;
  } else {
    result = 2;
  }
  if (me.labelAlign !== 'top' && !me.hasVisibleLabel()) 
  {
    result++;
  }
  return result;
}, getLabelCls: function() {
  var labelCls = this.labelCls + ' ' + Ext.dom.Element.unselectableCls, labelClsExtra = this.labelClsExtra;
  return labelClsExtra ? labelCls + ' ' + labelClsExtra : labelCls;
}, getLabelCellStyle: function() {
  var me = this, hideLabelCell = me.hideLabel || (!me.getFieldLabel() && me.hideEmptyLabel);
  return hideLabelCell ? 'display:none;' : '';
}, getErrorMsgCls: function() {
  var me = this, hideLabelCell = (me.hideLabel || (!me.fieldLabel && me.hideEmptyLabel));
  return me.errorMsgCls + (!hideLabelCell && me.labelAlign === 'top' ? ' ' + Ext.baseCSSPrefix + 'lbl-top-err-icon' : '');
}, getLabelCellAttrs: function() {
  var me = this, labelAlign = me.labelAlign, result = '';
  if (labelAlign !== 'top') 
  {
    result = 'valign="top" halign="' + labelAlign + '" width="' + (me.labelWidth + me.labelPad) + '"';
  }
  return result + ' class="' + Ext.baseCSSPrefix + 'field-label-cell"';
}, getLabelStyle: function() {
  var me = this, labelPad = me.labelPad, labelWidth = me.labelWidth, labelStyle = '';
  if (me.labelAlign !== 'top') 
  {
    if (labelWidth) 
    {
      labelStyle = 'width:' + labelWidth + 'px;';
    }
    if (labelPad) 
    {
      labelStyle += me.getLabelStyleMarginProp() + labelPad + 'px;';
    }
  } else if (labelPad) 
  {
    labelStyle = 'margin-bottom:' + labelPad + 'px;';
  }
  return labelStyle + (me.labelStyle || '');
}, getLabelStyleMarginProp: function() {
  return 'margin-right:';
}, getSubTplMarkup: function() {
  return '';
}, getInputId: function() {
  return '';
}, getActiveError: function() {
  return this.activeError || '';
}, hasActiveError: function() {
  return !!this.getActiveError();
}, setActiveError: function(msg) {
  this.setActiveErrors(msg);
}, getActiveErrors: function() {
  return this.activeErrors || [];
}, setActiveErrors: function(errors) {
  var me = this, tpl;
  errors = Ext.Array.from(errors);
  tpl = me.getTpl('activeErrorsTpl');
  me.activeErrors = errors;
  me.activeError = tpl.apply({fieldLabel: me.fieldLabel, errors: errors, listCls: Ext.plainListCls});
  me.renderActiveError();
}, unsetActiveError: function() {
  delete this.activeError;
  delete this.activeErrors;
  this.renderActiveError();
}, renderActiveError: function() {
  var me = this, activeError = me.getActiveError(), hasError = !!activeError;
  if (activeError !== me.lastActiveError) 
  {
    me.fireEvent('errorchange', me, activeError);
    me.lastActiveError = activeError;
  }
  if (me.rendered && !me.isDestroyed && !me.preventMark) 
  {
    me.el[hasError ? 'addCls' : 'removeCls'](me.invalidCls);
    if (me.errorEl) 
    {
      me.errorEl.dom.innerHTML = activeError;
    }
  }
}, setFieldDefaults: function(defaults) {
  var key;
  for (key in defaults) 
    {
      if (!this.hasOwnProperty(key)) 
      {
        this[key] = defaults[key];
      }
    }
}}, 0, 0, 0, 0, 0, 0, [Ext.form, 'Labelable'], 0));
;

(Ext.cmd.derive('Ext.form.field.Field', Ext.Base, {isFormField: true, disabled: false, submitValue: true, validateOnChange: true, suspendCheckChange: 0, initField: function() {
  this.addEvents('change', 'validitychange', 'dirtychange');
  this.initValue();
}, initValue: function() {
  var me = this;
  me.value = me.transformOriginalValue(me.value);
  me.originalValue = me.lastValue = me.value;
  me.suspendCheckChange++;
  me.setValue(me.value);
  me.suspendCheckChange--;
}, transformOriginalValue: Ext.identityFn, getFieldIdentifier: function() {
  return this.isEditorComponent ? this.dataIndex : this.name;
}, getName: function() {
  return this.name;
}, getValue: function() {
  return this.value;
}, setValue: function(value) {
  var me = this;
  me.value = value;
  me.checkChange();
  return me;
}, isEqual: function(value1, value2) {
  return String(value1) === String(value2);
}, isEqualAsString: function(value1, value2) {
  return String(Ext.value(value1, '')) === String(Ext.value(value2, ''));
}, getSubmitData: function() {
  var me = this, data = null;
  if (!me.disabled && me.submitValue) 
  {
    data = {};
    data[me.getName()] = '' + me.getValue();
  }
  return data;
}, getModelData: function(includeEmptyText, isSubmitting) {
  var me = this, data = null;
  if (!me.disabled && (me.submitValue || !isSubmitting)) 
  {
    data = {};
    data[me.getFieldIdentifier()] = me.getValue();
  }
  return data;
}, reset: function() {
  var me = this;
  me.beforeReset();
  me.setValue(me.originalValue);
  me.clearInvalid();
  delete me.wasValid;
}, beforeReset: Ext.emptyFn, resetOriginalValue: function() {
  this.originalValue = this.getValue();
  this.checkDirty();
}, checkChange: function() {
  var me = this, newVal, oldVal;
  if (!me.suspendCheckChange) 
  {
    newVal = me.getValue();
    oldVal = me.lastValue;
    if (!me.isDestroyed && me.didValueChange(newVal, oldVal)) 
    {
      me.lastValue = newVal;
      me.fireEvent('change', me, newVal, oldVal);
      me.onChange(newVal, oldVal);
    }
  }
}, didValueChange: function(newVal, oldVal) {
  return !this.isEqual(newVal, oldVal);
}, onChange: function(newVal, oldVal) {
  if (this.validateOnChange) 
  {
    this.validate();
  }
  this.checkDirty();
}, isDirty: function() {
  var me = this;
  return !me.disabled && !me.isEqual(me.getValue(), me.originalValue);
}, checkDirty: function() {
  var me = this, isDirty = me.isDirty();
  if (isDirty !== me.wasDirty) 
  {
    me.fireEvent('dirtychange', me, isDirty);
    me.onDirtyChange(isDirty);
    me.wasDirty = isDirty;
  }
}, onDirtyChange: Ext.emptyFn, getErrors: function(value) {
  return [];
}, isValid: function() {
  var me = this;
  return me.disabled || Ext.isEmpty(me.getErrors());
}, validate: function() {
  var me = this, isValid = me.isValid();
  if (isValid !== me.wasValid) 
  {
    me.wasValid = isValid;
    me.fireEvent('validitychange', me, isValid);
  }
  return isValid;
}, batchChanges: function(fn) {
  try {
    this.suspendCheckChange++;
    fn();
  }  catch (e) {
  throw e;
}
 finally   {
    this.suspendCheckChange--;
  }
  this.checkChange();
}, isFileUpload: function() {
  return false;
}, extractFileInput: function() {
  return null;
}, markInvalid: Ext.emptyFn, clearInvalid: Ext.emptyFn}, 0, 0, 0, 0, 0, 0, [Ext.form.field, 'Field'], 0));
;

(Ext.cmd.derive('Ext.layout.component.field.Field', Ext.layout.component.Auto, {type: 'field', naturalSizingProp: 'size', beginLayout: function(ownerContext) {
  var me = this, owner = me.owner;
  me.callParent(arguments);
  ownerContext.labelStrategy = me.getLabelStrategy();
  ownerContext.errorStrategy = me.getErrorStrategy();
  ownerContext.labelContext = ownerContext.getEl('labelEl');
  ownerContext.bodyCellContext = ownerContext.getEl('bodyEl');
  ownerContext.inputContext = ownerContext.getEl('inputEl');
  ownerContext.errorContext = ownerContext.getEl('errorEl');
  if (Ext.isIE7m && Ext.isStrict && ownerContext.inputContext) 
  {
    me.ieInputWidthAdjustment = ownerContext.inputContext.getPaddingInfo().width + ownerContext.inputContext.getBorderInfo().width;
  }
  ownerContext.labelStrategy.prepare(ownerContext, owner);
  ownerContext.errorStrategy.prepare(ownerContext, owner);
}, beginLayoutCycle: function(ownerContext) {
  var me = this, owner = me.owner, widthModel = ownerContext.widthModel, ownerNaturalSize = owner[me.naturalSizingProp], width;
  me.callParent(arguments);
  if (widthModel.shrinkWrap) 
  {
    me.beginLayoutShrinkWrap(ownerContext);
  } else if (widthModel.natural) 
  {
    if (typeof ownerNaturalSize == 'number' && !owner.inputWidth) 
    {
      me.beginLayoutFixed(ownerContext, (width = ownerNaturalSize * 6.5 + 20), 'px');
    } else {
      me.beginLayoutShrinkWrap(ownerContext);
    }
    ownerContext.setWidth(width, false);
  } else {
    me.beginLayoutFixed(ownerContext, '100', '%');
  }
}, beginLayoutFixed: function(ownerContext, width, suffix) {
  var owner = ownerContext.target, inputEl = owner.inputEl, inputWidth = owner.inputWidth;
  owner.el.setStyle('table-layout', 'fixed');
  owner.bodyEl.setStyle('width', width + suffix);
  if (inputEl) 
  {
    if (inputWidth) 
    {
      inputEl.setStyle('width', inputWidth + 'px');
    } else {
      inputEl.setStyle('width', owner.stretchInputElFixed ? '100%' : '');
    }
  }
  ownerContext.isFixed = true;
}, beginLayoutShrinkWrap: function(ownerContext) {
  var owner = ownerContext.target, inputEl = owner.inputEl, inputWidth = owner.inputWidth;
  if (inputEl && inputEl.dom) 
  {
    inputEl.dom.removeAttribute('size');
    if (inputWidth) 
    {
      inputEl.setStyle('width', inputWidth + 'px');
    } else {
      inputEl.setStyle('width', '');
    }
  }
  owner.el.setStyle('table-layout', 'auto');
  owner.bodyEl.setStyle('width', '');
}, finishedLayout: function(ownerContext) {
  var owner = this.owner;
  this.callParent(arguments);
  ownerContext.labelStrategy.finishedLayout(ownerContext, owner);
  ownerContext.errorStrategy.finishedLayout(ownerContext, owner);
}, calculateOwnerHeightFromContentHeight: function(ownerContext, contentHeight) {
  return contentHeight;
}, measureContentHeight: function(ownerContext) {
  return ownerContext.el.getHeight();
}, measureContentWidth: function(ownerContext) {
  return ownerContext.el.getWidth();
}, measureLabelErrorHeight: function(ownerContext) {
  return ownerContext.labelStrategy.getHeight(ownerContext) + ownerContext.errorStrategy.getHeight(ownerContext);
}, onFocus: function() {
  this.getErrorStrategy().onFocus(this.owner);
}, getLabelStrategy: function() {
  var me = this, strategies = me.labelStrategies, labelAlign = me.owner.labelAlign;
  return strategies[labelAlign] || strategies.base;
}, getErrorStrategy: function() {
  var me = this, owner = me.owner, strategies = me.errorStrategies, msgTarget = owner.msgTarget;
  return !owner.preventMark && Ext.isString(msgTarget) ? (strategies[msgTarget] || strategies.elementId) : strategies.none;
}, labelStrategies: (function() {
  var base = {prepare: function(ownerContext, owner) {
  var cls = owner.labelCls + '-' + owner.labelAlign, labelEl = owner.labelEl;
  if (labelEl) 
  {
    labelEl.addCls(cls);
  }
}, getHeight: function() {
  return 0;
}, finishedLayout: Ext.emptyFn};
  return {base: base, top: Ext.applyIf({getHeight: function(ownerContext) {
  var labelContext = ownerContext.labelContext, props = labelContext.props, height = props.height;
  if (height === undefined) 
  {
    props.height = height = labelContext.el.getHeight() + labelContext.getMarginInfo().height;
  }
  return height;
}}, base), left: base, right: base};
}()), errorStrategies: (function() {
  function showTip(owner) {
    var tip = Ext.layout.component.field.Field.tip, target;
    if (tip && tip.isVisible()) 
    {
      target = tip.activeTarget;
      if (target && target.el === owner.getActionEl().dom) 
      {
        tip.toFront(true);
      }
    }
  }
  var applyIf = Ext.applyIf, emptyFn = Ext.emptyFn, iconCls = Ext.baseCSSPrefix + 'form-invalid-icon', iconWidth, base = {prepare: function(ownerContext, owner) {
  var el = owner.errorEl;
  if (el) 
  {
    el.setDisplayed(false);
  }
}, getHeight: function() {
  return 0;
}, onFocus: emptyFn, finishedLayout: emptyFn};
  return {none: base, side: applyIf({prepare: function(ownerContext, owner) {
  var errorEl = owner.errorEl, sideErrorCell = owner.sideErrorCell, displayError = owner.hasActiveError(), tempEl;
  if (!iconWidth) 
  {
    iconWidth = (tempEl = Ext.getBody().createChild({style: 'position:absolute', cls: iconCls})).getWidth();
    tempEl.remove();
  }
  errorEl.addCls(iconCls);
  errorEl.set({'data-errorqtip': owner.getActiveError() || ''});
  if (owner.autoFitErrors) 
  {
    errorEl.setDisplayed(displayError);
  } else {
    errorEl.setVisible(displayError);
  }
  if (sideErrorCell && owner.autoFitErrors) 
  {
    sideErrorCell.setDisplayed(displayError);
  }
  owner.bodyEl.dom.colSpan = owner.getBodyColspan();
  Ext.layout.component.field.Field.initTip();
}, onFocus: showTip}, base), under: applyIf({prepare: function(ownerContext, owner) {
  var errorEl = owner.errorEl, cls = Ext.baseCSSPrefix + 'form-invalid-under';
  errorEl.addCls(cls);
  errorEl.setDisplayed(owner.hasActiveError());
}, getHeight: function(ownerContext) {
  var height = 0, errorContext, props;
  if (ownerContext.target.hasActiveError()) 
  {
    errorContext = ownerContext.errorContext;
    props = errorContext.props;
    height = props.height;
    if (height === undefined) 
    {
      props.height = height = errorContext.el.getHeight();
    }
  }
  return height;
}}, base), qtip: applyIf({prepare: function(ownerContext, owner) {
  Ext.layout.component.field.Field.initTip();
  owner.getActionEl().dom.setAttribute('data-errorqtip', owner.getActiveError() || '');
}, onFocus: showTip}, base), title: applyIf({prepare: function(ownerContext, owner) {
  owner.getActionEl().dom.setAttribute('title', owner.getActiveError() || '');
}}, base), elementId: applyIf({prepare: function(ownerContext, owner) {
  var targetEl = Ext.fly(owner.msgTarget);
  if (targetEl) 
  {
    targetEl.dom.innerHTML = owner.getActiveError() || '';
    targetEl.setDisplayed(owner.hasActiveError());
  }
}}, base)};
}()), statics: {initTip: function() {
  var tip = this.tip;
  if (!tip) 
  {
    tip = this.tip = Ext.create('Ext.tip.QuickTip', {ui: 'form-invalid'});
    tip.tagConfig = Ext.apply({}, {attribute: 'errorqtip'}, tip.tagConfig);
  }
}, destroyTip: function() {
  var tip = this.tip;
  if (tip) 
  {
    tip.destroy();
    delete this.tip;
  }
}}}, 0, 0, 0, 0, ["layout.field"], 0, [Ext.layout.component.field, 'Field'], 0));
;

(Ext.cmd.derive('Ext.form.field.Base', Ext.Component, {alternateClassName: ['Ext.form.Field', 'Ext.form.BaseField'], fieldSubTpl: ['<input id="{id}" type="{type}" role="{role}" {inputAttrTpl}', ' size="1"', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '{%if (values.maxLength !== undefined){%} maxlength="{maxLength}"{%}%}', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' class="{fieldCls} {typeCls} {editableCls} {inputCls}" autocomplete="off"/>', {disableFormats: true}], subTplInsertions: ['inputAttrTpl'], inputType: 'text', invalidText: 'The value in this field is invalid', fieldCls: Ext.baseCSSPrefix + 'form-field', focusCls: 'form-focus', dirtyCls: Ext.baseCSSPrefix + 'form-dirty', checkChangeEvents: Ext.isIE && (!document.documentMode || document.documentMode < 9) ? ['change', 'propertychange', 'keyup'] : ['change', 'input', 'textInput', 'keyup', 'dragdrop'], ignoreChangeRe: /data\-errorqtip|style\.|className/, checkChangeBuffer: 50, componentLayout: 'field', readOnly: false, readOnlyCls: Ext.baseCSSPrefix + 'form-readonly', validateOnBlur: true, hasFocus: false, baseCls: Ext.baseCSSPrefix + 'field', maskOnDisable: false, stretchInputElFixed: true, initComponent: function() {
  var me = this;
  me.callParent();
  me.subTplData = me.subTplData || {};
  me.addEvents('specialkey', 'writeablechange');
  me.initLabelable();
  me.initField();
  if (!me.name) 
  {
    me.name = me.getInputId();
  }
  if (me.readOnly) 
  {
    me.addCls(me.readOnlyCls);
  }
  me.addCls(Ext.baseCSSPrefix + 'form-type-' + me.inputType);
}, getInputId: function() {
  return this.inputId || (this.inputId = this.id + '-inputEl');
}, getSubTplData: function() {
  var me = this, type = me.inputType, inputId = me.getInputId(), data;
  data = Ext.apply({id: inputId, cmpId: me.id, name: me.name || inputId, disabled: me.disabled, readOnly: me.readOnly, value: me.getRawValue(), type: type, fieldCls: me.fieldCls, fieldStyle: me.getFieldStyle(), tabIdx: me.tabIndex, inputCls: me.inputCls, typeCls: Ext.baseCSSPrefix + 'form-' + (type === 'password' ? 'text' : type), role: me.ariaRole}, me.subTplData);
  me.getInsertionRenderData(data, me.subTplInsertions);
  return data;
}, applyRenderSelectors: function() {
  var me = this;
  me.callParent();
  me.addChildEls('inputEl');
  me.inputEl = me.el.getById(me.getInputId());
}, getSubTplMarkup: function() {
  return this.getTpl('fieldSubTpl').apply(this.getSubTplData());
}, initRenderTpl: function() {
  var me = this;
  if (!me.hasOwnProperty('renderTpl')) 
  {
    me.renderTpl = me.getTpl('labelableRenderTpl');
  }
  return me.callParent();
}, initRenderData: function() {
  return Ext.applyIf(this.callParent(), this.getLabelableRenderData());
}, setFieldStyle: function(style) {
  var me = this, inputEl = me.inputEl;
  if (inputEl) 
  {
    inputEl.applyStyles(style);
  }
  me.fieldStyle = style;
}, getFieldStyle: function() {
  var style = this.fieldStyle;
  return Ext.isObject(style) ? Ext.DomHelper.generateStyles(style, null, true) : style || '';
}, onRender: function() {
  this.callParent(arguments);
  this.renderActiveError();
}, getFocusEl: function() {
  return this.inputEl;
}, isFileUpload: function() {
  return this.inputType === 'file';
}, getSubmitData: function() {
  var me = this, data = null, val;
  if (!me.disabled && me.submitValue) 
  {
    val = me.getSubmitValue();
    if (val !== null) 
    {
      data = {};
      data[me.getName()] = val;
    }
  }
  return data;
}, getSubmitValue: function() {
  return this.processRawValue(this.getRawValue());
}, getRawValue: function() {
  var me = this, v = (me.inputEl ? me.inputEl.getValue() : Ext.value(me.rawValue, ''));
  me.rawValue = v;
  return v;
}, setRawValue: function(value) {
  var me = this;
  value = Ext.value(me.transformRawValue(value), '');
  me.rawValue = value;
  if (me.inputEl) 
  {
    me.bindPropertyChange(false);
    me.inputEl.dom.value = value;
    me.bindPropertyChange(true);
  }
  return value;
}, transformRawValue: Ext.identityFn, valueToRaw: function(value) {
  return '' + Ext.value(value, '');
}, rawToValue: Ext.identityFn, processRawValue: Ext.identityFn, getValue: function() {
  var me = this, val = me.rawToValue(me.processRawValue(me.getRawValue()));
  me.value = val;
  return val;
}, setValue: function(value) {
  var me = this;
  me.setRawValue(me.valueToRaw(value));
  return me.mixins.field.setValue.call(me, value);
}, onBoxReady: function() {
  var me = this;
  me.callParent(arguments);
  if (me.setReadOnlyOnBoxReady) 
  {
    me.setReadOnly(me.readOnly);
  }
}, onDisable: function() {
  var me = this, inputEl = me.inputEl;
  me.callParent();
  if (inputEl) 
  {
    inputEl.dom.disabled = true;
    if (me.hasActiveError()) 
    {
      me.clearInvalid();
      me.needsValidateOnEnable = true;
    }
  }
}, onEnable: function() {
  var me = this, inputEl = me.inputEl;
  me.callParent();
  if (inputEl) 
  {
    inputEl.dom.disabled = false;
    if (me.needsValidateOnEnable) 
    {
      delete me.needsValidateOnEnable;
      me.forceValidation = true;
      me.isValid();
      delete me.forceValidation;
    }
  }
}, setReadOnly: function(readOnly) {
  var me = this, inputEl = me.inputEl;
  readOnly = !!readOnly;
  me[readOnly ? 'addCls' : 'removeCls'](me.readOnlyCls);
  me.readOnly = readOnly;
  if (inputEl) 
  {
    inputEl.dom.readOnly = readOnly;
  } else if (me.rendering) 
  {
    me.setReadOnlyOnBoxReady = true;
  }
  me.fireEvent('writeablechange', me, readOnly);
}, fireKey: function(e) {
  if (e.isSpecialKey()) 
  {
    this.fireEvent('specialkey', this, new Ext.EventObjectImpl(e));
  }
}, initEvents: function() {
  var me = this, inputEl = me.inputEl, onChangeTask, onChangeEvent, events = me.checkChangeEvents, ignoreChangeRe = me.ignoreChangeRe, eLen = events.length, e, event;
  if (inputEl) 
  {
    me.mon(inputEl, Ext.EventManager.getKeyEvent(), me.fireKey, me);
    onChangeTask = new Ext.util.DelayedTask(me.checkChange, me);
    me.onChangeEvent = onChangeEvent = function(e) {
  if (!(e.type == 'propertychange' && ignoreChangeRe.test(e.browserEvent.propertyName))) 
  {
    onChangeTask.delay(me.checkChangeBuffer);
  }
};
    for (e = 0; e < eLen; e++) 
      {
        event = events[e];
        if (event === 'propertychange') 
        {
          me.usesPropertychange = true;
        }
        me.mon(inputEl, event, onChangeEvent);
      }
  }
  me.callParent();
}, doComponentLayout: function() {
  this.bindPropertyChange(false);
  this.callParent(arguments);
  this.bindPropertyChange(true);
}, bindPropertyChange: function(active) {
  var me = this, usesPropertychange = me.usesPropertychange;
  if (usesPropertychange) 
  {
    me[active ? 'mon' : 'mun'](me.inputEl, 'propertychange', me.onChangeEvent);
  }
}, onDirtyChange: function(isDirty) {
  this[isDirty ? 'addCls' : 'removeCls'](this.dirtyCls);
}, isValid: function() {
  var me = this, disabled = me.disabled, validate = me.forceValidation || !disabled;
  return validate ? me.validateValue(me.processRawValue(me.getRawValue())) : disabled;
}, validateValue: function(value) {
  var me = this, errors = me.getErrors(value), isValid = Ext.isEmpty(errors);
  if (!me.preventMark) 
  {
    if (isValid) 
    {
      me.clearInvalid();
    } else {
      me.markInvalid(errors);
    }
  }
  return isValid;
}, markInvalid: function(errors) {
  var me = this, oldMsg = me.getActiveError(), active;
  me.setActiveErrors(Ext.Array.from(errors));
  active = me.getActiveError();
  if (oldMsg !== active) 
  {
    me.setError(active);
  }
}, clearInvalid: function() {
  var me = this, hadError = me.hasActiveError();
  delete me.needsValidateOnEnable;
  me.unsetActiveError();
  if (hadError) 
  {
    me.setError('');
  }
}, setError: function(active) {
  var me = this, msgTarget = me.msgTarget, prop;
  if (me.rendered) 
  {
    if (msgTarget == 'title' || msgTarget == 'qtip') 
    {
      if (me.rendered) 
      {
        prop = msgTarget == 'qtip' ? 'data-errorqtip' : 'title';
      }
      me.getActionEl().dom.setAttribute(prop, active || '');
    } else {
      me.updateLayout();
    }
  }
}, renderActiveError: function() {
  var me = this, hasError = me.hasActiveError();
  if (me.inputEl) 
  {
    me.inputEl[hasError ? 'addCls' : 'removeCls'](me.invalidCls + '-field');
  }
  me.mixins.labelable.renderActiveError.call(me);
}, getActionEl: function() {
  return this.inputEl || this.el;
}}, 0, ["field"], ["component", "field", "box"], {"component": true, "field": true, "box": true}, ["widget.field"], [['labelable', Ext.form.Labelable], ['field', Ext.form.field.Field]], [Ext.form.field, 'Base', Ext.form, 'Field', Ext.form, 'BaseField'], 0));
;

(Ext.cmd.derive('Ext.form.field.VTypes', Ext.Base, (function() {
  var alpha = /^[a-zA-Z_]+$/, alphanum = /^[a-zA-Z0-9_]+$/, email = /^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+/=?^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/, url = /(((^https?)|(^ftp)):\/\/((([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*)|(localhost|LOCALHOST))\/?)/i;
  return {singleton: true, alternateClassName: 'Ext.form.VTypes', 'email': function(v) {
  return email.test(v);
}, 'emailText': 'This field should be an e-mail address in the format "user@example.com"', 'emailMask': /[\w.\-@'"!#$%&'*+/=?^_`{|}~]/i, 'url': function(v) {
  return url.test(v);
}, 'urlText': 'This field should be a URL in the format "http:/' + '/www.example.com"', 'alpha': function(v) {
  return alpha.test(v);
}, 'alphaText': 'This field should only contain letters and _', 'alphaMask': /[a-z_]/i, 'alphanum': function(v) {
  return alphanum.test(v);
}, 'alphanumText': 'This field should only contain letters, numbers and _', 'alphanumMask': /[a-z0-9_]/i};
}()), 0, 0, 0, 0, 0, 0, [Ext.form.field, 'VTypes', Ext.form, 'VTypes'], 0));
;

(Ext.cmd.derive('Ext.layout.component.field.Text', Ext.layout.component.field.Field, {type: 'textfield', setWidthInDom: true, canGrowWidth: true, beginLayoutCycle: function(ownerContext) {
  this.callParent(arguments);
  if (ownerContext.heightModel.shrinkWrap) 
  {
    ownerContext.inputContext.el.setStyle('height', '');
  }
}, measureContentWidth: function(ownerContext) {
  var me = this, owner = me.owner, width = me.callParent(arguments), inputContext = ownerContext.inputContext, inputEl, value, calcWidth, max, min;
  if (owner.grow && me.canGrowWidth && !ownerContext.state.growHandled) 
  {
    inputEl = owner.inputEl;
    value = Ext.util.Format.htmlEncode(inputEl.dom.value || (owner.hasFocus ? '' : owner.emptyText) || '');
    value += owner.growAppend;
    calcWidth = inputEl.getTextWidth(value) + inputContext.getFrameInfo().width;
    max = owner.growMax;
    min = Math.min(max, width);
    max = Math.max(owner.growMin, max, min);
    calcWidth = Ext.Number.constrain(calcWidth, owner.growMin, max);
    inputContext.setWidth(calcWidth);
    ownerContext.state.growHandled = true;
    inputContext.domBlock(me, 'width');
    width = NaN;
  }
  return width;
}, publishInnerHeight: function(ownerContext, height) {
  ownerContext.inputContext.setHeight(height - this.measureLabelErrorHeight(ownerContext));
}, beginLayoutFixed: function(ownerContext, width, suffix) {
  var me = this, ieInputWidthAdjustment = me.ieInputWidthAdjustment;
  if (ieInputWidthAdjustment) 
  {
    me.adjustIEInputPadding(ownerContext);
    if (suffix === 'px') 
    {
      width -= ieInputWidthAdjustment;
    }
  }
  me.callParent(arguments);
}, adjustIEInputPadding: function(ownerContext) {
  this.owner.bodyEl.setStyle('padding-right', this.ieInputWidthAdjustment + 'px');
}}, 0, 0, 0, 0, ["layout.textfield"], 0, [Ext.layout.component.field, 'Text'], 0));
;

(Ext.cmd.derive('Ext.form.field.Text', Ext.form.field.Base, {alternateClassName: ['Ext.form.TextField', 'Ext.form.Text'], size: 20, growMin: 30, growMax: 800, growAppend: 'W', allowBlank: true, validateBlank: false, allowOnlyWhitespace: true, minLength: 0, maxLength: Number.MAX_VALUE, minLengthText: 'The minimum length for this field is {0}', maxLengthText: 'The maximum length for this field is {0}', blankText: 'This field is required', regexText: '', emptyCls: Ext.baseCSSPrefix + 'form-empty-field', requiredCls: Ext.baseCSSPrefix + 'form-required-field', componentLayout: 'textfield', valueContainsPlaceholder: false, ariaRole: 'textbox', initComponent: function() {
  var me = this;
  if (me.allowOnlyWhitespace === false) 
  {
    me.allowBlank = false;
  }
  me.callParent();
  me.addEvents('autosize', 'keydown', 'keyup', 'keypress');
  me.addStateEvents('change');
  me.setGrowSizePolicy();
}, setGrowSizePolicy: function() {
  if (this.grow) 
  {
    this.shrinkWrap |= 1;
  }
}, initEvents: function() {
  var me = this, el = me.inputEl;
  me.callParent();
  if (me.selectOnFocus || me.emptyText) 
  {
    me.mon(el, 'mousedown', me.onMouseDown, me);
  }
  if (me.maskRe || (me.vtype && me.disableKeyFilter !== true && (me.maskRe = Ext.form.field.VTypes[me.vtype + 'Mask']))) 
  {
    me.mon(el, 'keypress', me.filterKeys, me);
  }
  if (me.enableKeyEvents) 
  {
    me.mon(el, {scope: me, keyup: me.onKeyUp, keydown: me.onKeyDown, keypress: me.onKeyPress});
  }
}, isEqual: function(value1, value2) {
  return this.isEqualAsString(value1, value2);
}, onChange: function(newVal, oldVal) {
  this.callParent(arguments);
  this.autoSize();
}, getSubTplData: function() {
  var me = this, value = me.getRawValue(), isEmpty = me.emptyText && value.length < 1, maxLength = me.maxLength, placeholder;
  if (me.enforceMaxLength) 
  {
    if (maxLength === Number.MAX_VALUE) 
    {
      maxLength = undefined;
    }
  } else {
    maxLength = undefined;
  }
  if (isEmpty) 
  {
    if (Ext.supports.Placeholder) 
    {
      placeholder = me.emptyText;
    } else {
      value = me.emptyText;
      me.valueContainsPlaceholder = true;
    }
  }
  return Ext.apply(me.callParent(), {maxLength: maxLength, readOnly: me.readOnly, placeholder: placeholder, value: value, fieldCls: me.fieldCls + ((isEmpty && (placeholder || value)) ? ' ' + me.emptyCls : '') + (me.allowBlank ? '' : ' ' + me.requiredCls)});
}, afterRender: function() {
  this.autoSize();
  this.callParent();
}, onMouseDown: function(e) {
  var me = this;
  if (!me.hasFocus) 
  {
    me.mon(me.inputEl, 'mouseup', Ext.emptyFn, me, {single: true, preventDefault: true});
  }
}, processRawValue: function(value) {
  var me = this, stripRe = me.stripCharsRe, newValue;
  if (stripRe) 
  {
    newValue = value.replace(stripRe, '');
    if (newValue !== value) 
    {
      me.setRawValue(newValue);
      value = newValue;
    }
  }
  return value;
}, onDisable: function() {
  this.callParent();
  if (Ext.isIE) 
  {
    this.inputEl.dom.unselectable = 'on';
  }
}, onEnable: function() {
  this.callParent();
  if (Ext.isIE) 
  {
    this.inputEl.dom.unselectable = '';
  }
}, onKeyDown: function(e) {
  this.fireEvent('keydown', this, e);
}, onKeyUp: function(e) {
  this.fireEvent('keyup', this, e);
}, onKeyPress: function(e) {
  this.fireEvent('keypress', this, e);
}, reset: function() {
  this.callParent();
  this.applyEmptyText();
}, applyEmptyText: function() {
  var me = this, emptyText = me.emptyText, isEmpty;
  if (me.rendered && emptyText) 
  {
    isEmpty = me.getRawValue().length < 1 && !me.hasFocus;
    if (Ext.supports.Placeholder) 
    {
      me.inputEl.dom.placeholder = emptyText;
    } else if (isEmpty) 
    {
      me.setRawValue(emptyText);
      me.valueContainsPlaceholder = true;
    }
    if (isEmpty) 
    {
      me.inputEl.addCls(me.emptyCls);
    }
    me.autoSize();
  }
}, afterFirstLayout: function() {
  this.callParent();
  if (Ext.isIE && this.disabled) 
  {
    var el = this.inputEl;
    if (el) 
    {
      el.dom.unselectable = 'on';
    }
  }
}, beforeFocus: function() {
  var me = this, inputEl = me.inputEl, emptyText = me.emptyText, isEmpty;
  me.callParent(arguments);
  if ((emptyText && !Ext.supports.Placeholder) && (inputEl.dom.value === me.emptyText && me.valueContainsPlaceholder)) 
  {
    me.setRawValue('');
    isEmpty = true;
    inputEl.removeCls(me.emptyCls);
    me.valueContainsPlaceholder = false;
  } else if (Ext.supports.Placeholder) 
  {
    inputEl.removeCls(me.emptyCls);
  }
  if (me.selectOnFocus || isEmpty) 
  {
    if (Ext.isWebKit) 
    {
      if (!me.inputFocusTask) 
      {
        me.inputFocusTask = new Ext.util.DelayedTask(me.focusInput, me);
      }
      me.inputFocusTask.delay(1);
    } else {
      me.focusInput();
    }
  }
}, focusInput: function() {
  var input = this.inputEl;
  if (input) 
  {
    input = input.dom;
    if (input) 
    {
      input.select();
    }
  }
}, onFocus: function() {
  var me = this;
  me.callParent(arguments);
  if (me.emptyText) 
  {
    me.autoSize();
  }
}, postBlur: function() {
  var task = this.inputFocusTask;
  this.callParent(arguments);
  this.applyEmptyText();
  if (task) 
  {
    task.cancel();
  }
}, filterKeys: function(e) {
  if (e.ctrlKey && !e.altKey) 
  {
    return;
  }
  var key = e.getKey(), charCode = String.fromCharCode(e.getCharCode());
  if ((Ext.isGecko || Ext.isOpera) && (e.isNavKeyPress() || key === e.BACKSPACE || (key === e.DELETE && e.button === -1))) 
  {
    return;
  }
  if ((!Ext.isGecko && !Ext.isOpera) && e.isSpecialKey() && !charCode) 
  {
    return;
  }
  if (!this.maskRe.test(charCode)) 
  {
    e.stopEvent();
  }
}, getState: function() {
  return this.addPropertyToState(this.callParent(), 'value');
}, applyState: function(state) {
  this.callParent(arguments);
  if (state.hasOwnProperty('value')) 
  {
    this.setValue(state.value);
  }
}, getRawValue: function() {
  var me = this, v = me.callParent();
  if (v === me.emptyText && me.valueContainsPlaceholder) 
  {
    v = '';
  }
  return v;
}, setValue: function(value) {
  var me = this, inputEl = me.inputEl;
  if (inputEl && me.emptyText && !Ext.isEmpty(value)) 
  {
    inputEl.removeCls(me.emptyCls);
    me.valueContainsPlaceholder = false;
  }
  me.callParent(arguments);
  me.applyEmptyText();
  return me;
}, getErrors: function(value) {
  var me = this, errors = me.callParent(arguments), validator = me.validator, vtype = me.vtype, vtypes = Ext.form.field.VTypes, regex = me.regex, format = Ext.String.format, msg, trimmed, isBlank;
  value = value || me.processRawValue(me.getRawValue());
  if (Ext.isFunction(validator)) 
  {
    msg = validator.call(me, value);
    if (msg !== true) 
    {
      errors.push(msg);
    }
  }
  trimmed = me.allowOnlyWhitespace ? value : Ext.String.trim(value);
  if (trimmed.length < 1 || (value === me.emptyText && me.valueContainsPlaceholder)) 
  {
    if (!me.allowBlank) 
    {
      errors.push(me.blankText);
    }
    if (!me.validateBlank) 
    {
      return errors;
    }
    isBlank = true;
  }
  if (!isBlank && value.length < me.minLength) 
  {
    errors.push(format(me.minLengthText, me.minLength));
  }
  if (value.length > me.maxLength) 
  {
    errors.push(format(me.maxLengthText, me.maxLength));
  }
  if (vtype) 
  {
    if (!vtypes[vtype](value, me)) 
    {
      errors.push(me.vtypeText || vtypes[vtype + 'Text']);
    }
  }
  if (regex && !regex.test(value)) 
  {
    errors.push(me.regexText || me.invalidText);
  }
  return errors;
}, selectText: function(start, end) {
  var me = this, v = me.getRawValue(), doFocus = true, el = me.inputEl.dom, undef, range;
  if (v.length > 0) 
  {
    start = start === undef ? 0 : start;
    end = end === undef ? v.length : end;
    if (el.setSelectionRange) 
    {
      el.setSelectionRange(start, end);
    } else if (el.createTextRange) 
    {
      range = el.createTextRange();
      range.moveStart('character', start);
      range.moveEnd('character', end - v.length);
      range.select();
    }
    doFocus = Ext.isGecko || Ext.isOpera;
  }
  if (doFocus) 
  {
    me.focus();
  }
}, autoSize: function() {
  var me = this;
  if (me.grow && me.rendered) 
  {
    me.autoSizing = true;
    me.updateLayout();
  }
}, afterComponentLayout: function() {
  var me = this, width;
  me.callParent(arguments);
  if (me.autoSizing) 
  {
    width = me.inputEl.getWidth();
    if (width !== me.lastInputWidth) 
    {
      me.fireEvent('autosize', me, width);
      me.lastInputWidth = width;
      delete me.autoSizing;
    }
  }
}, onDestroy: function() {
  var me = this;
  me.callParent();
  if (me.inputFocusTask) 
  {
    me.inputFocusTask.cancel();
    me.inputFocusTask = null;
  }
}}, 0, ["textfield"], ["component", "field", "textfield", "box"], {"component": true, "field": true, "textfield": true, "box": true}, ["widget.textfield"], 0, [Ext.form.field, 'Text', Ext.form, 'TextField', Ext.form, 'Text'], 0));
;

(Ext.cmd.derive('Ext.layout.component.field.TextArea', Ext.layout.component.field.Text, {type: 'textareafield', canGrowWidth: false, naturalSizingProp: 'cols', beginLayout: function(ownerContext) {
  this.callParent(arguments);
  ownerContext.target.inputEl.setStyle('height', '');
}, measureContentHeight: function(ownerContext) {
  var me = this, owner = me.owner, height = me.callParent(arguments), inputContext, inputEl, value, max, curWidth, calcHeight;
  if (owner.grow && !ownerContext.state.growHandled) 
  {
    inputContext = ownerContext.inputContext;
    inputEl = owner.inputEl;
    curWidth = inputEl.getWidth(true);
    value = Ext.util.Format.htmlEncode(inputEl.dom.value) || '&#160;';
    value += owner.growAppend;
    value = value.replace(/\n/g, '<br/>');
    calcHeight = Ext.util.TextMetrics.measure(inputEl, value, curWidth).height + inputContext.getBorderInfo().height + inputContext.getPaddingInfo().height;
    calcHeight = Ext.Number.constrain(calcHeight, owner.growMin, owner.growMax);
    inputContext.setHeight(calcHeight);
    ownerContext.state.growHandled = true;
    inputContext.domBlock(me, 'height');
    height = NaN;
  }
  return height;
}}, 0, 0, 0, 0, ["layout.textareafield"], 0, [Ext.layout.component.field, 'TextArea'], 0));
;

(Ext.cmd.derive('Ext.form.field.TextArea', Ext.form.field.Text, {alternateClassName: 'Ext.form.TextArea', fieldSubTpl: ['<textarea id="{id}" role="{role}" {inputAttrTpl}', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="rows"> rows="{rows}" </tpl>', '<tpl if="cols"> cols="{cols}" </tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '<tpl if="size"> size="{size}"</tpl>', '<tpl if="maxLength !== undefined"> maxlength="{maxLength}"</tpl>', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', ' class="{fieldCls} {typeCls} {inputCls}" ', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' autocomplete="off">\n', '<tpl if="value">{[Ext.util.Format.htmlEncode(values.value)]}</tpl>', '</textarea>', {disableFormats: true}], growMin: 60, growMax: 1000, growAppend: '\n-', cols: 20, rows: 4, enterIsSpecial: false, preventScrollbars: false, componentLayout: 'textareafield', setGrowSizePolicy: Ext.emptyFn, returnRe: /\r/g, inputCls: Ext.baseCSSPrefix + 'form-textarea', getSubTplData: function() {
  var me = this, fieldStyle = me.getFieldStyle(), ret = me.callParent();
  if (me.grow) 
  {
    if (me.preventScrollbars) 
    {
      ret.fieldStyle = (fieldStyle || '') + ';overflow:hidden;height:' + me.growMin + 'px';
    }
  }
  Ext.applyIf(ret, {cols: me.cols, rows: me.rows});
  return ret;
}, afterRender: function() {
  var me = this;
  me.callParent(arguments);
  me.needsMaxCheck = me.enforceMaxLength && me.maxLength !== Number.MAX_VALUE && !Ext.supports.TextAreaMaxLength;
  if (me.needsMaxCheck) 
  {
    me.inputEl.on('paste', me.onPaste, me);
  }
}, transformRawValue: function(value) {
  return this.stripReturns(value);
}, transformOriginalValue: function(value) {
  return this.stripReturns(value);
}, getValue: function() {
  return this.stripReturns(this.callParent());
}, valueToRaw: function(value) {
  value = this.stripReturns(value);
  return this.callParent([value]);
}, stripReturns: function(value) {
  if (value && typeof value === 'string') 
  {
    value = value.replace(this.returnRe, '');
  }
  return value;
}, onPaste: function(e) {
  var me = this;
  if (!me.pasteTask) 
  {
    me.pasteTask = new Ext.util.DelayedTask(me.pasteCheck, me);
  }
  me.pasteTask.delay(1);
}, pasteCheck: function() {
  var me = this, value = me.getValue(), max = me.maxLength;
  if (value.length > max) 
  {
    value = value.substr(0, max);
    me.setValue(value);
  }
}, fireKey: function(e) {
  var me = this, key = e.getKey(), value;
  if (e.isSpecialKey() && (me.enterIsSpecial || (key !== e.ENTER || e.hasModifier()))) 
  {
    me.fireEvent('specialkey', me, e);
  }
  if (me.needsMaxCheck && key !== e.BACKSPACE && key !== e.DELETE && !e.isNavKeyPress() && !me.isCutCopyPasteSelectAll(e, key)) 
  {
    value = me.getValue();
    if (value.length >= me.maxLength) 
    {
      e.stopEvent();
    }
  }
}, isCutCopyPasteSelectAll: function(e, key) {
  if (e.ctrlKey) 
  {
    return key === e.A || key === e.C || key === e.V || key === e.X;
  }
  return false;
}, autoSize: function() {
  var me = this, height;
  if (me.grow && me.rendered) 
  {
    me.updateLayout();
    height = me.inputEl.getHeight();
    if (height !== me.lastInputHeight) 
    {
      me.fireEvent('autosize', me, height);
      me.lastInputHeight = height;
    }
  }
}, beforeDestroy: function() {
  var task = this.pasteTask;
  if (task) 
  {
    task.cancel();
    this.pasteTask = null;
  }
  this.callParent();
}}, 0, ["textarea", "textareafield"], ["component", "field", "textfield", "textarea", "box", "textareafield"], {"component": true, "field": true, "textfield": true, "textarea": true, "box": true, "textareafield": true}, ["widget.textarea", "widget.textareafield"], 0, [Ext.form.field, 'TextArea', Ext.form, 'TextArea'], 0));
;

(Ext.cmd.derive('Ext.form.field.Display', Ext.form.field.Base, {alternateClassName: ['Ext.form.DisplayField', 'Ext.form.Display'], ariaRole: 'textbox', fieldSubTpl: ['<div id="{id}" role="{role}" {inputAttrTpl}', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', ' class="{fieldCls}">{value}</div>', {compiled: true, disableFormats: true}], readOnly: true, fieldCls: Ext.baseCSSPrefix + 'form-display-field', fieldBodyCls: Ext.baseCSSPrefix + 'form-display-field-body', htmlEncode: false, noWrap: false, validateOnChange: false, initEvents: Ext.emptyFn, submitValue: false, valueToRaw: function(value) {
  if (!value && value !== 0) 
  {
    return '';
  } else {
    return value;
  }
}, isDirty: function() {
  return false;
}, isValid: function() {
  return true;
}, validate: function() {
  return true;
}, getRawValue: function() {
  return this.rawValue;
}, setRawValue: function(value) {
  var me = this;
  value = Ext.value(value, '');
  me.rawValue = value;
  if (me.rendered) 
  {
    me.inputEl.dom.innerHTML = me.getDisplayValue();
    me.updateLayout();
  }
  return value;
}, getDisplayValue: function() {
  var me = this, value = this.getRawValue(), display;
  if (me.renderer) 
  {
    display = me.renderer.call(me.scope || me, value, me);
  } else {
    display = me.htmlEncode ? Ext.util.Format.htmlEncode(value) : value;
  }
  return display;
}, getSubTplData: function() {
  var ret = this.callParent(arguments);
  ret.value = this.getDisplayValue();
  return ret;
}}, 0, ["displayfield"], ["component", "field", "box", "displayfield"], {"component": true, "field": true, "box": true, "displayfield": true}, ["widget.displayfield"], 0, [Ext.form.field, 'Display', Ext.form, 'DisplayField', Ext.form, 'Display'], 0));
;

(Ext.cmd.derive('Ext.layout.container.Anchor', Ext.layout.container.Auto, {alternateClassName: 'Ext.layout.AnchorLayout', type: 'anchor', defaultAnchor: '100%', parseAnchorRE: /^(r|right|b|bottom)$/i, manageOverflow: true, beginLayoutCycle: function(ownerContext) {
  var me = this, dimensions = 0, anchorSpec, childContext, childItems, i, length, target;
  me.callParent(arguments);
  childItems = ownerContext.childItems;
  length = childItems.length;
  for (i = 0; i < length; ++i) 
    {
      childContext = childItems[i];
      anchorSpec = childContext.target.anchorSpec;
      if (anchorSpec) 
      {
        if (childContext.widthModel.calculated && anchorSpec.right) 
        {
          dimensions |= 1;
        }
        if (childContext.heightModel.calculated && anchorSpec.bottom) 
        {
          dimensions |= 2;
        }
        if (dimensions == 3) 
        {
          break;
        }
      }
    }
  ownerContext.anchorDimensions = dimensions;
}, calculateItems: function(ownerContext, containerSize) {
  var me = this, childItems = ownerContext.childItems, length = childItems.length, gotHeight = containerSize.gotHeight, gotWidth = containerSize.gotWidth, ownerHeight = containerSize.height, ownerWidth = containerSize.width, knownDimensions = (gotWidth ? 1 : 0) | (gotHeight ? 2 : 0), anchorDimensions = ownerContext.anchorDimensions, anchorSpec, childContext, childMargins, height, i, width;
  if (!anchorDimensions) 
  {
    return true;
  }
  for (i = 0; i < length; i++) 
    {
      childContext = childItems[i];
      childMargins = childContext.getMarginInfo();
      anchorSpec = childContext.target.anchorSpec;
      if (gotWidth && childContext.widthModel.calculated) 
      {
        width = anchorSpec.right(ownerWidth) - childMargins.width;
        width = me.adjustWidthAnchor(width, childContext);
        childContext.setWidth(width);
      }
      if (gotHeight && childContext.heightModel.calculated) 
      {
        height = anchorSpec.bottom(ownerHeight) - childMargins.height;
        height = me.adjustHeightAnchor(height, childContext);
        childContext.setHeight(height);
      }
    }
  return (knownDimensions & anchorDimensions) === anchorDimensions;
}, anchorFactory: {offset: function(delta) {
  return function(v) {
  return v + delta;
};
}, ratio: function(ratio) {
  return function(v) {
  return Math.floor(v * ratio);
};
}, standard: function(diff) {
  return function(v) {
  return v - diff;
};
}}, parseAnchor: function(a, start, cstart) {
  if (a && a != 'none') 
  {
    var factory = this.anchorFactory, delta;
    if (this.parseAnchorRE.test(a)) 
    {
      return factory.standard(cstart - start);
    }
    if (a.indexOf('%') != -1) 
    {
      return factory.ratio(parseFloat(a.replace('%', '')) * 0.01);
    }
    delta = parseInt(a, 10);
    if (!isNaN(delta)) 
    {
      return factory.offset(delta);
    }
  }
  return null;
}, adjustWidthAnchor: function(value, childContext) {
  return value;
}, adjustHeightAnchor: function(value, childContext) {
  return value;
}, configureItem: function(item) {
  var me = this, owner = me.owner, anchor = item.anchor, anchorsArray, anchorWidth, anchorHeight;
  me.callParent(arguments);
  if (!item.anchor && item.items && !Ext.isNumber(item.width) && !(Ext.isIE6 && Ext.isStrict)) 
  {
    item.anchor = anchor = me.defaultAnchor;
  }
  if (owner.anchorSize) 
  {
    if (typeof owner.anchorSize == 'number') 
    {
      anchorWidth = owner.anchorSize;
    } else {
      anchorWidth = owner.anchorSize.width;
      anchorHeight = owner.anchorSize.height;
    }
  } else {
    anchorWidth = owner.initialConfig.width;
    anchorHeight = owner.initialConfig.height;
  }
  if (anchor) 
  {
    anchorsArray = anchor.split(' ');
    item.anchorSpec = {right: me.parseAnchor(anchorsArray[0], item.initialConfig.width, anchorWidth), bottom: me.parseAnchor(anchorsArray[1], item.initialConfig.height, anchorHeight)};
  }
}, sizePolicy: {$: {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0}, b: {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1}, r: {$: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0}, b: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1}}}, getItemSizePolicy: function(item) {
  var anchorSpec = item.anchorSpec, key = '$', policy = this.sizePolicy, sizeModel;
  if (anchorSpec) 
  {
    sizeModel = this.owner.getSizeModel();
    if (anchorSpec.right && !sizeModel.width.shrinkWrap) 
    {
      policy = policy.r;
    }
    if (anchorSpec.bottom && !sizeModel.height.shrinkWrap) 
    {
      key = 'b';
    }
  }
  return policy[key];
}}, 0, 0, 0, 0, ["layout.anchor"], 0, [Ext.layout.container, 'Anchor', Ext.layout, 'AnchorLayout'], 0));
;

(Ext.cmd.derive('Ext.window.MessageBox', Ext.window.Window, {OK: 1, YES: 2, NO: 4, CANCEL: 8, OKCANCEL: 9, YESNO: 6, YESNOCANCEL: 14, INFO: Ext.baseCSSPrefix + 'message-box-info', WARNING: Ext.baseCSSPrefix + 'message-box-warning', QUESTION: Ext.baseCSSPrefix + 'message-box-question', ERROR: Ext.baseCSSPrefix + 'message-box-error', hideMode: 'offsets', closeAction: 'hide', resizable: false, title: '&#160;', defaultMinWidth: 250, defaultMaxWidth: 600, defaultMinHeight: 110, defaultMaxHeight: 500, minWidth: null, maxWidth: null, minHeight: null, maxHeight: null, constrain: true, cls: [Ext.baseCSSPrefix + 'message-box', Ext.baseCSSPrefix + 'hide-offsets'], layout: {type: 'vbox', align: 'stretch'}, shrinkWrapDock: true, defaultTextHeight: 75, minProgressWidth: 250, minPromptWidth: 250, buttonText: {ok: 'OK', yes: 'Yes', no: 'No', cancel: 'Cancel'}, buttonIds: ['ok', 'yes', 'no', 'cancel'], titleText: {confirm: 'Confirm', prompt: 'Prompt', wait: 'Loading...', alert: 'Attention'}, iconHeight: 35, iconWidth: 50, ariaRole: 'alertdialog', makeButton: function(btnIdx) {
  var btnId = this.buttonIds[btnIdx];
  return new Ext.button.Button({handler: this.btnCallback, itemId: btnId, scope: this, text: this.buttonText[btnId], minWidth: 75});
}, btnCallback: function(btn) {
  var me = this, value, field;
  if (me.cfg.prompt || me.cfg.multiline) 
  {
    if (me.cfg.multiline) 
    {
      field = me.textArea;
    } else {
      field = me.textField;
    }
    value = field.getValue();
    field.reset();
  }
  me.hide();
  me.userCallback(btn.itemId, value, me.cfg);
}, hide: function() {
  var me = this, cls = me.cfg ? me.cfg.cls : '';
  me.progressBar.reset();
  if (cls) 
  {
    me.removeCls(cls);
  }
  me.callParent(arguments);
}, constructor: function(cfg) {
  var me = this;
  me.callParent(arguments);
  me.minWidth = me.defaultMinWidth = (me.minWidth || me.defaultMinWidth);
  me.maxWidth = me.defaultMaxWidth = (me.maxWidth || me.defaultMaxWidth);
  me.minHeight = me.defaultMinHeight = (me.minHeight || me.defaultMinHeight);
  me.maxHeight = me.defaultMaxHeight = (me.maxHeight || me.defaultMaxHeight);
}, initComponent: function(cfg) {
  var me = this, baseId = me.id, i, button;
  me.title = me.title || '&#160;';
  me.iconCls = me.iconCls || '';
  me.topContainer = new Ext.container.Container({layout: 'hbox', padding: 10, style: {overflow: 'hidden'}, items: [me.iconComponent = new Ext.Component({width: me.iconWidth, height: me.iconHeight}), me.promptContainer = new Ext.container.Container({flex: 1, layout: 'anchor', items: [me.msg = new Ext.form.field.Display({id: baseId + '-displayfield', cls: me.baseCls + '-text'}), me.textField = new Ext.form.field.Text({id: baseId + '-textfield', anchor: '100%', enableKeyEvents: true, listeners: {keydown: me.onPromptKey, scope: me}}), me.textArea = new Ext.form.field.TextArea({id: baseId + '-textarea', anchor: '100%', height: 75})]})]});
  me.progressBar = new Ext.ProgressBar({id: baseId + '-progressbar', margin: '0 10 10 10'});
  me.items = [me.topContainer, me.progressBar];
  me.msgButtons = [];
  for (i = 0; i < 4; i++) 
    {
      button = me.makeButton(i);
      me.msgButtons[button.itemId] = button;
      me.msgButtons.push(button);
    }
  me.bottomTb = new Ext.toolbar.Toolbar({id: baseId + '-toolbar', ui: 'footer', dock: 'bottom', layout: {pack: 'center'}, items: [me.msgButtons[0], me.msgButtons[1], me.msgButtons[2], me.msgButtons[3]]});
  me.dockedItems = [me.bottomTb];
  me.on('close', me.onClose, me);
  me.callParent();
}, onClose: function() {
  var btn = this.header.child('[type=close]');
  btn.itemId = 'cancel';
  this.btnCallback(btn);
  delete btn.itemId;
}, onPromptKey: function(textField, e) {
  var me = this;
  if (e.keyCode === e.RETURN || e.keyCode === 10) 
  {
    if (me.msgButtons.ok.isVisible()) 
    {
      me.msgButtons.ok.handler.call(me, me.msgButtons.ok);
    } else if (me.msgButtons.yes.isVisible()) 
    {
      me.msgButtons.yes.handler.call(me, me.msgButtons.yes);
    }
  }
}, reconfigure: function(cfg) {
  var me = this, buttons = 0, hideToolbar = true, oldButtonText = me.buttonText, resizer = me.resizer, header = me.header, headerCfg = header && !header.isHeader, resizeTracker, title, width, height, i, textArea, textField, msg, progressBar, msgButtons;
  me.updateButtonText();
  cfg = cfg || {};
  me.cfg = cfg;
  if (cfg.width) 
  {
    width = cfg.width;
  }
  if (cfg.height) 
  {
    height = cfg.height;
  }
  me.minWidth = cfg.minWidth || me.defaultMinWidth;
  me.maxWidth = cfg.maxWidth || me.defaultMaxWidth;
  me.minHeight = cfg.minHeight || me.defaultMinHeight;
  me.maxHeight = cfg.maxHeight || me.defaultMaxHeight;
  if (resizer) 
  {
    resizeTracker = resizer.resizeTracker;
    resizer.minWidth = resizeTracker.minWidth = me.minWidth;
    resizer.maxWidth = resizeTracker.maxWidth = me.maxWidth;
    resizer.minHeight = resizeTracker.minHeight = me.minHeight;
    resizer.maxHeight = resizeTracker.maxHeight = me.maxHeight;
  }
  delete me.defaultFocus;
  if (cfg.defaultFocus) 
  {
    me.defaultFocus = cfg.defaultFocus;
  }
  me.animateTarget = cfg.animateTarget || undefined;
  me.modal = cfg.modal !== false;
  me.setTitle(cfg.title || (headerCfg && header.title) || me.title);
  me.setIconCls(cfg.iconCls || (headerCfg && header.iconCls) || me.iconCls);
  if (Ext.isObject(cfg.buttons)) 
  {
    me.buttonText = cfg.buttons;
    buttons = 0;
  } else {
    me.buttonText = cfg.buttonText || me.buttonText;
    buttons = Ext.isNumber(cfg.buttons) ? cfg.buttons : 0;
  }
  buttons = buttons | me.updateButtonText();
  me.buttonText = oldButtonText;
  Ext.suspendLayouts();
  delete me.width;
  delete me.height;
  if (width || height) 
  {
    if (width) 
    {
      me.setWidth(width);
    }
    if (height) 
    {
      me.setHeight(height);
    }
  }
  me.hidden = false;
  if (!me.rendered) 
  {
    me.render(Ext.getBody());
  }
  me.closable = cfg.closable !== false && !cfg.wait;
  header = me.header;
  if (header) 
  {
    header.child('[type=close]').setVisible(me.closable);
    if (!cfg.title && !me.closable && !cfg.iconCls) 
    {
      header.hide();
    } else {
      header.show();
    }
  }
  me.liveDrag = !cfg.proxyDrag;
  me.userCallback = Ext.Function.bind(cfg.callback || cfg.fn || Ext.emptyFn, cfg.scope || Ext.global);
  me.setIcon(cfg.icon, cfg.iconWidth, cfg.iconHeight);
  msg = me.msg;
  if (cfg.msg) 
  {
    msg.setValue(cfg.msg);
    msg.show();
  } else {
    msg.hide();
  }
  textArea = me.textArea;
  textField = me.textField;
  if (cfg.prompt || cfg.multiline) 
  {
    me.multiline = cfg.multiline;
    if (cfg.multiline) 
    {
      textArea.setValue(cfg.value);
      textArea.setHeight(cfg.defaultTextHeight || me.defaultTextHeight);
      textArea.show();
      textField.hide();
      me.defaultFocus = textArea;
    } else {
      textField.setValue(cfg.value);
      textArea.hide();
      textField.show();
      me.defaultFocus = textField;
    }
  } else {
    textArea.hide();
    textField.hide();
  }
  progressBar = me.progressBar;
  if (cfg.progress || cfg.wait) 
  {
    progressBar.show();
    me.updateProgress(0, cfg.progressText);
    if (cfg.wait === true) 
    {
      progressBar.wait(cfg.waitConfig);
    }
  } else {
    progressBar.hide();
  }
  msgButtons = me.msgButtons;
  for (i = 0; i < 4; i++) 
    {
      if (buttons & Math.pow(2, i)) 
      {
        if (!me.defaultFocus) 
        {
          me.defaultFocus = msgButtons[i];
        }
        msgButtons[i].show();
        hideToolbar = false;
      } else {
        msgButtons[i].hide();
      }
    }
  if (hideToolbar) 
  {
    me.bottomTb.hide();
  } else {
    me.bottomTb.show();
  }
  Ext.resumeLayouts(true);
}, updateButtonText: function() {
  var me = this, buttonText = me.buttonText, buttons = 0, btnId, btn;
  for (btnId in buttonText) 
    {
      if (buttonText.hasOwnProperty(btnId)) 
      {
        btn = me.msgButtons[btnId];
        if (btn) 
        {
          if (me.cfg && me.cfg.buttonText) 
          {
            buttons = buttons | Math.pow(2, Ext.Array.indexOf(me.buttonIds, btnId));
          }
          if (btn.text != buttonText[btnId]) 
          {
            btn.setText(buttonText[btnId]);
          }
        }
      }
    }
  return buttons;
}, show: function(cfg) {
  var me = this, visibleFocusables;
  cfg = cfg || {};
  if (Ext.AbstractComponent.layoutSuspendCount) 
  {
    Ext.on({resumelayouts: function() {
  me.show(cfg);
}, single: true});
    return me;
  }
  me.reconfigure(cfg);
  if (cfg.cls) 
  {
    me.addCls(cfg.cls);
  }
  visibleFocusables = me.query('textfield:not([hidden]),textarea:not([hidden]),button:not([hidden])');
  me.preventFocusOnActivate = !visibleFocusables.length;
  me.hidden = true;
  me.callParent();
  return me;
}, onShow: function() {
  this.callParent(arguments);
  this.center();
}, updateText: function(text) {
  this.msg.setValue(text);
}, setIcon: function(icon, width, height) {
  var me = this, iconCmp = me.iconComponent, cls = me.messageIconCls;
  if (cls) 
  {
    iconCmp.removeCls(cls);
  }
  if (icon) 
  {
    iconCmp.show();
    iconCmp.setSize(width || me.iconWidth, height || me.iconHeight);
    iconCmp.addCls(Ext.baseCSSPrefix + 'dlg-icon');
    iconCmp.addCls(me.messageIconCls = icon);
  } else {
    iconCmp.removeCls(Ext.baseCSSPrefix + 'dlg-icon');
    iconCmp.hide();
  }
  return me;
}, updateProgress: function(value, progressText, msg) {
  this.progressBar.updateProgress(value, progressText);
  if (msg) 
  {
    this.updateText(msg);
  }
  return this;
}, onEsc: function() {
  if (this.closable !== false) 
  {
    this.callParent(arguments);
  }
}, confirm: function(cfg, msg, fn, scope) {
  if (Ext.isString(cfg)) 
  {
    cfg = {title: cfg, icon: this.QUESTION, msg: msg, buttons: this.YESNO, callback: fn, scope: scope};
  }
  return this.show(cfg);
}, prompt: function(cfg, msg, fn, scope, multiline, value) {
  if (Ext.isString(cfg)) 
  {
    cfg = {prompt: true, title: cfg, minWidth: this.minPromptWidth, msg: msg, buttons: this.OKCANCEL, callback: fn, scope: scope, multiline: multiline, value: value};
  }
  return this.show(cfg);
}, wait: function(cfg, title, config) {
  if (Ext.isString(cfg)) 
  {
    cfg = {title: title, msg: cfg, closable: false, wait: true, modal: true, minWidth: this.minProgressWidth, waitConfig: config};
  }
  return this.show(cfg);
}, alert: function(cfg, msg, fn, scope) {
  if (Ext.isString(cfg)) 
  {
    cfg = {title: cfg, msg: msg, buttons: this.OK, fn: fn, scope: scope, minWidth: this.minWidth};
  }
  return this.show(cfg);
}, progress: function(cfg, msg, progressText) {
  if (Ext.isString(cfg)) 
  {
    cfg = {title: cfg, msg: msg, progress: true, progressText: progressText};
  }
  return this.show(cfg);
}}, 1, ["messagebox"], ["container", "component", "box", "window", "panel", "messagebox"], {"container": true, "component": true, "box": true, "window": true, "panel": true, "messagebox": true}, ["widget.messagebox"], 0, [Ext.window, 'MessageBox'], function() {
  Ext.MessageBox = Ext.Msg = new this();
}));
;

(Ext.cmd.derive('Ext.form.Basic', Ext.util.Observable, {alternateClassName: 'Ext.form.BasicForm', taskDelay: 10, constructor: function(owner, config) {
  var me = this, reader;
  me.owner = owner;
  me.checkValidityTask = new Ext.util.DelayedTask(me.checkValidity, me);
  me.checkDirtyTask = new Ext.util.DelayedTask(me.checkDirty, me);
  me.monitor = new Ext.container.Monitor({selector: '[isFormField]:not([excludeForm])', scope: me, addHandler: me.onFieldAdd, removeHandler: me.onFieldRemove, invalidateHandler: me.onMonitorInvalidate});
  me.monitor.bind(owner);
  Ext.apply(me, config);
  if (Ext.isString(me.paramOrder)) 
  {
    me.paramOrder = me.paramOrder.split(/[\s,|]/);
  }
  reader = me.reader;
  if (reader && !reader.isReader) 
  {
    if (typeof reader === 'string') 
    {
      reader = {type: reader};
    }
    me.reader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  reader = me.errorReader;
  if (reader && !reader.isReader) 
  {
    if (typeof reader === 'string') 
    {
      reader = {type: reader};
    }
    me.errorReader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  me.addEvents('beforeaction', 'actionfailed', 'actioncomplete', 'validitychange', 'dirtychange');
  me.callParent();
}, initialize: function() {
  this.initialized = true;
  this.onValidityChange(!this.hasInvalidField());
}, timeout: 30, paramsAsHash: false, waitTitle: 'Please Wait...', trackResetOnLoad: false, wasDirty: false, destroy: function() {
  var me = this, mon = me.monitor;
  if (mon) 
  {
    mon.unbind();
    me.monitor = null;
  }
  me.clearListeners();
  me.checkValidityTask.cancel();
  me.checkDirtyTask.cancel();
  me.isDestroyed = true;
}, onFieldAdd: function(field) {
  var me = this;
  me.mon(field, 'validitychange', me.checkValidityDelay, me);
  me.mon(field, 'dirtychange', me.checkDirtyDelay, me);
  me.onMonitorInvalidate();
}, onFieldRemove: function(field) {
  var me = this;
  me.mun(field, 'validitychange', me.checkValidityDelay, me);
  me.mun(field, 'dirtychange', me.checkDirtyDelay, me);
  me.onMonitorInvalidate();
}, onMonitorInvalidate: function() {
  if (this.initialized) 
  {
    this.checkValidityDelay();
  }
}, getFields: function() {
  return this.monitor.getItems();
}, getBoundItems: function() {
  var boundItems = this._boundItems;
  if (!boundItems || boundItems.getCount() === 0) 
  {
    boundItems = this._boundItems = new Ext.util.MixedCollection();
    boundItems.addAll(this.owner.query('[formBind]'));
  }
  return boundItems;
}, hasInvalidField: function() {
  return !!this.getFields().findBy(function(field) {
  var preventMark = field.preventMark, isValid;
  field.preventMark = true;
  isValid = field.isValid();
  field.preventMark = preventMark;
  return !isValid;
});
}, isValid: function() {
  var me = this, invalid;
  Ext.suspendLayouts();
  invalid = me.getFields().filterBy(function(field) {
  return !field.validate();
});
  Ext.resumeLayouts(true);
  return invalid.length < 1;
}, checkValidity: function() {
  var me = this, valid;
  if (me.isDestroyed) 
  {
    return;
  }
  valid = !me.hasInvalidField();
  if (valid !== me.wasValid) 
  {
    me.onValidityChange(valid);
    me.fireEvent('validitychange', me, valid);
    me.wasValid = valid;
  }
}, checkValidityDelay: function() {
  var timer = this.taskDelay;
  if (timer) 
  {
    this.checkValidityTask.delay(timer);
  } else {
    this.checkValidity();
  }
}, onValidityChange: function(valid) {
  var boundItems = this.getBoundItems(), items, i, iLen, cmp;
  if (boundItems) 
  {
    items = boundItems.items;
    iLen = items.length;
    for (i = 0; i < iLen; i++) 
      {
        cmp = items[i];
        if (cmp.disabled === valid) 
        {
          cmp.setDisabled(!valid);
        }
      }
  }
}, isDirty: function() {
  return !!this.getFields().findBy(function(f) {
  return f.isDirty();
});
}, checkDirtyDelay: function() {
  var timer = this.taskDelay;
  if (timer) 
  {
    this.checkDirtyTask.delay(timer);
  } else {
    this.checkDirty();
  }
}, checkDirty: function() {
  var me = this, dirty;
  if (me.isDestroyed) 
  {
    return;
  }
  dirty = this.isDirty();
  if (dirty !== this.wasDirty) 
  {
    this.fireEvent('dirtychange', this, dirty);
    this.wasDirty = dirty;
  }
}, hasUpload: function() {
  return !!this.getFields().findBy(function(f) {
  return f.isFileUpload();
});
}, doAction: function(action, options) {
  if (Ext.isString(action)) 
  {
    action = Ext.ClassManager.instantiateByAlias('formaction.' + action, Ext.apply({}, options, {form: this}));
  }
  if (this.fireEvent('beforeaction', this, action) !== false) 
  {
    this.beforeAction(action);
    Ext.defer(action.run, 100, action);
  }
  return this;
}, submit: function(options) {
  options = options || {};
  var me = this, action;
  if (options.standardSubmit || me.standardSubmit) 
  {
    action = 'standardsubmit';
  } else {
    action = me.api ? 'directsubmit' : 'submit';
  }
  return me.doAction(action, options);
}, load: function(options) {
  return this.doAction(this.api ? 'directload' : 'load', options);
}, updateRecord: function(record) {
  record = record || this._record;
  if (!record) 
  {
    return this;
  }
  var fields = record.fields.items, values = this.getFieldValues(), obj = {}, i = 0, len = fields.length, name;
  for (; i < len; ++i) 
    {
      name = fields[i].name;
      if (values.hasOwnProperty(name)) 
      {
        obj[name] = values[name];
      }
    }
  record.beginEdit();
  record.set(obj);
  record.endEdit();
  return this;
}, loadRecord: function(record) {
  this._record = record;
  return this.setValues(record.getData());
}, getRecord: function() {
  return this._record;
}, beforeAction: function(action) {
  var me = this, waitMsg = action.waitMsg, maskCls = Ext.baseCSSPrefix + 'mask-loading', fields = me.getFields().items, f, fLen = fields.length, field, waitMsgTarget;
  for (f = 0; f < fLen; f++) 
    {
      field = fields[f];
      if (field.isFormField && field.syncValue) 
      {
        field.syncValue();
      }
    }
  if (waitMsg) 
  {
    waitMsgTarget = me.waitMsgTarget;
    if (waitMsgTarget === true) 
    {
      me.owner.el.mask(waitMsg, maskCls);
    } else if (waitMsgTarget) 
    {
      waitMsgTarget = me.waitMsgTarget = Ext.get(waitMsgTarget);
      waitMsgTarget.mask(waitMsg, maskCls);
    } else {
      me.floatingAncestor = me.owner.up('[floating]');
      if (me.floatingAncestor) 
      {
        me.savePreventFocusOnActivate = me.floatingAncestor.preventFocusOnActivate;
        me.floatingAncestor.preventFocusOnActivate = true;
      }
      Ext.MessageBox.wait(waitMsg, action.waitTitle || me.waitTitle);
    }
  }
}, afterAction: function(action, success) {
  var me = this;
  if (action.waitMsg) 
  {
    var messageBox = Ext.MessageBox, waitMsgTarget = me.waitMsgTarget;
    if (waitMsgTarget === true) 
    {
      me.owner.el.unmask();
    } else if (waitMsgTarget) 
    {
      waitMsgTarget.unmask();
    } else {
      messageBox.hide();
    }
  }
  if (me.floatingAncestor) 
  {
    me.floatingAncestor.preventFocusOnActivate = me.savePreventFocusOnActivate;
  }
  if (success) 
  {
    if (action.reset) 
    {
      me.reset();
    }
    Ext.callback(action.success, action.scope || action, [me, action]);
    me.fireEvent('actioncomplete', me, action);
  } else {
    Ext.callback(action.failure, action.scope || action, [me, action]);
    me.fireEvent('actionfailed', me, action);
  }
}, findField: function(id) {
  return this.getFields().findBy(function(f) {
  return f.id === id || f.name === id || f.dataIndex === id;
});
}, markInvalid: function(errors) {
  var me = this, e, eLen, error, value, key;
  function mark(fieldId, msg) {
    var field = me.findField(fieldId);
    if (field) 
    {
      field.markInvalid(msg);
    }
  }
  if (Ext.isArray(errors)) 
  {
    eLen = errors.length;
    for (e = 0; e < eLen; e++) 
      {
        error = errors[e];
        mark(error.id, error.msg);
      }
  } else if (errors instanceof Ext.data.Errors) 
  {
    eLen = errors.items.length;
    for (e = 0; e < eLen; e++) 
      {
        error = errors.items[e];
        mark(error.field, error.message);
      }
  } else {
    for (key in errors) 
      {
        if (errors.hasOwnProperty(key)) 
        {
          value = errors[key];
          mark(key, value, errors);
        }
      }
  }
  return this;
}, setValues: function(values) {
  var me = this, v, vLen, val, field;
  function setVal(fieldId, val) {
    var field = me.findField(fieldId);
    if (field) 
    {
      field.setValue(val);
      if (me.trackResetOnLoad) 
      {
        field.resetOriginalValue();
      }
    }
  }
  Ext.suspendLayouts();
  if (Ext.isArray(values)) 
  {
    vLen = values.length;
    for (v = 0; v < vLen; v++) 
      {
        val = values[v];
        setVal(val.id, val.value);
      }
  } else {
    Ext.iterate(values, setVal);
  }
  Ext.resumeLayouts(true);
  return this;
}, getValues: function(asString, dirtyOnly, includeEmptyText, useDataValues, isSubmitting) {
  var values = {}, fields = this.getFields().items, fLen = fields.length, isArray = Ext.isArray, field, data, val, bucket, name, f;
  for (f = 0; f < fLen; f++) 
    {
      field = fields[f];
      if (!dirtyOnly || field.isDirty()) 
      {
        data = field[useDataValues ? 'getModelData' : 'getSubmitData'](includeEmptyText, isSubmitting);
        if (Ext.isObject(data)) 
        {
          for (name in data) 
            {
              if (data.hasOwnProperty(name)) 
              {
                val = data[name];
                if (includeEmptyText && val === '') 
                {
                  val = field.emptyText || '';
                }
                if (!field.isRadio) 
                {
                  if (values.hasOwnProperty(name)) 
                  {
                    bucket = values[name];
                    if (!isArray(bucket)) 
                    {
                      bucket = values[name] = [bucket];
                    }
                    if (isArray(val)) 
                    {
                      values[name] = bucket.concat(val);
                    } else {
                      bucket.push(val);
                    }
                  } else {
                    values[name] = val;
                  }
                } else {
                  values[name] = values[name] || val;
                }
              }
            }
        }
      }
    }
  if (asString) 
  {
    values = Ext.Object.toQueryString(values);
  }
  return values;
}, getFieldValues: function(dirtyOnly) {
  return this.getValues(false, dirtyOnly, false, true);
}, clearInvalid: function() {
  Ext.suspendLayouts();
  var me = this, fields = me.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) 
    {
      fields[f].clearInvalid();
    }
  Ext.resumeLayouts(true);
  return me;
}, reset: function(resetRecord) {
  Ext.suspendLayouts();
  var me = this, fields = me.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) 
    {
      fields[f].reset();
    }
  Ext.resumeLayouts(true);
  if (resetRecord === true) 
  {
    delete me._record;
  }
  return me;
}, applyToFields: function(obj) {
  var fields = this.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) 
    {
      Ext.apply(fields[f], obj);
    }
  return this;
}, applyIfToFields: function(obj) {
  var fields = this.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) 
    {
      Ext.applyIf(fields[f], obj);
    }
  return this;
}}, 1, 0, 0, 0, 0, 0, [Ext.form, 'Basic', Ext.form, 'BasicForm'], 0));
;

(Ext.cmd.derive('Ext.form.FieldAncestor', Ext.Base, {xhooks: {initHierarchyState: function(hierarchyState) {
  if (this.fieldDefaults) 
  {
    if (hierarchyState.fieldDefaults) 
    {
      hierarchyState.fieldDefaults = Ext.apply(Ext.Object.chain(hierarchyState.fieldDefaults), this.fieldDefaults);
    } else {
      hierarchyState.fieldDefaults = this.fieldDefaults;
    }
  }
}}, initFieldAncestor: function() {
  var me = this;
  me.addEvents('fieldvaliditychange', 'fielderrorchange');
  me.monitor = new Ext.container.Monitor({scope: me, selector: '[isFormField]:not([excludeForm])', addHandler: me.onChildFieldAdd, removeHandler: me.onChildFieldRemove});
  me.initFieldDefaults();
}, initMonitor: function() {
  this.monitor.bind(this);
}, onChildFieldAdd: function(field) {
  var me = this;
  me.mon(field, 'errorchange', me.handleFieldErrorChange, me);
  me.mon(field, 'validitychange', me.handleFieldValidityChange, me);
}, onChildFieldRemove: function(field) {
  var me = this;
  me.mun(field, 'errorchange', me.handleFieldErrorChange, me);
  me.mun(field, 'validitychange', me.handleFieldValidityChange, me);
}, initFieldDefaults: function() {
  if (!this.fieldDefaults) 
  {
    this.fieldDefaults = {};
  }
}, handleFieldValidityChange: function(field, isValid) {
  var me = this;
  if (field !== me) 
  {
    me.fireEvent('fieldvaliditychange', me, field, isValid);
    me.onFieldValidityChange(field, isValid);
  }
}, handleFieldErrorChange: function(labelable, activeError) {
  var me = this;
  if (labelable !== me) 
  {
    me.fireEvent('fielderrorchange', me, labelable, activeError);
    me.onFieldErrorChange(labelable, activeError);
  }
}, onFieldValidityChange: Ext.emptyFn, onFieldErrorChange: Ext.emptyFn, beforeDestroy: function() {
  this.monitor.unbind();
  this.callParent();
}}, 0, 0, 0, 0, 0, 0, [Ext.form, 'FieldAncestor'], 0));
;

(Ext.cmd.derive('Ext.form.Panel', Ext.panel.Panel, {alternateClassName: ['Ext.FormPanel', 'Ext.form.FormPanel'], layout: 'anchor', ariaRole: 'form', basicFormConfigs: ['api', 'baseParams', 'errorReader', 'jsonSubmit', 'method', 'paramOrder', 'paramsAsHash', 'reader', 'standardSubmit', 'timeout', 'trackResetOnLoad', 'url', 'waitMsgTarget', 'waitTitle'], initComponent: function() {
  var me = this;
  if (me.frame) 
  {
    me.border = false;
  }
  me.initFieldAncestor();
  me.callParent();
  me.relayEvents(me.form, ['beforeaction', 'actionfailed', 'actioncomplete', 'validitychange', 'dirtychange']);
  if (me.pollForChanges) 
  {
    me.startPolling(me.pollInterval || 500);
  }
}, initItems: function() {
  this.callParent();
  this.initMonitor();
  this.form = this.createForm();
}, afterFirstLayout: function() {
  this.callParent(arguments);
  this.form.initialize();
}, createForm: function() {
  var cfg = {}, props = this.basicFormConfigs, len = props.length, i = 0, prop;
  for (; i < len; ++i) 
    {
      prop = props[i];
      cfg[prop] = this[prop];
    }
  return new Ext.form.Basic(this, cfg);
}, getForm: function() {
  return this.form;
}, loadRecord: function(record) {
  return this.getForm().loadRecord(record);
}, getRecord: function() {
  return this.getForm().getRecord();
}, updateRecord: function(record) {
  return this.getForm().updateRecord(record);
}, getValues: function(asString, dirtyOnly, includeEmptyText, useDataValues) {
  return this.getForm().getValues(asString, dirtyOnly, includeEmptyText, useDataValues);
}, isDirty: function() {
  return this.form.isDirty();
}, isValid: function() {
  return this.form.isValid();
}, hasInvalidField: function() {
  return this.form.hasInvalidField();
}, beforeDestroy: function() {
  this.stopPolling();
  this.form.destroy();
  this.callParent();
}, load: function(options) {
  this.form.load(options);
}, submit: function(options) {
  this.form.submit(options);
}, startPolling: function(interval) {
  this.stopPolling();
  var task = new Ext.util.TaskRunner(interval);
  task.start({interval: 0, run: this.checkChange, scope: this});
  this.pollTask = task;
}, stopPolling: function() {
  var task = this.pollTask;
  if (task) 
  {
    task.stopAll();
    delete this.pollTask;
  }
}, checkChange: function() {
  var fields = this.form.getFields().items, f, fLen = fields.length;
  for (f = 0; f < fLen; f++) 
    {
      fields[f].checkChange();
    }
}}, 0, ["form"], ["container", "component", "form", "box", "panel"], {"container": true, "component": true, "form": true, "box": true, "panel": true}, ["widget.form"], [['fieldAncestor', Ext.form.FieldAncestor]], [Ext.form, 'Panel', Ext, 'FormPanel', Ext.form, 'FormPanel'], 0));
;

(Ext.cmd.derive('Ext.layout.component.field.Trigger', Ext.layout.component.field.Field, {type: 'triggerfield', setWidthInDom: true, borderWidths: {}, beginLayout: function(ownerContext) {
  var me = this, owner = me.owner, flags;
  ownerContext.triggerWrap = ownerContext.getEl('triggerWrap');
  me.callParent(arguments);
  flags = owner.getTriggerStateFlags();
  if (flags != owner.lastTriggerStateFlags) 
  {
    owner.lastTriggerStateFlags = flags;
    me.updateEditState();
  }
}, beginLayoutCycle: function(ownerContext) {
  this.callParent(arguments);
  if (ownerContext.widthModel.shrinkWrap && !this.owner.inputWidth) 
  {
    ownerContext.inputContext.el.setStyle('width', '');
  }
}, beginLayoutFixed: function(ownerContext, width, suffix) {
  var me = this, owner = ownerContext.target, ieInputWidthAdjustment = me.ieInputWidthAdjustment || 0, inputWidth = '100%', triggerWrap = owner.triggerWrap;
  me.callParent(arguments);
  owner.inputCell.setStyle('width', '100%');
  if (ieInputWidthAdjustment) 
  {
    me.adjustIEInputPadding(ownerContext);
    if (suffix === 'px') 
    {
      if (owner.inputWidth) 
      {
        inputWidth = owner.inputWidth - me.getExtraWidth(ownerContext);
      } else {
        inputWidth = width - ieInputWidthAdjustment - me.getExtraWidth(ownerContext);
      }
      inputWidth += 'px';
    }
  }
  owner.inputEl.setStyle('width', inputWidth);
  inputWidth = owner.inputWidth;
  if (inputWidth) 
  {
    triggerWrap.setStyle('width', inputWidth + (ieInputWidthAdjustment) + 'px');
  } else {
    triggerWrap.setStyle('width', width + suffix);
  }
  triggerWrap.setStyle('table-layout', 'fixed');
}, adjustIEInputPadding: function(ownerContext) {
  this.owner.inputCell.setStyle('padding-right', this.ieInputWidthAdjustment + 'px');
}, getExtraWidth: function(ownerContext) {
  var me = this, owner = me.owner, borderWidths = me.borderWidths, ui = owner.ui + owner.triggerEl.getCount();
  if (!(ui in borderWidths)) 
  {
    borderWidths[ui] = ownerContext.triggerWrap.getBorderInfo().width;
  }
  return borderWidths[ui] + owner.getTriggerWidth();
}, beginLayoutShrinkWrap: function(ownerContext) {
  var owner = ownerContext.target, emptyString = '', inputWidth = owner.inputWidth, triggerWrap = owner.triggerWrap;
  this.callParent(arguments);
  if (inputWidth) 
  {
    triggerWrap.setStyle('width', inputWidth + 'px');
    inputWidth = (inputWidth - this.getExtraWidth(ownerContext)) + 'px';
    owner.inputEl.setStyle('width', inputWidth);
    owner.inputCell.setStyle('width', inputWidth);
  } else {
    owner.inputCell.setStyle('width', emptyString);
    owner.inputEl.setStyle('width', emptyString);
    triggerWrap.setStyle('width', emptyString);
    triggerWrap.setStyle('table-layout', 'auto');
  }
}, getTextWidth: function() {
  var me = this, owner = me.owner, inputEl = owner.inputEl, value;
  value = (inputEl.dom.value || (owner.hasFocus ? '' : owner.emptyText) || '') + owner.growAppend;
  return inputEl.getTextWidth(value);
}, publishOwnerWidth: function(ownerContext, width) {
  var owner = this.owner;
  this.callParent(arguments);
  if (!owner.grow && !owner.inputWidth) 
  {
    width -= this.getExtraWidth(ownerContext);
    if (owner.labelAlign != 'top') 
    {
      width -= owner.getLabelWidth();
    }
    ownerContext.inputContext.setWidth(width);
  }
}, publishInnerHeight: function(ownerContext, height) {
  ownerContext.inputContext.setHeight(height - this.measureLabelErrorHeight(ownerContext));
}, measureContentWidth: function(ownerContext) {
  var me = this, owner = me.owner, width = me.callParent(arguments), inputContext = ownerContext.inputContext, calcWidth, max, min;
  if (owner.grow && !ownerContext.state.growHandled) 
  {
    calcWidth = me.getTextWidth() + ownerContext.inputContext.getFrameInfo().width;
    max = owner.growMax;
    min = Math.min(max, width);
    max = Math.max(owner.growMin, max, min);
    calcWidth = Ext.Number.constrain(calcWidth, owner.growMin, max);
    inputContext.setWidth(calcWidth);
    ownerContext.state.growHandled = true;
    inputContext.domBlock(me, 'width');
    width = NaN;
  } else if (!owner.inputWidth) 
  {
    width -= me.getExtraWidth(ownerContext);
  }
  return width;
}, updateEditState: function() {
  var me = this, owner = me.owner, inputEl = owner.inputEl, noeditCls = Ext.baseCSSPrefix + 'trigger-noedit', displayed, readOnly;
  if (me.owner.readOnly) 
  {
    inputEl.addCls(noeditCls);
    readOnly = true;
    displayed = false;
  } else {
    if (me.owner.editable) 
    {
      inputEl.removeCls(noeditCls);
      readOnly = false;
    } else {
      inputEl.addCls(noeditCls);
      readOnly = true;
    }
    displayed = !me.owner.hideTrigger;
  }
  owner.triggerCell.setDisplayed(displayed);
  inputEl.dom.readOnly = readOnly;
}}, 0, 0, 0, 0, ["layout.triggerfield"], 0, [Ext.layout.component.field, 'Trigger'], 0));
;

(Ext.cmd.derive('Ext.form.field.Trigger', Ext.form.field.Text, {alternateClassName: ['Ext.form.TriggerField', 'Ext.form.TwinTriggerField', 'Ext.form.Trigger'], childEls: [{name: 'triggerCell', select: '.' + Ext.baseCSSPrefix + 'trigger-cell'}, {name: 'triggerEl', select: '.' + Ext.baseCSSPrefix + 'form-trigger'}, 'triggerWrap', 'inputCell'], triggerBaseCls: Ext.baseCSSPrefix + 'form-trigger', triggerWrapCls: Ext.baseCSSPrefix + 'form-trigger-wrap', triggerNoEditCls: Ext.baseCSSPrefix + 'trigger-noedit', hideTrigger: false, editable: true, readOnly: false, repeatTriggerClick: false, autoSize: Ext.emptyFn, monitorTab: true, mimicing: false, triggerIndexRe: /trigger-index-(\d+)/, extraTriggerCls: '', componentLayout: 'triggerfield', initComponent: function() {
  this.wrapFocusCls = this.triggerWrapCls + '-focus';
  this.callParent(arguments);
}, initEvents: function() {
  this.mon(Ext.globalEvents, 'beforefocus', this.onOtherFocus, this);
  this.callParent();
}, getSubTplMarkup: function(values) {
  var me = this, childElCls = values.childElCls, field = me.callParent(arguments);
  return ['<table id="', me.id, '-triggerWrap" class="', Ext.baseCSSPrefix, 'form-trigger-wrap', childElCls, '" cellpadding="0" cellspacing="0" role="presentation">', '<tbody role="presentation">', '<tr role="presentation">', '<td id="', me.id, '-inputCell" class="', Ext.baseCSSPrefix, 'form-trigger-input-cell', childElCls, '" role="presentation">', field, '</td>', me.getTriggerMarkup(), '</tr>', '</tbody>', '</table>'].join('');
}, getSubTplData: function() {
  var me = this, data = me.callParent(), readOnly = me.readOnly === true, editable = me.editable !== false;
  return Ext.apply(data, {editableCls: (readOnly || !editable) ? ' ' + me.triggerNoEditCls : '', readOnly: !editable || readOnly});
}, getLabelableRenderData: function() {
  var me = this, triggerWrapCls = me.triggerWrapCls, result = me.callParent(arguments);
  return Ext.applyIf(result, {triggerWrapCls: triggerWrapCls, triggerMarkup: me.getTriggerMarkup()});
}, getTriggerMarkup: function() {
  var me = this, i = 0, hideTrigger = (me.readOnly || me.hideTrigger), triggerCls, triggerBaseCls = me.triggerBaseCls, triggerConfigs = [], unselectableCls = Ext.dom.Element.unselectableCls, style = 'width:' + me.triggerWidth + 'px;' + (hideTrigger ? 'display:none;' : ''), cls = me.extraTriggerCls + ' ' + Ext.baseCSSPrefix + 'trigger-cell ' + unselectableCls;
  if (!me.trigger1Cls) 
  {
    me.trigger1Cls = me.triggerCls;
  }
  for (i = 0; (triggerCls = me['trigger' + (i + 1) + 'Cls']) || i < 1; i++) 
    {
      triggerConfigs.push({tag: 'td', role: 'presentation', valign: 'top', cls: cls, style: style, cn: {cls: [Ext.baseCSSPrefix + 'trigger-index-' + i, triggerBaseCls, triggerCls].join(' '), role: 'presentation'}});
    }
  triggerConfigs[0].cn.cls += ' ' + triggerBaseCls + '-first';
  return Ext.DomHelper.markup(triggerConfigs);
}, disableCheck: function() {
  return !this.disabled;
}, beforeRender: function() {
  var me = this, triggerBaseCls = me.triggerBaseCls, tempEl;
  if (!me.triggerWidth) 
  {
    tempEl = Ext.getBody().createChild({role: 'presentation', style: 'position: absolute;', cls: Ext.baseCSSPrefix + 'form-trigger'});
    Ext.form.field.Trigger.prototype.triggerWidth = tempEl.getWidth();
    tempEl.remove();
  }
  me.callParent();
  if (triggerBaseCls !== Ext.baseCSSPrefix + 'form-trigger') 
  {
    me.addChildEls({name: 'triggerEl', select: '.' + triggerBaseCls});
  }
  me.lastTriggerStateFlags = me.getTriggerStateFlags();
}, onRender: function() {
  var me = this;
  me.callParent(arguments);
  me.doc = Ext.getDoc();
  me.initTrigger();
}, getTriggerWidth: function() {
  var me = this, totalTriggerWidth = 0;
  if (me.triggerWrap && !me.hideTrigger && !me.readOnly) 
  {
    totalTriggerWidth = me.triggerEl.getCount() * me.triggerWidth;
  }
  return totalTriggerWidth;
}, setHideTrigger: function(hideTrigger) {
  if (hideTrigger != this.hideTrigger) 
  {
    this.hideTrigger = hideTrigger;
    this.updateLayout();
  }
}, setEditable: function(editable) {
  if (editable != this.editable) 
  {
    this.editable = editable;
    this.updateLayout();
  }
}, setReadOnly: function(readOnly) {
  var me = this, old = me.readOnly;
  me.callParent(arguments);
  if (readOnly != old) 
  {
    me.updateLayout();
  }
}, initTrigger: function() {
  var me = this, triggerWrap = me.triggerWrap, triggerEl = me.triggerEl, disableCheck = me.disableCheck, els, len, el, i, idx, cls;
  if (me.repeatTriggerClick) 
  {
    me.triggerRepeater = new Ext.util.ClickRepeater(triggerWrap, {preventDefault: true, handler: me.onTriggerWrapClick, listeners: {mouseup: me.onTriggerWrapMouseup, scope: me}, scope: me});
  } else {
    me.mon(triggerWrap, {click: me.onTriggerWrapClick, mouseup: me.onTriggerWrapMouseup, scope: me});
  }
  triggerEl.setVisibilityMode(Ext.Element.DISPLAY);
  triggerEl.addClsOnOver(me.triggerBaseCls + '-over', disableCheck, me);
  els = triggerEl.elements;
  len = els.length;
  for (i = 0; i < len; i++) 
    {
      el = els[i];
      idx = i + 1;
      cls = me['trigger' + (idx) + 'Cls'];
      if (cls) 
      {
        el.addClsOnOver(cls + '-over', disableCheck, me);
        el.addClsOnClick(cls + '-click', disableCheck, me);
      }
    }
  triggerEl.addClsOnClick(me.triggerBaseCls + '-click', disableCheck, me);
}, onDestroy: function() {
  var me = this;
  Ext.destroyMembers(me, 'triggerRepeater', 'triggerWrap', 'triggerEl');
  delete me.doc;
  me.callParent();
}, onFocus: function() {
  var me = this;
  me.otherFocused = false;
  me.callParent(arguments);
  if (!me.mimicing) 
  {
    me.bodyEl.addCls(me.wrapFocusCls);
    me.mimicing = true;
    me.mon(me.doc, 'mousedown', me.mimicBlur, me, {delay: 10});
    if (me.monitorTab) 
    {
      me.on('specialkey', me.checkTab, me);
    }
  }
}, checkTab: function(me, e) {
  if (!this.ignoreMonitorTab && e.getKey() === e.TAB) 
  {
    this.triggerBlur();
  }
}, getTriggerStateFlags: function() {
  var me = this, state = 0;
  if (me.readOnly) 
  {
    state += 1;
  }
  if (me.editable) 
  {
    state += 2;
  }
  if (me.hideTrigger) 
  {
    state += 4;
  }
  return state;
}, onOtherFocus: function(dom) {
  this.otherFocused = (this.hasFocus && !this.bodyEl.contains(dom));
}, onBlur: function() {
  if (this.blurring || this.otherFocused) 
  {
    this.triggerBlur();
    this.otherFocused = false;
  }
}, mimicBlur: function(e) {
  if (!this.isDestroyed && !this.bodyEl.contains(e.target)) 
  {
    this.triggerBlur(e);
  }
}, triggerBlur: function(e) {
  var me = this;
  me.mimicing = false;
  me.mun(me.doc, 'mousedown', me.mimicBlur, me);
  if (me.monitorTab && me.inputEl) 
  {
    me.un('specialkey', me.checkTab, me);
  }
  Ext.form.field.Trigger.superclass.onBlur.call(me, e);
  if (me.bodyEl) 
  {
    me.bodyEl.removeCls(me.wrapFocusCls);
  }
}, onTriggerWrapClick: function() {
  var me = this, targetEl, match, triggerClickMethod, event;
  event = arguments[me.triggerRepeater ? 1 : 0];
  if (event && !me.readOnly && !me.disabled) 
  {
    targetEl = event.getTarget('.' + me.triggerBaseCls, null);
    match = targetEl && targetEl.className.match(me.triggerIndexRe);
    if (match) 
    {
      triggerClickMethod = me['onTrigger' + (parseInt(match[1], 10) + 1) + 'Click'] || me.onTriggerClick;
      if (triggerClickMethod) 
      {
        triggerClickMethod.call(me, event);
      }
    }
  }
}, onTriggerWrapMouseup: Ext.emptyFn, onTriggerClick: Ext.emptyFn}, 0, ["triggerfield", "trigger"], ["component", "field", "triggerfield", "textfield", "box", "trigger"], {"component": true, "field": true, "triggerfield": true, "textfield": true, "box": true, "trigger": true}, ["widget.trigger", "widget.triggerfield"], 0, [Ext.form.field, 'Trigger', Ext.form, 'TriggerField', Ext.form, 'TwinTriggerField', Ext.form, 'Trigger'], 0));
;

(Ext.cmd.derive('Ext.form.field.Picker', Ext.form.field.Trigger, {alternateClassName: 'Ext.form.Picker', matchFieldWidth: true, pickerAlign: 'tl-bl?', openCls: Ext.baseCSSPrefix + 'pickerfield-open', editable: true, initComponent: function() {
  this.callParent();
  this.addEvents('expand', 'collapse', 'select');
}, initEvents: function() {
  var me = this;
  me.callParent();
  me.keyNav = new Ext.util.KeyNav(me.inputEl, {down: me.onDownArrow, esc: {handler: me.onEsc, scope: me, defaultEventAction: false}, scope: me, forceKeyDown: true});
  if (!me.editable) 
  {
    me.mon(me.inputEl, 'click', me.onTriggerClick, me);
  }
  if (Ext.isGecko) 
  {
    me.inputEl.dom.setAttribute('autocomplete', 'off');
  }
}, onEsc: function(e) {
  if (Ext.isIE) 
  {
    e.preventDefault();
  }
  if (this.isExpanded) 
  {
    this.collapse();
    e.stopEvent();
  }
}, onDownArrow: function(e) {
  if (!this.isExpanded) 
  {
    this.onTriggerClick();
  }
}, expand: function() {
  var me = this, bodyEl, picker, collapseIf;
  if (me.rendered && !me.isExpanded && !me.isDestroyed) 
  {
    me.expanding = true;
    bodyEl = me.bodyEl;
    picker = me.getPicker();
    collapseIf = me.collapseIf;
    picker.show();
    me.isExpanded = true;
    me.alignPicker();
    bodyEl.addCls(me.openCls);
    me.mon(Ext.getDoc(), {mousewheel: collapseIf, mousedown: collapseIf, scope: me});
    Ext.EventManager.onWindowResize(me.alignPicker, me);
    me.fireEvent('expand', me);
    me.onExpand();
    delete me.expanding;
  }
}, onExpand: Ext.emptyFn, alignPicker: function() {
  var me = this, picker = me.getPicker();
  if (me.isExpanded) 
  {
    if (me.matchFieldWidth) 
    {
      picker.setWidth(me.bodyEl.getWidth());
    }
    if (picker.isFloating()) 
    {
      me.doAlign();
    }
  }
}, doAlign: function() {
  var me = this, picker = me.picker, aboveSfx = '-above', isAbove;
  me.picker.alignTo(me.triggerWrap, me.pickerAlign, me.pickerOffset);
  isAbove = picker.el.getY() < me.inputEl.getY();
  me.bodyEl[isAbove ? 'addCls' : 'removeCls'](me.openCls + aboveSfx);
  picker[isAbove ? 'addCls' : 'removeCls'](picker.baseCls + aboveSfx);
}, collapse: function() {
  var me = this;
  if (me.isExpanded && !me.isDestroyed && !me.destroying) 
  {
    var openCls = me.openCls, picker = me.picker, doc = Ext.getDoc(), collapseIf = me.collapseIf, aboveSfx = '-above';
    picker.hide();
    me.isExpanded = false;
    me.bodyEl.removeCls([openCls, openCls + aboveSfx]);
    picker.el.removeCls(picker.baseCls + aboveSfx);
    doc.un('mousewheel', collapseIf, me);
    doc.un('mousedown', collapseIf, me);
    Ext.EventManager.removeResizeListener(me.alignPicker, me);
    me.fireEvent('collapse', me);
    me.onCollapse();
  }
}, onCollapse: Ext.emptyFn, collapseIf: function(e) {
  var me = this;
  if (!me.isDestroyed && !e.within(me.bodyEl, false, true) && !me.owns(e.target)) 
  {
    me.collapse();
  }
}, getPicker: function() {
  var me = this, picker = me.picker;
  if (!picker) 
  {
    me.picker = picker = me.createPicker();
    picker.ownerCmp = me;
  }
  return picker;
}, getRefItems: function() {
  var result = [];
  if (this.picker) 
  {
    result[0] = this.picker;
  }
  return result;
}, createPicker: Ext.emptyFn, onTriggerClick: function() {
  var me = this;
  if (!me.readOnly && !me.disabled) 
  {
    if (me.isExpanded) 
    {
      me.collapse();
    } else {
      me.expand();
    }
    me.inputEl.focus();
  }
}, onOtherFocus: function(dom) {
  if (this.hasFocus && !this.owns(dom)) 
  {
    this.callParent([dom]);
  }
}, triggerBlur: function() {
  var picker = this.picker;
  this.callParent(arguments);
  this.collapse();
}, mimicBlur: function(e) {
  var me = this, picker = me.picker;
  if (!picker || !me.owns(e.target)) 
  {
    me.callParent(arguments);
  } else {
    me.inputEl.focus();
  }
}, onDestroy: function() {
  var me = this, picker = me.picker;
  Ext.EventManager.removeResizeListener(me.alignPicker, me);
  Ext.destroy(me.keyNav, picker);
  if (picker) 
  {
    delete me.picker;
    delete picker.pickerField;
  }
  me.callParent();
}}, 0, ["pickerfield"], ["component", "pickerfield", "field", "triggerfield", "textfield", "box", "trigger"], {"component": true, "pickerfield": true, "field": true, "triggerfield": true, "textfield": true, "box": true, "trigger": true}, ["widget.pickerfield"], 0, [Ext.form.field, 'Picker', Ext.form, 'Picker'], 0));
;

(Ext.cmd.derive('Ext.selection.Model', Ext.util.Observable, {alternateClassName: 'Ext.AbstractSelectionModel', allowDeselect: undefined, toggleOnClick: true, selected: null, pruneRemoved: true, suspendChange: 0, constructor: function(cfg) {
  var me = this;
  cfg = cfg || {};
  Ext.apply(me, cfg);
  me.addEvents('selectionchange', 'focuschange');
  me.modes = {SINGLE: true, SIMPLE: true, MULTI: true};
  me.setSelectionMode(cfg.mode || me.mode);
  me.selected = new Ext.util.MixedCollection(null, me.getSelectionId);
  me.callParent(arguments);
}, bindStore: function(store, initial) {
  var me = this;
  me.mixins.bindable.bindStore.apply(me, arguments);
  if (me.store && !initial) 
  {
    me.refresh();
  }
}, getStoreListeners: function() {
  var me = this;
  return {add: me.onStoreAdd, clear: me.onStoreClear, bulkremove: me.onStoreRemove, update: me.onStoreUpdate, load: me.onStoreLoad, idchanged: me.onModelIdChanged, refresh: me.onStoreRefresh};
}, suspendChanges: function() {
  ++this.suspendChange;
}, resumeChanges: function() {
  if (this.suspendChange) 
  {
    --this.suspendChange;
  }
}, selectAll: function(suppressEvent) {
  var me = this, selections = me.store.getRange(), i = 0, len = selections.length, start = me.getSelection().length;
  me.suspendChanges();
  for (; i < len; i++) 
    {
      me.doSelect(selections[i], true, suppressEvent);
    }
  me.resumeChanges();
  if (!suppressEvent) 
  {
    me.maybeFireSelectionChange(me.getSelection().length !== start);
  }
}, deselectAll: function(suppressEvent) {
  var me = this, selections = me.getSelection(), selIndexes = {}, store = me.store, start = selections.length, i, l, rec;
  for (i = 0 , l = selections.length; i < l; i++) 
    {
      rec = selections[i];
      selIndexes[rec.internalId] = store.indexOf(rec);
    }
  selections = Ext.Array.sort(selections, function(r1, r2) {
  var idx1 = selIndexes[r1.internalId], idx2 = selIndexes[r2.internalId];
  return idx1 < idx2 ? -1 : 1;
});
  me.suspendChanges();
  me.doDeselect(selections, suppressEvent);
  me.resumeChanges();
  if (!suppressEvent) 
  {
    me.maybeFireSelectionChange(me.getSelection().length !== start);
  }
}, getSelectionStart: function() {
  if (!this.selectionStart) 
  {
    this.setSelectionStart(this.lastFocused);
  }
  return this.selectionStart;
}, setSelectionStart: function(selection) {
  this.selectionStart = selection;
}, selectWithEvent: function(record, e) {
  var me = this, isSelected = me.isSelected(record), shift = e.shiftKey, ctrl = e.ctrlKey, start = shift && me.getSelectionStart(), selected = me.getSelection(), len = selected.length, allowDeselect = me.allowDeselect, toDeselect, i, item;
  switch (me.selectionMode) {
    case 'MULTI':
      if (shift && start) 
      {
        me.selectRange(start, record, ctrl);
      } else if (ctrl && isSelected) 
      {
        me.doDeselect(record, false);
      } else if (ctrl) 
      {
        me.doSelect(record, true, false);
      } else if (isSelected && !shift && !ctrl && len > 1) 
      {
        toDeselect = [];
        for (i = 0; i < len; ++i) 
          {
            item = selected[i];
            if (item !== record) 
            {
              toDeselect.push(item);
            }
          }
        me.doDeselect(toDeselect);
      } else if (!isSelected) 
      {
        me.doSelect(record, false);
      }
      break;
    case 'SIMPLE':
      if (isSelected) 
      {
        me.doDeselect(record);
      } else {
        me.doSelect(record, true);
      }
      break;
    case 'SINGLE':
      if (allowDeselect && !ctrl) 
      {
        allowDeselect = me.toggleOnClick;
      }
      if (allowDeselect && isSelected) 
      {
        me.doDeselect(record);
      } else {
        me.doSelect(record, false);
      }
      break;
  }
  if (!shift) 
  {
    if (me.isSelected(record)) 
    {
      me.selectionStart = record;
    } else {
      me.selectionStart = null;
    }
  }
}, afterKeyNavigate: function(e, record) {
  var me = this, recIdx, fromIdx, isSelected = me.isSelected(record), from = (me.selectionStart && me.isSelected(me.lastFocused)) ? me.selectionStart : (me.selectionStart = me.lastFocused), key = e.getCharCode(), isSpace = key === e.SPACE, direction = key === e.UP || key === e.PAGE_UP ? 'up' : (key === e.DOWN || key === e.DOWN ? 'down' : null);
  switch (me.selectionMode) {
    case 'MULTI':
      if (isSpace) 
      {
        if (e.shiftKey) 
        {
          me.selectRange(from, record, e.ctrlKey);
        } else {
          if (isSelected) 
          {
            me.doDeselect(record, e.ctrlKey);
            me.setLastFocused(null);
            me.setLastFocused(record);
          } else {
            me.doSelect(record, e.ctrlKey);
          }
        }
      } else if (e.shiftKey && from) 
      {
        fromIdx = me.store.indexOf(from);
        recIdx = me.store.indexOf(record);
        if (direction === 'up' && fromIdx <= recIdx) 
        {
          me.deselectRange(me.lastFocused, recIdx + 1);
        } else if (direction === 'down' && fromIdx >= recIdx) 
        {
          me.deselectRange(me.lastFocused, recIdx - 1);
        } else if (from !== record) 
        {
          me.selectRange(from, record, e.ctrlKey);
        }
        me.lastSelected = record;
        me.setLastFocused(record);
      } else if (e.ctrlKey && isSelected) 
      {
        me.setLastFocused(record);
      } else if (e.ctrlKey) 
      {
        me.setLastFocused(record);
      } else {
        me.doSelect(record, false);
      }
      break;
    case 'SIMPLE':
      if (isSelected) 
      {
        if (me.allowDeselect) 
        {
          me.doDeselect(record);
        }
      } else {
        me.doSelect(record, true);
      }
      break;
    case 'SINGLE':
      if (isSpace) 
      {
        if (isSelected) 
        {
          if (me.allowDeselect) 
          {
            me.doDeselect(record);
            me.setLastFocused(record);
          }
        } else {
          me.doSelect(record);
        }
      } else if (e.ctrlKey) 
      {
        me.setLastFocused(record);
      } else if (isSpace && me.allowDeselect && isSelected) 
      {
        me.doDeselect(record);
      } else {
        me.doSelect(record, false);
        me.setLastFocused(record);
      }
      break;
  }
  if (!e.shiftKey) 
  {
    if (me.isSelected(record)) 
    {
      me.selectionStart = record;
    }
  }
}, selectRange: function(startRow, endRow, keepExisting) {
  var me = this, store = me.store, selected = me.selected.items, result, i, len, toSelect, toDeselect, idx, rec;
  if (me.isLocked()) 
  {
    return;
  }
  result = me.normalizeRowRange(startRow, endRow);
  startRow = result[0];
  endRow = result[1];
  toSelect = [];
  for (i = startRow; i <= endRow; i++) 
    {
      if (!me.isSelected(store.getAt(i))) 
      {
        toSelect.push(store.getAt(i));
      }
    }
  if (!keepExisting) 
  {
    toDeselect = [];
    me.suspendChanges();
    for (i = 0 , len = selected.length; i < len; ++i) 
      {
        rec = selected[i];
        idx = store.indexOf(rec);
        if (idx < startRow || idx > endRow) 
        {
          toDeselect.push(rec);
        }
      }
    for (i = 0 , len = toDeselect.length; i < len; ++i) 
      {
        me.doDeselect(toDeselect[i]);
      }
    me.resumeChanges();
  }
  if (toSelect.length) 
  {
    me.doMultiSelect(toSelect, true);
  } else {
    me.maybeFireSelectionChange(toDeselect.length > 0);
  }
}, deselectRange: function(startRow, endRow) {
  var me = this, store = me.store, result, i, toDeselect, record;
  if (me.isLocked()) 
  {
    return;
  }
  result = me.normalizeRowRange(startRow, endRow);
  startRow = result[0];
  endRow = result[1];
  toDeselect = [];
  for (i = startRow; i <= endRow; i++) 
    {
      record = store.getAt(i);
      if (me.isSelected(record)) 
      {
        toDeselect.push(record);
      }
    }
  if (toDeselect.length) 
  {
    me.doDeselect(toDeselect);
  }
}, normalizeRowRange: function(startRow, endRow) {
  var store = this.store, tmp;
  if (!Ext.isNumber(startRow)) 
  {
    startRow = store.indexOf(startRow);
  }
  startRow = Math.max(0, startRow);
  if (!Ext.isNumber(endRow)) 
  {
    endRow = store.indexOf(endRow);
  }
  endRow = Math.min(endRow, store.getCount() - 1);
  if (startRow > endRow) 
  {
    tmp = endRow;
    endRow = startRow;
    startRow = tmp;
  }
  return [startRow, endRow];
}, onModelIdChanged: function(store, model, oldId, newId, oldInternalId) {
  this.selected.updateKey(oldInternalId, newId);
}, select: function(records, keepExisting, suppressEvent) {
  if (Ext.isDefined(records) && !(Ext.isArray(records) && !records.length)) 
  {
    this.doSelect(records, keepExisting, suppressEvent);
  }
}, deselect: function(records, suppressEvent) {
  this.doDeselect(records, suppressEvent);
}, doSelect: function(records, keepExisting, suppressEvent) {
  var me = this, record;
  if (me.locked || !me.store) 
  {
    return;
  }
  if (typeof records === "number") 
  {
    record = me.store.getAt(records);
    if (!record) 
    {
      return;
    }
    records = [record];
  }
  if (me.selectionMode == "SINGLE" && records) 
  {
    record = records.length ? records[0] : records;
    me.doSingleSelect(record, suppressEvent);
  } else {
    me.doMultiSelect(records, keepExisting, suppressEvent);
  }
}, doMultiSelect: function(records, keepExisting, suppressEvent) {
  var me = this, selected = me.selected, change = false, result, i, len, record, commit;
  if (me.locked) 
  {
    return;
  }
  records = !Ext.isArray(records) ? [records] : records;
  len = records.length;
  if (!keepExisting && selected.getCount() > 0) 
  {
    result = me.deselectDuringSelect(records, selected.getRange(), suppressEvent);
    if (result[0]) 
    {
      me.maybeFireSelectionChange(result[1] > 0 && !suppressEvent);
      return;
    }
  }
  commit = function() {
  selected.add(record);
  change = true;
};
  for (i = 0; i < len; i++) 
    {
      record = records[i];
      if (me.isSelected(record)) 
      {
        continue;
      }
      me.lastSelected = record;
      me.onSelectChange(record, true, suppressEvent, commit);
    }
  if (!me.preventFocus) 
  {
    me.setLastFocused(record, suppressEvent);
  }
  me.maybeFireSelectionChange(change && !suppressEvent);
}, deselectDuringSelect: function(toSelect, selected, suppressEvent) {
  var me = this, len = selected.length, changed = 0, failed = false, item, i;
  me.suspendChanges();
  for (i = 0; i < len; ++i) 
    {
      item = selected[i];
      if (!Ext.Array.contains(toSelect, item)) 
      {
        if (me.doDeselect(item, suppressEvent)) 
        {
          ++changed;
        } else {
          failed = true;
        }
      }
    }
  me.resumeChanges();
  return [failed, changed];
}, doDeselect: function(records, suppressEvent) {
  var me = this, selected = me.selected, i = 0, len, record, attempted = 0, accepted = 0, commit;
  if (me.locked || !me.store) 
  {
    return false;
  }
  if (typeof records === "number") 
  {
    record = me.store.getAt(records);
    if (!record) 
    {
      return false;
    }
    records = [record];
  } else if (!Ext.isArray(records)) 
  {
    records = [records];
  }
  commit = function() {
  ++accepted;
  selected.remove(record);
};
  len = records.length;
  me.suspendChanges();
  for (; i < len; i++) 
    {
      record = records[i];
      if (me.isSelected(record)) 
      {
        if (me.lastSelected === record) 
        {
          me.lastSelected = selected.last();
          if (me.lastFocused === record) 
          {
            me.setLastFocused(null);
          }
        }
        ++attempted;
        me.onSelectChange(record, false, suppressEvent, commit);
      }
    }
  me.resumeChanges();
  me.maybeFireSelectionChange(accepted > 0 && !suppressEvent);
  return accepted === attempted;
}, doSingleSelect: function(record, suppressEvent) {
  var me = this, changed = false, selected = me.selected, commit;
  if (me.locked) 
  {
    return;
  }
  if (me.isSelected(record)) 
  {
    return;
  }
  if (selected.getCount()) 
  {
    me.suspendChanges();
    if (!me.doDeselect(me.lastSelected, suppressEvent)) 
    {
      me.resumeChanges();
      return;
    }
    me.resumeChanges();
  }
  commit = function() {
  selected.add(record);
  me.lastSelected = record;
  changed = true;
};
  me.onSelectChange(record, true, suppressEvent, commit);
  if (changed) 
  {
    if (!suppressEvent && !me.preventFocus) 
    {
      me.setLastFocused(record);
    }
    me.maybeFireSelectionChange(!suppressEvent);
  }
}, setLastFocused: function(record, supressFocus) {
  var me = this, recordBeforeLast = me.lastFocused;
  if (record !== recordBeforeLast) 
  {
    me.lastFocused = record;
    me.onLastFocusChanged(recordBeforeLast, record, supressFocus);
  }
}, isFocused: function(record) {
  return record === this.getLastFocused();
}, maybeFireSelectionChange: function(fireEvent) {
  var me = this;
  if (fireEvent && !me.suspendChange) 
  {
    me.fireEvent('selectionchange', me, me.getSelection());
  }
}, getLastSelected: function() {
  return this.lastSelected;
}, getLastFocused: function() {
  return this.lastFocused;
}, getSelection: function() {
  return this.selected.getRange();
}, getSelectionMode: function() {
  return this.selectionMode;
}, setSelectionMode: function(selMode) {
  selMode = selMode ? selMode.toUpperCase() : 'SINGLE';
  this.selectionMode = this.modes[selMode] ? selMode : 'SINGLE';
}, isLocked: function() {
  return this.locked;
}, setLocked: function(locked) {
  this.locked = !!locked;
}, isRangeSelected: function(startRow, endRow) {
  var me = this, store = me.store, i, result;
  result = me.normalizeRowRange(startRow, endRow);
  startRow = result[0];
  endRow = result[1];
  for (i = startRow; i <= endRow; i++) 
    {
      if (!me.isSelected(store.getAt(i))) 
      {
        return false;
      }
    }
  return true;
}, isSelected: function(record) {
  record = Ext.isNumber(record) ? this.store.getAt(record) : record;
  return this.selected.contains(record);
}, hasSelection: function() {
  return this.selected.getCount() > 0;
}, getSelectionId: function(record) {
  return record.internalId;
}, pruneIf: function() {
  var me = this, selected = me.selected, toRemove = [], len = selected.length, i, item;
  if (me.pruneRemoved) 
  {
    for (i = 0; i < len; i++) 
      {
        item = selected.getAt(i);
        if (!me.getStoreRecord(item)) 
        {
          toRemove.push(item);
        }
      }
    if (toRemove.length) 
    {
      for (i = 0 , len = toRemove.length; i < len; i++) 
        {
          selected.remove(toRemove[i]);
        }
      me.maybeFireSelectionChange(true);
    }
  }
}, getStoreRecord: function(record) {
  var store = this.store, records, rec, len, id, i;
  if (record) 
  {
    if (record.hasId()) 
    {
      return store.getById(record.getId());
    } else {
      records = store.data.items;
      len = records.length;
      id = record.internalId;
      for (i = 0; i < len; ++i) 
        {
          rec = records[i];
          if (id === rec.internalId) 
          {
            return rec;
          }
        }
    }
  }
  return null;
}, refresh: function() {
  var me = this, store = me.store, rec, toBeSelected = [], toBeReAdded = [], oldSelections = me.getSelection(), len = oldSelections.length, selection, change, i = 0, lastFocused = me.getLastFocused();
  if (!store) 
  {
    return;
  }
  for (; i < len; i++) 
    {
      selection = oldSelections[i];
      if (store.indexOf(selection) !== -1) 
      {
        toBeSelected.push(selection);
      } else if (!me.pruneRemoved) 
      {
        rec = store.getById(selection.getId());
        if (rec) 
        {
          toBeSelected.push(rec);
        } else {
          toBeReAdded.push(selection);
        }
      }
      if (me.mode === 'SINGLE' && toBeReAdded.length) 
      {
        break;
      }
    }
  if (me.selected.getCount() != (toBeSelected.length + toBeReAdded.length)) 
  {
    change = true;
  }
  me.clearSelections();
  if (store.indexOf(lastFocused) !== -1) 
  {
    me.setLastFocused(lastFocused, true);
  }
  if (toBeSelected.length) 
  {
    me.doSelect(toBeSelected, false, true);
  }
  if (toBeReAdded.length) 
  {
    me.selected.addAll(toBeReAdded);
    if (!me.lastSelected) 
    {
      me.lastSelected = toBeReAdded[toBeReAdded.length - 1];
    }
  }
  me.maybeFireSelectionChange(change);
}, clearSelections: function() {
  this.selected.clear();
  this.lastSelected = null;
  this.setLastFocused(null);
}, onStoreAdd: Ext.emptyFn, onStoreClear: function() {
  if (this.selected.getCount() > 0) 
  {
    this.clearSelections();
    this.maybeFireSelectionChange(true);
  }
}, onStoreRemove: function(store, records, indexes, isMove) {
  var me = this;
  if (me.selectionStart && Ext.Array.contains(records, me.selectionStart)) 
  {
    me.selectionStart = null;
  }
  if (isMove || me.locked || !me.pruneRemoved) 
  {
    return;
  }
  me.deselectDeletedRecords(records);
}, deselectDeletedRecords: function(records) {
  var me = this, selected = me.selected, i, length = records.length, removed = 0, record;
  for (i = 0; i < length; i++) 
    {
      record = records[i];
      if (selected.remove(record)) 
      {
        if (me.lastSelected == record) 
        {
          me.lastSelected = null;
        }
        if (me.getLastFocused() == record) 
        {
          me.setLastFocused(null);
        }
        ++removed;
      }
    }
  if (removed) 
  {
    me.maybeFireSelectionChange(true);
  }
}, getCount: function() {
  return this.selected.getCount();
}, onUpdate: Ext.emptyFn, destroy: function() {
  this.clearListeners();
}, onStoreUpdate: Ext.emptyFn, onStoreRefresh: function() {
  var me = this, selected = me.selected, items, length, i, rec, storeRec;
  if (me.store.buffered) 
  {
    return;
  }
  items = selected.items;
  length = items.length;
  me.lastSelected = me.getStoreRecord(me.lastSelected);
  for (i = 0; i < length; ++i) 
    {
      rec = items[i];
      storeRec = me.getStoreRecord(rec);
      if (storeRec) 
      {
        if (rec.hasId()) 
        {
          me.selected.replace(storeRec);
        }
      } else {
        me.selected.remove(rec);
      }
    }
}, onStoreLoad: Ext.emptyFn, onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
  var me = this, eventName = isSelected ? 'select' : 'deselect';
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false && commitFn() !== false) 
  {
    if (!suppressEvent) 
    {
      me.fireEvent(eventName, me, record);
    }
  }
}, onLastFocusChanged: function(oldFocused, newFocused) {
  this.fireEvent('focuschange', this, oldFocused, newFocused);
}, onEditorKey: Ext.emptyFn, beforeViewRender: function(view) {
  this.views = this.views || [];
  this.views.push(view);
  this.bindStore(view.getStore(), true);
}, bindComponent: Ext.emptyFn}, 1, 0, 0, 0, 0, [['bindable', Ext.util.Bindable]], [Ext.selection, 'Model', Ext, 'AbstractSelectionModel'], 0));
;

(Ext.cmd.derive('Ext.selection.DataViewModel', Ext.selection.Model, {deselectOnContainerClick: true, enableKeyNav: true, constructor: function(cfg) {
  this.addEvents('beforedeselect', 'beforeselect', 'deselect', 'select');
  this.callParent(arguments);
}, bindComponent: function(view) {
  var me = this, eventListeners = {refresh: me.refresh, scope: me};
  me.view = view;
  me.bindStore(view.getStore());
  eventListeners[view.triggerEvent] = me.onItemClick;
  eventListeners[view.triggerCtEvent] = me.onContainerClick;
  view.on(eventListeners);
  if (me.enableKeyNav) 
  {
    me.initKeyNav(view);
  }
}, onUpdate: function(record) {
  var view = this.view;
  if (view && this.isSelected(record)) 
  {
    view.onItemSelect(record);
  }
}, onItemClick: function(view, record, item, index, e) {
  this.selectWithEvent(record, e);
}, onContainerClick: function() {
  if (this.deselectOnContainerClick) 
  {
    this.deselectAll();
  }
}, initKeyNav: function(view) {
  var me = this;
  if (!view.rendered) 
  {
    view.on({render: Ext.Function.bind(me.initKeyNav, me, [view]), single: true});
    return;
  }
  view.el.set({tabIndex: -1});
  me.keyNav = new Ext.util.KeyNav({target: view.el, ignoreInputFields: true, down: Ext.pass(me.onNavKey, [1], me), right: Ext.pass(me.onNavKey, [1], me), left: Ext.pass(me.onNavKey, [-1], me), up: Ext.pass(me.onNavKey, [-1], me), scope: me});
}, onNavKey: function(step) {
  step = step || 1;
  var me = this, view = me.view, selected = me.getSelection()[0], numRecords = me.view.store.getCount(), idx;
  if (selected) 
  {
    idx = view.indexOf(view.getNode(selected)) + step;
  } else {
    idx = 0;
  }
  if (idx < 0) 
  {
    idx = numRecords - 1;
  } else if (idx >= numRecords) 
  {
    idx = 0;
  }
  me.select(idx);
}, onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
  var me = this, view = me.view, eventName = isSelected ? 'select' : 'deselect';
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false && commitFn() !== false) 
  {
    if (view) 
    {
      if (isSelected) 
      {
        view.onItemSelect(record);
      } else {
        view.onItemDeselect(record);
      }
    }
    if (!suppressEvent) 
    {
      me.fireEvent(eventName, me, record);
    }
  }
}, onLastFocusChanged: function(oldFocus, newFocus, suppressFocus) {
  var view = this.view;
  if (view && !suppressFocus && newFocus) 
  {
    view.focusNode(newFocus);
    this.fireEvent('focuschange', this, oldFocus, newFocus);
  }
}, destroy: function() {
  Ext.destroy(this.keyNav);
  this.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.selection, 'DataViewModel'], 0));
;

(Ext.cmd.derive('Ext.view.AbstractView', Ext.Component, {inheritableStatics: {getRecord: function(node) {
  return this.getBoundView(node).getRecord(node);
}, getBoundView: function(node) {
  return Ext.getCmp(node.boundView);
}}, deferInitialRefresh: true, itemCls: Ext.baseCSSPrefix + 'dataview-item', loadingText: 'Loading...', loadMask: true, loadingUseMsg: true, selectedItemCls: Ext.baseCSSPrefix + 'item-selected', emptyText: "", deferEmptyText: true, trackOver: false, blockRefresh: false, preserveScrollOnRefresh: false, ariaRole: 'listbox', itemAriaRole: 'option', last: false, triggerEvent: 'itemclick', triggerCtEvent: 'containerclick', refreshNeeded: true, addCmpEvents: Ext.emptyFn, initComponent: function() {
  var me = this, isDef = Ext.isDefined, itemTpl = me.itemTpl, memberFn = {};
  if (itemTpl) 
  {
    if (Ext.isArray(itemTpl)) 
    {
      itemTpl = itemTpl.join('');
    } else if (Ext.isObject(itemTpl)) 
    {
      memberFn = Ext.apply(memberFn, itemTpl.initialConfig);
      itemTpl = itemTpl.html;
    }
    if (!me.itemSelector) 
    {
      me.itemSelector = '.' + me.itemCls;
    }
    itemTpl = Ext.String.format('<tpl for="."><div class="{0}" role="{2}">{1}</div></tpl>', me.itemCls, itemTpl, me.itemAriaRole);
    me.tpl = new Ext.XTemplate(itemTpl, memberFn);
  }
  me.callParent();
  me.tpl = me.getTpl('tpl');
  if (me.overItemCls) 
  {
    me.trackOver = true;
  }
  me.addEvents('beforerefresh', 'refresh', 'viewready', 'itemupdate', 'itemadd', 'itemremove');
  me.addCmpEvents();
  me.store = Ext.data.StoreManager.lookup(me.store || 'ext-empty-store');
  if (!me.dataSource) 
  {
    me.dataSource = me.store;
  }
  me.bindStore(me.dataSource, true, 'dataSource');
  if (!me.all) 
  {
    me.all = new Ext.CompositeElementLite();
  }
  me.scrollState = {top: 0, left: 0};
  me.on({scroll: me.onViewScroll, element: 'el', scope: me});
}, onRender: function() {
  var me = this, mask = me.loadMask, maskStore = me.getMaskStore(), cfg = {target: me, msg: me.loadingText, useMsg: me.loadingUseMsg, store: maskStore};
  me.callParent(arguments);
  if (mask && !maskStore.proxy.isSynchronous) 
  {
    if (me.loadingCls) 
    {
      cfg.msgCls = me.loadingCls;
    }
    if (Ext.isObject(mask)) 
    {
      cfg = Ext.apply(cfg, mask);
    }
    me.loadMask = new Ext.LoadMask(cfg);
    me.loadMask.on({scope: me, beforeshow: me.onMaskBeforeShow, hide: me.onMaskHide});
  }
}, beforeLayout: function() {
  var me = this;
  me.callParent(arguments);
  if (me.refreshNeeded && !me.pendingRefresh) 
  {
    if (me.refreshCounter) 
    {
      me.refresh();
    } else {
      me.doFirstRefresh(me.dataSource);
    }
  }
}, getMaskStore: function() {
  return this.store;
}, onMaskBeforeShow: function() {
  var me = this, loadingHeight = me.loadingHeight;
  if (loadingHeight && loadingHeight > me.getHeight()) 
  {
    me.hasLoadingHeight = true;
    me.oldMinHeight = me.minHeight;
    me.minHeight = loadingHeight;
    me.updateLayout();
  }
}, onMaskHide: function() {
  var me = this;
  if (!me.destroying && me.hasLoadingHeight) 
  {
    me.minHeight = me.oldMinHeight;
    me.updateLayout();
    delete me.hasLoadingHeight;
  }
}, beforeRender: function() {
  this.callParent(arguments);
  this.getSelectionModel().beforeViewRender(this);
}, afterRender: function() {
  this.callParent(arguments);
  this.getSelectionModel().bindComponent(this);
}, getSelectionModel: function() {
  var me = this, mode = 'SINGLE';
  if (me.simpleSelect) 
  {
    mode = 'SIMPLE';
  } else if (me.multiSelect) 
  {
    mode = 'MULTI';
  }
  if (!me.selModel || !me.selModel.events) 
  {
    me.selModel = new Ext.selection.DataViewModel(Ext.apply({allowDeselect: me.allowDeselect, mode: mode}, me.selModel));
  }
  if (!me.selModel.hasRelaySetup) 
  {
    me.relayEvents(me.selModel, ['selectionchange', 'beforeselect', 'beforedeselect', 'select', 'deselect', 'focuschange']);
    me.selModel.hasRelaySetup = true;
  }
  if (me.disableSelection) 
  {
    me.selModel.locked = true;
  }
  return me.selModel;
}, refresh: function() {
  var me = this, targetEl, targetParent, oldDisplay, nextSibling, dom, records, hasFirstRefresh;
  if (!me.rendered || me.isDestroyed) 
  {
    return;
  }
  if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) 
  {
    targetEl = me.getTargetEl();
    records = me.getViewRange();
    dom = targetEl.dom;
    if (!me.preserveScrollOnRefresh) 
    {
      targetParent = dom.parentNode;
      oldDisplay = dom.style.display;
      dom.style.display = 'none';
      nextSibling = dom.nextSibling;
      targetParent.removeChild(dom);
    }
    if (me.refreshCounter) 
    {
      hasFirstRefresh = true;
      me.clearViewEl();
    } else {
      me.fixedNodes = targetEl.dom.childNodes.length;
      me.refreshCounter = 1;
    }
    me.tpl.append(targetEl, me.collectData(records, me.all.startIndex || 0));
    if (!me.preserveScrollOnRefresh) 
    {
      targetParent.insertBefore(dom, nextSibling);
      dom.style.display = oldDisplay;
    }
    if (records.length < 1) 
    {
      if (!this.store.loading && (!me.deferEmptyText || hasFirstRefresh)) 
      {
        Ext.core.DomHelper.insertHtml('beforeEnd', targetEl.dom, me.emptyText);
      }
      me.all.clear();
    } else {
      me.collectNodes(targetEl.dom);
      me.updateIndexes(0);
    }
    if (hasFirstRefresh) 
    {
      if (me.refreshSelmodelOnRefresh !== false) 
      {
        me.selModel.refresh();
      } else {
        me.selModel.pruneIf();
      }
    }
    me.refreshNeeded = false;
    this.refreshSize();
    me.fireEvent('refresh', me);
    if (!me.viewReady) 
    {
      me.viewReady = true;
      me.fireEvent('viewready', me);
    }
  }
}, collectNodes: function(targetEl) {
  var all = this.all;
  all.fill(Ext.query(this.getItemSelector(), Ext.getDom(targetEl)), all.startIndex || 0);
}, getViewRange: function() {
  return this.dataSource.getRange();
}, refreshSize: function() {
  var sizeModel = this.getSizeModel();
  if (sizeModel.height.shrinkWrap || sizeModel.width.shrinkWrap) 
  {
    this.updateLayout();
  }
}, clearViewEl: function() {
  var me = this, el = me.getTargetEl();
  if (me.fixedNodes) 
  {
    while (el.dom.childNodes[me.fixedNodes]) 
      {
        el.dom.removeChild(el.dom.childNodes[me.fixedNodes]);
      }
  } else {
    el.update('');
  }
  me.refreshCounter++;
}, onViewScroll: Ext.emptyFn, onIdChanged: Ext.emptyFn, saveScrollState: function() {
  if (this.rendered) 
  {
    var dom = this.el.dom, state = this.scrollState;
    state.left = dom.scrollLeft;
    state.top = dom.scrollTop;
  }
}, restoreScrollState: function() {
  if (this.rendered) 
  {
    var dom = this.el.dom, state = this.scrollState;
    dom.scrollLeft = state.left;
    dom.scrollTop = state.top;
  }
}, prepareData: function(data, index, record) {
  var associatedData, attr, hasCopied;
  if (record) 
  {
    associatedData = record.getAssociatedData();
    for (attr in associatedData) 
      {
        if (associatedData.hasOwnProperty(attr)) 
        {
          if (!hasCopied) 
          {
            data = Ext.Object.chain(data);
            hasCopied = true;
          }
          data[attr] = associatedData[attr];
        }
      }
  }
  return data;
}, collectData: function(records, startIndex) {
  var data = [], i = 0, len = records.length, record;
  for (; i < len; i++) 
    {
      record = records[i];
      data[i] = this.prepareData(record.data, startIndex + i, record);
    }
  return data;
}, bufferRender: function(records, index) {
  var me = this, div = me.renderBuffer || (me.renderBuffer = document.createElement('div'));
  me.tpl.overwrite(div, me.collectData(records, index));
  return Ext.DomQuery.select(me.getItemSelector(), div);
}, getNodeContainer: function() {
  return this.getTargetEl();
}, onUpdate: function(ds, record) {
  var me = this, index, node;
  if (me.viewReady) 
  {
    index = me.dataSource.indexOf(record);
    if (index > -1) 
    {
      node = me.bufferRender([record], index)[0];
      if (me.getNode(record)) 
      {
        me.all.replaceElement(index, node, true);
        me.updateIndexes(index, index);
        me.selModel.onUpdate(record);
        if (me.hasListeners.itemupdate) 
        {
          me.fireEvent('itemupdate', record, index, node);
        }
        return node;
      }
    }
  }
}, onReplace: function(store, startIndex, oldRecords, newRecords) {
  var me = this, endIndex, rows = me.all, nodes, item, i, j;
  if (me.rendered) 
  {
    nodes = me.bufferRender(newRecords, startIndex, true);
    item = rows.item(startIndex);
    if (item) 
    {
      rows.item(startIndex).insertSibling(nodes, 'before', true);
    } else {
      me.appendNodes(nodes);
    }
    rows.insert(startIndex, nodes);
    startIndex += newRecords.length;
    endIndex = startIndex + oldRecords.length - 1;
    rows.removeRange(startIndex, endIndex, true);
    if (me.refreshSelmodelOnRefresh !== false) 
    {
      me.selModel.refresh();
    }
    me.updateIndexes(startIndex);
    me.refreshSize();
    if (me.hasListeners.itemremove) 
    {
      for (i = oldRecords.length , j = endIndex; i >= 0; --i , --j) 
        {
          me.fireEvent('itemremove', oldRecords[i], j);
        }
    }
    if (me.hasListeners.itemadd) 
    {
      me.fireEvent('itemadd', newRecords, startIndex, nodes);
    }
  }
}, onAdd: function(store, records, index) {
  var me = this, nodes;
  if (me.rendered) 
  {
    if (me.all.getCount() === 0) 
    {
      me.refresh();
      nodes = me.all.slice();
    } else {
      nodes = me.doAdd(records, index);
      if (me.refreshSelmodelOnRefresh !== false) 
      {
        me.selModel.refresh();
      }
      me.updateIndexes(index);
      me.refreshSize();
    }
    if (me.hasListeners.itemadd) 
    {
      me.fireEvent('itemadd', records, index, nodes);
    }
  }
}, appendNodes: function(nodes) {
  var fragment = document.createDocumentFragment(), len = nodes.length, i;
  for (i = 0; i < len; ++i) 
    {
      fragment.appendChild(nodes[i]);
    }
  this.getNodeContainer().appendChild(fragment);
}, doAdd: function(records, index) {
  var me = this, nodes = me.bufferRender(records, index, true), all = me.all, count = all.getCount(), firstRowIndex = all.startIndex || 0, lastRowIndex = all.endIndex || count - 1;
  if (count === 0 || index > lastRowIndex) 
  {
    me.appendNodes(nodes);
  } else if (index <= firstRowIndex) 
  {
    all.item(firstRowIndex).insertSibling(nodes, 'before', true);
  } else {
    all.item(index).insertSibling(nodes, 'before', true);
  }
  all.insert(index, nodes);
  return nodes;
}, onRemove: function(ds, records, indices) {
  var me = this, fireItemRemove = me.hasListeners.itemremove, i, record, index;
  if (me.all.getCount()) 
  {
    if (me.dataSource.getCount() === 0) 
    {
      if (fireItemRemove) 
      {
        for (i = indices.length - 1; i >= 0; --i) 
          {
            me.fireEvent('itemremove', records[i], indices[i]);
          }
      }
      me.refresh();
    } else {
      for (i = indices.length - 1; i >= 0; --i) 
        {
          record = records[i];
          index = indices[i];
          if (me.all.item(index)) 
          {
            me.doRemove(record, index);
            if (fireItemRemove) 
            {
              me.fireEvent('itemremove', record, index);
            }
          }
        }
      me.updateIndexes(indices[0]);
    }
    this.refreshSize();
  }
}, doRemove: function(record, index) {
  this.all.removeElement(index, true);
}, refreshNode: function(index) {
  this.onUpdate(this.dataSource, this.store.getAt(index));
}, updateIndexes: function(startIndex, endIndex) {
  var nodes = this.all.elements, records = this.getViewRange(), i;
  startIndex = startIndex || 0;
  endIndex = endIndex || ((endIndex === 0) ? 0 : (nodes.length - 1));
  for (i = startIndex; i <= endIndex; i++) 
    {
      nodes[i].viewIndex = i;
      nodes[i].viewRecordId = records[i].internalId;
      if (!nodes[i].boundView) 
      {
        nodes[i].boundView = this.id;
      }
    }
}, getStore: function() {
  return this.store;
}, bindStore: function(store, initial, propName) {
  var me = this;
  me.mixins.bindable.bindStore.apply(me, arguments);
  if (!initial) 
  {
    me.getSelectionModel().bindStore(store);
  }
  if (me.componentLayoutCounter) 
  {
    me.doFirstRefresh(store);
  }
}, doFirstRefresh: function(store) {
  var me = this;
  if (store && !store.loading) 
  {
    if (me.deferInitialRefresh) 
    {
      me.applyFirstRefresh();
    } else {
      me.refresh();
    }
  }
}, applyFirstRefresh: function() {
  var me = this;
  if (me.isDestroyed) 
  {
    return;
  }
  me.pendingRefresh = 0;
  if (me.up('[isCollapsingOrExpanding]')) 
  {
    me.pendingRefresh = Ext.Function.defer(me.applyFirstRefresh, 100, me);
  } else {
    me.pendingRefresh = Ext.Function.defer(function() {
  me.pendingRefresh = 0;
  if (!me.isDestroyed) 
  {
    me.refresh();
  }
}, 1);
  }
}, onUnbindStore: function(store) {
  this.setMaskBind(null);
}, onBindStore: function(store, initial, propName) {
  this.setMaskBind(store);
  if (!initial && propName === 'store') 
  {
    this.bindStore(store, false, 'dataSource');
  }
}, setMaskBind: function(store) {
  var mask = this.loadMask;
  if (mask && mask.bindStore) 
  {
    mask.bindStore(store);
  }
}, getStoreListeners: function() {
  var me = this;
  return {idchanged: me.onIdChanged, refresh: me.onDataRefresh, replace: me.onReplace, add: me.onAdd, bulkremove: me.onRemove, update: me.onUpdate, clear: me.refresh};
}, onDataRefresh: function() {
  this.refreshView();
}, refreshView: function() {
  var me = this, blocked = me.blockRefresh || !me.rendered || me.up('[collapsed],[isCollapsingOrExpanding],[hidden]');
  if (blocked) 
  {
    me.refreshNeeded = true;
    me.deferInitialRefresh = false;
  } else {
    me.refresh();
  }
}, findItemByChild: function(node) {
  return Ext.fly(node).findParent(this.getItemSelector(), this.getTargetEl());
}, findTargetByEvent: function(e) {
  return e.getTarget(this.getItemSelector(), this.getTargetEl());
}, getSelectedNodes: function() {
  var nodes = [], records = this.selModel.getSelection(), ln = records.length, i = 0;
  for (; i < ln; i++) 
    {
      nodes.push(this.getNode(records[i]));
    }
  return nodes;
}, getRecords: function(nodes) {
  var records = [], i = 0, len = nodes.length, data = this.dataSource.data;
  for (; i < len; i++) 
    {
      records[records.length] = data.getByKey(nodes[i].viewRecordId);
    }
  return records;
}, getRecord: function(node) {
  return this.dataSource.data.getByKey(Ext.getDom(node).viewRecordId);
}, isSelected: function(node) {
  var r = this.getRecord(node);
  return this.selModel.isSelected(r);
}, select: function(records, keepExisting, suppressEvent) {
  this.selModel.select(records, keepExisting, suppressEvent);
}, deselect: function(records, suppressEvent) {
  this.selModel.deselect(records, suppressEvent);
}, getNode: function(nodeInfo) {
  if ((!nodeInfo && nodeInfo !== 0) || !this.rendered) 
  {
    return null;
  }
  if (Ext.isString(nodeInfo)) 
  {
    return document.getElementById(nodeInfo);
  }
  if (Ext.isNumber(nodeInfo)) 
  {
    return this.all.elements[nodeInfo];
  }
  if (nodeInfo.isModel) 
  {
    return this.getNodeByRecord(nodeInfo);
  }
  return nodeInfo;
}, getNodeByRecord: function(record) {
  var ns = this.all.elements, ln = ns.length, i = 0;
  for (; i < ln; i++) 
    {
      if (ns[i].viewRecordId === record.internalId) 
      {
        return ns[i];
      }
    }
  return null;
}, getNodes: function(start, end) {
  var all = this.all;
  if (end === undefined) 
  {
    end = all.getCount();
  } else {
    end++;
  }
  return all.slice(start || 0, end);
}, indexOf: function(node) {
  node = this.getNode(node);
  if (!node && node !== 0) 
  {
    return -1;
  }
  if (Ext.isNumber(node.viewIndex)) 
  {
    return node.viewIndex;
  }
  return this.all.indexOf(node);
}, onDestroy: function() {
  var me = this;
  me.all.clear();
  me.callParent();
  me.bindStore(null);
  me.selModel.destroy();
}, onItemSelect: function(record) {
  var node = this.getNode(record);
  if (node) 
  {
    Ext.fly(node).addCls(this.selectedItemCls);
  }
}, onItemDeselect: function(record) {
  var node = this.getNode(record);
  if (node) 
  {
    Ext.fly(node).removeCls(this.selectedItemCls);
  }
}, getItemSelector: function() {
  return this.itemSelector;
}}, 0, 0, ["component", "box"], {"component": true, "box": true}, 0, [['bindable', Ext.util.Bindable]], [Ext.view, 'AbstractView'], function() {
  Ext.deprecate('extjs', '4.0', function() {
  Ext.view.AbstractView.override({getSelectionCount: function() {
  if (Ext.global.console) 
  {
    Ext.global.console.warn("DataView: getSelectionCount will be removed, please interact with the Ext.selection.DataViewModel");
  }
  return this.selModel.getSelection().length;
}, getSelectedRecords: function() {
  if (Ext.global.console) 
  {
    Ext.global.console.warn("DataView: getSelectedRecords will be removed, please interact with the Ext.selection.DataViewModel");
  }
  return this.selModel.getSelection();
}, select: function(records, keepExisting, supressEvents) {
  if (Ext.global.console) 
  {
    Ext.global.console.warn("DataView: select will be removed, please access select through a DataView's SelectionModel, ie: view.getSelectionModel().select()");
  }
  var sm = this.getSelectionModel();
  return sm.select.apply(sm, arguments);
}, clearSelections: function() {
  if (Ext.global.console) 
  {
    Ext.global.console.warn("DataView: clearSelections will be removed, please access deselectAll through DataView's SelectionModel, ie: view.getSelectionModel().deselectAll()");
  }
  var sm = this.getSelectionModel();
  return sm.deselectAll();
}});
});
}));
;

(Ext.cmd.derive('Ext.view.View', Ext.view.AbstractView, {alternateClassName: 'Ext.DataView', deferHighlight: Ext.isIE7m ? 100 : 0, mouseOverOutBuffer: 20, inputTagRe: /^textarea$|^input$/i, inheritableStatics: {EventMap: {mousedown: 'MouseDown', mouseup: 'MouseUp', click: 'Click', dblclick: 'DblClick', contextmenu: 'ContextMenu', mouseover: 'MouseOver', mouseout: 'MouseOut', mouseenter: 'MouseEnter', mouseleave: 'MouseLeave', keydown: 'KeyDown', focus: 'Focus'}}, initComponent: function() {
  var me = this;
  me.callParent();
  if (me.mouseOverOutBuffer) 
  {
    me.handleMouseOver = Ext.Function.createBuffered(me.handleMouseOver, me.mouseOverOutBuffer, me);
    me.handleMouseOut = Ext.Function.createBuffered(me.handleMouseOut, me.mouseOverOutBuffer, me);
    me.lastMouseOverEvent = new Ext.EventObjectImpl();
    me.lastMouseOutEvent = new Ext.EventObjectImpl();
  } else if (me.deferHighlight) 
  {
    me.setHighlightedItem = Ext.Function.createBuffered(me.setHighlightedItem, me.deferHighlight, me);
  }
}, addCmpEvents: function() {
  this.addEvents('beforeitemmousedown', 'beforeitemmouseup', 'beforeitemmouseenter', 'beforeitemmouseleave', 'beforeitemclick', 'beforeitemdblclick', 'beforeitemcontextmenu', 'beforeitemkeydown', 'itemmousedown', 'itemmouseup', 'itemmouseenter', 'itemmouseleave', 'itemclick', 'itemdblclick', 'itemcontextmenu', 'itemkeydown', 'beforecontainermousedown', 'beforecontainermouseup', 'beforecontainermouseover', 'beforecontainermouseout', 'beforecontainerclick', 'beforecontainerdblclick', 'beforecontainercontextmenu', 'beforecontainerkeydown', 'containermousedown', 'containermouseup', 'containermouseover', 'containermouseout', 'containerclick', 'containerdblclick', 'containercontextmenu', 'containerkeydown', 'selectionchange', 'beforeselect', 'beforedeselect', 'select', 'deselect', 'focuschange', 'highlightitem', 'unhighlightitem');
}, getFocusEl: function() {
  return this.getTargetEl();
}, afterRender: function() {
  var me = this;
  me.callParent();
  me.mon(me.getTargetEl(), {scope: me, freezeEvent: true, click: me.handleEvent, mousedown: me.handleEvent, mouseup: me.handleEvent, dblclick: me.handleEvent, contextmenu: me.handleEvent, keydown: me.handleEvent, mouseover: me.onMouseOver, mouseout: me.onMouseOut});
}, onMouseOver: function(e) {
  var me = this;
  if (me.mouseOverOutBuffer) 
  {
    e = me.lastMouseOverEvent.setEvent(e.browserEvent, true);
  }
  me.handleMouseOver(e);
}, onMouseOut: function(e) {
  var me = this, itemSelector = me.getTargetSelector(), item = e.getTarget(itemSelector), computedRelatedTarget = e.getRelatedTarget(itemSelector);
  if ((item === computedRelatedTarget) && !(item === null && computedRelatedTarget === null)) 
  {
    return;
  }
  if (me.mouseOverOutBuffer) 
  {
    e = me.lastMouseOutEvent.setEvent(e.browserEvent, true);
  }
  me.handleMouseOut(e, item);
}, getTargetSelector: function() {
  return this.dataRowSelector || this.itemSelector;
}, handleMouseOver: function(e) {
  var me = this, itemSelector = me.getTargetSelector(), item = e.getTarget(itemSelector);
  if (!me.isDestroyed) 
  {
    if (item) 
    {
      if (me.mouseOverItem !== item && me.el.contains(item)) 
      {
        me.mouseOverItem = e.item = item;
        e.newType = 'mouseenter';
        me.handleEvent(e);
      }
    } else {
      me.handleEvent(e);
    }
  }
}, handleMouseOut: function(e, item) {
  var me = this, sourceView;
  if (!me.isDestroyed) 
  {
    if (item && (sourceView = me.self.getBoundView(item))) 
    {
      e.item = item;
      e.newType = 'mouseleave';
      sourceView.handleEvent(e);
      sourceView.mouseOverItem = null;
    } else {
      me.handleEvent(e);
    }
  }
}, handleEvent: function(e) {
  var me = this, key = e.type === 'keydown' && e.getKey();
  if (me.processUIEvent(e) !== false) 
  {
    me.processSpecialEvent(e);
  }
  if (key === e.SPACE) 
  {
    if (!me.inputTagRe.test(e.getTarget().tagName)) 
    {
      e.stopEvent();
    }
  }
}, processItemEvent: Ext.emptyFn, processContainerEvent: Ext.emptyFn, processSpecialEvent: Ext.emptyFn, processUIEvent: function(e) {
  if (!Ext.getBody().isAncestor(e.target)) 
  {
    return;
  }
  var me = this, item = e.getTarget(me.getTargetSelector(), me.getTargetEl()), map = me.statics().EventMap, index, record, type = e.type, newType = type, sm;
  if (e.newType) 
  {
    newType = e.newType;
    item = e.item;
    e.newType = e.item = null;
  }
  if (!item && type == 'keydown') 
  {
    sm = me.getSelectionModel();
    record = sm.lastFocused || sm.getLastSelected();
    if (record) 
    {
      item = me.getNode(record, true);
    }
  }
  if (item) 
  {
    if (!record) 
    {
      record = me.getRecord(item);
    }
    index = me.indexInStore ? me.indexInStore(record) : me.indexOf(item);
    if (!record || me.processItemEvent(record, item, index, e) === false) 
    {
      return false;
    }
    if ((me['onBeforeItem' + map[newType]](record, item, index, e) === false) || (me.fireEvent('beforeitem' + newType, me, record, item, index, e) === false) || (me['onItem' + map[newType]](record, item, index, e) === false)) 
    {
      return false;
    }
    me.fireEvent('item' + newType, me, record, item, index, e);
  } else {
    if ((me.processContainerEvent(e) === false) || (me['onBeforeContainer' + map[type]](e) === false) || (me.fireEvent('beforecontainer' + type, me, e) === false) || (me['onContainer' + map[type]](e) === false)) 
    {
      return false;
    }
    me.fireEvent('container' + type, me, e);
  }
  return true;
}, onItemMouseEnter: function(record, item, index, e) {
  if (this.trackOver) 
  {
    this.highlightItem(item);
  }
}, onItemMouseLeave: function(record, item, index, e) {
  if (this.trackOver) 
  {
    this.clearHighlight();
  }
}, onItemMouseDown: Ext.emptyFn, onItemMouseUp: Ext.emptyFn, onItemFocus: Ext.emptyFn, onItemClick: Ext.emptyFn, onItemDblClick: Ext.emptyFn, onItemContextMenu: Ext.emptyFn, onItemKeyDown: Ext.emptyFn, onBeforeItemMouseDown: Ext.emptyFn, onBeforeItemMouseUp: Ext.emptyFn, onBeforeItemFocus: Ext.emptyFn, onBeforeItemMouseEnter: Ext.emptyFn, onBeforeItemMouseLeave: Ext.emptyFn, onBeforeItemClick: Ext.emptyFn, onBeforeItemDblClick: Ext.emptyFn, onBeforeItemContextMenu: Ext.emptyFn, onBeforeItemKeyDown: Ext.emptyFn, onContainerMouseDown: Ext.emptyFn, onContainerMouseUp: Ext.emptyFn, onContainerMouseOver: Ext.emptyFn, onContainerMouseOut: Ext.emptyFn, onContainerClick: Ext.emptyFn, onContainerDblClick: Ext.emptyFn, onContainerContextMenu: Ext.emptyFn, onContainerKeyDown: Ext.emptyFn, onBeforeContainerMouseDown: Ext.emptyFn, onBeforeContainerMouseUp: Ext.emptyFn, onBeforeContainerMouseOver: Ext.emptyFn, onBeforeContainerMouseOut: Ext.emptyFn, onBeforeContainerClick: Ext.emptyFn, onBeforeContainerDblClick: Ext.emptyFn, onBeforeContainerContextMenu: Ext.emptyFn, onBeforeContainerKeyDown: Ext.emptyFn, setHighlightedItem: function(item) {
  var me = this, highlighted = me.highlightedItem, overItemCls = me.overItemCls, beforeOverItemCls = me.beforeOverItemCls, previous;
  if (highlighted != item) 
  {
    if (highlighted) 
    {
      Ext.fly(highlighted).removeCls(overItemCls);
      previous = highlighted.previousSibling;
      if (beforeOverItemCls && previous) 
      {
        Ext.fly(previous).removeCls(beforeOverItemCls);
      }
      me.fireEvent('unhighlightitem', me, highlighted);
    }
    me.highlightedItem = item;
    if (item) 
    {
      Ext.fly(item).addCls(me.overItemCls);
      previous = item.previousSibling;
      if (beforeOverItemCls && previous) 
      {
        Ext.fly(previous).addCls(beforeOverItemCls);
      }
      me.fireEvent('highlightitem', me, item);
    }
  }
}, highlightItem: function(item) {
  this.setHighlightedItem(item);
}, clearHighlight: function() {
  this.setHighlightedItem(undefined);
}, onUpdate: function(store, record) {
  var me = this, node, newNode, highlighted;
  if (me.viewReady) 
  {
    node = me.getNode(record);
    newNode = me.callParent(arguments);
    highlighted = me.highlightedItem;
    if (highlighted && highlighted === node) 
    {
      delete me.highlightedItem;
      if (newNode) 
      {
        me.highlightItem(newNode);
      }
    }
  }
}, refresh: function() {
  this.clearHighlight();
  this.callParent(arguments);
}, focusNode: function(rec) {
  var me = this, node = me.getNode(rec, true), el = me.el, adjustmentY = 0, adjustmentX = 0, elRegion = el.getRegion(), nodeRegion;
  elRegion.bottom = elRegion.top + el.dom.clientHeight;
  elRegion.right = elRegion.left + el.dom.clientWidth;
  if (node) 
  {
    nodeRegion = Ext.fly(node).getRegion();
    if (nodeRegion.top < elRegion.top) 
    {
      adjustmentY = nodeRegion.top - elRegion.top;
    } else if (nodeRegion.bottom > elRegion.bottom) 
    {
      adjustmentY = nodeRegion.bottom - elRegion.bottom;
    }
    if (nodeRegion.left < elRegion.left) 
    {
      adjustmentX = nodeRegion.left - elRegion.left;
    } else if (nodeRegion.right > elRegion.right) 
    {
      adjustmentX = nodeRegion.right - elRegion.right;
    }
    if (adjustmentX || adjustmentY) 
    {
      me.scrollBy(adjustmentX, adjustmentY, false);
    }
    Ext.fly(node).set({tabIndex: -1});
    node.focus();
  }
}, bindStore: function(store, initial, propertyName) {
  var dataSource = this[propertyName];
  if (dataSource && dataSource.isFeatureStore) 
  {
    if (store.isFeatureStore) 
    {
      this.bindStoreListeners(store);
      dataSource.bindStore(dataSource.store);
    } else {
      dataSource.bindStore(store);
    }
  } else {
    this.callParent(arguments);
  }
}}, 0, ["dataview"], ["component", "box", "dataview"], {"component": true, "box": true, "dataview": true}, ["widget.dataview"], 0, [Ext.view, 'View', Ext, 'DataView'], 0));
;

(Ext.cmd.derive('Ext.layout.component.BoundList', Ext.layout.component.Auto, {type: 'component', beginLayout: function(ownerContext) {
  var me = this, owner = me.owner, toolbar = owner.pagingToolbar;
  me.callParent(arguments);
  if (owner.floating) 
  {
    ownerContext.savedXY = owner.getXY();
    owner.setXY([0, -9999]);
  }
  if (toolbar) 
  {
    ownerContext.toolbarContext = ownerContext.context.getCmp(toolbar);
  }
  ownerContext.listContext = ownerContext.getEl('listEl');
}, beginLayoutCycle: function(ownerContext) {
  var owner = this.owner;
  this.callParent(arguments);
  if (ownerContext.heightModel.auto) 
  {
    owner.el.setHeight('auto');
    owner.listEl.setHeight('auto');
  }
}, getLayoutItems: function() {
  var toolbar = this.owner.pagingToolbar;
  return toolbar ? [toolbar] : [];
}, isValidParent: function() {
  return true;
}, finishedLayout: function(ownerContext) {
  var xy = ownerContext.savedXY;
  this.callParent(arguments);
  if (xy) 
  {
    this.owner.setXY(xy);
  }
}, measureContentWidth: function(ownerContext) {
  return this.owner.listEl.getWidth();
}, measureContentHeight: function(ownerContext) {
  return this.owner.listEl.getHeight();
}, publishInnerHeight: function(ownerContext, height) {
  var toolbar = ownerContext.toolbarContext, toolbarHeight = 0;
  if (toolbar) 
  {
    toolbarHeight = toolbar.getProp('height');
  }
  if (toolbarHeight === undefined) 
  {
    this.done = false;
  } else {
    ownerContext.listContext.setHeight(height - ownerContext.getFrameInfo().height - toolbarHeight);
  }
}, calculateOwnerHeightFromContentHeight: function(ownerContext) {
  var height = this.callParent(arguments), toolbar = ownerContext.toolbarContext;
  if (toolbar) 
  {
    height += toolbar.getProp('height');
  }
  return height;
}}, 0, 0, 0, 0, ["layout.boundlist"], 0, [Ext.layout.component, 'BoundList'], 0));
;

(Ext.cmd.derive('Ext.toolbar.TextItem', Ext.toolbar.Item, {alternateClassName: 'Ext.Toolbar.TextItem', text: '', renderTpl: '{text}', baseCls: Ext.baseCSSPrefix + 'toolbar-text', ariaRole: null, beforeRender: function() {
  var me = this;
  me.callParent();
  Ext.apply(me.renderData, {text: me.text});
}, setText: function(text) {
  var me = this;
  me.text = text;
  if (me.rendered) 
  {
    me.el.update(text);
    me.updateLayout();
  }
}}, 0, ["tbtext"], ["component", "tbtext", "tbitem", "box"], {"component": true, "tbtext": true, "tbitem": true, "box": true}, ["widget.tbtext"], 0, [Ext.toolbar, 'TextItem', Ext.Toolbar, 'TextItem'], 0));
;

(Ext.cmd.derive('Ext.form.field.Spinner', Ext.form.field.Trigger, {alternateClassName: 'Ext.form.Spinner', trigger1Cls: Ext.baseCSSPrefix + 'form-spinner-up', trigger2Cls: Ext.baseCSSPrefix + 'form-spinner-down', spinUpEnabled: true, spinDownEnabled: true, keyNavEnabled: true, mouseWheelEnabled: true, repeatTriggerClick: true, onSpinUp: Ext.emptyFn, onSpinDown: Ext.emptyFn, ariaRole: 'spinbutton', triggerTpl: '<td style="{triggerStyle}" class="{triggerCls}" role="presentation">' + '<div class="' + Ext.baseCSSPrefix + 'trigger-index-0 ' + Ext.baseCSSPrefix + 'form-trigger ' + Ext.baseCSSPrefix + 'form-spinner-up {spinnerUpCls} {childElCls}" role="presentation"></div>' + '<div class="' + Ext.baseCSSPrefix + 'trigger-index-1 ' + Ext.baseCSSPrefix + 'form-trigger ' + Ext.baseCSSPrefix + 'form-spinner-down {spinnerDownCls} {childElCls}" role="presentation"></div>' + '</td>' + '</tr>', initComponent: function() {
  this.callParent();
  this.addEvents('spin', 'spinup', 'spindown');
}, onRender: function() {
  var me = this, triggers;
  me.callParent(arguments);
  triggers = me.triggerEl;
  me.spinUpEl = triggers.item(0);
  me.spinDownEl = triggers.item(1);
  me.triggerCell = me.spinUpEl.parent();
  if (me.keyNavEnabled) 
  {
    me.spinnerKeyNav = new Ext.util.KeyNav(me.inputEl, {scope: me, up: me.spinUp, down: me.spinDown});
  }
  if (me.mouseWheelEnabled) 
  {
    me.mon(me.bodyEl, 'mousewheel', me.onMouseWheel, me);
  }
}, getSubTplMarkup: function(values) {
  var me = this, childElCls = values.childElCls, field = Ext.form.field.Base.prototype.getSubTplMarkup.apply(me, arguments);
  return '<table id="' + me.id + '-triggerWrap" class="' + Ext.baseCSSPrefix + 'form-trigger-wrap' + childElCls + '" cellpadding="0" cellspacing="0" role="presentation">' + '<tbody role="presentation">' + '<tr role="presentation"><td id="' + me.id + '-inputCell" class="' + Ext.baseCSSPrefix + 'form-trigger-input-cell' + childElCls + '" role="presentation">' + field + '</td>' + me.getTriggerMarkup() + '</tbody></table>';
}, getTriggerMarkup: function() {
  return this.getTpl('triggerTpl').apply(this.getTriggerData());
}, getTriggerData: function() {
  var me = this, hideTrigger = (me.readOnly || me.hideTrigger);
  return {triggerCls: Ext.baseCSSPrefix + 'trigger-cell', triggerStyle: hideTrigger ? 'display:none' : '', spinnerUpCls: !me.spinUpEnabled ? me.trigger1Cls + '-disabled' : '', spinnerDownCls: !me.spinDownEnabled ? me.trigger2Cls + '-disabled' : ''};
}, getTriggerWidth: function() {
  var me = this, totalTriggerWidth = 0;
  if (me.triggerWrap && !me.hideTrigger && !me.readOnly) 
  {
    totalTriggerWidth = me.triggerWidth;
  }
  return totalTriggerWidth;
}, onTrigger1Click: function() {
  this.spinUp();
}, onTrigger2Click: function() {
  this.spinDown();
}, onTriggerWrapMouseup: function() {
  this.inputEl.focus();
}, spinUp: function() {
  var me = this;
  if (me.spinUpEnabled && !me.disabled) 
  {
    me.fireEvent('spin', me, 'up');
    me.fireEvent('spinup', me);
    me.onSpinUp();
  }
}, spinDown: function() {
  var me = this;
  if (me.spinDownEnabled && !me.disabled) 
  {
    me.fireEvent('spin', me, 'down');
    me.fireEvent('spindown', me);
    me.onSpinDown();
  }
}, setSpinUpEnabled: function(enabled) {
  var me = this, wasEnabled = me.spinUpEnabled;
  me.spinUpEnabled = enabled;
  if (wasEnabled !== enabled && me.rendered) 
  {
    me.spinUpEl[enabled ? 'removeCls' : 'addCls'](me.trigger1Cls + '-disabled');
  }
}, setSpinDownEnabled: function(enabled) {
  var me = this, wasEnabled = me.spinDownEnabled;
  me.spinDownEnabled = enabled;
  if (wasEnabled !== enabled && me.rendered) 
  {
    me.spinDownEl[enabled ? 'removeCls' : 'addCls'](me.trigger2Cls + '-disabled');
  }
}, onMouseWheel: function(e) {
  var me = this, delta;
  if (me.hasFocus) 
  {
    delta = e.getWheelDelta();
    if (delta > 0) 
    {
      me.spinUp();
    } else if (delta < 0) 
    {
      me.spinDown();
    }
    e.stopEvent();
  }
}, onDestroy: function() {
  Ext.destroyMembers(this, 'spinnerKeyNav', 'spinUpEl', 'spinDownEl');
  this.callParent();
}}, 0, ["spinnerfield"], ["spinnerfield", "component", "field", "triggerfield", "textfield", "box", "trigger"], {"spinnerfield": true, "component": true, "field": true, "triggerfield": true, "textfield": true, "box": true, "trigger": true}, ["widget.spinnerfield"], 0, [Ext.form.field, 'Spinner', Ext.form, 'Spinner'], 0));
;

(Ext.cmd.derive('Ext.form.field.Number', Ext.form.field.Spinner, {alternateClassName: ['Ext.form.NumberField', 'Ext.form.Number'], allowExponential: true, allowDecimals: true, decimalSeparator: null, submitLocaleSeparator: true, decimalPrecision: 2, minValue: Number.NEGATIVE_INFINITY, maxValue: Number.MAX_VALUE, step: 1, minText: 'The minimum value for this field is {0}', maxText: 'The maximum value for this field is {0}', nanText: '{0} is not a valid number', negativeText: 'The value cannot be negative', baseChars: '0123456789', autoStripChars: false, initComponent: function() {
  var me = this;
  if (me.decimalSeparator === null) 
  {
    me.decimalSeparator = Ext.util.Format.decimalSeparator;
  }
  me.callParent();
  me.setMinValue(me.minValue);
  me.setMaxValue(me.maxValue);
}, getErrors: function(value) {
  var me = this, errors = me.callParent(arguments), format = Ext.String.format, num;
  value = Ext.isDefined(value) ? value : this.processRawValue(this.getRawValue());
  if (value.length < 1) 
  {
    return errors;
  }
  value = String(value).replace(me.decimalSeparator, '.');
  if (isNaN(value)) 
  {
    errors.push(format(me.nanText, value));
  }
  num = me.parseValue(value);
  if (me.minValue === 0 && num < 0) 
  {
    errors.push(this.negativeText);
  } else if (num < me.minValue) 
  {
    errors.push(format(me.minText, me.minValue));
  }
  if (num > me.maxValue) 
  {
    errors.push(format(me.maxText, me.maxValue));
  }
  return errors;
}, rawToValue: function(rawValue) {
  var value = this.fixPrecision(this.parseValue(rawValue));
  if (value === null) 
  {
    value = rawValue || null;
  }
  return value;
}, valueToRaw: function(value) {
  var me = this, decimalSeparator = me.decimalSeparator;
  value = me.parseValue(value);
  value = me.fixPrecision(value);
  value = Ext.isNumber(value) ? value : parseFloat(String(value).replace(decimalSeparator, '.'));
  value = isNaN(value) ? '' : String(value).replace('.', decimalSeparator);
  return value;
}, getSubmitValue: function() {
  var me = this, value = me.callParent();
  if (!me.submitLocaleSeparator) 
  {
    value = value.replace(me.decimalSeparator, '.');
  }
  return value;
}, onChange: function() {
  this.toggleSpinners();
  this.callParent(arguments);
}, toggleSpinners: function() {
  var me = this, value = me.getValue(), valueIsNull = value === null, enabled;
  if (me.spinUpEnabled || me.spinUpDisabledByToggle) 
  {
    enabled = valueIsNull || value < me.maxValue;
    me.setSpinUpEnabled(enabled, true);
  }
  if (me.spinDownEnabled || me.spinDownDisabledByToggle) 
  {
    enabled = valueIsNull || value > me.minValue;
    me.setSpinDownEnabled(enabled, true);
  }
}, setMinValue: function(value) {
  var me = this, allowed;
  me.minValue = Ext.Number.from(value, Number.NEGATIVE_INFINITY);
  me.toggleSpinners();
  if (me.disableKeyFilter !== true) 
  {
    allowed = me.baseChars + '';
    if (me.allowExponential) 
    {
      allowed += me.decimalSeparator + 'e+-';
    } else {
      if (me.allowDecimals) 
      {
        allowed += me.decimalSeparator;
      }
      if (me.minValue < 0) 
      {
        allowed += '-';
      }
    }
    allowed = Ext.String.escapeRegex(allowed);
    me.maskRe = new RegExp('[' + allowed + ']');
    if (me.autoStripChars) 
    {
      me.stripCharsRe = new RegExp('[^' + allowed + ']', 'gi');
    }
  }
}, setMaxValue: function(value) {
  this.maxValue = Ext.Number.from(value, Number.MAX_VALUE);
  this.toggleSpinners();
}, parseValue: function(value) {
  value = parseFloat(String(value).replace(this.decimalSeparator, '.'));
  return isNaN(value) ? null : value;
}, fixPrecision: function(value) {
  var me = this, nan = isNaN(value), precision = me.decimalPrecision;
  if (nan || !value) 
  {
    return nan ? '' : value;
  } else if (!me.allowDecimals || precision <= 0) 
  {
    precision = 0;
  }
  return parseFloat(Ext.Number.toFixed(parseFloat(value), precision));
}, beforeBlur: function() {
  var me = this, v = me.rawToValue(me.getRawValue());
  if (!Ext.isEmpty(v)) 
  {
    me.setValue(v);
  }
}, setSpinUpEnabled: function(enabled, internal) {
  this.callParent(arguments);
  if (!internal) 
  {
    delete this.spinUpDisabledByToggle;
  } else {
    this.spinUpDisabledByToggle = !enabled;
  }
}, onSpinUp: function() {
  var me = this;
  if (!me.readOnly) 
  {
    me.setSpinValue(Ext.Number.constrain(me.getValue() + me.step, me.minValue, me.maxValue));
  }
}, setSpinDownEnabled: function(enabled, internal) {
  this.callParent(arguments);
  if (!internal) 
  {
    delete this.spinDownDisabledByToggle;
  } else {
    this.spinDownDisabledByToggle = !enabled;
  }
}, onSpinDown: function() {
  var me = this;
  if (!me.readOnly) 
  {
    me.setSpinValue(Ext.Number.constrain(me.getValue() - me.step, me.minValue, me.maxValue));
  }
}, setSpinValue: function(value) {
  var me = this, len;
  if (me.enforceMaxLength) 
  {
    if (me.fixPrecision(value).toString().length > me.maxLength) 
    {
      return;
    }
  }
  me.setValue(value);
}}, 0, ["numberfield"], ["spinnerfield", "component", "field", "triggerfield", "textfield", "numberfield", "box", "trigger"], {"spinnerfield": true, "component": true, "field": true, "triggerfield": true, "textfield": true, "numberfield": true, "box": true, "trigger": true}, ["widget.numberfield"], 0, [Ext.form.field, 'Number', Ext.form, 'NumberField', Ext.form, 'Number'], 0));
;

(Ext.cmd.derive('Ext.toolbar.Paging', Ext.toolbar.Toolbar, {alternateClassName: 'Ext.PagingToolbar', displayInfo: false, prependButtons: false, displayMsg: 'Displaying {0} - {1} of {2}', emptyMsg: 'No data to display', beforePageText: 'Page', afterPageText: 'of {0}', firstText: 'First Page', prevText: 'Previous Page', nextText: 'Next Page', lastText: 'Last Page', refreshText: 'Refresh', inputItemWidth: 30, getPagingItems: function() {
  var me = this, inputListeners = {scope: me, blur: me.onPagingBlur};
  inputListeners[Ext.EventManager.getKeyEvent()] = me.onPagingKeyDown;
  return [{itemId: 'first', tooltip: me.firstText, overflowText: me.firstText, iconCls: Ext.baseCSSPrefix + 'tbar-page-first', disabled: true, handler: me.moveFirst, scope: me}, {itemId: 'prev', tooltip: me.prevText, overflowText: me.prevText, iconCls: Ext.baseCSSPrefix + 'tbar-page-prev', disabled: true, handler: me.movePrevious, scope: me}, '-', me.beforePageText, {xtype: 'numberfield', itemId: 'inputItem', name: 'inputItem', cls: Ext.baseCSSPrefix + 'tbar-page-number', allowDecimals: false, minValue: 1, hideTrigger: true, enableKeyEvents: true, keyNavEnabled: false, selectOnFocus: true, submitValue: false, isFormField: false, width: me.inputItemWidth, margins: '-1 2 3 2', listeners: inputListeners}, {xtype: 'tbtext', itemId: 'afterTextItem', text: Ext.String.format(me.afterPageText, 1)}, '-', {itemId: 'next', tooltip: me.nextText, overflowText: me.nextText, iconCls: Ext.baseCSSPrefix + 'tbar-page-next', disabled: true, handler: me.moveNext, scope: me}, {itemId: 'last', tooltip: me.lastText, overflowText: me.lastText, iconCls: Ext.baseCSSPrefix + 'tbar-page-last', disabled: true, handler: me.moveLast, scope: me}, '-', {itemId: 'refresh', tooltip: me.refreshText, overflowText: me.refreshText, iconCls: Ext.baseCSSPrefix + 'tbar-loading', disabled: me.store.isLoading(), handler: me.doRefresh, scope: me}];
}, initComponent: function() {
  var me = this, userItems = me.items || me.buttons || [], pagingItems;
  me.bindStore(me.store || 'ext-empty-store', true);
  pagingItems = me.getPagingItems();
  if (me.prependButtons) 
  {
    me.items = userItems.concat(pagingItems);
  } else {
    me.items = pagingItems.concat(userItems);
  }
  delete me.buttons;
  if (me.displayInfo) 
  {
    me.items.push('->');
    me.items.push({xtype: 'tbtext', itemId: 'displayItem'});
  }
  me.callParent();
  me.addEvents('change', 'beforechange');
}, beforeRender: function() {
  var me = this;
  me.callParent(arguments);
  if (!me.store.isLoading()) 
  {
    me.calledFromRender = true;
    me.onLoad();
    delete me.calledFromRender;
  }
}, updateInfo: function() {
  var me = this, displayItem = me.child('#displayItem'), store = me.store, pageData = me.getPageData(), count, msg;
  if (displayItem) 
  {
    count = store.getCount();
    if (count === 0) 
    {
      msg = me.emptyMsg;
    } else {
      msg = Ext.String.format(me.displayMsg, pageData.fromRecord, pageData.toRecord, pageData.total);
    }
    displayItem.setText(msg);
  }
}, onLoad: function() {
  var me = this, pageData, currPage, pageCount, afterText, count, isEmpty, item;
  count = me.store.getCount();
  isEmpty = count === 0;
  if (!isEmpty) 
  {
    pageData = me.getPageData();
    currPage = pageData.currentPage;
    pageCount = pageData.pageCount;
    if (currPage > pageCount) 
    {
      me.store.loadPage(pageCount);
      return;
    }
    afterText = Ext.String.format(me.afterPageText, isNaN(pageCount) ? 1 : pageCount);
  } else {
    currPage = 0;
    pageCount = 0;
    afterText = Ext.String.format(me.afterPageText, 0);
  }
  Ext.suspendLayouts();
  item = me.child('#afterTextItem');
  if (item) 
  {
    item.setText(afterText);
  }
  item = me.getInputItem();
  if (item) 
  {
    item.setDisabled(isEmpty).setValue(currPage);
  }
  me.setChildDisabled('#first', currPage === 1 || isEmpty);
  me.setChildDisabled('#prev', currPage === 1 || isEmpty);
  me.setChildDisabled('#next', currPage === pageCount || isEmpty);
  me.setChildDisabled('#last', currPage === pageCount || isEmpty);
  me.setChildDisabled('#refresh', false);
  me.updateInfo();
  Ext.resumeLayouts(true);
  if (!me.calledFromRender) 
  {
    me.fireEvent('change', me, pageData);
  }
}, setChildDisabled: function(selector, disabled) {
  var item = this.child(selector);
  if (item) 
  {
    item.setDisabled(disabled);
  }
}, getPageData: function() {
  var store = this.store, totalCount = store.getTotalCount();
  return {total: totalCount, currentPage: store.currentPage, pageCount: Math.ceil(totalCount / store.pageSize), fromRecord: ((store.currentPage - 1) * store.pageSize) + 1, toRecord: Math.min(store.currentPage * store.pageSize, totalCount)};
}, onLoadError: function() {
  this.setChildDisabled('#refresh', false);
}, getInputItem: function() {
  return this.child('#inputItem');
}, readPageFromInput: function(pageData) {
  var inputItem = this.getInputItem(), pageNum = false, v;
  if (inputItem) 
  {
    v = inputItem.getValue();
    pageNum = parseInt(v, 10);
    if (!v || isNaN(pageNum)) 
    {
      inputItem.setValue(pageData.currentPage);
      return false;
    }
  }
  return pageNum;
}, onPagingBlur: function(e) {
  var inputItem = this.getInputItem(), curPage;
  if (inputItem) 
  {
    curPage = this.getPageData().currentPage;
    inputItem.setValue(curPage);
  }
}, onPagingKeyDown: function(field, e) {
  this.processKeyEvent(field, e);
}, processKeyEvent: function(field, e) {
  var me = this, k = e.getKey(), pageData = me.getPageData(), increment = e.shiftKey ? 10 : 1, pageNum;
  if (k == e.RETURN) 
  {
    e.stopEvent();
    pageNum = me.readPageFromInput(pageData);
    if (pageNum !== false) 
    {
      pageNum = Math.min(Math.max(1, pageNum), pageData.pageCount);
      if (pageNum !== pageData.currentPage && me.fireEvent('beforechange', me, pageNum) !== false) 
      {
        me.store.loadPage(pageNum);
      }
    }
  } else if (k == e.HOME || k == e.END) 
  {
    e.stopEvent();
    pageNum = k == e.HOME ? 1 : pageData.pageCount;
    field.setValue(pageNum);
  } else if (k == e.UP || k == e.PAGE_UP || k == e.DOWN || k == e.PAGE_DOWN) 
  {
    e.stopEvent();
    pageNum = me.readPageFromInput(pageData);
    if (pageNum) 
    {
      if (k == e.DOWN || k == e.PAGE_DOWN) 
      {
        increment *= -1;
      }
      pageNum += increment;
      if (pageNum >= 1 && pageNum <= pageData.pageCount) 
      {
        field.setValue(pageNum);
      }
    }
  }
}, beforeLoad: function() {
  this.setChildDisabled('#refresh', true);
}, moveFirst: function() {
  if (this.fireEvent('beforechange', this, 1) !== false) 
  {
    this.store.loadPage(1);
    return true;
  }
  return false;
}, movePrevious: function() {
  var me = this, store = me.store, prev = store.currentPage - 1;
  if (prev > 0) 
  {
    if (me.fireEvent('beforechange', me, prev) !== false) 
    {
      store.previousPage();
      return true;
    }
  }
  return false;
}, moveNext: function() {
  var me = this, store = me.store, total = me.getPageData().pageCount, next = store.currentPage + 1;
  if (next <= total) 
  {
    if (me.fireEvent('beforechange', me, next) !== false) 
    {
      store.nextPage();
      return true;
    }
  }
  return false;
}, moveLast: function() {
  var me = this, last = me.getPageData().pageCount;
  if (me.fireEvent('beforechange', me, last) !== false) 
  {
    me.store.loadPage(last);
    return true;
  }
  return false;
}, doRefresh: function() {
  var me = this, store = me.store, current = store.currentPage;
  if (me.fireEvent('beforechange', me, current) !== false) 
  {
    store.loadPage(current);
    return true;
  }
  return false;
}, getStoreListeners: function() {
  return {beforeload: this.beforeLoad, load: this.onLoad, exception: this.onLoadError};
}, unbind: function(store) {
  this.bindStore(null);
}, bind: function(store) {
  this.bindStore(store);
}, onDestroy: function() {
  this.unbind();
  this.callParent();
}}, 0, ["pagingtoolbar"], ["container", "toolbar", "component", "box", "pagingtoolbar"], {"container": true, "toolbar": true, "component": true, "box": true, "pagingtoolbar": true}, ["widget.pagingtoolbar"], [['bindable', Ext.util.Bindable]], [Ext.toolbar, 'Paging', Ext, 'PagingToolbar'], 0));
;

(Ext.cmd.derive('Ext.view.BoundList', Ext.view.View, {alternateClassName: 'Ext.BoundList', pageSize: 0, baseCls: Ext.baseCSSPrefix + 'boundlist', itemCls: Ext.baseCSSPrefix + 'boundlist-item', listItemCls: '', shadow: false, trackOver: true, refreshed: 0, preserveScrollOnRefresh: true, deferInitialRefresh: false, componentLayout: 'boundlist', childEls: ['listEl'], renderTpl: ['<div id="{id}-listEl" role="presentation" class="{baseCls}-list-ct ', Ext.dom.Element.unselectableCls, '" style="overflow:auto"></div>', '{%', 'var me=values.$comp, pagingToolbar=me.pagingToolbar;', 'if (pagingToolbar) {', 'pagingToolbar.ownerLayout = me.componentLayout;', 'Ext.DomHelper.generateMarkup(pagingToolbar.getRenderTree(), out);', '}', '%}', {disableFormats: true}], initComponent: function() {
  var me = this, baseCls = me.baseCls, itemCls = me.itemCls;
  me.selectedItemCls = baseCls + '-selected';
  if (me.trackOver) 
  {
    me.overItemCls = baseCls + '-item-over';
  }
  me.itemSelector = "." + itemCls;
  if (me.floating) 
  {
    me.addCls(baseCls + '-floating');
  }
  if (!me.tpl) 
  {
    me.tpl = new Ext.XTemplate('<ul class="' + Ext.plainListCls + '"><tpl for=".">', '<li role="option" unselectable="on" class="' + itemCls + '">' + me.getInnerTpl(me.displayField) + '</li>', '</tpl></ul>');
  } else if (!me.tpl.isTemplate) 
  {
    me.tpl = new Ext.XTemplate(me.tpl);
  }
  if (me.pageSize) 
  {
    me.pagingToolbar = me.createPagingToolbar();
  }
  me.callParent();
}, getRefOwner: function() {
  return this.pickerField || this.callParent();
}, getRefItems: function() {
  var me = this, result = [];
  if (me.pagingToolbar) 
  {
    result.push(me.pagingToolbar);
  }
  if (me.loadMask) 
  {
    result.push(me.loadMask);
  }
  return result;
}, createPagingToolbar: function() {
  return Ext.widget('pagingtoolbar', {id: this.id + '-paging-toolbar', pageSize: this.pageSize, store: this.dataSource, border: false, ownerCt: this, ownerLayout: this.getComponentLayout()});
}, finishRenderChildren: function() {
  var toolbar = this.pagingToolbar;
  this.callParent(arguments);
  if (toolbar) 
  {
    toolbar.finishRender();
  }
}, refresh: function() {
  var me = this, tpl = me.tpl, toolbar = me.pagingToolbar, rendered = me.rendered;
  tpl.field = me.pickerField;
  tpl.store = me.store;
  me.callParent();
  tpl.field = tpl.store = null;
  if (rendered && toolbar && toolbar.rendered && !me.preserveScrollOnRefresh) 
  {
    me.el.appendChild(toolbar.el);
  }
  if (rendered && Ext.isIE6 && Ext.isStrict) 
  {
    me.listEl.repaint();
  }
}, bindStore: function(store, initial) {
  var toolbar = this.pagingToolbar;
  this.callParent(arguments);
  if (toolbar) 
  {
    toolbar.bindStore(store, initial);
  }
}, getTargetEl: function() {
  return this.listEl || this.el;
}, getNodeContainer: function() {
  return Ext.get(this.listEl.dom.firstChild);
}, getInnerTpl: function(displayField) {
  return '{' + displayField + '}';
}, onDestroy: function() {
  Ext.destroyMembers(this, 'pagingToolbar', 'listEl');
  this.callParent();
}}, 0, ["boundlist"], ["component", "box", "boundlist", "dataview"], {"component": true, "box": true, "boundlist": true, "dataview": true}, ["widget.boundlist"], [['queryable', Ext.Queryable]], [Ext.view, 'BoundList', Ext, 'BoundList'], 0));
;

(Ext.cmd.derive('Ext.view.BoundListKeyNav', Ext.util.KeyNav, {constructor: function(el, config) {
  var me = this;
  me.boundList = config.boundList;
  me.callParent([el, Ext.apply({}, config, me.defaultHandlers)]);
}, defaultHandlers: {up: function() {
  var me = this, boundList = me.boundList, allItems = boundList.all, oldItem = boundList.highlightedItem, oldItemIdx = oldItem ? boundList.indexOf(oldItem) : -1, newItemIdx = oldItemIdx > 0 ? oldItemIdx - 1 : allItems.getCount() - 1;
  me.highlightAt(newItemIdx);
}, down: function() {
  var me = this, boundList = me.boundList, allItems = boundList.all, oldItem = boundList.highlightedItem, oldItemIdx = oldItem ? boundList.indexOf(oldItem) : -1, newItemIdx = oldItemIdx < allItems.getCount() - 1 ? oldItemIdx + 1 : 0;
  me.highlightAt(newItemIdx);
}, pageup: function() {
}, pagedown: function() {
}, home: function() {
  this.highlightAt(0);
}, end: function() {
  var me = this;
  me.highlightAt(me.boundList.all.getCount() - 1);
}, enter: function(e) {
  this.selectHighlighted(e);
}}, highlightAt: function(index) {
  var boundList = this.boundList, item = boundList.all.item(index);
  if (item) 
  {
    item = item.dom;
    boundList.highlightItem(item);
    boundList.getTargetEl().scrollChildIntoView(item, false);
  }
}, selectHighlighted: function(e) {
  var boundList = this.boundList, selModel = boundList.getSelectionModel(), highlighted, highlightedRec;
  highlighted = boundList.highlightedItem;
  if (highlighted) 
  {
    highlightedRec = boundList.getRecord(highlighted);
    if (e.getKey() === e.ENTER || !selModel.isSelected(highlightedRec)) 
    {
      selModel.selectWithEvent(highlightedRec, e);
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.view, 'BoundListKeyNav'], 0));
;

(Ext.cmd.derive('Ext.layout.component.field.ComboBox', Ext.layout.component.field.Trigger, {type: 'combobox', startingWidth: null, getTextWidth: function() {
  var me = this, owner = me.owner, store = owner.store, field = owner.displayField, storeLn = store.data.length, value = '', i = 0, n = 0, ln, item, width;
  for (; i < storeLn; i++) 
    {
      item = store.getAt(i).data[field];
      ln = item.length;
      if (ln > n) 
      {
        n = ln;
        value = item;
      }
    }
  width = Math.max(me.callParent(arguments), owner.inputEl.getTextWidth(value + owner.growAppend));
  if (!me.startingWidth || owner.removingRecords) 
  {
    me.startingWidth = width;
    if (width < owner.growMin) 
    {
      owner.defaultListConfig.minWidth = owner.growMin;
    }
    owner.removingRecords = false;
  }
  return (width < me.startingWidth) ? me.startingWidth : width;
}}, 0, 0, 0, 0, ["layout.combobox"], 0, [Ext.layout.component.field, 'ComboBox'], 0));
;

(Ext.cmd.derive('Ext.form.field.ComboBox', Ext.form.field.Picker, {alternateClassName: 'Ext.form.ComboBox', componentLayout: 'combobox', triggerCls: Ext.baseCSSPrefix + 'form-arrow-trigger', hiddenName: '', hiddenDataCls: Ext.baseCSSPrefix + 'hide-display ' + Ext.baseCSSPrefix + 'form-data-hidden', ariaRole: 'combobox', fieldSubTpl: ['<div class="{hiddenDataCls}" role="presentation"></div>', '<input id="{id}" type="{type}" role="{role}" {inputAttrTpl} class="{fieldCls} {typeCls} {editableCls}" autocomplete="off"', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="name"> name="{name}"</tpl>', '<tpl if="placeholder"> placeholder="{placeholder}"</tpl>', '<tpl if="size"> size="{size}"</tpl>', '<tpl if="maxLength !== undefined"> maxlength="{maxLength}"</tpl>', '<tpl if="readOnly"> readonly="readonly"</tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', '<tpl if="tabIdx"> tabIndex="{tabIdx}"</tpl>', '<tpl if="fieldStyle"> style="{fieldStyle}"</tpl>', '/>', {compiled: true, disableFormats: true}], getSubTplData: function() {
  var me = this;
  Ext.applyIf(me.subTplData, {hiddenDataCls: me.hiddenDataCls});
  return me.callParent(arguments);
}, afterRender: function() {
  var me = this;
  me.callParent(arguments);
  me.setHiddenValue(me.value);
}, multiSelect: false, delimiter: ', ', displayField: 'text', triggerAction: 'all', allQuery: '', queryParam: 'query', queryMode: 'remote', queryCaching: true, pageSize: 0, anyMatch: false, caseSensitive: false, autoSelect: true, typeAhead: false, typeAheadDelay: 250, selectOnTab: true, forceSelection: false, growToLongestValue: true, clearFilterOnBlur: true, defaultListConfig: {loadingHeight: 70, minWidth: 70, maxHeight: 300, shadow: 'sides'}, transformInPlace: true, ignoreSelection: 0, removingRecords: null, resizeComboToGrow: function() {
  var me = this;
  return me.grow && me.growToLongestValue;
}, initComponent: function() {
  var me = this, isDefined = Ext.isDefined, store = me.store, transform = me.transform, displayTpl = me.displayTpl, transformSelect, isLocalMode;
  Ext.applyIf(me.renderSelectors, {hiddenDataEl: '.' + me.hiddenDataCls.split(' ').join('.')});
  me.addEvents('beforequery', 'select', 'beforeselect', 'beforedeselect');
  if (transform) 
  {
    transformSelect = Ext.getDom(transform);
    if (transformSelect) 
    {
      if (!me.store) 
      {
        store = Ext.Array.map(Ext.Array.from(transformSelect.options), function(option) {
  return [option.value, option.text];
});
      }
      if (!me.name) 
      {
        me.name = transformSelect.name;
      }
      if (!('value' in me)) 
      {
        me.value = transformSelect.value;
      }
    }
  }
  me.bindStore(store || 'ext-empty-store', true, true);
  store = me.store;
  if (store.autoCreated) 
  {
    me.queryMode = 'local';
    me.valueField = me.displayField = 'field1';
    if (!store.expanded) 
    {
      me.displayField = 'field2';
    }
  }
  if (!isDefined(me.valueField)) 
  {
    me.valueField = me.displayField;
  }
  isLocalMode = me.queryMode === 'local';
  if (!isDefined(me.queryDelay)) 
  {
    me.queryDelay = isLocalMode ? 10 : 500;
  }
  if (!isDefined(me.minChars)) 
  {
    me.minChars = isLocalMode ? 0 : 4;
  }
  if (!displayTpl) 
  {
    me.displayTpl = new Ext.XTemplate('<tpl for=".">' + '{[typeof values === "string" ? values : values["' + me.displayField + '"]]}' + '<tpl if="xindex < xcount">' + me.delimiter + '</tpl>' + '</tpl>');
  } else if (!displayTpl.isTemplate) 
  {
    me.displayTpl = new Ext.XTemplate(displayTpl);
  }
  me.callParent();
  me.doQueryTask = new Ext.util.DelayedTask(me.doRawQuery, me);
  if (me.store.getCount() > 0) 
  {
    me.setValue(me.value);
  }
  if (transformSelect) 
  {
    if (me.transformInPlace) 
    {
      me.render(transformSelect.parentNode, transformSelect);
      delete me.renderTo;
    }
    Ext.removeNode(transformSelect);
  }
}, getStore: function() {
  return this.store;
}, beforeBlur: function() {
  var me = this, filter = me.queryFilter;
  me.doQueryTask.cancel();
  me.assertValue();
  if (filter && !filter.disabled && me.queryMode === 'local' && me.clearFilterOnBlur) 
  {
    filter.disabled = true;
    me.store.filter();
  }
}, onFocus: function() {
  var me = this, filter = me.queryFilter;
  me.callParent(arguments);
  if (!me.duringTriggerClick && me.triggerAction !== 'all' && filter && filter.disabled && me.queryMode === 'local' && me.clearFilterOnBlur) 
  {
    delete me.lastQuery;
    me.doRawQuery();
  }
}, assertValue: function() {
  var me = this, value = me.getRawValue(), rec, currentValue;
  if (me.forceSelection) 
  {
    if (me.multiSelect) 
    {
      if (value !== me.getDisplayValue()) 
      {
        me.setValue(me.lastSelection);
      }
    } else {
      rec = me.findRecordByDisplay(value);
      if (rec) 
      {
        currentValue = me.value;
        if (!me.findRecordByValue(currentValue)) 
        {
          me.select(rec, true);
        }
      } else {
        me.setValue(me.lastSelection);
      }
    }
  }
  me.collapse();
}, onTypeAhead: function() {
  var me = this, displayField = me.displayField, record = me.store.findRecord(displayField, me.getRawValue()), boundList = me.getPicker(), newValue, len, selStart;
  if (record) 
  {
    newValue = record.get(displayField);
    len = newValue.length;
    selStart = me.getRawValue().length;
    boundList.highlightItem(boundList.getNode(record));
    if (selStart !== 0 && selStart !== len) 
    {
      me.setRawValue(newValue);
      me.selectText(selStart, newValue.length);
    }
  }
}, resetToDefault: Ext.emptyFn, beforeReset: function() {
  var filter = this.queryFilter;
  this.callParent();
  if (filter && !filter.disabled) 
  {
    filter.disabled = true;
    this.store.filter();
  }
}, onUnbindStore: function(store) {
  var me = this, picker = me.picker, filter = me.queryFilter;
  if (filter) 
  {
    me.store.removeFilter(filter);
  }
  if (picker) 
  {
    picker.bindStore(null);
  }
}, onBindStore: function(store, initial) {
  var picker = this.picker;
  if (!initial) 
  {
    this.resetToDefault();
  }
  if (picker) 
  {
    picker.bindStore(store);
  }
}, bindStore: function(store, preventFilter, initial) {
  var me = this, filter = me.queryFilter;
  me.mixins.bindable.bindStore.call(me, store, initial);
  store = me.getStore();
  if (store && filter) 
  {
    filter.disabled = !!preventFilter;
    store.addFilter(filter);
  }
}, getStoreListeners: function() {
  var me = this;
  return {beforeload: me.onBeforeLoad, clear: me.onClear, datachanged: me.onDataChanged, load: me.onLoad, exception: me.onException, remove: me.onRemove};
}, onBeforeLoad: function() {
  ++this.ignoreSelection;
}, onDataChanged: function() {
  var me = this;
  if (me.resizeComboToGrow()) 
  {
    me.updateLayout();
  }
}, onClear: function() {
  var me = this;
  if (me.resizeComboToGrow()) 
  {
    me.removingRecords = true;
    me.onDataChanged();
  }
}, onRemove: function() {
  var me = this;
  if (me.resizeComboToGrow()) 
  {
    me.removingRecords = true;
  }
}, onException: function() {
  if (this.ignoreSelection > 0) 
  {
    --this.ignoreSelection;
  }
  this.collapse();
}, onLoad: function(store, records, success) {
  var me = this;
  if (me.ignoreSelection > 0) 
  {
    --me.ignoreSelection;
  }
  if (success && !store.lastOptions.rawQuery) 
  {
    if (me.value == null) 
    {
      if (me.store.getCount()) 
      {
        me.doAutoSelect();
      } else {
        me.setValue(me.value);
      }
    } else {
      me.setValue(me.value);
    }
  }
}, doRawQuery: function() {
  this.doQuery(this.getRawValue(), false, true);
}, doQuery: function(queryString, forceAll, rawQuery) {
  var me = this, queryPlan = me.beforeQuery({query: queryString || '', rawQuery: rawQuery, forceAll: forceAll, combo: me, cancel: false});
  if (queryPlan === false || queryPlan.cancel) 
  {
    return false;
  }
  if (me.queryCaching && queryPlan.query === me.lastQuery) 
  {
    me.expand();
    if (me.queryMode === 'local') 
    {
      me.doAutoSelect();
    }
  } else {
    me.lastQuery = queryPlan.query;
    if (me.queryMode === 'local') 
    {
      me.doLocalQuery(queryPlan);
    } else {
      me.doRemoteQuery(queryPlan);
    }
  }
  return true;
}, beforeQuery: function(queryPlan) {
  var me = this;
  if (me.fireEvent('beforequery', queryPlan) === false) 
  {
    queryPlan.cancel = true;
  } else if (!queryPlan.cancel) 
  {
    if (queryPlan.query.length < me.minChars && !queryPlan.forceAll) 
    {
      queryPlan.cancel = true;
    }
  }
  return queryPlan;
}, doLocalQuery: function(queryPlan) {
  var me = this, queryString = queryPlan.query;
  if (!me.queryFilter) 
  {
    me.queryFilter = new Ext.util.Filter({id: me.id + '-query-filter', anyMatch: me.anyMatch, caseSensitive: me.caseSensitive, root: 'data', property: me.displayField});
    me.store.addFilter(me.queryFilter, false);
  }
  if (queryString || !queryPlan.forceAll) 
  {
    me.queryFilter.disabled = false;
    me.queryFilter.setValue(me.enableRegEx ? new RegExp(queryString) : queryString);
  } else {
    me.queryFilter.disabled = true;
  }
  me.store.filter();
  if (me.store.getCount() || me.getPicker().emptyText) 
  {
    me.expand();
  } else {
    me.collapse();
  }
  me.afterQuery(queryPlan);
}, doRemoteQuery: function(queryPlan) {
  var me = this, loadCallback = function() {
  me.afterQuery(queryPlan);
};
  me.expand();
  if (me.pageSize) 
  {
    me.loadPage(1, {rawQuery: queryPlan.rawQuery, callback: loadCallback});
  } else {
    me.store.load({params: me.getParams(queryPlan.query), rawQuery: queryPlan.rawQuery, callback: loadCallback});
  }
}, afterQuery: function(queryPlan) {
  var me = this;
  if (me.store.getCount()) 
  {
    if (me.typeAhead) 
    {
      me.doTypeAhead();
    }
    if (me.getRawValue() !== me.getDisplayValue()) 
    {
      me.ignoreSelection++;
      me.picker.getSelectionModel().deselectAll();
      me.ignoreSelection--;
    }
    if (queryPlan.rawQuery) 
    {
      me.syncSelection();
      if (me.picker && !me.picker.getSelectionModel().hasSelection()) 
      {
        me.doAutoSelect();
      }
    } else {
      me.doAutoSelect();
    }
  }
}, loadPage: function(pageNum, options) {
  this.store.loadPage(pageNum, Ext.apply({params: this.getParams(this.lastQuery)}, options));
}, onPageChange: function(toolbar, newPage) {
  this.loadPage(newPage);
  return false;
}, getParams: function(queryString) {
  var params = {}, param = this.queryParam;
  if (param) 
  {
    params[param] = queryString;
  }
  return params;
}, doAutoSelect: function() {
  var me = this, picker = me.picker, lastSelected, itemNode;
  if (picker && me.autoSelect && me.store.getCount() > 0) 
  {
    lastSelected = picker.getSelectionModel().lastSelected;
    itemNode = picker.getNode(lastSelected || 0);
    if (itemNode) 
    {
      picker.highlightItem(itemNode);
      picker.listEl.scrollChildIntoView(itemNode, false);
    }
  }
}, doTypeAhead: function() {
  var me = this;
  if (!me.typeAheadTask) 
  {
    me.typeAheadTask = new Ext.util.DelayedTask(me.onTypeAhead, me);
  }
  if (me.lastKey != Ext.EventObject.BACKSPACE && me.lastKey != Ext.EventObject.DELETE) 
  {
    me.typeAheadTask.delay(me.typeAheadDelay);
  }
}, onTriggerClick: function() {
  var me = this;
  me.duringTriggerClick = true;
  if (!me.readOnly && !me.disabled) 
  {
    if (me.isExpanded) 
    {
      me.collapse();
    } else {
      me.onFocus({});
      if (me.triggerAction === 'all') 
      {
        me.doQuery(me.allQuery, true);
      } else if (me.triggerAction === 'last') 
      {
        me.doQuery(me.lastQuery, true);
      } else {
        me.doQuery(me.getRawValue(), false, true);
      }
    }
    me.inputEl.focus();
  }
  delete me.duringTriggerClick;
}, onPaste: function() {
  var me = this;
  if (!me.readOnly && !me.disabled && me.editable) 
  {
    me.doQueryTask.delay(me.queryDelay);
  }
}, onKeyUp: function(e, t) {
  var me = this, key = e.getKey();
  if (!me.readOnly && !me.disabled && me.editable) 
  {
    me.lastKey = key;
    if (!e.isSpecialKey() || key == e.BACKSPACE || key == e.DELETE) 
    {
      me.doQueryTask.delay(me.queryDelay);
    }
  }
  if (me.enableKeyEvents) 
  {
    me.callParent(arguments);
  }
}, initEvents: function() {
  var me = this;
  me.callParent();
  if (!me.enableKeyEvents) 
  {
    me.mon(me.inputEl, 'keyup', me.onKeyUp, me);
  }
  me.mon(me.inputEl, 'paste', me.onPaste, me);
}, onDestroy: function() {
  var me = this;
  if (me.typeAheadTask) 
  {
    me.typeAheadTask.cancel();
    me.typeAheadTask = null;
  }
  Ext.destroy(me.listKeyNav);
  me.bindStore(null);
  me.callParent();
}, onAdded: function() {
  var me = this;
  me.callParent(arguments);
  if (me.picker) 
  {
    me.picker.ownerCt = me.up('[floating]');
    me.picker.registerWithOwnerCt();
  }
}, createPicker: function() {
  var me = this, picker, pickerCfg = Ext.apply({xtype: 'boundlist', pickerField: me, selModel: {mode: me.multiSelect ? 'SIMPLE' : 'SINGLE'}, floating: true, hidden: true, store: me.store, displayField: me.displayField, focusOnToFront: false, pageSize: me.pageSize, tpl: me.tpl}, me.listConfig, me.defaultListConfig);
  picker = me.picker = Ext.widget(pickerCfg);
  if (me.pageSize) 
  {
    picker.pagingToolbar.on('beforechange', me.onPageChange, me);
  }
  me.mon(picker, {itemclick: me.onItemClick, refresh: me.onListRefresh, scope: me});
  me.mon(picker.getSelectionModel(), {beforeselect: me.onBeforeSelect, beforedeselect: me.onBeforeDeselect, selectionchange: me.onListSelectionChange, scope: me});
  return picker;
}, alignPicker: function() {
  var me = this, picker = me.getPicker(), heightAbove = me.getPosition()[1] - Ext.getBody().getScroll().top, heightBelow = Ext.Element.getViewHeight() - heightAbove - me.getHeight(), space = Math.max(heightAbove, heightBelow);
  if (picker.height) 
  {
    delete picker.height;
    picker.updateLayout();
  }
  if (picker.getHeight() > space - 5) 
  {
    picker.setHeight(space - 5);
  }
  me.callParent();
}, onListRefresh: function() {
  if (!this.expanding) 
  {
    this.alignPicker();
  }
  this.syncSelection();
}, onItemClick: function(picker, record) {
  var me = this, selection = me.picker.getSelectionModel().getSelection(), valueField = me.valueField;
  if (!me.multiSelect && selection.length) 
  {
    if (record.get(valueField) === selection[0].get(valueField)) 
    {
      me.displayTplData = [record.data];
      me.setRawValue(me.getDisplayValue());
      me.collapse();
    }
  }
}, onBeforeSelect: function(list, record) {
  return this.fireEvent('beforeselect', this, record, record.index);
}, onBeforeDeselect: function(list, record) {
  return this.fireEvent('beforedeselect', this, record, record.index);
}, onListSelectionChange: function(list, selectedRecords) {
  var me = this, isMulti = me.multiSelect, hasRecords = selectedRecords.length > 0;
  if (!me.ignoreSelection && me.isExpanded) 
  {
    if (!isMulti) 
    {
      Ext.defer(me.collapse, 1, me);
    }
    if (isMulti || hasRecords) 
    {
      me.setValue(selectedRecords, false);
    }
    if (hasRecords) 
    {
      me.fireEvent('select', me, selectedRecords);
    }
    me.inputEl.focus();
  }
}, onExpand: function() {
  var me = this, keyNav = me.listKeyNav, selectOnTab = me.selectOnTab, picker = me.getPicker();
  if (keyNav) 
  {
    keyNav.enable();
  } else {
    keyNav = me.listKeyNav = new Ext.view.BoundListKeyNav(me.inputEl, {boundList: picker, forceKeyDown: true, tab: function(e) {
  if (selectOnTab) 
  {
    this.selectHighlighted(e);
    me.triggerBlur();
  }
  return true;
}, enter: function(e) {
  var selModel = picker.getSelectionModel(), count = selModel.getCount();
  this.selectHighlighted(e);
  if (!me.multiSelect && count === selModel.getCount()) 
  {
    me.collapse();
  }
}});
  }
  if (selectOnTab) 
  {
    me.ignoreMonitorTab = true;
  }
  Ext.defer(keyNav.enable, 1, keyNav);
  me.inputEl.focus();
}, onCollapse: function() {
  var me = this, keyNav = me.listKeyNav;
  if (keyNav) 
  {
    keyNav.disable();
    me.ignoreMonitorTab = false;
  }
}, select: function(r, assert) {
  var me = this, picker = me.picker, fireSelect;
  if (r && r.isModel && assert === true && picker) 
  {
    fireSelect = !picker.getSelectionModel().isSelected(r);
  }
  me.setValue(r, true);
  if (fireSelect) 
  {
    me.fireEvent('select', me, r);
  }
}, findRecord: function(field, value) {
  var ds = this.store, idx = ds.findExact(field, value);
  return idx !== -1 ? ds.getAt(idx) : false;
}, findRecordByValue: function(value) {
  return this.findRecord(this.valueField, value);
}, findRecordByDisplay: function(value) {
  return this.findRecord(this.displayField, value);
}, setValue: function(value, doSelect) {
  var me = this, valueNotFoundText = me.valueNotFoundText, inputEl = me.inputEl, i, len, record, dataObj, matchedRecords = [], displayTplData = [], processedValue = [];
  if (me.store.loading) 
  {
    me.value = value;
    me.setHiddenValue(me.value);
    return me;
  }
  value = Ext.Array.from(value);
  for (i = 0 , len = value.length; i < len; i++) 
    {
      record = value[i];
      if (!record || !record.isModel) 
      {
        record = me.findRecordByValue(record);
      }
      if (record) 
      {
        matchedRecords.push(record);
        displayTplData.push(record.data);
        processedValue.push(record.get(me.valueField));
      } else {
        if (!me.forceSelection) 
        {
          processedValue.push(value[i]);
          dataObj = {};
          dataObj[me.displayField] = value[i];
          displayTplData.push(dataObj);
        } else if (Ext.isDefined(valueNotFoundText)) 
        {
          displayTplData.push(valueNotFoundText);
        }
      }
    }
  me.setHiddenValue(processedValue);
  me.value = me.multiSelect ? processedValue : processedValue[0];
  if (!Ext.isDefined(me.value)) 
  {
    me.value = null;
  }
  me.displayTplData = displayTplData;
  me.lastSelection = me.valueModels = matchedRecords;
  if (inputEl && me.emptyText && !Ext.isEmpty(value)) 
  {
    inputEl.removeCls(me.emptyCls);
  }
  me.setRawValue(me.getDisplayValue());
  me.checkChange();
  if (doSelect !== false) 
  {
    me.syncSelection();
  }
  me.applyEmptyText();
  return me;
}, setHiddenValue: function(values) {
  var me = this, name = me.hiddenName, i, dom, childNodes, input, valueCount, childrenCount;
  if (!me.hiddenDataEl || !name) 
  {
    return;
  }
  values = Ext.Array.from(values);
  dom = me.hiddenDataEl.dom;
  childNodes = dom.childNodes;
  input = childNodes[0];
  valueCount = values.length;
  childrenCount = childNodes.length;
  if (!input && valueCount > 0) 
  {
    me.hiddenDataEl.update(Ext.DomHelper.markup({tag: 'input', type: 'hidden', name: name}));
    childrenCount = 1;
    input = dom.firstChild;
  }
  while (childrenCount > valueCount) 
    {
      dom.removeChild(childNodes[0]);
      --childrenCount;
    }
  while (childrenCount < valueCount) 
    {
      dom.appendChild(input.cloneNode(true));
      ++childrenCount;
    }
  for (i = 0; i < valueCount; i++) 
    {
      childNodes[i].value = values[i];
    }
}, getDisplayValue: function() {
  return this.displayTpl.apply(this.displayTplData);
}, getValue: function() {
  var me = this, picker = me.picker, rawValue = me.getRawValue(), value = me.value;
  if (me.getDisplayValue() !== rawValue) 
  {
    value = rawValue;
    me.value = me.displayTplData = me.valueModels = null;
    if (picker) 
    {
      me.ignoreSelection++;
      picker.getSelectionModel().deselectAll();
      me.ignoreSelection--;
    }
  }
  return value;
}, getSubmitValue: function() {
  var value = this.getValue();
  if (Ext.isEmpty(value)) 
  {
    value = '';
  }
  return value;
}, isEqual: function(v1, v2) {
  var fromArray = Ext.Array.from, i, len;
  v1 = fromArray(v1);
  v2 = fromArray(v2);
  len = v1.length;
  if (len !== v2.length) 
  {
    return false;
  }
  for (i = 0; i < len; i++) 
    {
      if (v2[i] !== v1[i]) 
      {
        return false;
      }
    }
  return true;
}, clearValue: function() {
  this.setValue([]);
}, syncSelection: function() {
  var me = this, picker = me.picker, selection, selModel, values = me.valueModels || [], vLen = values.length, v, value;
  if (picker) 
  {
    selection = [];
    for (v = 0; v < vLen; v++) 
      {
        value = values[v];
        if (value && value.isModel && me.store.indexOf(value) >= 0) 
        {
          selection.push(value);
        }
      }
    me.ignoreSelection++;
    selModel = picker.getSelectionModel();
    selModel.deselectAll();
    if (selection.length) 
    {
      selModel.select(selection, undefined, true);
    }
    me.ignoreSelection--;
  }
}, onEditorTab: function(e) {
  var keyNav = this.listKeyNav;
  if (this.selectOnTab && keyNav) 
  {
    keyNav.selectHighlighted(e);
  }
}}, 0, ["combo", "combobox"], ["component", "pickerfield", "field", "triggerfield", "textfield", "combo", "box", "trigger", "combobox"], {"component": true, "pickerfield": true, "field": true, "triggerfield": true, "textfield": true, "combo": true, "box": true, "trigger": true, "combobox": true}, ["widget.combo", "widget.combobox"], [['bindable', Ext.util.Bindable]], [Ext.form.field, 'ComboBox', Ext.form, 'ComboBox'], 0));
;

(Ext.cmd.derive('Ext.grid.CellContext', Ext.Base, {isCellContext: true, constructor: function(view) {
  this.view = view;
}, isEqual: function(other) {
  if (other) 
  {
    return this.record === other.record && this.columnHeader === other.columnHeader;
  }
  return false;
}, setPosition: function(row, col) {
  var me = this;
  if (arguments.length === 1) 
  {
    if (row.view) 
    {
      me.view = row.view;
    }
    col = row.column;
    row = row.row;
  }
  me.setRow(row);
  me.setColumn(col);
  return me;
}, setRow: function(row) {
  var me = this;
  if (row !== undefined) 
  {
    if (typeof row === 'number') 
    {
      me.row = Math.max(Math.min(row, me.view.dataSource.getCount() - 1), 0);
      me.record = me.view.dataSource.getAt(row);
    } else if (row.isModel) 
    {
      me.record = row;
      me.row = me.view.indexOf(row);
    } else if (row.tagName) 
    {
      me.record = me.view.getRecord(row);
      me.row = me.view.indexOf(me.record);
    }
  }
}, setColumn: function(col) {
  var me = this, mgr = me.view.ownerCt.getColumnManager();
  if (col !== undefined) 
  {
    if (typeof col === 'number') 
    {
      me.column = col;
      me.columnHeader = mgr.getHeaderAtIndex(col);
    } else if (col.isHeader) 
    {
      me.columnHeader = col;
      me.column = mgr.getHeaderIndex(col);
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.grid, 'CellContext'], 0));
;

(Ext.cmd.derive('Ext.grid.CellEditor', Ext.Editor, {y: 0, constructor: function(config) {
  config = Ext.apply({}, config);
  if (config.field) 
  {
    config.field.monitorTab = false;
  }
  this.callParent([config]);
}, setGrid: function(grid) {
  var me = this, oldGrid = me.grid, view, viewListeners;
  if (grid != oldGrid) 
  {
    viewListeners = {beforerefresh: me.beforeViewRefresh, refresh: me.onViewRefresh, scope: me};
    if (oldGrid) 
    {
      oldGrid.getView().un(viewListeners);
    }
    view = grid.getView() , me.renderTo = view.getTargetEl().dom;
    me.grid = me.ownerCt = grid;
    view.on(viewListeners);
  }
}, adjustPosition: function() {
  return {x: 0, y: 0};
}, beforeViewRefresh: function() {
  var me = this, dom = me.el && me.el.dom;
  if (dom && dom.parentNode) 
  {
    if (me.editing && !me.field.column.sorting) 
    {
      me.wasAllowBlur = me.allowBlur;
      me.allowBlur = false;
    }
    dom.parentNode.removeChild(dom);
  }
}, onViewRefresh: function() {
  var me = this, dom = me.el && me.el.dom, sorting;
  if (dom) 
  {
    sorting = me.field.column.sorting;
    if (me.editing && !sorting) 
    {
      me.allowBlur = me.wasAllowBlur;
      me.renderTo.appendChild(dom);
      me.field.focus();
    } else if (!sorting) 
    {
      Ext.getDetachedBody().dom.appendChild(dom);
    }
    if (me.editing && sorting) 
    {
      me.completeEdit();
    }
  }
}, onShow: function() {
  var me = this, innerCell = me.boundEl.first();
  if (me.el.dom.parentNode !== me.renderTo) 
  {
    me.renderTo.appendChild(me.el.dom);
  }
  if (innerCell) 
  {
    if (me.isForTree) 
    {
      innerCell = innerCell.child(me.treeNodeSelector);
    }
    innerCell.hide();
  }
  me.callParent(arguments);
}, onHide: function() {
  var me = this, innerCell = me.boundEl.first();
  if (innerCell) 
  {
    if (me.isForTree) 
    {
      innerCell = innerCell.child(me.treeNodeSelector);
    }
    innerCell.show();
  }
  me.callParent(arguments);
}, afterRender: function() {
  var me = this, field = me.field;
  me.callParent(arguments);
  if (field.isCheckbox) 
  {
    field.mon(field.inputEl, {mousedown: me.onCheckBoxMouseDown, click: me.onCheckBoxClick, scope: me});
  }
}, onCheckBoxMouseDown: function() {
  this.completeEdit = Ext.emptyFn;
}, onCheckBoxClick: function() {
  delete this.completeEdit;
  this.field.focus(false, 10);
}, realign: function(autoSize) {
  var me = this, boundEl = me.boundEl, innerCell = boundEl.first(), innerCellTextNode = innerCell.dom.firstChild, width = boundEl.getWidth(), offsets = Ext.Array.clone(me.offsets), grid = me.grid, xOffset, v = '', isEmpty = !innerCellTextNode || (innerCellTextNode.nodeType === 3 && !(Ext.String.trim(v = innerCellTextNode.data).length));
  if (me.isForTree) 
  {
    xOffset = me.getTreeNodeOffset(innerCell);
    width -= Math.abs(xOffset);
    offsets[0] += xOffset;
  }
  if (grid.columnLines) 
  {
    width -= boundEl.getBorderWidth('rl');
  }
  if (autoSize === true) 
  {
    me.field.setWidth(width);
  }
  if (isEmpty) 
  {
    innerCell.dom.innerHTML = 'X';
  }
  me.alignTo(innerCell, me.alignment, offsets);
  if (isEmpty) 
  {
    innerCell.dom.firstChild.data = v;
  }
}, getTreeNodeOffset: function(innerCell) {
  return innerCell.child(this.treeNodeSelector).getOffsetsTo(innerCell)[0];
}, onEditorTab: function(e) {
  var field = this.field;
  if (field.onEditorTab) 
  {
    field.onEditorTab(e);
  }
}, onFieldBlur: function() {
  this.callParent(arguments);
  this.selectSameEditor = false;
}, alignment: "l-l", hideEl: false, cls: Ext.baseCSSPrefix + 'small-editor ' + Ext.baseCSSPrefix + 'grid-editor ' + Ext.baseCSSPrefix + 'grid-cell-editor', treeNodeSelector: '.' + Ext.baseCSSPrefix + 'tree-node-text', shim: false, shadow: false}, 1, 0, ["container", "editor", "component", "box"], {"container": true, "editor": true, "component": true, "box": true}, 0, 0, [Ext.grid, 'CellEditor'], 0));
;

(Ext.cmd.derive('Ext.grid.ColumnComponentLayout', Ext.layout.component.Auto, {type: 'columncomponent', setWidthInDom: true, beginLayout: function(ownerContext) {
  this.callParent(arguments);
  ownerContext.titleContext = ownerContext.getEl('titleEl');
  ownerContext.triggerContext = ownerContext.getEl('triggerEl');
}, beginLayoutCycle: function(ownerContext) {
  var owner = this.owner;
  this.callParent(arguments);
  if (ownerContext.widthModel.shrinkWrap) 
  {
    owner.el.setWidth('');
  }
  owner.titleEl.setStyle({paddingTop: '', paddingBottom: ''});
}, publishInnerHeight: function(ownerContext, outerHeight) {
  var me = this, owner = me.owner, innerHeight, availableHeight, textHeight, titleHeight, paddingTop, paddingBottom;
  if (owner.getOwnerHeaderCt().hiddenHeaders) 
  {
    ownerContext.setProp('innerHeight', 0);
    return;
  }
  innerHeight = outerHeight - ownerContext.getBorderInfo().height;
  availableHeight = innerHeight;
  if (!owner.noWrap && !ownerContext.hasDomProp('width')) 
  {
    me.done = false;
    return;
  }
  if (ownerContext.hasRawContent) 
  {
    titleHeight = availableHeight;
    textHeight = owner.textEl.getHeight();
    if (textHeight) 
    {
      availableHeight -= textHeight;
      if (availableHeight > 0) 
      {
        paddingTop = Math.floor(availableHeight / 2);
        paddingBottom = availableHeight - paddingTop;
        ownerContext.titleContext.setProp('padding-top', paddingTop);
        ownerContext.titleContext.setProp('padding-bottom', paddingBottom);
      }
    }
  } else {
    titleHeight = owner.titleEl.getHeight();
    ownerContext.setProp('innerHeight', innerHeight - titleHeight, false);
  }
  if ((Ext.isIE6 || Ext.isIEQuirks) && ownerContext.triggerContext) 
  {
    ownerContext.triggerContext.setHeight(titleHeight);
  }
}, measureContentHeight: function(ownerContext) {
  return ownerContext.el.dom.offsetHeight;
}, publishOwnerHeight: function(ownerContext, contentHeight) {
  this.callParent(arguments);
  if ((Ext.isIE6 || Ext.isIEQuirks) && ownerContext.triggerContext) 
  {
    ownerContext.triggerContext.setHeight(contentHeight);
  }
}, publishInnerWidth: function(ownerContext, outerWidth) {
  if (!ownerContext.hasRawContent) 
  {
    ownerContext.setProp('innerWidth', outerWidth - ownerContext.getBorderInfo().width, false);
  }
}, calculateOwnerHeightFromContentHeight: function(ownerContext, contentHeight) {
  var result = this.callParent(arguments);
  if (!ownerContext.hasRawContent) 
  {
    if (this.owner.noWrap || ownerContext.hasDomProp('width')) 
    {
      return contentHeight + this.owner.titleEl.getHeight() + ownerContext.getBorderInfo().height;
    }
    return null;
  }
  return result;
}, calculateOwnerWidthFromContentWidth: function(ownerContext, contentWidth) {
  var owner = this.owner, padWidth = ownerContext.getPaddingInfo().width, triggerOffset = this.getTriggerOffset(owner, ownerContext), inner;
  if (owner.isGroupHeader) 
  {
    inner = contentWidth;
  } else {
    inner = Math.max(contentWidth, owner.textEl.getWidth() + ownerContext.titleContext.getPaddingInfo().width);
  }
  return inner + padWidth + triggerOffset;
}, getTriggerOffset: function(owner, ownerContext) {
  var width = 0;
  if (ownerContext.widthModel.shrinkWrap && !owner.menuDisabled) 
  {
    if (owner.query('>:not([hidden])').length === 0) 
    {
      width = owner.self.triggerElWidth;
    }
  }
  return width;
}}, 0, 0, 0, 0, ["layout.columncomponent"], 0, [Ext.grid, 'ColumnComponentLayout'], 0));
;

(Ext.cmd.derive('Ext.grid.ColumnLayout', Ext.layout.container.HBox, {type: 'gridcolumn', reserveOffset: false, firstHeaderCls: Ext.baseCSSPrefix + 'column-header-first', lastHeaderCls: Ext.baseCSSPrefix + 'column-header-last', initLayout: function() {
  var me = this;
  if (me.scrollbarWidth === undefined) 
  {
    me.self.prototype.scrollbarWidth = Ext.getScrollbarSize().width;
  }
  me.grid = me.owner.up('tablepanel');
  me.controllingGrid = me.owner.up('[scrollerOwner]');
  me.callParent();
}, beginLayout: function(ownerContext) {
  var me = this, owner = me.owner, grid = me.controllingGrid, view = me.grid.view, items = me.getVisibleItems(), len = items.length, firstCls = me.firstHeaderCls, lastCls = me.lastHeaderCls, removeCls = [firstCls, lastCls], i, item;
  if (!view.scrollFlags.y) 
  {
    me.scrollbarWidth = 0;
  } else {
    delete me.scrollbarWidth;
  }
  for (i = 0; i < len; i++) 
    {
      item = items[i];
      item.margin = null;
      item.removeCls(removeCls);
      if (i === 0) 
      {
        item.addCls(firstCls);
      }
      if (i === len - 1) 
      {
        item.addCls(lastCls);
      }
    }
  me.scrollbarAdjustment = me.scrollbarWidth;
  me.callParent(arguments);
  if (!owner.isColumn && !grid.collapsed && view && view.rendered && (ownerContext.viewTable = view.body.dom) && me.scrollbarWidth) 
  {
    ownerContext.viewContext = ownerContext.context.getCmp(view);
  }
}, injectViewContext: function(ownerContext, view) {
  if (!this.controllingGrid.collapsed && view.rendered && (ownerContext.viewTable = view.body.dom) && this.scrollbarWidth) 
  {
    ownerContext.viewContext = ownerContext.context.getCmp(view);
  }
}, roundFlex: function(width) {
  return Math.floor(width);
}, calculate: function(ownerContext) {
  this.callParent(arguments);
  if (ownerContext.state.parallelDone && !(this.owner.forceFit && !ownerContext.state.flexesCalculated)) 
  {
    ownerContext.setProp('columnWidthsDone', true);
  }
  if (ownerContext.viewContext) 
  {
    ownerContext.state.tableHeight = ownerContext.viewTable.offsetHeight;
  }
}, completeLayout: function(ownerContext) {
  var me = this, owner = me.owner, state = ownerContext.state;
  me.callParent(arguments);
  if (ownerContext.viewTable && !state.flexesCalculated && !ownerContext.flexedItems.length && owner.forceFit && me.convertWidthsToFlexes(ownerContext)) 
  {
    me.cacheFlexes(ownerContext);
    ownerContext.invalidate({state: {flexesCalculated: true, tableHeight: ownerContext.viewTable.offsetHeight}});
  } else {
    ownerContext.setProp('columnWidthsDone', true);
  }
}, finishedLayout: function(ownerContext) {
  var view = this.grid.getView();
  this.callParent(arguments);
  if (!this.owner.isColumn && view.scrollFlags.x && this.owner.tooNarrow && this.owner.componentLayoutCounter) 
  {
    this.owner.el.dom.scrollLeft = view.el.dom.scrollLeft;
  }
}, convertWidthsToFlexes: function(ownerContext) {
  var me = this, totalWidth = 0, calculated = me.sizeModels.calculated, childItems, len, i, childContext, item;
  childItems = ownerContext.childItems;
  len = childItems.length;
  for (i = 0; i < len; i++) 
    {
      childContext = childItems[i];
      item = childContext.target;
      totalWidth += childContext.props.width;
      if (!(item.fixed || item.resizable === false)) 
      {
        item.flex = ownerContext.childItems[i].flex = childContext.props.width;
        item.width = null;
        childContext.widthModel = calculated;
      }
    }
  return totalWidth !== ownerContext.props.width;
}, getContainerSize: function(ownerContext) {
  var me = this, result, viewContext = ownerContext.viewContext, viewHeight, viewLayoutContext, shrinkWrapHeight = viewContext && viewContext.heightModel.shrinkWrap;
  if (me.owner.isColumn) 
  {
    result = me.getColumnContainerSize(ownerContext);
  } else {
    result = me.callParent(arguments);
    if (me.scrollbarWidth && !me.controllingGrid.reserveScrollbar && viewContext) 
    {
      viewLayoutContext = viewContext.target.componentLayout.ownerContext;
      if (!shrinkWrapHeight && viewContext.target.scrollFlags.y && (ownerContext.flexedItems && ownerContext.flexedItems.length || me.owner.forceFit) && viewLayoutContext) 
      {
        viewHeight = viewContext.getProp('height');
        if (isNaN(viewHeight)) 
        {
          me.done = false;
        } else if (ownerContext.state.tableHeight <= viewHeight && viewContext.target.scrollFlags.y) 
        {
          ownerContext.state.parallelDone = false;
          viewLayoutContext.invalidate();
          return result;
        }
      }
    }
  }
  if (!shrinkWrapHeight) 
  {
    result.width -= me.scrollbarWidth;
  }
  return result;
}, getColumnContainerSize: function(ownerContext) {
  var padding = ownerContext.paddingContext.getPaddingInfo(), got = 0, needed = 0, gotWidth, gotHeight, width, height;
  if (!ownerContext.widthModel.shrinkWrap) 
  {
    ++needed;
    width = ownerContext.getProp('innerWidth');
    gotWidth = (typeof width == 'number');
    if (gotWidth) 
    {
      ++got;
      width -= padding.width;
      if (width < 0) 
      {
        width = 0;
      }
    }
  }
  if (!ownerContext.heightModel.shrinkWrap) 
  {
    ++needed;
    height = ownerContext.getProp('innerHeight');
    gotHeight = (typeof height == 'number');
    if (gotHeight) 
    {
      ++got;
      height -= padding.height;
      if (height < 0) 
      {
        height = 0;
      }
    }
  }
  return {width: width, height: height, needed: needed, got: got, gotAll: got == needed, gotWidth: gotWidth, gotHeight: gotHeight};
}, publishInnerCtSize: function(ownerContext) {
  var me = this, owner = me.owner, size = ownerContext.state.boxPlan.targetSize, cw = ownerContext.peek('contentWidth');
  me.owner.tooNarrow = ownerContext.state.boxPlan.tooNarrow;
  if ((cw != null) && !owner.isColumn) 
  {
    size.width = cw;
    if (owner.ownerCt.view.scrollFlags.y) 
    {
      size.width += me.scrollbarAdjustment;
    }
  }
  return me.callParent(arguments);
}}, 0, 0, 0, 0, ["layout.gridcolumn"], 0, [Ext.grid, 'ColumnLayout'], 0));
;

(Ext.cmd.derive('Ext.grid.ColumnManager', Ext.Base, {alternateClassName: ['Ext.grid.ColumnModel'], columns: null, constructor: function(visibleOnly, headerCt, secondHeaderCt) {
  this.headerCt = headerCt;
  if (secondHeaderCt) 
  {
    this.secondHeaderCt = secondHeaderCt;
  }
  this.visibleOnly = !!visibleOnly;
}, getColumns: function() {
  if (!this.columns) 
  {
    this.cacheColumns();
  }
  return this.columns;
}, getHeaderIndex: function(header) {
  if (header.isGroupHeader) 
  {
    header = this.getHeaderColumns(header)[0];
  }
  return Ext.Array.indexOf(this.getColumns(), header);
}, getHeaderAtIndex: function(index) {
  var columns = this.getColumns(), col = columns[index];
  return col || null;
}, getPreviousSibling: function(header) {
  var index = this.getHeaderIndex(header), col = null;
  if (index > 0) 
  {
    col = this.getColumns()[index - 1];
  }
  return col;
}, getNextSibling: function(header) {
  var index = this.getHeaderIndex(header), col;
  if (index !== -1) 
  {
    col = this.getColumns()[index + 1];
  }
  return col || null;
}, getFirst: function() {
  var columns = this.getColumns();
  return columns.length > 0 ? columns[0] : null;
}, getLast: function() {
  var columns = this.getColumns(), len = columns.length;
  return len > 0 ? columns[len - 1] : null;
}, getHeaderById: function(id) {
  var columns = this.getColumns(), len = columns.length, i, header;
  for (i = 0; i < len; ++i) 
    {
      header = columns[i];
      if (header.getItemId() === id) 
      {
        return header;
      }
    }
  return null;
}, getVisibleHeaderClosestToIndex: function(index) {
  var result = this.getHeaderAtIndex(index);
  if (result && result.hidden) 
  {
    result = result.next(':not([hidden])') || result.prev(':not([hidden])');
  }
  return result;
}, cacheColumns: function() {
  var columns = this.getHeaderColumns(this.headerCt), second = this.secondHeaderCt;
  if (second) 
  {
    columns = columns.concat(this.getHeaderColumns(second));
  }
  this.columns = columns;
}, getHeaderColumns: function(header) {
  var result = this.visibleOnly ? header.getVisibleGridColumns() : header.getGridColumns();
  return Ext.Array.clone(result);
}, invalidate: function() {
  var root = this.rootColumns;
  this.columns = null;
  if (root) 
  {
    root.invalidate();
  }
}, destroy: function() {
  this.columns = this.rootColumns = null;
}}, 1, 0, 0, 0, 0, 0, [Ext.grid, 'ColumnManager', Ext.grid, 'ColumnModel'], function() {
  this.createAlias('indexOf', 'getHeaderIndex');
}));
;

(Ext.cmd.derive('Ext.layout.container.Fit', Ext.layout.container.Container, {alternateClassName: 'Ext.layout.FitLayout', itemCls: Ext.baseCSSPrefix + 'fit-item', targetCls: Ext.baseCSSPrefix + 'layout-fit', type: 'fit', defaultMargins: {top: 0, right: 0, bottom: 0, left: 0}, manageMargins: true, sizePolicies: {0: {readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0}, 1: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0}, 2: {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1}, 3: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1}}, getItemSizePolicy: function(item, ownerSizeModel) {
  var sizeModel = ownerSizeModel || this.owner.getSizeModel(), mode = (sizeModel.width.shrinkWrap ? 0 : 1) | (sizeModel.height.shrinkWrap ? 0 : 2);
  return this.sizePolicies[mode];
}, beginLayoutCycle: function(ownerContext, firstCycle) {
  var me = this, resetHeight = me.lastHeightModel && me.lastHeightModel.calculated, resetWidth = me.lastWidthModel && me.lastWidthModel.calculated, resetSizes = resetWidth || resetHeight, maxChildMinHeight = 0, maxChildMinWidth = 0, c, childItems, i, item, length, margins, minHeight, minWidth, style, undef;
  me.callParent(arguments);
  if (resetSizes && ownerContext.targetContext.el.dom.tagName.toUpperCase() != 'TD') 
  {
    resetSizes = resetWidth = resetHeight = false;
  }
  childItems = ownerContext.childItems;
  length = childItems.length;
  for (i = 0; i < length; ++i) 
    {
      item = childItems[i];
      if (firstCycle) 
      {
        c = item.target;
        minHeight = c.minHeight;
        minWidth = c.minWidth;
        if (minWidth || minHeight) 
        {
          margins = item.marginInfo || item.getMarginInfo();
          minHeight += margins.height;
          minWidth += margins.height;
          if (maxChildMinHeight < minHeight) 
          {
            maxChildMinHeight = minHeight;
          }
          if (maxChildMinWidth < minWidth) 
          {
            maxChildMinWidth = minWidth;
          }
        }
      }
      if (resetSizes) 
      {
        style = item.el.dom.style;
        if (resetHeight) 
        {
          style.height = '';
        }
        if (resetWidth) 
        {
          style.width = '';
        }
      }
    }
  if (firstCycle) 
  {
    ownerContext.maxChildMinHeight = maxChildMinHeight;
    ownerContext.maxChildMinWidth = maxChildMinWidth;
  }
  c = ownerContext.target;
  ownerContext.overflowX = (!ownerContext.widthModel.shrinkWrap && ownerContext.maxChildMinWidth && c.scrollFlags.x) || undef;
  ownerContext.overflowY = (!ownerContext.heightModel.shrinkWrap && ownerContext.maxChildMinHeight && c.scrollFlags.y) || undef;
}, calculate: function(ownerContext) {
  var me = this, childItems = ownerContext.childItems, length = childItems.length, containerSize = me.getContainerSize(ownerContext), info = {length: length, ownerContext: ownerContext, targetSize: containerSize}, shrinkWrapWidth = ownerContext.widthModel.shrinkWrap, shrinkWrapHeight = ownerContext.heightModel.shrinkWrap, overflowX = ownerContext.overflowX, overflowY = ownerContext.overflowY, scrollbars, scrollbarSize, padding, i, contentWidth, contentHeight;
  if (overflowX || overflowY) 
  {
    scrollbars = me.getScrollbarsNeeded(overflowX && containerSize.width, overflowY && containerSize.height, ownerContext.maxChildMinWidth, ownerContext.maxChildMinHeight);
    if (scrollbars) 
    {
      scrollbarSize = Ext.getScrollbarSize();
      if (scrollbars & 1) 
      {
        containerSize.height -= scrollbarSize.height;
      }
      if (scrollbars & 2) 
      {
        containerSize.width -= scrollbarSize.width;
      }
    }
  }
  if (length > 0) 
  {
    for (i = 0; i < length; ++i) 
      {
        info.index = i;
        me.fitItem(childItems[i], info);
      }
  } else {
    info.contentWidth = info.contentHeight = 0;
  }
  if (shrinkWrapHeight || shrinkWrapWidth) 
  {
    padding = ownerContext.targetContext.getPaddingInfo();
    if (shrinkWrapWidth) 
    {
      if (overflowY && !containerSize.gotHeight) 
      {
        me.done = false;
      } else {
        contentWidth = info.contentWidth + padding.width;
        if (scrollbars & 2) 
        {
          contentWidth += scrollbarSize.width;
        }
        if (!ownerContext.setContentWidth(contentWidth)) 
        {
          me.done = false;
        }
      }
    }
    if (shrinkWrapHeight) 
    {
      if (overflowX && !containerSize.gotWidth) 
      {
        me.done = false;
      } else {
        contentHeight = info.contentHeight + padding.height;
        if (scrollbars & 1) 
        {
          contentHeight += scrollbarSize.height;
        }
        if (!ownerContext.setContentHeight(contentHeight)) 
        {
          me.done = false;
        }
      }
    }
  }
}, fitItem: function(itemContext, info) {
  var me = this;
  if (itemContext.invalid) 
  {
    me.done = false;
    return;
  }
  info.margins = itemContext.getMarginInfo();
  info.needed = info.got = 0;
  me.fitItemWidth(itemContext, info);
  me.fitItemHeight(itemContext, info);
  if (info.got != info.needed) 
  {
    me.done = false;
  }
}, fitItemWidth: function(itemContext, info) {
  var contentWidth, width;
  if (info.ownerContext.widthModel.shrinkWrap) 
  {
    width = itemContext.getProp('width') + info.margins.width;
    contentWidth = info.contentWidth;
    if (contentWidth === undefined) 
    {
      info.contentWidth = width;
    } else {
      info.contentWidth = Math.max(contentWidth, width);
    }
  } else if (itemContext.widthModel.calculated) 
  {
    ++info.needed;
    if (info.targetSize.gotWidth) 
    {
      ++info.got;
      this.setItemWidth(itemContext, info);
    }
  }
  this.positionItemX(itemContext, info);
}, fitItemHeight: function(itemContext, info) {
  var contentHeight, height;
  if (info.ownerContext.heightModel.shrinkWrap) 
  {
    height = itemContext.getProp('height') + info.margins.height;
    contentHeight = info.contentHeight;
    if (contentHeight === undefined) 
    {
      info.contentHeight = height;
    } else {
      info.contentHeight = Math.max(contentHeight, height);
    }
  } else if (itemContext.heightModel.calculated) 
  {
    ++info.needed;
    if (info.targetSize.gotHeight) 
    {
      ++info.got;
      this.setItemHeight(itemContext, info);
    }
  }
  this.positionItemY(itemContext, info);
}, positionItemX: function(itemContext, info) {
  var margins = info.margins;
  if (info.index || margins.left) 
  {
    itemContext.setProp('x', margins.left);
  }
  if (margins.width) 
  {
    itemContext.setProp('margin-right', margins.width);
  }
}, positionItemY: function(itemContext, info) {
  var margins = info.margins;
  if (info.index || margins.top) 
  {
    itemContext.setProp('y', margins.top);
  }
  if (margins.height) 
  {
    itemContext.setProp('margin-bottom', margins.height);
  }
}, setItemHeight: function(itemContext, info) {
  itemContext.setHeight(info.targetSize.height - info.margins.height);
}, setItemWidth: function(itemContext, info) {
  itemContext.setWidth(info.targetSize.width - info.margins.width);
}}, 0, 0, 0, 0, ["layout.fit"], 0, [Ext.layout.container, 'Fit', Ext.layout, 'FitLayout'], 0));
;

(Ext.cmd.derive('Ext.panel.Table', Ext.panel.Panel, {extraBaseCls: Ext.baseCSSPrefix + 'grid', extraBodyCls: Ext.baseCSSPrefix + 'grid-body', layout: 'fit', hasView: false, viewType: null, selType: 'rowmodel', scroll: true, deferRowRender: true, sortableColumns: true, multiColumnSort: false, enableLocking: false, scrollerOwner: true, enableColumnMove: true, sealedColumns: false, enableColumnResize: true, rowLines: true, colLinesCls: Ext.baseCSSPrefix + 'grid-with-col-lines', rowLinesCls: Ext.baseCSSPrefix + 'grid-with-row-lines', noRowLinesCls: Ext.baseCSSPrefix + 'grid-no-row-lines', hiddenHeaderCtCls: Ext.baseCSSPrefix + 'grid-header-ct-hidden', hiddenHeaderCls: Ext.baseCSSPrefix + 'grid-header-hidden', resizeMarkerCls: Ext.baseCSSPrefix + 'grid-resize-marker', emptyCls: Ext.baseCSSPrefix + 'grid-empty', initComponent: function() {
  var me = this, headerCtCfg = me.columns || me.colModel, view, i, len, store = me.store = Ext.data.StoreManager.lookup(me.store || 'ext-empty-store'), columns;
  if (me.plugins) 
  {
    me.plugins = me.constructPlugins();
  }
  if (me.columnLines) 
  {
    me.addBodyCls(me.colLinesCls);
  }
  me.addBodyCls(me.rowLines ? me.rowLinesCls : me.noRowLinesCls);
  me.addBodyCls(me.extraBodyCls);
  if (headerCtCfg.isRootHeader) 
  {
    me.headerCt = headerCtCfg;
    me.headerCt.forceFit = !!me.forceFit;
    me.columnManager = headerCtCfg.columnManager;
    me.visibleColumnManager = headerCtCfg.visibleColumnManager;
    if (me.columnLines) 
    {
      me.headerCt.cascade(function(h) {
  if (!h.isColumn) 
  {
    h.columnLines = true;
  }
});
    }
  } else {
    if (me.enableLocking || me.hasLockedColumns(headerCtCfg)) 
    {
      me.self.mixin('lockable', Ext.grid.locking.Lockable);
      me.injectLockable();
    } else {
      if (Ext.isArray(headerCtCfg)) 
      {
        headerCtCfg = {items: headerCtCfg};
      }
      Ext.apply(headerCtCfg, {grid: me, forceFit: me.forceFit, sortable: me.sortableColumns, enableColumnMove: me.enableColumnMove, enableColumnResize: me.enableColumnResize, columnLines: me.columnLines, sealed: me.sealedColumns});
      if (Ext.isDefined(me.enableColumnHide)) 
      {
        headerCtCfg.enableColumnHide = me.enableColumnHide;
      }
      if (!me.headerCt) 
      {
        me.headerCt = new Ext.grid.header.Container(headerCtCfg);
      }
    }
  }
  me.columns = columns = me.headerCt.getGridColumns();
  me.scrollTask = new Ext.util.DelayedTask(me.syncHorizontalScroll, me);
  me.addEvents('reconfigure', 'viewready');
  me.cls = (me.cls || '') + (' ' + me.extraBaseCls);
  delete me.autoScroll;
  if (!me.hasView) 
  {
    if (store.buffered && !store.remoteSort) 
    {
      for (i = 0 , len = columns.length; i < len; i++) 
        {
          columns[i].sortable = false;
        }
    }
    if (me.hideHeaders) 
    {
      me.headerCt.height = 0;
      me.headerCt.hiddenHeaders = true;
      me.headerCt.addCls(me.hiddenHeaderCtCls);
      me.addCls(me.hiddenHeaderCls);
      if (Ext.isIEQuirks) 
      {
        me.headerCt.style = {display: 'none'};
      }
    }
    me.relayHeaderCtEvents(me.headerCt);
    me.features = me.features || [];
    if (!Ext.isArray(me.features)) 
    {
      me.features = [me.features];
    }
    me.dockedItems = [].concat(me.dockedItems || []);
    me.dockedItems.unshift(me.headerCt);
    me.viewConfig = me.viewConfig || {};
    view = me.getView();
    me.items = [view];
    me.hasView = true;
    if (!me.hideHeaders) 
    {
      view.on({scroll: {fn: me.onHorizontalScroll, element: 'el', scope: me}});
    }
    me.bindStore(store, true);
    me.mon(view, {viewready: me.onViewReady, refresh: me.onRestoreHorzScroll, scope: me});
  }
  me.relayEvents(me.view, ['beforeitemmousedown', 'beforeitemmouseup', 'beforeitemmouseenter', 'beforeitemmouseleave', 'beforeitemclick', 'beforeitemdblclick', 'beforeitemcontextmenu', 'itemmousedown', 'itemmouseup', 'itemmouseenter', 'itemmouseleave', 'itemclick', 'itemdblclick', 'itemcontextmenu', 'beforecellclick', 'cellclick', 'beforecelldblclick', 'celldblclick', 'beforecellcontextmenu', 'cellcontextmenu', 'beforecellmousedown', 'cellmousedown', 'beforecellmouseup', 'cellmouseup', 'beforecellkeydown', 'cellkeydown', 'beforeitemkeydown', 'itemkeydown', 'beforecontainermousedown', 'beforecontainermouseup', 'beforecontainermouseover', 'beforecontainermouseout', 'beforecontainerclick', 'beforecontainerdblclick', 'beforecontainercontextmenu', 'beforecontainerkeydown', 'containermouseup', 'containermousedown', 'containermouseover', 'containermouseout', 'containerclick', 'containerdblclick', 'containercontextmenu', 'containerkeydown', 'selectionchange', 'beforeselect', 'select', 'beforedeselect', 'deselect']);
  me.callParent(arguments);
  me.addStateEvents(['columnresize', 'columnmove', 'columnhide', 'columnshow', 'sortchange', 'filterchange', 'groupchange']);
}, hasLockedColumns: function(columns) {
  var i, len, column;
  if (Ext.isObject(columns)) 
  {
    columns = columns.items;
  }
  for (i = 0 , len = columns.length; i < len; i++) 
    {
      column = columns[i];
      if (!column.processed && column.locked) 
      {
        return true;
      }
    }
}, relayHeaderCtEvents: function(headerCt) {
  this.relayEvents(headerCt, ['columnresize', 'columnmove', 'columnhide', 'columnshow', 'columnschanged', 'sortchange', 'headerclick', 'headercontextmenu', 'headertriggerclick']);
}, getState: function() {
  var me = this, state = me.callParent(), storeState = me.store.getState();
  state = me.addPropertyToState(state, 'columns', me.headerCt.getColumnsState());
  if (storeState) 
  {
    state.storeState = storeState;
  }
  return state;
}, applyState: function(state) {
  var me = this, sorter = state.sort, storeState = state.storeState, store = me.store, columns = state.columns;
  delete state.columns;
  me.callParent(arguments);
  if (columns) 
  {
    me.headerCt.applyColumnsState(columns);
  }
  if (sorter) 
  {
    if (store.remoteSort) 
    {
      store.sort({property: sorter.property, direction: sorter.direction, root: sorter.root}, null, false);
    } else {
      store.sort(sorter.property, sorter.direction);
    }
  } else if (storeState) 
  {
    store.applyState(storeState);
  }
}, getStore: function() {
  return this.store;
}, getView: function() {
  var me = this, sm;
  if (!me.view) 
  {
    sm = me.getSelectionModel();
    Ext.widget(Ext.apply({grid: me, deferInitialRefresh: me.deferRowRender !== false, trackOver: me.trackMouseOver !== false, scroll: me.scroll, xtype: me.viewType, store: me.store, headerCt: me.headerCt, columnLines: me.columnLines, rowLines: me.rowLines, selModel: sm, features: me.features, panel: me, emptyText: me.emptyText || ''}, me.viewConfig));
    if (me.view.emptyText) 
    {
      me.view.emptyText = '<div class="' + me.emptyCls + '">' + me.view.emptyText + '</div>';
    }
    me.view.getComponentLayout().headerCt = me.headerCt;
    me.mon(me.view, {uievent: me.processEvent, scope: me});
    sm.view = me.view;
    me.headerCt.view = me.view;
    if (me.hasListeners.viewcreated) 
    {
      me.fireEvent('viewcreated', me, me.view);
    }
  }
  return me.view;
}, getColumnManager: function() {
  return this.columnManager;
}, getVisibleColumnManager: function() {
  return this.visibleColumnManager;
}, getTopLevelColumnManager: function() {
  var ownerLock = this.ownerLockable;
  return ownerLock ? ownerLock.getColumnManager() : this.getColumnManager();
}, getTopLevelVisibleColumnManager: function() {
  var ownerLock = this.ownerLockable;
  return ownerLock ? ownerLock.getVisibleColumnManager() : this.getVisibleColumnManager();
}, setAutoScroll: Ext.emptyFn, processEvent: function(type, view, cell, recordIndex, cellIndex, e, record, row) {
  var me = this, header;
  if (cellIndex !== -1) 
  {
    header = me.getColumnManager().getHeaderAtIndex(cellIndex);
    return header.processEvent.apply(header, arguments);
  }
}, determineScrollbars: function() {
}, invalidateScroller: function() {
}, scrollByDeltaY: function(yDelta, animate) {
  this.getView().scrollBy(0, yDelta, animate);
}, scrollByDeltaX: function(xDelta, animate) {
  this.getView().scrollBy(xDelta, 0, animate);
}, afterCollapse: function() {
  this.saveScrollPos();
  this.callParent(arguments);
}, afterExpand: function() {
  this.callParent(arguments);
  this.restoreScrollPos();
}, saveScrollPos: Ext.emptyFn, restoreScrollPos: Ext.emptyFn, onHeaderResize: Ext.emptyFn, onHeaderMove: function(headerCt, header, colsToMove, fromIdx, toIdx) {
  var me = this;
  if (me.optimizedColumnMove === false) 
  {
    me.view.refreshView();
  } else {
    me.view.moveColumn(fromIdx, toIdx, colsToMove);
  }
  me.delayScroll();
}, onHeaderHide: function(headerCt, header) {
  if (this.view.refreshCounter) 
  {
    this.view.refreshView();
  }
}, onHeaderShow: function(headerCt, header) {
  if (this.view.refreshCounter) 
  {
    this.view.refreshView();
  }
}, onHeadersChanged: function(headerCt, header) {
  var me = this;
  if (me.rendered && !me.reconfiguring) 
  {
    me.view.refreshView();
    me.delayScroll();
  }
}, delayScroll: function() {
  var target = this.getScrollTarget().el;
  if (target) 
  {
    this.scrollTask.delay(10, null, null, [target.dom]);
  }
}, onViewReady: function() {
  this.fireEvent('viewready', this);
}, onRestoreHorzScroll: function() {
  var left = this.scrollLeft;
  if (left) 
  {
    this.syncHorizontalScroll(this, true);
  }
}, getScrollerOwner: function() {
  var rootCmp = this;
  if (!this.scrollerOwner) 
  {
    rootCmp = this.up('[scrollerOwner]');
  }
  return rootCmp;
}, getLhsMarker: function() {
  var me = this;
  return me.lhsMarker || (me.lhsMarker = Ext.DomHelper.append(me.el, {role: 'presentation', cls: me.resizeMarkerCls}, true));
}, getRhsMarker: function() {
  var me = this;
  return me.rhsMarker || (me.rhsMarker = Ext.DomHelper.append(me.el, {role: 'presentation', cls: me.resizeMarkerCls}, true));
}, getSelectionModel: function() {
  var me = this, selModel = me.selModel, applyMode, mode, type;
  if (!selModel) 
  {
    selModel = {};
    applyMode = true;
  }
  if (!selModel.events) 
  {
    type = selModel.selType || me.selType;
    applyMode = !selModel.mode;
    selModel = me.selModel = Ext.create('selection.' + type, selModel);
  }
  if (me.simpleSelect) 
  {
    mode = 'SIMPLE';
  } else if (me.multiSelect) 
  {
    mode = 'MULTI';
  }
  Ext.applyIf(selModel, {allowDeselect: me.allowDeselect});
  if (mode && applyMode) 
  {
    selModel.setSelectionMode(mode);
  }
  if (!selModel.hasRelaySetup) 
  {
    me.relayEvents(selModel, ['selectionchange', 'beforeselect', 'beforedeselect', 'select', 'deselect']);
    selModel.hasRelaySetup = true;
  }
  if (me.disableSelection) 
  {
    selModel.locked = true;
  }
  return selModel;
}, getScrollTarget: function() {
  var owner = this.getScrollerOwner(), items = owner.query('tableview');
  return items[1] || items[0];
}, onHorizontalScroll: function(event, target) {
  this.syncHorizontalScroll(target);
}, syncHorizontalScroll: function(target, setBody) {
  var me = this, left = target.scrollLeft, scrollTarget;
  setBody = setBody === true;
  if (me.rendered && (setBody || left !== me.scrollLeft)) 
  {
    if (setBody) 
    {
      scrollTarget = me.getScrollTarget();
      scrollTarget.el.dom.scrollLeft = left;
    }
    me.headerCt.el.dom.scrollLeft = left;
    me.scrollLeft = left;
  }
}, onStoreLoad: Ext.emptyFn, getEditorParent: function() {
  return this.body;
}, bindStore: function(store, initial) {
  var me = this, view = me.getView(), bufferedStore = store && store.buffered, bufferedRenderer;
  if (store) 
  {
    me.store = store;
    bufferedRenderer = me.findPlugin('bufferedrenderer');
    if (bufferedRenderer) 
    {
      me.verticalScroller = bufferedRenderer;
      if (bufferedRenderer.store) 
      {
        bufferedRenderer.bindStore(store);
      }
    } else if (bufferedStore) 
    {
      me.verticalScroller = bufferedRenderer = me.addPlugin(Ext.apply({ptype: 'bufferedrenderer'}, me.initialConfig.verticalScroller));
    }
    if (view.store !== store) 
    {
      view.bindStore(store, false);
    }
    me.mon(store, {load: me.onStoreLoad, scope: me});
    me.storeRelayers = me.relayEvents(store, ['filterchange', 'groupchange']);
    if (bufferedRenderer) 
    {
      me.invalidateScrollerOnRefresh = false;
    }
    if (me.invalidateScrollerOnRefresh !== undefined) 
    {
      view.preserveScrollOnRefresh = !me.invalidateScrollerOnRefresh;
    }
  } else {
    me.unbindStore();
  }
}, unbindStore: function() {
  var me = this, store = me.store, view;
  if (store) 
  {
    me.store = null;
    me.mun(store, {load: me.onStoreLoad, scope: me});
    Ext.destroy(me.storeRelayers);
    view = me.view;
    if (view.store) 
    {
      view.bindStore(null);
    }
  }
}, reconfigure: function(store, columns) {
  var me = this, view = me.getView(), originalDeferinitialRefresh, oldStore = me.store, headerCt = me.headerCt, oldColumns = headerCt ? headerCt.items.getRange() : me.columns;
  if (arguments.length === 1 && Ext.isArray(store)) 
  {
    columns = store;
    store = null;
  }
  if (columns) 
  {
    columns = Ext.Array.slice(columns);
  }
  me.reconfiguring = true;
  me.fireEvent('beforereconfigure', me, store, columns, oldStore, oldColumns);
  if (me.lockable) 
  {
    me.reconfigureLockable(store, columns);
  } else {
    Ext.suspendLayouts();
    if (columns) 
    {
      delete me.scrollLeft;
      headerCt.removeAll();
      headerCt.add(columns);
    }
    if (store && (store = Ext.StoreManager.lookup(store)) !== oldStore) 
    {
      if (me.store) 
      {
        me.unbindStore();
      }
      originalDeferinitialRefresh = view.deferInitialRefresh;
      view.deferInitialRefresh = false;
      me.bindStore(store);
      view.deferInitialRefresh = originalDeferinitialRefresh;
    } else {
      me.getView().refreshView();
    }
    headerCt.setSortState();
    Ext.resumeLayouts(true);
  }
  me.fireEvent('reconfigure', me, store, columns, oldStore, oldColumns);
  delete me.reconfiguring;
}, beforeDestroy: function() {
  var task = this.scrollTask;
  if (task) 
  {
    task.cancel();
    this.scrollTask = null;
  }
  this.callParent();
}, onDestroy: function() {
  var me = this;
  if (me.lockable) 
  {
    me.destroyLockable();
  }
  me.callParent();
  me.columns = me.storeRelayers = me.columnManager = me.visibleColumnManager = null;
}, destroy: function() {
  var me = this;
  me.callParent();
  if (me.isDestroyed) 
  {
    me.view = me.selModel = me.headerCt = null;
  }
}}, 0, ["tablepanel"], ["container", "component", "box", "panel", "tablepanel"], {"container": true, "component": true, "box": true, "panel": true, "tablepanel": true}, ["widget.tablepanel"], 0, [Ext.panel, 'Table'], 0));
;

(Ext.cmd.derive('Ext.util.CSS', Ext.Base, function() {
  var CSS, rules = null, doc = document, camelRe = /(-[a-z])/gi, camelFn = function(m, a) {
  return a.charAt(1).toUpperCase();
};
  return {singleton: true, rules: rules, initialized: false, constructor: function() {
  CSS = this;
}, createStyleSheet: function(cssText, id) {
  var ss, head = doc.getElementsByTagName('head')[0], styleEl = doc.createElement('style');
  styleEl.setAttribute('type', 'text/css');
  if (id) 
  {
    styleEl.setAttribute('id', id);
  }
  ss = styleEl.styleSheet;
  if (ss) 
  {
    head.appendChild(styleEl);
    ss.cssText = cssText;
  } else {
    styleEl.appendChild(doc.createTextNode(cssText));
    head.appendChild(styleEl);
    ss = styleEl.sheet;
  }
  CSS.cacheStyleSheet(ss);
  return ss;
}, removeStyleSheet: function(id) {
  var existing = doc.getElementById(id);
  if (existing) 
  {
    existing.parentNode.removeChild(existing);
  }
}, swapStyleSheet: function(id, url) {
  var ss;
  CSS.removeStyleSheet(id);
  ss = doc.createElement("link");
  ss.setAttribute("rel", "stylesheet");
  ss.setAttribute("type", "text/css");
  ss.setAttribute("id", id);
  ss.setAttribute("href", url);
  doc.getElementsByTagName("head")[0].appendChild(ss);
}, cacheStyleSheet: function(ss) {
  if (!rules) 
  {
    rules = CSS.rules = {};
  }
  try {
    var ssRules = ss.cssRules || ss.rules, i = ssRules.length - 1, imports = ss.imports, len = imports ? imports.length : 0, rule, j;
    for (j = 0; j < len; ++j) 
      {
        CSS.cacheStyleSheet(imports[j]);
      }
    for (; i >= 0; --i) 
      {
        rule = ssRules[i];
        if (rule.styleSheet) 
        {
          CSS.cacheStyleSheet(rule.styleSheet);
        }
        CSS.cacheRule(rule, ss);
      }
  }  catch (e) {
}
}, cacheRule: function(cssRule, styleSheet) {
  if (cssRule.styleSheet) 
  {
    return CSS.cacheStyleSheet(cssRule.styleSheet);
  }
  var selectorText = cssRule.selectorText, selectorCount, j;
  if (selectorText) 
  {
    selectorText = selectorText.split(',');
    selectorCount = selectorText.length;
    for (j = 0; j < selectorCount; j++) 
      {
        rules[Ext.String.trim(selectorText[j]).toLowerCase()] = {parentStyleSheet: styleSheet, cssRule: cssRule};
      }
  }
}, getRules: function(refreshCache) {
  var result = {}, selector;
  if (rules === null || refreshCache) 
  {
    CSS.refreshCache();
  }
  for (selector in rules) 
    {
      result[selector] = rules[selector].cssRule;
    }
  return result;
}, refreshCache: function() {
  var ds = doc.styleSheets, i = 0, len = ds.length;
  rules = CSS.rules = {};
  for (; i < len; i++) 
    {
      try {
        if (!ds[i].disabled) 
        {
          CSS.cacheStyleSheet(ds[i]);
        }
      }      catch (e) {
}
    }
}, getRule: function(selector, refreshCache, rawCache) {
  var i, result;
  if (!rules || refreshCache) 
  {
    CSS.refreshCache();
  }
  if (!Ext.isArray(selector)) 
  {
    result = rules[selector.toLowerCase()];
    if (result && !rawCache) 
    {
      result = result.cssRule;
    }
    return result || null;
  }
  for (i = 0; i < selector.length; i++) 
    {
      if (rules[selector[i]]) 
      {
        return rawCache ? rules[selector[i].toLowerCase()] : rules[selector[i].toLowerCase()].cssRule;
      }
    }
  return null;
}, createRule: function(styleSheet, selector, cssText) {
  var result, ruleSet = styleSheet.cssRules || styleSheet.rules, index = ruleSet.length;
  if (styleSheet.insertRule) 
  {
    styleSheet.insertRule(selector + '{' + cssText + '}', index);
  } else {
    styleSheet.addRule(selector, cssText || ' ');
  }
  CSS.cacheRule(result = ruleSet[index], styleSheet);
  return result;
}, updateRule: function(selector, property, value) {
  var rule, i, styles;
  if (!Ext.isArray(selector)) 
  {
    rule = CSS.getRule(selector);
    if (rule) 
    {
      if (arguments.length === 2) 
      {
        styles = Ext.Element.parseStyles(property);
        for (property in styles) 
          {
            rule.style[property.replace(camelRe, camelFn)] = styles[property];
          }
      } else {
        rule.style[property.replace(camelRe, camelFn)] = value;
      }
      return true;
    }
  } else {
    for (i = 0; i < selector.length; i++) 
      {
        if (CSS.updateRule(selector[i], property, value)) 
        {
          return true;
        }
      }
  }
  return false;
}, deleteRule: function(selector) {
  var rule = CSS.getRule(selector, false, true), styleSheet, index;
  if (rule) 
  {
    styleSheet = rule.parentStyleSheet;
    index = Ext.Array.indexOf(styleSheet.cssRules || styleSheet.rules, rule.cssRule);
    if (styleSheet.deleteRule) 
    {
      styleSheet.deleteRule(index);
    } else {
      styleSheet.removeRule(index);
    }
    delete rules[selector];
  }
}};
}, 1, 0, 0, 0, 0, 0, [Ext.util, 'CSS'], 0));
;

(Ext.cmd.derive('Ext.view.TableLayout', Ext.layout.component.Auto, {type: 'tableview', beginLayout: function(ownerContext) {
  var me = this, otherSide = me.owner.lockingPartner, owner = me.owner;
  me.callParent(arguments);
  if (otherSide) 
  {
    me.lockedGrid = me.owner.up('[lockable]');
    me.lockedGrid.needsRowHeightSync = true;
    if (!ownerContext.lockingPartner) 
    {
      ownerContext.lockingPartner = ownerContext.context.getItem(otherSide, otherSide.el);
      if (ownerContext.lockingPartner && !ownerContext.lockingPartner.lockingPartner) 
      {
        ownerContext.lockingPartner.lockingPartner = ownerContext;
      }
    }
  }
  ownerContext.headerContext = ownerContext.context.getCmp(me.headerCt);
  if (me.owner.body.dom) 
  {
    ownerContext.bodyContext = ownerContext.getEl(me.owner.body);
  }
  if (Ext.isWebKit) 
  {
    owner.el.select(owner.getBodySelector()).setStyle('table-layout', 'auto');
  }
}, calculate: function(ownerContext) {
  var me = this, lockingPartner = me.lockingPartner, owner = me.owner, contentHeight = 0, emptyEl;
  if (ownerContext.headerContext.hasProp('columnWidthsDone')) 
  {
    if (!me.setColumnWidths(ownerContext)) 
    {
      me.done = false;
      return;
    }
    ownerContext.state.columnWidthsSynced = true;
    if (ownerContext.bodyContext) 
    {
      emptyEl = me.owner.el.down('.' + owner.ownerCt.emptyCls, true);
      if (!emptyEl) 
      {
        contentHeight = ownerContext.bodyContext.el.dom.offsetHeight;
        ownerContext.bodyContext.setHeight(contentHeight, false);
      } else {
        contentHeight = emptyEl.offsetHeight;
      }
      if (ownerContext.headerContext.state.boxPlan.tooNarrow && ownerContext.ownerCtContext.sizeModel.height.shrinkWrap) 
      {
        contentHeight += Ext.getScrollbarSize().height;
      }
      ownerContext.setProp('contentHeight', contentHeight);
    }
    if (lockingPartner && !lockingPartner.state.columnWidthsSynced) 
    {
      me.done = false;
    } else {
      me.callParent(arguments);
    }
  } else {
    me.done = false;
  }
}, measureContentHeight: function(ownerContext) {
  var lockingPartner = ownerContext.lockingPartner;
  if (!ownerContext.bodyContext || (ownerContext.state.columnWidthsSynced && (!lockingPartner || lockingPartner.state.columnWidthsSynced))) 
  {
    return this.callParent(arguments);
  }
}, setColumnWidths: function(ownerContext) {
  if (!this.owner.body.dom) 
  {
    return true;
  }
  var me = this, owner = me.owner, context = ownerContext.context, columns = me.headerCt.getVisibleGridColumns(), column, i, len = columns.length, tableWidth = 0, columnLineWidth = 0, childContext, colWidth, isContentBox = !Ext.isBorderBox, colGroup = owner.body.dom.firstChild, isColGroup = colGroup.tagName.toUpperCase() === 'COLGROUP', changedColumns = [];
  if (context) 
  {
    context.currentLayout = me;
  }
  for (i = 0; i < len; i++) 
    {
      column = columns[i];
      childContext = context.getCmp(column);
      if (!column.lastBox || column.lastBox.invalid || childContext.props.width !== column.lastBox.width || (childContext.cellWidth && childContext.cellWidth != childContext.props.width)) 
      {
        colWidth = childContext.props.width;
        if (isNaN(colWidth)) 
        {
          childContext.getProp('width');
          return false;
        }
        tableWidth += colWidth;
        childContext.columnIndex = i;
        changedColumns.push(childContext);
      } else {
        tableWidth += column.lastBox.width;
      }
      childContext.cellWidth = childContext.props.width;
    }
  len = changedColumns.length;
  if (!len) 
  {
    return true;
  }
  owner.body.setWidth(tableWidth);
  for (i = 0; i < len; i++) 
    {
      childContext = changedColumns[i];
      colWidth = childContext.props.width;
      if (isContentBox && owner.columnLines) 
      {
        if (!columnLineWidth) 
        {
          columnLineWidth = ownerContext.headerContext.childItems[0].borderInfo.width;
        }
        colWidth -= columnLineWidth;
      }
      if (isColGroup) 
      {
        colGroup.childNodes[childContext.columnIndex].style.width = colWidth + 'px';
      }
      if (owner.features.length) 
      {
        owner.body.select(owner.getColumnSizerSelector(childContext.target)).setWidth(colWidth);
      }
    }
  return true;
}, finishedLayout: function() {
  var me = this, owner = me.owner;
  me.callParent(arguments);
  if (Ext.isWebKit) 
  {
    owner.el.select(owner.getBodySelector()).setStyle('table-layout', '');
  }
  if (owner.refreshCounter && me.lockedGrid && me.lockedGrid.syncRowHeight && me.lockedGrid.needsRowHeightSync) 
  {
    me.lockedGrid.syncRowHeights();
    me.lockedGrid.needsRowHeightSync = false;
  }
}}, 0, 0, 0, 0, ["layout.tableview"], 0, [Ext.view, 'TableLayout'], 0));
;

(Ext.cmd.derive('Ext.view.NodeCache', Ext.Base, {constructor: function(view) {
  this.view = view;
  this.clear();
  this.el = new Ext.dom.AbstractElement.Fly();
}, clear: function(removeDom) {
  var me = this, elements = this.elements, i, el;
  if (removeDom) 
  {
    for (i in elements) 
      {
        el = elements[i];
        el.parentNode.removeChild(el);
      }
  }
  me.elements = {};
  me.count = me.startIndex = 0;
  me.endIndex = -1;
}, fill: function(newElements, startIndex) {
  var me = this, elements = me.elements = {}, i, len = newElements.length;
  if (!startIndex) 
  {
    startIndex = 0;
  }
  for (i = 0; i < len; i++) 
    {
      elements[startIndex + i] = newElements[i];
    }
  me.startIndex = startIndex;
  me.endIndex = startIndex + len - 1;
  me.count = len;
  return this;
}, insert: function(insertPoint, nodes) {
  var me = this, elements = me.elements, i, nodeCount = nodes.length;
  if (me.count) 
  {
    if (insertPoint < me.count) 
    {
      for (i = me.endIndex + nodeCount; i >= insertPoint + nodeCount; i--) 
        {
          elements[i] = elements[i - nodeCount];
          elements[i].setAttribute('data-recordIndex', i);
        }
    }
    me.endIndex = me.endIndex + nodeCount;
  } else {
    me.startIndex = insertPoint;
    me.endIndex = insertPoint + nodeCount - 1;
  }
  for (i = 0; i < nodeCount; i++ , insertPoint++) 
    {
      elements[insertPoint] = nodes[i];
      elements[insertPoint].setAttribute('data-recordIndex', insertPoint);
    }
  me.count += nodeCount;
}, item: function(index, asDom) {
  var el = this.elements[index], result = null;
  if (el) 
  {
    result = asDom ? this.elements[index] : this.el.attach(this.elements[index]);
  }
  return result;
}, first: function(asDom) {
  return this.item(this.startIndex, asDom);
}, last: function(asDom) {
  return this.item(this.endIndex, asDom);
}, getCount: function() {
  return this.count;
}, slice: function(start, end) {
  var elements = this.elements, result = [], i;
  if (arguments.length < 2) 
  {
    end = this.endIndex;
  } else {
    end = Math.min(this.endIndex, end - 1);
  }
  for (i = start || this.startIndex; i <= end; i++) 
    {
      result.push(elements[i]);
    }
  return result;
}, replaceElement: function(el, replacement, domReplace) {
  var elements = this.elements, index = (typeof el === 'number') ? el : this.indexOf(el);
  if (index > -1) 
  {
    replacement = Ext.getDom(replacement);
    if (domReplace) 
    {
      el = elements[index];
      el.parentNode.insertBefore(replacement, el);
      Ext.removeNode(el);
      replacement.setAttribute('data-recordIndex', index);
    }
    this.elements[index] = replacement;
  }
  return this;
}, indexOf: function(el) {
  var elements = this.elements, index;
  el = Ext.getDom(el);
  for (index = this.startIndex; index <= this.endIndex; index++) 
    {
      if (elements[index] === el) 
      {
        return index;
      }
    }
  return -1;
}, removeRange: function(start, end, removeDom) {
  var me = this, elements = me.elements, el, i, removeCount, fromPos;
  if (end == null) 
  {
    end = me.endIndex + 1;
  } else {
    end = Math.min(me.endIndex + 1, end + 1);
  }
  if (start == null) 
  {
    start = me.startIndex;
  }
  removeCount = end - start;
  for (i = start , fromPos = end; i <= me.endIndex; i++ , fromPos++) 
    {
      if (removeDom && i < end) 
      {
        Ext.removeNode(elements[i]);
      }
      if (fromPos <= me.endIndex) 
      {
        el = elements[i] = elements[fromPos];
        el.setAttribute('data-recordIndex', i);
      } else {
        delete elements[i];
      }
    }
  me.count -= removeCount;
  me.endIndex -= removeCount;
}, removeElement: function(keys, removeDom) {
  var me = this, inKeys, key, elements = me.elements, el, deleteCount, keyIndex = 0, index, fromIndex;
  if (Ext.isArray(keys)) 
  {
    inKeys = keys;
    keys = [];
    deleteCount = inKeys.length;
    for (keyIndex = 0; keyIndex < deleteCount; keyIndex++) 
      {
        key = inKeys[keyIndex];
        if (typeof key !== 'number') 
        {
          key = me.indexOf(key);
        }
        if (key >= me.startIndex && key <= me.endIndex) 
        {
          keys[keys.length] = key;
        }
      }
    Ext.Array.sort(keys);
    deleteCount = keys.length;
  } else {
    if (keys < me.startIndex || keys > me.endIndex) 
    {
      return;
    }
    deleteCount = 1;
    keys = [keys];
  }
  for (index = fromIndex = keys[0] , keyIndex = 0; index <= me.endIndex; index++ , fromIndex++) 
    {
      if (keyIndex < deleteCount && index === keys[keyIndex]) 
      {
        fromIndex++;
        keyIndex++;
        if (removeDom) 
        {
          Ext.removeNode(elements[index]);
        }
      }
      if (fromIndex <= me.endIndex && fromIndex >= me.startIndex) 
      {
        el = elements[index] = elements[fromIndex];
        el.setAttribute('data-recordIndex', index);
      } else {
        delete elements[index];
      }
    }
  me.endIndex -= deleteCount;
  me.count -= deleteCount;
}, scroll: function(newRecords, direction, removeCount) {
  var me = this, elements = me.elements, recCount = newRecords.length, i, el, removeEnd, newNodes, nodeContainer = me.view.getNodeContainer(), frag = document.createDocumentFragment();
  if (direction == -1) 
  {
    for (i = (me.endIndex - removeCount) + 1; i <= me.endIndex; i++) 
      {
        el = elements[i];
        delete elements[i];
        el.parentNode.removeChild(el);
      }
    me.endIndex -= removeCount;
    newNodes = me.view.bufferRender(newRecords, me.startIndex -= recCount);
    for (i = 0; i < recCount; i++) 
      {
        elements[me.startIndex + i] = newNodes[i];
        frag.appendChild(newNodes[i]);
      }
    nodeContainer.insertBefore(frag, nodeContainer.firstChild);
  } else {
    removeEnd = me.startIndex + removeCount;
    for (i = me.startIndex; i < removeEnd; i++) 
      {
        el = elements[i];
        delete elements[i];
        el.parentNode.removeChild(el);
      }
    me.startIndex = i;
    newNodes = me.view.bufferRender(newRecords, me.endIndex + 1);
    for (i = 0; i < recCount; i++) 
      {
        elements[me.endIndex += 1] = newNodes[i];
        frag.appendChild(newNodes[i]);
      }
    nodeContainer.appendChild(frag);
  }
  me.count = me.endIndex - me.startIndex + 1;
}}, 1, 0, 0, 0, 0, 0, [Ext.view, 'NodeCache'], 0));
;

(Ext.cmd.derive('Ext.view.Table', Ext.view.View, {componentLayout: 'tableview', baseCls: Ext.baseCSSPrefix + 'grid-view', unselectableCls: Ext.baseCSSPrefix + 'unselectable', firstCls: Ext.baseCSSPrefix + 'grid-cell-first', lastCls: Ext.baseCSSPrefix + 'grid-cell-last', headerRowSelector: 'tr.' + Ext.baseCSSPrefix + 'grid-header-row', selectedItemCls: Ext.baseCSSPrefix + 'grid-row-selected', beforeSelectedItemCls: Ext.baseCSSPrefix + 'grid-row-before-selected', selectedCellCls: Ext.baseCSSPrefix + 'grid-cell-selected', focusedItemCls: Ext.baseCSSPrefix + 'grid-row-focused', beforeFocusedItemCls: Ext.baseCSSPrefix + 'grid-row-before-focused', tableFocusedFirstCls: Ext.baseCSSPrefix + 'grid-table-focused-first', tableSelectedFirstCls: Ext.baseCSSPrefix + 'grid-table-selected-first', tableOverFirstCls: Ext.baseCSSPrefix + 'grid-table-over-first', overItemCls: Ext.baseCSSPrefix + 'grid-row-over', beforeOverItemCls: Ext.baseCSSPrefix + 'grid-row-before-over', altRowCls: Ext.baseCSSPrefix + 'grid-row-alt', dirtyCls: Ext.baseCSSPrefix + 'grid-dirty-cell', rowClsRe: new RegExp('(?:^|\\s*)' + Ext.baseCSSPrefix + 'grid-row-(first|last|alt)(?:\\s+|$)', 'g'), cellRe: new RegExp(Ext.baseCSSPrefix + 'grid-cell-headerId-([^\\s]+)(?:\\s|$)', ''), positionBody: true, trackOver: true, getRowClass: null, stripeRows: true, markDirty: true, ariaRole: 'grid', tpl: '{%values.view.tableTpl.applyOut(values, out)%}', tableTpl: ['{%', 'var view=values.view,tableCls="' + Ext.baseCSSPrefix + '" + view.id + "-table ' + Ext.baseCSSPrefix + 'grid-table";', 'values.fullWidth', '%}', '<table id="{view.id}-table" class="{[tableCls]}" border="0" cellspacing="0" cellpadding="0" style="{tableStyle}" {ariaTableAttr}>', '{[view.renderColumnSizer(out)]}', '{[view.renderTHead(values, out)]}', '{[view.renderTFoot(values, out)]}', '<tbody id="{view.id}-body" {ariaTbodyAttr}>', '{%', 'view.renderRows(values.rows, values.viewStartIndex, out);', '%}', '</tbody>', '</table>', {priority: 0}], rowTpl: ['{%', 'var dataRowCls = values.recordIndex === -1 ? "" : " ' + Ext.baseCSSPrefix + 'grid-data-row";', '%}', '<tr {[values.rowId ? ("id=\\"" + values.rowId + "\\"") : ""]} ', 'data-boundView="{view.id}" ', 'data-recordId="{record.internalId}" ', 'data-recordIndex="{recordIndex}" ', 'class="{[values.itemClasses.join(" ")]} {[values.rowClasses.join(" ")]}{[dataRowCls]}" ', '{rowAttr:attributes} tabIndex="-1" {ariaRowAttr}>', '<tpl for="columns">' + '{%', 'parent.view.renderCell(values, parent.record, parent.recordIndex, parent.rowIndex, xindex - 1, out, parent)', '%}', '</tpl>', '</tr>', {priority: 0}], cellTpl: ['<td class="{tdCls}" {tdAttr} {[Ext.aria ? "id=\\"" + Ext.id() + "\\"" : ""]} {ariaCellAttr}>', '<div {unselectableAttr} class="' + Ext.baseCSSPrefix + 'grid-cell-inner {innerCls}"', 'style="text-align:{align};<tpl if="style">{style}</tpl>" {ariaCellInnerAttr}>{value}</div>', '</td>', {priority: 0}], refreshSelmodelOnRefresh: false, tableValues: {}, rowValues: {itemClasses: [], rowClasses: []}, cellValues: {classes: [Ext.baseCSSPrefix + 'grid-cell ' + Ext.baseCSSPrefix + 'grid-td']}, renderBuffer: document.createElement('div'), constructor: function(config) {
  if (config.grid.isTree) 
  {
    config.baseCls = Ext.baseCSSPrefix + 'tree-view';
  }
  this.callParent([config]);
}, initComponent: function() {
  var me = this, scroll = me.scroll;
  this.addEvents('beforecellclick', 'cellclick', 'beforecelldblclick', 'celldblclick', 'beforecellcontextmenu', 'cellcontextmenu', 'beforecellmousedown', 'cellmousedown', 'beforecellmouseup', 'cellmouseup', 'beforecellkeydown', 'cellkeydown');
  me.body = new Ext.dom.Element.Fly();
  me.body.id = me.id + 'gridBody';
  me.autoScroll = undefined;
  if (!me.trackOver) 
  {
    me.overItemCls = null;
    me.beforeOverItemCls = null;
  }
  if (scroll === true || scroll === 'both') 
  {
    me.autoScroll = true;
  } else if (scroll === 'horizontal') 
  {
    me.overflowX = 'auto';
  } else if (scroll === 'vertical') 
  {
    me.overflowY = 'auto';
  }
  me.selModel.view = me.headerCt.view = me;
  me.grid.view = me;
  me.initFeatures(me.grid);
  delete me.grid;
  me.itemSelector = me.getItemSelector();
  me.all = new Ext.view.NodeCache(me);
  me.callParent();
}, getVisibleColumnManager: function() {
  var owner = this.ownerCt, lock = owner.ownerLockable;
  return lock ? lock.getVisibleColumnManager() : owner.getVisibleColumnManager();
}, beforeLayout: function() {
  var me = this, needsContextInjection = !me.firstRefreshDone && me.headerCt.layout.running;
  me.callParent(arguments);
  if (needsContextInjection && me.body.dom) 
  {
    me.headerCt.layout.injectViewContext(me.headerCt.layout.ownerContext, me);
  }
}, moveColumn: function(fromIdx, toIdx, colsToMove) {
  var me = this, fragment = (colsToMove > 1) ? document.createDocumentFragment() : undefined, destinationCellIdx = toIdx, colCount = me.getGridColumns().length, lastIndex = colCount - 1, doFirstLastClasses = (me.firstCls || me.lastCls) && (toIdx === 0 || toIdx == colCount || fromIdx === 0 || fromIdx == lastIndex), i, j, rows, len, tr, cells, tables;
  if (me.rendered && toIdx !== fromIdx) 
  {
    rows = me.el.query(me.getDataRowSelector());
    if (toIdx > fromIdx && fragment) 
    {
      destinationCellIdx -= 1;
    }
    for (i = 0 , len = rows.length; i < len; i++) 
      {
        tr = rows[i];
        cells = tr.childNodes;
        if (doFirstLastClasses) 
        {
          if (cells.length === 1) 
          {
            Ext.fly(cells[0]).addCls(me.firstCls);
            Ext.fly(cells[0]).addCls(me.lastCls);
            continue;
          }
          if (fromIdx === 0) 
          {
            Ext.fly(cells[0]).removeCls(me.firstCls);
            Ext.fly(cells[1]).addCls(me.firstCls);
          } else if (fromIdx === lastIndex) 
          {
            Ext.fly(cells[lastIndex]).removeCls(me.lastCls);
            Ext.fly(cells[lastIndex - 1]).addCls(me.lastCls);
          }
          if (toIdx === 0) 
          {
            Ext.fly(cells[0]).removeCls(me.firstCls);
            Ext.fly(cells[fromIdx]).addCls(me.firstCls);
          } else if (toIdx === colCount) 
          {
            Ext.fly(cells[lastIndex]).removeCls(me.lastCls);
            Ext.fly(cells[fromIdx]).addCls(me.lastCls);
          }
        }
        if (fragment) 
        {
          for (j = 0; j < colsToMove; j++) 
            {
              fragment.appendChild(cells[fromIdx]);
            }
          tr.insertBefore(fragment, cells[destinationCellIdx] || null);
        } else {
          tr.insertBefore(cells[fromIdx], cells[destinationCellIdx] || null);
        }
      }
    tables = me.el.query(me.getBodySelector());
    for (i = 0 , len = tables.length; i < len; i++) 
      {
        tr = tables[i].firstChild;
        if (tr.tagName.toUpperCase() === 'COLGROUP') 
        {
          if (fragment) 
          {
            for (j = 0; j < colsToMove; j++) 
              {
                fragment.appendChild(tr.childNodes[fromIdx]);
              }
            tr.insertBefore(fragment, tr.childNodes[destinationCellIdx] || null);
          } else {
            tr.insertBefore(tr.childNodes[fromIdx], tr.childNodes[destinationCellIdx] || null);
          }
        }
      }
  }
}, scrollToTop: Ext.emptyFn, addElListener: function(eventName, fn, scope) {
  this.mon(this, eventName, fn, scope, {element: 'el'});
}, getGridColumns: function() {
  return this.ownerCt.getVisibleColumnManager().getColumns();
}, getHeaderAtIndex: function(index) {
  return this.ownerCt.getVisibleColumnManager().getHeaderAtIndex(index);
}, getCell: function(record, column) {
  var row = this.getNode(record, true);
  return Ext.fly(row).down(column.getCellSelector());
}, getFeature: function(id) {
  var features = this.featuresMC;
  if (features) 
  {
    return features.get(id);
  }
}, findFeature: function(ftype) {
  if (this.features) 
  {
    return Ext.Array.findBy(this.features, function(feature) {
  if (feature.ftype === ftype) 
  {
    return true;
  }
});
  }
}, initFeatures: function(grid) {
  var me = this, i, features, feature, len;
  me.tableTpl = Ext.XTemplate.getTpl(this, 'tableTpl');
  me.rowTpl = Ext.XTemplate.getTpl(this, 'rowTpl');
  me.cellTpl = Ext.XTemplate.getTpl(this, 'cellTpl');
  me.featuresMC = new Ext.util.MixedCollection();
  features = me.features = me.constructFeatures();
  len = features ? features.length : 0;
  for (i = 0; i < len; i++) 
    {
      feature = features[i];
      feature.view = me;
      feature.grid = grid;
      me.featuresMC.add(feature);
      feature.init(grid);
    }
}, renderTHead: function(values, out) {
  var headers = values.view.headerFns, len, i;
  if (headers) 
  {
    for (i = 0 , len = headers.length; i < len; ++i) 
      {
        headers[i].call(this, values, out);
      }
  }
}, addHeaderFn: function() {
  var headers = this.headerFns;
  if (!headers) 
  {
    headers = this.headerFns = [];
  }
  headers.push(fn);
}, renderTFoot: function(values, out) {
  var footers = values.view.footerFns, len, i;
  if (footers) 
  {
    for (i = 0 , len = footers.length; i < len; ++i) 
      {
        footers[i].call(this, values, out);
      }
  }
}, addFooterFn: function(fn) {
  var footers = this.footerFns;
  if (!footers) 
  {
    footers = this.footerFns = [];
  }
  footers.push(fn);
}, addTableTpl: function(newTpl) {
  return this.addTpl('tableTpl', newTpl);
}, addRowTpl: function(newTpl) {
  return this.addTpl('rowTpl', newTpl);
}, addCellTpl: function(newTpl) {
  return this.addTpl('cellTpl', newTpl);
}, addTpl: function(which, newTpl) {
  var me = this, tpl, prevTpl;
  newTpl = Ext.Object.chain(newTpl);
  if (!newTpl.isTemplate) 
  {
    newTpl.applyOut = me.tplApplyOut;
  }
  for (tpl = me[which]; newTpl.priority < tpl.priority; tpl = tpl.nextTpl) 
    {
      prevTpl = tpl;
    }
  if (prevTpl) 
  {
    prevTpl.nextTpl = newTpl;
  } else {
    me[which] = newTpl;
  }
  newTpl.nextTpl = tpl;
  return newTpl;
}, tplApplyOut: function(values, out) {
  if (this.before) 
  {
    if (this.before(values, out) === false) 
    {
      return;
    }
  }
  this.nextTpl.applyOut(values, out);
  if (this.after) 
  {
    this.after(values, out);
  }
}, constructFeatures: function() {
  var me = this, features = me.features, feature, result, i = 0, len;
  if (features) 
  {
    result = [];
    len = features.length;
    for (; i < len; i++) 
      {
        feature = features[i];
        if (!feature.isFeature) 
        {
          feature = Ext.create('feature.' + feature.ftype, feature);
        }
        result[i] = feature;
      }
  }
  return result;
}, beforeRender: function() {
  var me = this;
  me.callParent();
  if (!me.enableTextSelection) 
  {
    me.protoEl.unselectable();
  }
}, onViewScroll: function(e, t) {
  if (!this.ignoreScroll) 
  {
    this.callParent(arguments);
    this.fireEvent('bodyscroll', e, t);
  }
}, createRowElement: function(record, index) {
  var me = this, div = me.renderBuffer;
  me.tpl.overwrite(div, me.collectData([record], index));
  return Ext.fly(div).down(me.getNodeContainerSelector(), true).firstChild;
}, bufferRender: function(records, index) {
  var me = this, div = me.renderBuffer;
  me.tpl.overwrite(div, me.collectData(records, index));
  return Ext.Array.toArray(Ext.fly(div).down(me.getNodeContainerSelector(), true).childNodes);
}, collectData: function(records, startIndex) {
  this.rowValues.view = this;
  return {view: this, rows: records, viewStartIndex: startIndex, tableStyle: 'width:' + this.headerCt.getTableWidth() + 'px' + (this.bufferedRenderer ? (';position:absolute;top:' + this.bufferedRenderer.bodyTop + 'px') : '')};
}, collectNodes: function(targetEl) {
  this.all.fill(this.getNodeContainer().childNodes, this.all.startIndex);
}, refreshSize: function() {
  var me = this, grid, bodySelector = me.getBodySelector();
  if (bodySelector) 
  {
    me.body.attach(me.el.child(bodySelector, true));
  }
  if (!me.hasLoadingHeight) 
  {
    grid = me.up('tablepanel');
    Ext.suspendLayouts();
    me.callParent();
    if (me.dataSource.getCount()) 
    {
      grid.updateLayout();
    }
    Ext.resumeLayouts(true);
  }
}, getMaskTarget: function() {
  var grid = this.ownerCt;
  if (grid.ownerLockable) 
  {
    grid = grid.ownerLockable;
  }
  return grid.getMaskTarget();
}, statics: {getBoundView: function(node) {
  return Ext.getCmp(node.getAttribute('data-boundView'));
}}, getRecord: function(node) {
  var me = this, recordIndex;
  if (me.store.isDestroyed) 
  {
    return;
  }
  node = me.getNode(node);
  if (node) 
  {
    if (!me.hasActiveFeature()) 
    {
      recordIndex = node.getAttribute('data-recordIndex');
      if (recordIndex) 
      {
        recordIndex = parseInt(recordIndex, 10);
        if (recordIndex > -1) 
        {
          return me.store.data.getAt(recordIndex);
        }
      }
    }
    return me.dataSource.getByInternalId(node.getAttribute('data-recordId'));
  }
}, indexOf: function(node) {
  node = this.getNode(node, false);
  if (!node && node !== 0) 
  {
    return -1;
  }
  return this.all.indexOf(node);
}, indexInStore: function(node) {
  return this.dataSource.indexOf(this.getRecord(node));
}, renderRows: function(rows, viewStartIndex, out) {
  var rowValues = this.rowValues, rowCount = rows.length, i;
  rowValues.view = this;
  rowValues.columns = this.ownerCt.getVisibleColumnManager().getColumns();
  for (i = 0; i < rowCount; i++ , viewStartIndex++) 
    {
      rowValues.itemClasses.length = rowValues.rowClasses.length = 0;
      this.renderRow(rows[i], viewStartIndex, out);
    }
  rowValues.view = rowValues.columns = rowValues.record = null;
}, renderColumnSizer: function(out) {
  var columns = this.getGridColumns(), len = columns.length, i, column;
  out.push('<colgroup role="presentation">');
  for (i = 0; i < len; i++) 
    {
      column = columns[i];
      out.push('<col role="presentation" class="', columns[i].getCellId(), '" style="width:' + column.getCellWidth() + 'px">');
    }
  out.push('</colgroup>');
}, renderRow: function(record, rowIdx, out) {
  var me = this, isMetadataRecord = rowIdx === -1, selModel = me.selModel, rowValues = me.rowValues, itemClasses = rowValues.itemClasses, rowClasses = rowValues.rowClasses, cls, rowTpl = me.rowTpl;
  rowValues.rowAttr = {};
  rowValues.record = record;
  rowValues.recordId = record.internalId;
  rowValues.recordIndex = me.store.indexOf(record);
  rowValues.rowIndex = rowIdx;
  rowValues.rowId = me.getRowId(record);
  rowValues.itemCls = rowValues.rowCls = '';
  if (!rowValues.columns) 
  {
    rowValues.columns = me.ownerCt.getVisibleColumnManager().getColumns();
  }
  itemClasses.length = rowClasses.length = 0;
  if (!isMetadataRecord) 
  {
    itemClasses[0] = Ext.baseCSSPrefix + "grid-row";
    if (!me.ownerCt.disableSelection && selModel.isRowSelected) 
    {
      if (selModel.isRowSelected(record)) 
      {
        itemClasses.push(me.selectedItemCls);
      }
      if (me.rowValues.recordIndex < me.store.getTotalCount() - 1 && selModel.isRowSelected(me.rowValues.recordIndex + 1) && !me.isRowStyleFirst(rowIdx + 1)) 
      {
        rowClasses.push(me.beforeSelectedItemCls);
      }
    }
    if (me.stripeRows && rowIdx % 2 !== 0) 
    {
      itemClasses.push(me.altRowCls);
    }
    if (me.getRowClass) 
    {
      cls = me.getRowClass(record, rowIdx, null, me.dataSource);
      if (cls) 
      {
        rowClasses.push(cls);
      }
    }
  }
  if (out) 
  {
    rowTpl.applyOut(rowValues, out);
  } else {
    return rowTpl.apply(rowValues);
  }
}, renderCell: function(column, record, recordIndex, rowIndex, columnIndex, out) {
  var me = this, selModel = me.selModel, cellValues = me.cellValues, classes = cellValues.classes, fieldValue = record.data[column.dataIndex], cellTpl = me.cellTpl, fullIndex, value, clsInsertPoint;
  cellValues.record = record;
  cellValues.column = column;
  cellValues.recordIndex = recordIndex;
  cellValues.rowIndex = rowIndex;
  cellValues.columnIndex = columnIndex;
  cellValues.cellIndex = columnIndex;
  cellValues.align = column.align;
  cellValues.tdCls = column.tdCls;
  cellValues.innerCls = column.innerCls;
  cellValues.style = cellValues.tdAttr = "";
  cellValues.unselectableAttr = me.enableTextSelection ? '' : 'unselectable="on"';
  if (column.renderer && column.renderer.call) 
  {
    fullIndex = me.ownerCt.columnManager.getHeaderIndex(column);
    value = column.renderer.call(column.usingDefaultRenderer ? column : column.scope || me.ownerCt, fieldValue, cellValues, record, recordIndex, fullIndex, me.dataSource, me);
    if (cellValues.css) 
    {
      record.cssWarning = true;
      cellValues.tdCls += ' ' + cellValues.css;
      delete cellValues.css;
    }
  } else {
    value = fieldValue;
  }
  cellValues.value = (value == null || value === '') ? column.emptyCellText : value;
  classes[1] = column.getCellId();
  clsInsertPoint = 2;
  if (column.tdCls) 
  {
    classes[clsInsertPoint++] = column.tdCls;
  }
  if (me.markDirty && record.isModified(column.dataIndex)) 
  {
    classes[clsInsertPoint++] = me.dirtyCls;
  }
  if (column.isFirstVisible) 
  {
    classes[clsInsertPoint++] = me.firstCls;
  }
  if (column.isLastVisible) 
  {
    classes[clsInsertPoint++] = me.lastCls;
  }
  if (!me.enableTextSelection) 
  {
    classes[clsInsertPoint++] = me.unselectableCls;
  }
  if (cellValues.tdCls) 
  {
    classes[clsInsertPoint++] = cellValues.tdCls;
  }
  if (selModel && selModel.isCellModel && selModel.isCellSelected(me, recordIndex, column)) 
  {
    classes[clsInsertPoint++] = (me.selectedCellCls);
  }
  classes.length = clsInsertPoint;
  cellValues.tdCls = classes.join(' ');
  cellTpl.applyOut(cellValues, out);
  cellValues.column = null;
}, getNode: function(nodeInfo, dataRow) {
  var fly, result = this.callParent(arguments);
  if (result && result.tagName) 
  {
    if (dataRow) 
    {
      if (!(fly = Ext.fly(result)).is(this.dataRowSelector)) 
      {
        return fly.down(this.dataRowSelector, true);
      }
    } else if (dataRow === false) 
    {
      if (!(fly = Ext.fly(result)).is(this.itemSelector)) 
      {
        return fly.up(this.itemSelector, null, true);
      }
    }
  }
  return result;
}, getRowId: function(record) {
  return this.id + '-record-' + record.internalId;
}, constructRowId: function(internalId) {
  return this.id + '-record-' + internalId;
}, getNodeById: function(id, dataRow) {
  id = this.constructRowId(id);
  return this.retrieveNode(id, dataRow);
}, getNodeByRecord: function(record, dataRow) {
  var id = this.getRowId(record);
  return this.retrieveNode(id, dataRow);
}, retrieveNode: function(id, dataRow) {
  var result = this.el.getById(id, true), itemSelector = this.itemSelector, fly;
  if (dataRow === false && result) 
  {
    if (!(fly = Ext.fly(result)).is(itemSelector)) 
    {
      return fly.up(itemSelector, null, true);
    }
  }
  return result;
}, updateIndexes: Ext.emptyFn, bodySelector: 'table', nodeContainerSelector: 'tbody', itemSelector: 'tr.' + Ext.baseCSSPrefix + 'grid-row', dataRowSelector: 'tr.' + Ext.baseCSSPrefix + 'grid-data-row', cellSelector: 'td.' + Ext.baseCSSPrefix + 'grid-cell', sizerSelector: 'col.' + Ext.baseCSSPrefix + 'grid-cell-headerId', innerSelector: 'div.' + Ext.baseCSSPrefix + 'grid-cell-inner', getNodeContainer: function() {
  return this.el.down(this.nodeContainerSelector, true);
}, getBodySelector: function() {
  return this.bodySelector + '.' + Ext.baseCSSPrefix + this.id + '-table';
}, getNodeContainerSelector: function() {
  return this.nodeContainerSelector;
}, getColumnSizerSelector: function(header) {
  return this.sizerSelector + '-' + header.getItemId();
}, getItemSelector: function() {
  return this.itemSelector;
}, getDataRowSelector: function() {
  return this.dataRowSelector;
}, getCellSelector: function(header) {
  return header ? header.getCellSelector() : this.cellSelector;
}, getCellInnerSelector: function(header) {
  return this.getCellSelector(header) + ' ' + this.innerSelector;
}, addRowCls: function(rowInfo, cls) {
  var row = this.getNode(rowInfo, false);
  if (row) 
  {
    Ext.fly(row).addCls(cls);
  }
}, removeRowCls: function(rowInfo, cls) {
  var row = this.getNode(rowInfo, false);
  if (row) 
  {
    Ext.fly(row).removeCls(cls);
  }
}, setHighlightedItem: function(item) {
  var me = this, highlighted = me.highlightedItem;
  if (highlighted && me.el.isAncestor(highlighted) && me.isRowStyleFirst(highlighted)) 
  {
    me.toggleRowTableCls(highlighted, me.tableOverFirstCls, false);
  }
  item = me.getNode(item, false);
  if (item && me.isRowStyleFirst(item)) 
  {
    me.toggleRowTableCls(item, me.tableOverFirstCls, true);
  }
  me.callParent(arguments);
}, onRowSelect: function(rowIdx) {
  var me = this, beforeSelectedItemCls = me.beforeSelectedItemCls;
  me.addRowCls(rowIdx, me.selectedItemCls);
  if (me.isRowStyleFirst(rowIdx)) 
  {
    me.toggleRowTableCls(rowIdx, me.tableSelectedFirstCls, true);
    if (rowIdx > 0) 
    {
      me.removeRowCls(rowIdx - 1, beforeSelectedItemCls);
    }
  } else {
    me.addRowCls(rowIdx - 1, beforeSelectedItemCls);
  }
}, onRowDeselect: function(rowIdx) {
  var me = this;
  me.removeRowCls(rowIdx, [me.selectedItemCls, me.focusedItemCls]);
  if (me.isRowStyleFirst(rowIdx)) 
  {
    me.toggleRowTableCls(rowIdx, [me.tableFocusedFirstCls, me.tableSelectedFirstCls], false);
  } else {
    me.removeRowCls(rowIdx - 1, [me.beforeFocusedItemCls, me.beforeSelectedItemCls]);
  }
}, onCellSelect: function(position) {
  var cell = this.getCellByPosition(position);
  if (cell) 
  {
    cell.addCls(this.selectedCellCls);
  }
}, onCellDeselect: function(position) {
  var cell = this.getCellByPosition(position, true);
  if (cell) 
  {
    Ext.fly(cell).removeCls(this.selectedCellCls);
  }
}, getCellByPosition: function(position, returnDom) {
  if (position) 
  {
    var row = this.getNode(position.row, true), header = this.ownerCt.getColumnManager().getHeaderAtIndex(position.column);
    if (header && row) 
    {
      return Ext.fly(row).down(this.getCellSelector(header), returnDom);
    }
  }
  return false;
}, getFocusEl: function() {
  return this.focusEl;
}, onRowFocus: function(rowIdx, highlight, supressFocus) {
  var me = this;
  if (highlight) 
  {
    me.addRowCls(rowIdx, me.focusedItemCls);
    if (me.isRowStyleFirst(rowIdx)) 
    {
      me.toggleRowTableCls(rowIdx, me.tableFocusedFirstCls, true);
    } else {
      me.addRowCls(rowIdx - 1, me.beforeFocusedItemCls);
    }
    if (!supressFocus) 
    {
      me.focusRow(rowIdx);
    }
  } else {
    me.removeRowCls(rowIdx, me.focusedItemCls);
    if (me.isRowStyleFirst(rowIdx)) 
    {
      me.toggleRowTableCls(rowIdx, me.tableFocusedFirstCls, false);
    } else {
      me.removeRowCls(rowIdx - 1, me.beforeFocusedItemCls);
    }
  }
  if ((Ext.isIE6 || Ext.isIE7) && !me.ownerCt.rowLines) 
  {
    me.repaintRow(rowIdx);
  }
}, focusRow: function(row, delay) {
  var me = this, record, focusTask = me.getFocusTask();
  if (delay) 
  {
    focusTask.delay(Ext.isNumber(delay) ? delay : 10, me.focusRow, me, [row, false]);
    return;
  }
  focusTask.cancel();
  if (me.isVisible(true) && (row = me.getNode(row, true))) 
  {
    me.scrollRowIntoView(row);
    record = me.getRecord(row);
    me.selModel.setLastFocused(record);
    me.doFocus(row);
    me.fireEvent('rowfocus', record, row, me.indexInStore(row));
  }
}, scrollRowIntoView: function(row) {
  row = this.getNode(row, true);
  if (row) 
  {
    Ext.fly(row).scrollIntoView(this.el, false);
  }
}, focusCell: function(position, delay) {
  var me = this, cell, focusTask = me.getFocusTask();
  if (delay) 
  {
    focusTask.delay(Ext.isNumber(delay) ? delay : 10, me.focusCell, me, [position, false]);
    return;
  }
  focusTask.cancel();
  if (me.isVisible(true) && (cell = me.getCellByPosition(position))) 
  {
    me.scrollCellIntoView(cell);
    me.doFocus(me.getNode(position.row, true));
    me.fireEvent('cellfocus', position.record, cell, position);
  }
}, doFocus: function(rowDom) {
  var me = this, saveScroll = Ext.isIE, scrollLeft;
  if (saveScroll) 
  {
    scrollLeft = me.el.getScrollLeft();
    me.ignoreScroll = true;
  }
  (me.focusEl = Ext.get(rowDom)).focus();
  if (saveScroll) 
  {
    me.el.setScrollLeft(scrollLeft);
    me.ignoreScroll = false;
  }
}, scrollCellIntoView: function(cell) {
  if (cell.row != null && cell.column != null) 
  {
    cell = this.getCellByPosition(cell);
  }
  if (cell) 
  {
    Ext.fly(cell).scrollIntoView(this.el);
  }
}, scrollByDelta: function(delta, dir) {
  dir = dir || 'scrollTop';
  var elDom = this.el.dom;
  elDom[dir] = (elDom[dir] += delta);
}, isDataRow: function(row) {
  return Ext.fly(row).hasCls(Ext.baseCSSPrefix + 'grid-data-row');
}, syncRowHeights: function(firstRow, secondRow) {
  firstRow = Ext.get(firstRow);
  secondRow = Ext.get(secondRow);
  firstRow.dom.style.height = secondRow.dom.style.height = '';
  var me = this, rowTpl = me.rowTpl, firstRowHeight = firstRow.dom.offsetHeight, secondRowHeight = secondRow.dom.offsetHeight;
  if (firstRowHeight !== secondRowHeight) 
  {
    while (rowTpl) 
      {
        if (rowTpl.syncRowHeights) 
        {
          if (rowTpl.syncRowHeights(firstRow, secondRow) === false) 
          {
            break;
          }
        }
        rowTpl = rowTpl.nextTpl;
      }
    firstRowHeight = firstRow.dom.offsetHeight;
    secondRowHeight = secondRow.dom.offsetHeight;
    if (firstRowHeight !== secondRowHeight) 
    {
      firstRow = firstRow.down('[data-recordId]') || firstRow;
      secondRow = secondRow.down('[data-recordId]') || secondRow;
      if (firstRow && secondRow) 
      {
        firstRow.dom.style.height = secondRow.dom.style.height = '';
        firstRowHeight = firstRow.dom.offsetHeight;
        secondRowHeight = secondRow.dom.offsetHeight;
        if (firstRowHeight > secondRowHeight) 
        {
          firstRow.setHeight(firstRowHeight);
          secondRow.setHeight(firstRowHeight);
        } else if (secondRowHeight > firstRowHeight) 
        {
          firstRow.setHeight(secondRowHeight);
          secondRow.setHeight(secondRowHeight);
        }
      }
    }
  }
}, onIdChanged: function(store, rec, oldId, newId, oldInternalId) {
  var me = this, rowDom;
  if (me.viewReady) 
  {
    rowDom = me.getNodeById(oldInternalId);
    if (rowDom) 
    {
      rowDom.setAttribute('data-recordId', rec.internalId);
      rowDom.id = me.getRowId(rec);
    }
  }
}, onUpdate: function(store, record, operation, changedFieldNames) {
  var me = this, rowTpl = me.rowTpl, oldRow, oldRowDom, oldDataRow, newRowDom, newAttrs, attLen, attName, attrIndex, overItemCls, beforeOverItemCls, focusedItemCls, beforeFocusedItemCls, selectedItemCls, beforeSelectedItemCls, columns;
  if (me.viewReady) 
  {
    oldRowDom = me.getNodeByRecord(record, false);
    if (oldRowDom) 
    {
      overItemCls = me.overItemCls;
      beforeOverItemCls = me.beforeOverItemCls;
      focusedItemCls = me.focusedItemCls;
      beforeFocusedItemCls = me.beforeFocusedItemCls;
      selectedItemCls = me.selectedItemCls;
      beforeSelectedItemCls = me.beforeSelectedItemCls;
      oldRow = Ext.fly(oldRowDom, '_internal');
      newRowDom = me.createRowElement(record, me.dataSource.data.indexOf(record));
      if (oldRow.hasCls(overItemCls)) 
      {
        Ext.fly(newRowDom).addCls(overItemCls);
      }
      if (oldRow.hasCls(beforeOverItemCls)) 
      {
        Ext.fly(newRowDom).addCls(beforeOverItemCls);
      }
      if (oldRow.hasCls(focusedItemCls)) 
      {
        Ext.fly(newRowDom).addCls(focusedItemCls);
      }
      if (oldRow.hasCls(beforeFocusedItemCls)) 
      {
        Ext.fly(newRowDom).addCls(beforeFocusedItemCls);
      }
      if (oldRow.hasCls(selectedItemCls)) 
      {
        Ext.fly(newRowDom).addCls(selectedItemCls);
      }
      if (oldRow.hasCls(beforeSelectedItemCls)) 
      {
        Ext.fly(newRowDom).addCls(beforeSelectedItemCls);
      }
      columns = me.ownerCt.getVisibleColumnManager().getColumns();
      if (Ext.isIE9m && oldRowDom.mergeAttributes) 
      {
        oldRowDom.mergeAttributes(newRowDom, true);
      } else {
        newAttrs = newRowDom.attributes;
        attLen = newAttrs.length;
        for (attrIndex = 0; attrIndex < attLen; attrIndex++) 
          {
            attName = newAttrs[attrIndex].name;
            if (attName !== 'id') 
            {
              oldRowDom.setAttribute(attName, newAttrs[attrIndex].value);
            }
          }
      }
      if (columns.length && (oldDataRow = me.getNode(oldRowDom, true))) 
      {
        me.updateColumns(record, oldDataRow, me.getNode(newRowDom, true), columns, changedFieldNames);
      }
      while (rowTpl) 
        {
          if (rowTpl.syncContent) 
          {
            if (rowTpl.syncContent(oldRowDom, newRowDom) === false) 
            {
              break;
            }
          }
          rowTpl = rowTpl.nextTpl;
        }
      me.fireEvent('itemupdate', record, me.store.indexOf(record), oldRowDom);
      me.refreshSize();
    }
  }
}, updateColumns: function(record, oldRowDom, newRowDom, columns, changedFieldNames) {
  var me = this, newAttrs, attLen, attName, attrIndex, colCount = columns.length, colIndex, column, oldCell, newCell, row, editingPlugin = me.editingPlugin || (me.lockingPartner && me.ownerCt.ownerLockable.view.editingPlugin), isEditing = editingPlugin && editingPlugin.editing, cellSelector = me.getCellSelector();
  if (oldRowDom.mergeAttributes) 
  {
    oldRowDom.mergeAttributes(newRowDom, true);
  } else {
    newAttrs = newRowDom.attributes;
    attLen = newAttrs.length;
    for (attrIndex = 0; attrIndex < attLen; attrIndex++) 
      {
        attName = newAttrs[attrIndex].name;
        if (attName !== 'id') 
        {
          oldRowDom.setAttribute(attName, newAttrs[attrIndex].value);
        }
      }
  }
  for (colIndex = 0; colIndex < colCount; colIndex++) 
    {
      column = columns[colIndex];
      if (me.shouldUpdateCell(record, column, changedFieldNames)) 
      {
        cellSelector = me.getCellSelector(column);
        oldCell = Ext.DomQuery.selectNode(cellSelector, oldRowDom);
        newCell = Ext.DomQuery.selectNode(cellSelector, newRowDom);
        if (isEditing) 
        {
          Ext.fly(oldCell).syncContent(newCell);
        } else {
          row = oldCell.parentNode;
          row.insertBefore(newCell, oldCell);
          row.removeChild(oldCell);
        }
      }
    }
}, shouldUpdateCell: function(record, column, changedFieldNames) {
  if (column.hasCustomRenderer || !changedFieldNames) 
  {
    return true;
  }
  if (changedFieldNames) 
  {
    var len = changedFieldNames.length, i, field;
    for (i = 0; i < len; ++i) 
      {
        field = changedFieldNames[i];
        if (field === column.dataIndex || field === record.idProperty) 
        {
          return true;
        }
      }
  }
  return false;
}, refresh: function() {
  var me = this;
  me.callParent(arguments);
  me.headerCt.setSortState();
  if (me.el && me.headerCt && !me.ownerCt.hideHeaders && me.headerCt.tooNarrow && !me.all.getCount()) 
  {
    me.el.createChild({role: 'presentation', style: 'position:absolute;height:1px;width:1px;left:' + (me.headerCt.getTableWidth() - 1) + 'px'});
  }
  me.refreshSelection();
}, refreshSelection: function() {
  var me = this, selModel = me.selModel, selected, len, i;
  if (selModel.isRowModel) 
  {
    selected = selModel.selected.items;
    len = selected.length;
    for (i = 0; i < len; i++) 
      {
        me.onRowSelect(me.indexOf(me.getNode(selected[i])));
      }
  }
  me.selModel.onLastFocusChanged(null, me.selModel.lastFocused, true);
}, processItemEvent: function(record, row, rowIndex, e) {
  me = this;
  if (Ext.isIE && e.type === 'mouseup' && !e.within(me.el)) 
  {
    return false;
  }
  if (this.indexInStore(row) !== -1) 
  {
    var me, cell = e.getTarget(me.getCellSelector(), row), cellIndex, map = me.statics().EventMap, selModel = me.getSelectionModel(), type = e.type, features = me.features, len = features.length, i, result, feature, header;
    if (type == 'keydown' && !cell && selModel.getCurrentPosition) 
    {
      cell = me.getCellByPosition(selModel.getCurrentPosition(), true);
    }
    if (cell) 
    {
      if (!cell.parentNode) 
      {
        return false;
      }
      header = me.getHeaderByCell(cell);
      cellIndex = me.ownerCt.getColumnManager().getHeaderIndex(header);
    } else {
      cellIndex = -1;
    }
    result = me.fireEvent('uievent', type, me, cell, rowIndex, cellIndex, e, record, row);
    if ((result === false || me.callParent(arguments) === false)) 
    {
      if (selModel.onVetoUIEvent) 
      {
        selModel.onVetoUIEvent(type, me, cell, rowIndex, cellIndex, e, record, row);
      }
      return false;
    }
    for (i = 0; i < len; ++i) 
      {
        feature = features[i];
        if (feature.wrapsItem) 
        {
          if (feature.vetoEvent(record, row, rowIndex, e) === false) 
          {
            me.processSpecialEvent(e);
            return false;
          }
        }
      }
    if (type == 'mouseover' || type == 'mouseout') 
    {
      return true;
    }
    if (!cell) 
    {
      return true;
    }
    return !((me['onBeforeCell' + map[type]](cell, cellIndex, record, row, rowIndex, e) === false) || (me.fireEvent('beforecell' + type, me, cell, cellIndex, record, row, rowIndex, e) === false) || (me['onCell' + map[type]](cell, cellIndex, record, row, rowIndex, e) === false) || (me.fireEvent('cell' + type, me, cell, cellIndex, record, row, rowIndex, e) === false));
  } else {
    this.processSpecialEvent(e);
    return false;
  }
}, processSpecialEvent: function(e) {
  var me = this, features = me.features, ln = features.length, type = e.type, i, feature, prefix, featureTarget, beforeArgs, args, panel = me.ownerCt;
  me.callParent(arguments);
  if (type == 'mouseover' || type == 'mouseout') 
  {
    return;
  }
  for (i = 0; i < ln; i++) 
    {
      feature = features[i];
      if (feature.hasFeatureEvent) 
      {
        featureTarget = e.getTarget(feature.eventSelector, me.getTargetEl());
        if (featureTarget) 
        {
          prefix = feature.eventPrefix;
          beforeArgs = feature.getFireEventArgs('before' + prefix + type, me, featureTarget, e);
          args = feature.getFireEventArgs(prefix + type, me, featureTarget, e);
          if ((me.fireEvent.apply(me, beforeArgs) === false) || (panel.fireEvent.apply(panel, beforeArgs) === false) || (me.fireEvent.apply(me, args) === false) || (panel.fireEvent.apply(panel, args) === false)) 
          {
            return false;
          }
        }
      }
    }
  return true;
}, onCellMouseDown: Ext.emptyFn, onCellMouseUp: Ext.emptyFn, onCellClick: Ext.emptyFn, onCellDblClick: Ext.emptyFn, onCellContextMenu: Ext.emptyFn, onCellKeyDown: Ext.emptyFn, onBeforeCellMouseDown: Ext.emptyFn, onBeforeCellMouseUp: Ext.emptyFn, onBeforeCellClick: Ext.emptyFn, onBeforeCellDblClick: Ext.emptyFn, onBeforeCellContextMenu: Ext.emptyFn, onBeforeCellKeyDown: Ext.emptyFn, expandToFit: function(header) {
  this.autoSizeColumn(header);
}, autoSizeColumn: function(header) {
  if (Ext.isNumber(header)) 
  {
    header = this.getGridColumns[header];
  }
  if (header) 
  {
    if (header.isGroupHeader) 
    {
      header.autoSize();
      return;
    }
    delete header.flex;
    header.setWidth(this.getMaxContentWidth(header));
  }
}, getMaxContentWidth: function(header) {
  var me = this, cells = me.el.query(header.getCellInnerSelector()), originalWidth = header.getWidth(), i = 0, ln = cells.length, columnSizer = me.body.select(me.getColumnSizerSelector(header)), max = Math.max, widthAdjust = 0, maxWidth;
  if (ln > 0) 
  {
    if (Ext.supports.ScrollWidthInlinePaddingBug) 
    {
      widthAdjust += me.getCellPaddingAfter(cells[0]);
    }
    if (me.columnLines) 
    {
      widthAdjust += Ext.fly(cells[0].parentNode).getBorderWidth('lr');
    }
  }
  columnSizer.setWidth(1);
  header.titleEl.setStyle('text-overflow', 'clip');
  maxWidth = header.textEl.dom.offsetWidth + header.titleEl.getPadding('lr');
  header.titleEl.setStyle('text-overflow', '');
  for (; i < ln; i++) 
    {
      maxWidth = max(maxWidth, cells[i].scrollWidth);
    }
  maxWidth += widthAdjust;
  maxWidth = max(maxWidth, 40);
  columnSizer.setWidth(originalWidth);
  return maxWidth;
}, getPositionByEvent: function(e) {
  var me = this, cellNode = e.getTarget(me.cellSelector), rowNode = e.getTarget(me.itemSelector), record = me.getRecord(rowNode), header = me.getHeaderByCell(cellNode);
  return me.getPosition(record, header);
}, getHeaderByCell: function(cell) {
  if (cell) 
  {
    var match = cell.className.match(this.cellRe);
    if (match && match[1]) 
    {
      return this.ownerCt.getVisibleColumnManager().getHeaderById(match[1]);
    }
  }
  return false;
}, walkCells: function(pos, direction, e, preventWrap, verifierFn, scope) {
  if (!pos) 
  {
    return false;
  }
  var me = this, row = pos.row, column = pos.column, rowCount = me.dataSource.getCount(), allCols = me.ownerCt.getColumnManager(), visible = me.ownerCt.getVisibleColumnManager(), firstIndex = allCols.getHeaderIndex(visible.getFirst()), lastIndex = allCols.getHeaderIndex(visible.getLast()), newRow = row, newColumn = column, activeHeader = allCols.getHeaderAtIndex(column);
  if (!activeHeader || activeHeader.hidden || !rowCount) 
  {
    return false;
  }
  e = e || {};
  direction = direction.toLowerCase();
  switch (direction) {
    case 'right':
      if (column === lastIndex) 
      {
        if (preventWrap || row === rowCount - 1) 
        {
          return false;
        }
        if (!e.ctrlKey) 
        {
          newRow = me.walkRows(row, 1);
          if (newRow !== row) 
          {
            newColumn = firstIndex;
          }
        }
      } else {
        if (!e.ctrlKey) 
        {
          newColumn = allCols.getHeaderIndex(visible.getNextSibling(activeHeader));
        } else {
          newColumn = lastIndex;
        }
      }
      break;
    case 'left':
      if (column === firstIndex) 
      {
        if (preventWrap || row === 0) 
        {
          return false;
        }
        if (!e.ctrlKey) 
        {
          newRow = me.walkRows(row, -1);
          if (newRow !== row) 
          {
            newColumn = lastIndex;
          }
        }
      } else {
        if (!e.ctrlKey) 
        {
          newColumn = allCols.getHeaderIndex(visible.getPreviousSibling(activeHeader));
        } else {
          newColumn = firstIndex;
        }
      }
      break;
    case 'up':
      if (row === 0) 
      {
        return false;
      } else {
        if (!e.ctrlKey) 
        {
          newRow = me.walkRows(row, -1);
        } else {
          newRow = me.walkRows(-1, 1);
        }
      }
      break;
    case 'down':
      if (row === rowCount - 1) 
      {
        return false;
      } else {
        if (!e.ctrlKey) 
        {
          newRow = me.walkRows(row, 1);
        } else {
          newRow = me.walkRows(rowCount, -1);
        }
      }
      break;
  }
  if (verifierFn && verifierFn.call(scope || me, {row: newRow, column: newColumn}) !== true) 
  {
    return false;
  }
  newColumn = allCols.getHeaderAtIndex(newColumn);
  return new Ext.grid.CellContext(me).setPosition(newRow, newColumn);
}, walkRows: function(startRow, distance) {
  var me = this, store = me.dataSource, moved = 0, lastValid = startRow, node, limit = (distance < 0) ? 0 : (store.buffered ? store.getTotalCount() : store.getCount()) - 1, increment = limit ? 1 : -1, result = startRow;
  do {
    if (limit ? result >= limit : result <= limit) 
    {
      return lastValid || limit;
    }
    result += increment;
    if ((node = Ext.fly(me.getNode(result, true))) && node.isVisible(true)) 
    {
      moved += increment;
      lastValid = result;
    }
  } while (moved !== distance);
  return result;
}, walkRecs: function(startRec, distance) {
  var me = this, store = me.dataSource, moved = 0, lastValid = startRec, node, limit = (distance < 0) ? 0 : (store.buffered ? store.getTotalCount() : store.getCount()) - 1, increment = limit ? 1 : -1, testIndex = store.indexOf(startRec), rec;
  do {
    if (limit ? testIndex >= limit : testIndex <= limit) 
    {
      return lastValid;
    }
    testIndex += increment;
    rec = store.getAt(testIndex);
    if (!rec.isCollapsedPlaceholder && (node = Ext.fly(me.getNodeByRecord(rec, true))) && node.isVisible(true)) 
    {
      moved += increment;
      lastValid = rec;
    }
  } while (moved !== distance);
  return lastValid;
}, getFirstVisibleRowIndex: function() {
  var me = this, count = (me.dataSource.buffered ? me.dataSource.getTotalCount() : me.dataSource.getCount()), result = me.indexOf(me.all.first()) - 1;
  do {
    result += 1;
    if (result === count) 
    {
      return;
    }
  } while (!Ext.fly(me.getNode(result, true)).isVisible(true));
  return result;
}, getLastVisibleRowIndex: function() {
  var me = this, result = me.indexOf(me.all.last());
  do {
    result -= 1;
    if (result === -1) 
    {
      return;
    }
  } while (!Ext.fly(me.getNode(result, true)).isVisible(true));
  return result;
}, getHeaderCt: function() {
  return this.headerCt;
}, getPosition: function(record, header) {
  return new Ext.grid.CellContext(this).setPosition(record, header);
}, beforeDestroy: function() {
  var me = this;
  if (me.rendered) 
  {
    me.el.removeAllListeners();
  }
  me.callParent(arguments);
}, onDestroy: function() {
  var me = this, features = me.featuresMC, len, i;
  if (features) 
  {
    for (i = 0 , len = features.getCount(); i < len; ++i) 
      {
        features.getAt(i).destroy();
      }
  }
  me.featuresMC = null;
  this.callParent(arguments);
}, onReplace: function(store, startIndex, oldRecords, newRecords) {
  var me = this, selModel = me.selModel, nextIndex, isNextRowSelected, isNextRowFocused;
  me.callParent(arguments);
  me.doStripeRows(startIndex);
  if (me.rendered && selModel.isRowModel && !newRecords[0].isCollapsedPlaceholder) 
  {
    nextIndex = startIndex + newRecords.length;
    isNextRowSelected = selModel.isRowSelected(nextIndex);
    isNextRowFocused = me.indexOf(selModel.lastFocused) === (nextIndex);
    if (isNextRowSelected || isNextRowFocused) 
    {
      me.onRowDeselect(startIndex);
    }
    if (isNextRowSelected) 
    {
      me.onRowSelect(nextIndex);
    }
    if (selModel.isRowSelected(startIndex)) 
    {
      me.onRowSelect(startIndex);
    }
  }
  me.selModel.onLastFocusChanged(null, me.selModel.lastFocused, true);
}, onAdd: function(ds, records, index) {
  var me = this, selModel = me.selModel, nextIndex, isNextRowSelected, isNextRowFocused;
  me.callParent(arguments);
  me.doStripeRows(index);
  if (me.rendered && selModel.isRowModel && !records[0].isCollapsedPlaceholder) 
  {
    nextIndex = index + records.length;
    isNextRowSelected = selModel.isRowSelected(nextIndex);
    isNextRowFocused = me.indexOf(selModel.lastFocused) === (nextIndex);
    if (isNextRowSelected || isNextRowFocused) 
    {
      me.onRowDeselect(index);
    }
    if (isNextRowSelected) 
    {
      me.onRowSelect(nextIndex);
    }
    if (selModel.isRowSelected(index)) 
    {
      me.onRowSelect(index);
    }
  }
  me.selModel.onLastFocusChanged(null, me.selModel.lastFocused, true);
}, onRemove: function(ds, records, indexes) {
  var me = this, index, selModel = me.selModel, len = indexes.length, i = 0, delta = 0, record;
  me.callParent(arguments);
  me.doStripeRows(indexes[0]);
  if (me.rendered && selModel.isRowModel && !records[0].isCollapsedPlaceholder) 
  {
    for (; i < len; i++ , delta++) 
      {
        index = indexes[i] - delta;
        record = me.store.getAt(index);
        me.onRowDeselect(index);
        if (selModel.isRowSelected(record) && me.getNode(record)) 
        {
          me.onRowSelect(index);
        }
      }
  }
  selModel.onLastFocusChanged(null, selModel.lastFocused, true);
}, doStripeRows: function(startRow, endRow) {
  var me = this, rows, rowsLn, i, row;
  if (me.rendered && me.stripeRows) 
  {
    rows = me.getNodes(startRow, endRow);
    for (i = 0 , rowsLn = rows.length; i < rowsLn; i++) 
      {
        row = rows[i];
        row.className = row.className.replace(me.rowClsRe, ' ');
        startRow++;
        if (startRow % 2 === 0) 
        {
          row.className += (' ' + me.altRowCls);
        }
      }
  }
}, repaintRow: function(rowIdx) {
  var node = this.getNode(rowIdx), tds, i;
  if (node) 
  {
    tds = node.childNodes;
    i = tds.length;
    while (i--) 
      {
        tds[i].className = tds[i].className;
      }
  }
}, getRowStyleTableEl: function(item) {
  var me = this;
  if (!item.tagName) 
  {
    item = this.getNode(item);
  }
  return (me.hasActiveFeature() ? Ext.fly(item) : this.el).down('table.' + Ext.baseCSSPrefix + 'grid-table');
}, toggleRowTableCls: function(item, cls, enabled) {
  var me = this, table, root;
  if (!item.tagName) 
  {
    item = this.getNode(item);
  }
  root = me.isGrouping ? Ext.fly(item) : this.el;
  if (root) 
  {
    table = root.down('table.' + Ext.baseCSSPrefix + 'grid-table');
  }
  if (table) 
  {
    table[enabled ? 'addCls' : 'removeCls'](cls);
  }
}, isRowStyleFirst: function(item) {
  var me = this, index;
  if (item === -1) 
  {
    return false;
  }
  if (!item.tagName) 
  {
    index = item;
    item = this.getNode(item);
  } else {
    index = me.indexOf(item);
  }
  return (!index || me.hasActiveFeature() && item && Ext.fly(item).hasCls(Ext.baseCSSPrefix + 'grid-group-row'));
}, hasActiveFeature: function() {
  return (this.isGrouping && this.store.isGrouped()) || this.isRowWrapped;
}, getCellPaddingAfter: function(cell) {
  return Ext.fly(cell).getPadding('r');
}, hasVerticalScroll: function() {
  var me = this, first;
  if (me.ownerCt.isLocked || !me.scrollFlags.y) 
  {
    return false;
  }
  first = me.el.down('table');
  if (!first) 
  {
    return false;
  }
  return this.getHeight() < first.getHeight();
}}, 1, ["tableview"], ["component", "box", "tableview", "dataview"], {"component": true, "box": true, "tableview": true, "dataview": true}, ["widget.tableview"], 0, [Ext.view, 'Table'], 0));
;

(Ext.cmd.derive('Ext.grid.View', Ext.view.Table, {stripeRows: true, autoScroll: true}, 0, ["gridview"], ["component", "box", "tableview", "dataview", "gridview"], {"component": true, "box": true, "tableview": true, "dataview": true, "gridview": true}, ["widget.gridview"], 0, [Ext.grid, 'View'], 0));
;

(Ext.cmd.derive('Ext.grid.Panel', Ext.panel.Table, {alternateClassName: ['Ext.list.ListView', 'Ext.ListView', 'Ext.grid.GridPanel'], viewType: 'gridview', lockable: false, rowLines: true}, 0, ["grid", "gridpanel"], ["container", "component", "grid", "gridpanel", "box", "panel", "tablepanel"], {"container": true, "component": true, "grid": true, "gridpanel": true, "box": true, "panel": true, "tablepanel": true}, ["widget.grid", "widget.gridpanel"], 0, [Ext.grid, 'Panel', Ext.list, 'ListView', Ext, 'ListView', Ext.grid, 'GridPanel'], 0));
;

Ext.define('Ext.grid.plugin.BufferedRendererTableView', {override: 'Ext.view.Table', onReplace: function(store, startIndex, oldRecords, newRecords) {
  var me = this, bufferedRenderer = me.bufferedRenderer;
  if (me.rendered && bufferedRenderer) 
  {
    bufferedRenderer.onReplace(store, startIndex, oldRecords, newRecords);
  } else {
    me.callParent(arguments);
  }
}, onAdd: function(store, records, index) {
  var me = this, bufferedRenderer = me.bufferedRenderer;
  if (me.rendered && bufferedRenderer) 
  {
    bufferedRenderer.onReplace(store, index, [], records);
  } else {
    me.callParent([store, records, index]);
  }
}, onRemove: function(store, records, indices, isMove, removeRange) {
  var me = this, bufferedRenderer = me.bufferedRenderer;
  if (me.rendered && bufferedRenderer) 
  {
    if (removeRange) 
    {
      bufferedRenderer.onReplace(store, indices[0], records, []);
    } else {
      bufferedRenderer.refreshView();
    }
  } else {
    me.callParent([store, records, indices]);
  }
}, onDataRefresh: function() {
  var me = this;
  if (me.bufferedRenderer) 
  {
    me.all.clear();
    me.bufferedRenderer.onStoreClear();
  }
  me.callParent();
}});

(Ext.cmd.derive('Ext.view.DropZone', Ext.dd.DropZone, {indicatorCls: Ext.baseCSSPrefix + 'grid-drop-indicator', indicatorHtml: ['<div class="', Ext.baseCSSPrefix, 'grid-drop-indicator-left" role="presentation"></div>', '<div class="' + Ext.baseCSSPrefix + 'grid-drop-indicator-right" role="presentation"></div>'].join(''), constructor: function(config) {
  var me = this;
  Ext.apply(me, config);
  if (!me.ddGroup) 
  {
    me.ddGroup = 'view-dd-zone-' + me.view.id;
  }
  me.callParent([me.view.el]);
}, fireViewEvent: function() {
  var me = this, result;
  me.lock();
  result = me.view.fireEvent.apply(me.view, arguments);
  me.unlock();
  return result;
}, getTargetFromEvent: function(e) {
  var node = e.getTarget(this.view.getItemSelector()), mouseY, nodeList, testNode, i, len, box;
  if (!node) 
  {
    mouseY = e.getPageY();
    for (i = 0 , nodeList = this.view.getNodes() , len = nodeList.length; i < len; i++) 
      {
        testNode = nodeList[i];
        box = Ext.fly(testNode).getBox();
        if (mouseY <= box.bottom) 
        {
          return testNode;
        }
      }
  }
  return node;
}, getIndicator: function() {
  var me = this;
  if (!me.indicator) 
  {
    me.indicator = new Ext.Component({ariaRole: 'presentation', html: me.indicatorHtml, cls: me.indicatorCls, ownerCt: me.view, floating: true, shadow: false});
  }
  return me.indicator;
}, getPosition: function(e, node) {
  var y = e.getXY()[1], region = Ext.fly(node).getRegion(), pos;
  if ((region.bottom - y) >= (region.bottom - region.top) / 2) 
  {
    pos = "before";
  } else {
    pos = "after";
  }
  return pos;
}, containsRecordAtOffset: function(records, record, offset) {
  if (!record) 
  {
    return false;
  }
  var view = this.view, recordIndex = view.indexOf(record), nodeBefore = view.getNode(recordIndex + offset, true), recordBefore = nodeBefore ? view.getRecord(nodeBefore) : null;
  return recordBefore && Ext.Array.contains(records, recordBefore);
}, positionIndicator: function(node, data, e) {
  var me = this, view = me.view, pos = me.getPosition(e, node), overRecord = view.getRecord(node), draggingRecords = data.records, indicatorY;
  if (!Ext.Array.contains(draggingRecords, overRecord) && (pos == 'before' && !me.containsRecordAtOffset(draggingRecords, overRecord, -1) || pos == 'after' && !me.containsRecordAtOffset(draggingRecords, overRecord, 1))) 
  {
    me.valid = true;
    if (me.overRecord != overRecord || me.currentPosition != pos) 
    {
      indicatorY = Ext.fly(node).getY() - view.el.getY() - 1;
      if (pos == 'after') 
      {
        indicatorY += Ext.fly(node).getHeight();
      }
      me.getIndicator().setWidth(Ext.fly(view.el).getWidth()).showAt(0, indicatorY);
      me.overRecord = overRecord;
      me.currentPosition = pos;
    }
  } else {
    me.invalidateDrop();
  }
}, invalidateDrop: function() {
  if (this.valid) 
  {
    this.valid = false;
    this.getIndicator().hide();
  }
}, onNodeOver: function(node, dragZone, e, data) {
  var me = this;
  if (!Ext.Array.contains(data.records, me.view.getRecord(node))) 
  {
    me.positionIndicator(node, data, e);
  }
  return me.valid ? me.dropAllowed : me.dropNotAllowed;
}, notifyOut: function(node, dragZone, e, data) {
  var me = this;
  me.callParent(arguments);
  me.overRecord = me.currentPosition = null;
  me.valid = false;
  if (me.indicator) 
  {
    me.indicator.hide();
  }
}, onContainerOver: function(dd, e, data) {
  var me = this, view = me.view, count = view.dataSource.getCount();
  if (count) 
  {
    me.positionIndicator(view.all.last(), data, e);
  } else {
    me.overRecord = me.currentPosition = null;
    me.getIndicator().setWidth(Ext.fly(view.el).getWidth()).showAt(0, 0);
    me.valid = true;
  }
  return me.dropAllowed;
}, onContainerDrop: function(dd, e, data) {
  return this.onNodeDrop(dd, null, e, data);
}, onNodeDrop: function(targetNode, dragZone, e, data) {
  var me = this, dropHandled = false, dropHandlers = {wait: false, processDrop: function() {
  me.invalidateDrop();
  me.handleNodeDrop(data, me.overRecord, me.currentPosition);
  dropHandled = true;
  me.fireViewEvent('drop', targetNode, data, me.overRecord, me.currentPosition);
}, cancelDrop: function() {
  me.invalidateDrop();
  dropHandled = true;
}}, performOperation = false;
  if (me.valid) 
  {
    performOperation = me.fireViewEvent('beforedrop', targetNode, data, me.overRecord, me.currentPosition, dropHandlers);
    if (dropHandlers.wait) 
    {
      return;
    }
    if (performOperation !== false) 
    {
      if (!dropHandled) 
      {
        dropHandlers.processDrop();
      }
    }
  }
  return performOperation;
}, destroy: function() {
  Ext.destroy(this.indicator);
  delete this.indicator;
  this.callParent();
}}, 1, 0, 0, 0, 0, 0, [Ext.view, 'DropZone'], 0));
;

(Ext.cmd.derive('Ext.grid.ViewDropZone', Ext.view.DropZone, {indicatorHtml: '<div class="' + Ext.baseCSSPrefix + 'grid-drop-indicator-left" role="presentation"></div><div class="' + Ext.baseCSSPrefix + 'grid-drop-indicator-right" role="presentation"></div>', indicatorCls: Ext.baseCSSPrefix + 'grid-drop-indicator', handleNodeDrop: function(data, record, position) {
  var view = this.view, store = view.getStore(), index, records, i, len;
  if (data.copy) 
  {
    records = data.records;
    data.records = [];
    for (i = 0 , len = records.length; i < len; i++) 
      {
        data.records.push(records[i].copy());
      }
  } else {
    data.view.store.remove(data.records, data.view === view);
  }
  if (record && position) 
  {
    index = store.indexOf(record);
    if (position !== 'before') 
    {
      index++;
    }
    store.insert(index, data.records);
  } else {
    store.add(data.records);
  }
  view.getSelectionModel().select(data.records);
}}, 0, 0, 0, 0, 0, 0, [Ext.grid, 'ViewDropZone'], 0));
;

(Ext.cmd.derive('Ext.grid.plugin.HeaderResizer', Ext.AbstractPlugin, {disabled: false, config: {dynamic: false}, colHeaderCls: Ext.baseCSSPrefix + 'column-header', minColWidth: 40, maxColWidth: 1000, wResizeCursor: 'col-resize', eResizeCursor: 'col-resize', init: function(headerCt) {
  this.headerCt = headerCt;
  headerCt.on('render', this.afterHeaderRender, this, {single: true});
}, destroy: function() {
  var tracker = this.tracker;
  if (tracker) 
  {
    delete tracker.onBeforeStart;
    delete tracker.onStart;
    delete tracker.onDrag;
    delete tracker.onEnd;
    tracker.destroy();
    this.tracker = null;
  }
}, afterHeaderRender: function() {
  var me = this, headerCt = this.headerCt, el = headerCt.el;
  headerCt.mon(el, 'mousemove', this.onHeaderCtMouseMove, this);
  me.markerOwner = me.ownerGrid = me.headerCt.up('tablepanel');
  if (me.markerOwner.ownerLockable) 
  {
    me.markerOwner = me.markerOwner.ownerLockable;
  }
  me.tracker = new Ext.dd.DragTracker({disabled: me.disabled, onBeforeStart: Ext.Function.bind(me.onBeforeStart, me), onStart: Ext.Function.bind(me.onStart, me), onDrag: Ext.Function.bind(me.onDrag, me), onEnd: Ext.Function.bind(me.onEnd, me), tolerance: 3, autoStart: 300, el: el});
}, onHeaderCtMouseMove: function(e) {
  var me = this, headerEl, overHeader, resizeHeader, headers;
  if (me.headerCt.dragging || me.disabled) 
  {
    if (me.activeHd) 
    {
      me.activeHd.el.dom.style.cursor = '';
      delete me.activeHd;
    }
  } else {
    headerEl = e.getTarget('.' + me.colHeaderCls, 3, true);
    if (headerEl) 
    {
      overHeader = Ext.getCmp(headerEl.id);
      if (overHeader.isOnRightEdge(e)) 
      {
        if (me.headerCt.visibleColumnManager.getColumns().length === 1 && me.headerCt.forceFit) 
        {
          return;
        }
        resizeHeader = overHeader;
      } else if (overHeader.isOnLeftEdge(e)) 
      {
        headers = me.headerCt.visibleColumnManager.getColumns();
        resizeHeader = headers[Ext.Array.indexOf(headers, overHeader) - 1];
        if (!resizeHeader && me.ownerGrid.ownerLockable && !me.ownerGrid.isLocked) 
        {
          headers = me.ownerGrid.ownerLockable.lockedGrid.headerCt.visibleColumnManager.getColumns();
          resizeHeader = headers[headers.length - 1];
        }
      }
      if (resizeHeader) 
      {
        if (resizeHeader.isGroupHeader) 
        {
          headers = resizeHeader.getGridColumns();
          resizeHeader = headers[headers.length - 1];
        }
        if (resizeHeader && !(resizeHeader.fixed || (resizeHeader.resizable === false))) 
        {
          me.activeHd = resizeHeader;
          overHeader.el.dom.style.cursor = me.eResizeCursor;
          if (overHeader.triggerEl) 
          {
            overHeader.triggerEl.dom.style.cursor = me.eResizeCursor;
          }
        }
      } else {
        overHeader.el.dom.style.cursor = '';
        if (overHeader.triggerEl) 
        {
          overHeader.triggerEl.dom.style.cursor = '';
        }
        me.activeHd = null;
      }
    }
  }
}, onBeforeStart: function(e) {
  var me = this;
  me.dragHd = me.activeHd;
  if (!!me.dragHd && !me.headerCt.dragging) 
  {
    me.xDelta = me.dragHd.getX() + me.dragHd.getWidth() - me.tracker.getXY()[0];
    this.tracker.constrainTo = this.getConstrainRegion();
    return true;
  } else {
    me.headerCt.dragging = false;
    return false;
  }
}, getConstrainRegion: function() {
  var me = this, dragHdEl = me.dragHd.el, rightAdjust = 0, nextHd, lockedGrid, maxColWidth = me.headerCt.getWidth() - me.headerCt.visibleColumnManager.getColumns().length * me.minColWidth;
  if (me.headerCt.forceFit) 
  {
    nextHd = me.dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
    if (nextHd && me.headerInSameGrid(nextHd)) 
    {
      rightAdjust = nextHd.getWidth() - me.minColWidth;
    }
  } else if ((lockedGrid = me.dragHd.up('tablepanel')).isLocked) 
  {
    rightAdjust = me.dragHd.up('[scrollerOwner]').getTargetEl().getWidth() - lockedGrid.getWidth() - (lockedGrid.ownerLockable.normalGrid.visibleColumnManager.getColumns().length * me.minColWidth + Ext.getScrollbarSize().width);
  } else {
    rightAdjust = maxColWidth - dragHdEl.getWidth();
  }
  return me.adjustConstrainRegion(dragHdEl.getRegion(), 0, rightAdjust - me.xDelta, 0, me.minColWidth - me.xDelta);
}, onStart: function(e) {
  var me = this, dragHd = me.dragHd, width = dragHd.el.getWidth(), headerCt = dragHd.getOwnerHeaderCt(), x, y, markerOwner, lhsMarker, rhsMarker, markerHeight;
  me.headerCt.dragging = true;
  me.origWidth = width;
  if (!me.dynamic) 
  {
    markerOwner = me.markerOwner;
    if (markerOwner.frame && markerOwner.resizable) 
    {
      me.gridOverflowSetting = markerOwner.el.dom.style.overflow;
      markerOwner.el.dom.style.overflow = 'hidden';
    }
    x = me.getLeftMarkerX(markerOwner);
    lhsMarker = markerOwner.getLhsMarker();
    rhsMarker = markerOwner.getRhsMarker();
    markerHeight = me.ownerGrid.body.getHeight() + headerCt.getHeight();
    y = headerCt.getOffsetsTo(markerOwner)[1] - markerOwner.el.getBorderWidth('t');
    lhsMarker.setLocalY(y);
    rhsMarker.setLocalY(y);
    lhsMarker.setHeight(markerHeight);
    rhsMarker.setHeight(markerHeight);
    me.setMarkerX(lhsMarker, x);
    me.setMarkerX(rhsMarker, x + width);
  }
}, onDrag: function(e) {
  var me = this;
  if (me.dynamic) 
  {
    me.doResize();
  } else {
    me.setMarkerX(me.getMovingMarker(me.markerOwner), me.calculateDragX(me.markerOwner));
  }
}, getMovingMarker: function(markerOwner) {
  return markerOwner.getRhsMarker();
}, onEnd: function(e) {
  this.headerCt.dragging = false;
  if (this.dragHd) 
  {
    if (!this.dynamic) 
    {
      var markerOwner = this.headerCt.up('tablepanel');
      if (markerOwner.ownerLockable) 
      {
        markerOwner = markerOwner.ownerLockable;
      }
      if ('gridOverflowSetting' in this) 
      {
        markerOwner.el.dom.style.overflow = this.gridOverflowSetting;
      }
      this.setMarkerX(markerOwner.getLhsMarker(), -9999);
      this.setMarkerX(markerOwner.getRhsMarker(), -9999);
    }
    this.doResize();
  }
  this.onHeaderCtMouseMove(e);
}, doResize: function() {
  var me = this, dragHd = me.dragHd, nextHd, offset = me.tracker.getOffset('point');
  if (dragHd && offset[0]) 
  {
    if (dragHd.flex) 
    {
      delete dragHd.flex;
    }
    Ext.suspendLayouts();
    me.adjustColumnWidth(offset[0]);
    if (me.headerCt.forceFit) 
    {
      nextHd = dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
      if (nextHd && !me.headerInSameGrid(nextHd)) 
      {
        nextHd = null;
      }
      if (nextHd) 
      {
        delete nextHd.flex;
        nextHd.setWidth(nextHd.getWidth() - offset[0]);
      }
    }
    Ext.resumeLayouts(true);
  }
}, headerInSameGrid: function(header) {
  var grid = this.dragHd.up('tablepanel');
  return !!header.up(grid);
}, disable: function() {
  this.disabled = true;
  if (this.tracker) 
  {
    this.tracker.disable();
  }
}, enable: function() {
  this.disabled = false;
  if (this.tracker) 
  {
    this.tracker.enable();
  }
}, calculateDragX: function(markerOwner) {
  return this.tracker.getXY('point')[0] + this.xDelta - markerOwner.getX() - markerOwner.el.getBorderWidth('l');
}, getLeftMarkerX: function(markerOwner) {
  return this.dragHd.getX() - markerOwner.getX() - markerOwner.el.getBorderWidth('l') - 1;
}, setMarkerX: function(marker, x) {
  marker.setLocalX(x);
}, adjustConstrainRegion: function(region, t, r, b, l) {
  return region.adjust(t, r, b, l);
}, adjustColumnWidth: function(offsetX) {
  this.dragHd.setWidth(this.origWidth + offsetX);
}}, 0, 0, 0, 0, ["plugin.gridheaderresizer"], 0, [Ext.grid.plugin, 'HeaderResizer'], 0));
;

(Ext.cmd.derive('Ext.grid.header.DragZone', Ext.dd.DragZone, {colHeaderSelector: '.' + Ext.baseCSSPrefix + 'column-header', colInnerSelector: '.' + Ext.baseCSSPrefix + 'column-header-inner', maxProxyWidth: 120, constructor: function(headerCt) {
  var me = this;
  me.headerCt = headerCt;
  me.ddGroup = me.getDDGroup();
  me.autoGroup = true;
  me.callParent([headerCt.el]);
  me.proxy.el.addCls(Ext.baseCSSPrefix + 'grid-col-dd');
}, getDDGroup: function() {
  return 'header-dd-zone-' + this.headerCt.up('[scrollerOwner]').id;
}, getDragData: function(e) {
  if (e.getTarget(this.colInnerSelector)) 
  {
    var header = e.getTarget(this.colHeaderSelector), headerCmp, ddel;
    if (header) 
    {
      headerCmp = Ext.getCmp(header.id);
      if (!this.headerCt.dragging && headerCmp.draggable && !(headerCmp.isOnLeftEdge(e) || headerCmp.isOnRightEdge(e))) 
      {
        ddel = document.createElement('div');
        ddel.role = 'presentation';
        ddel.innerHTML = Ext.getCmp(header.id).text;
        return {ddel: ddel, header: headerCmp};
      }
    }
  }
  return false;
}, onBeforeDrag: function() {
  return !(this.headerCt.dragging || this.disabled);
}, onInitDrag: function() {
  this.headerCt.dragging = true;
  this.callParent(arguments);
}, onDragDrop: function() {
  this.headerCt.dragging = false;
  this.callParent(arguments);
}, afterRepair: function() {
  this.callParent();
  this.headerCt.dragging = false;
}, getRepairXY: function() {
  return this.dragData.header.el.getXY();
}, disable: function() {
  this.disabled = true;
}, enable: function() {
  this.disabled = false;
}}, 1, 0, 0, 0, 0, 0, [Ext.grid.header, 'DragZone'], 0));
;

(Ext.cmd.derive('Ext.grid.header.DropZone', Ext.dd.DropZone, {colHeaderCls: Ext.baseCSSPrefix + 'column-header', proxyOffsets: [-4, -9], constructor: function(headerCt) {
  var me = this;
  me.headerCt = headerCt;
  me.ddGroup = me.getDDGroup();
  me.autoGroup = true;
  me.callParent([headerCt.el]);
}, destroy: function() {
  this.callParent();
  Ext.destroy(this.topIndicator, this.bottomIndicator);
}, getDDGroup: function() {
  return 'header-dd-zone-' + this.headerCt.up('[scrollerOwner]').id;
}, getTargetFromEvent: function(e) {
  return e.getTarget('.' + this.colHeaderCls);
}, getTopIndicator: function() {
  if (!this.topIndicator) 
  {
    this.topIndicator = Ext.DomHelper.append(Ext.getBody(), {role: 'presentation', cls: "col-move-top", html: "&#160;"}, true);
    this.indicatorXOffset = Math.floor((this.topIndicator.dom.offsetWidth + 1) / 2);
  }
  return this.topIndicator;
}, getBottomIndicator: function() {
  if (!this.bottomIndicator) 
  {
    this.bottomIndicator = Ext.DomHelper.append(Ext.getBody(), {role: 'presentation', cls: "col-move-bottom", html: "&#160;"}, true);
  }
  return this.bottomIndicator;
}, getLocation: function(e, t) {
  var x = e.getXY()[0], region = Ext.fly(t).getRegion(), pos;
  if ((region.right - x) <= (region.right - region.left) / 2) 
  {
    pos = "after";
  } else {
    pos = "before";
  }
  return {pos: pos, header: Ext.getCmp(t.id), node: t};
}, positionIndicator: function(data, node, e) {
  var me = this, dragHeader = data.header, dropLocation = me.getLocation(e, node), targetHeader = dropLocation.header, pos = dropLocation.pos, nextHd, prevHd, topIndicator, bottomIndicator, topAnchor, bottomAnchor, topXY, bottomXY, headerCtEl, minX, maxX, allDropZones, ln, i, dropZone;
  if (targetHeader === me.lastTargetHeader && pos === me.lastDropPos) 
  {
    return;
  }
  nextHd = dragHeader.nextSibling('gridcolumn:not([hidden])');
  prevHd = dragHeader.previousSibling('gridcolumn:not([hidden])');
  me.lastTargetHeader = targetHeader;
  me.lastDropPos = pos;
  if (!targetHeader.draggable && pos === 'before' && targetHeader.getIndex() === 0) 
  {
    return false;
  }
  data.dropLocation = dropLocation;
  if ((dragHeader !== targetHeader) && ((pos === "before" && nextHd !== targetHeader) || (pos === "after" && prevHd !== targetHeader)) && !targetHeader.isDescendantOf(dragHeader)) 
  {
    allDropZones = Ext.dd.DragDropManager.getRelated(me);
    ln = allDropZones.length;
    i = 0;
    for (; i < ln; i++) 
      {
        dropZone = allDropZones[i];
        if (dropZone !== me && dropZone.invalidateDrop) 
        {
          dropZone.invalidateDrop();
        }
      }
    me.valid = true;
    topIndicator = me.getTopIndicator();
    bottomIndicator = me.getBottomIndicator();
    if (pos === 'before') 
    {
      topAnchor = 'bc-tl';
      bottomAnchor = 'tc-bl';
    } else {
      topAnchor = 'bc-tr';
      bottomAnchor = 'tc-br';
    }
    topXY = topIndicator.getAlignToXY(targetHeader.el, topAnchor);
    bottomXY = bottomIndicator.getAlignToXY(targetHeader.el, bottomAnchor);
    headerCtEl = me.headerCt.el;
    minX = headerCtEl.getX() - me.indicatorXOffset;
    maxX = headerCtEl.getX() + headerCtEl.getWidth();
    topXY[0] = Ext.Number.constrain(topXY[0], minX, maxX);
    bottomXY[0] = Ext.Number.constrain(bottomXY[0], minX, maxX);
    topIndicator.setXY(topXY);
    bottomIndicator.setXY(bottomXY);
    topIndicator.show();
    bottomIndicator.show();
  } else {
    me.invalidateDrop();
  }
}, invalidateDrop: function() {
  this.valid = false;
  this.hideIndicators();
}, onNodeOver: function(node, dragZone, e, data) {
  var me = this, from = data.header, doPosition, to, fromPanel, toPanel;
  if (data.header.el.dom === node) 
  {
    doPosition = false;
  } else {
    data.isLock = data.isUnlock = data.crossPanel = false;
    to = me.getLocation(e, node).header;
    doPosition = (from.ownerCt === to.ownerCt);
    if (!doPosition && (!from.ownerCt.sealed && !to.ownerCt.sealed)) 
    {
      doPosition = true;
      fromPanel = from.up('tablepanel');
      toPanel = to.up('tablepanel');
      if (fromPanel !== toPanel) 
      {
        data.crossPanel = true;
        data.isLock = toPanel.isLocked && !fromPanel.isLocked;
        data.isUnlock = !toPanel.isLocked && fromPanel.isLocked;
        if ((data.isUnlock && from.lockable === false) || (data.isLock && !from.isLockable())) 
        {
          doPosition = false;
        }
      }
    }
  }
  if (doPosition) 
  {
    me.positionIndicator(data, node, e);
  } else {
    me.valid = false;
  }
  return me.valid ? me.dropAllowed : me.dropNotAllowed;
}, hideIndicators: function() {
  var me = this;
  me.getTopIndicator().hide();
  me.getBottomIndicator().hide();
  me.lastTargetHeader = me.lastDropPos = null;
}, onNodeOut: function() {
  this.hideIndicators();
}, onNodeDrop: function(node, dragZone, e, data) {
  if (this.valid) 
  {
    var dragHeader = data.header, dropLocation = data.dropLocation, targetHeader = dropLocation.header, fromCt = dragHeader.ownerCt, toCt = targetHeader.ownerCt, sameCt = fromCt === toCt, localFromIdx = fromCt.items.indexOf(data.header), localToIdx = toCt.items.indexOf(targetHeader), headerCt = this.headerCt, columns = headerCt.visibleColumnManager, visibleFromIdx = columns.getHeaderIndex(dragHeader), visibleToIdx = targetHeader.isGroupHeader ? toCt.items.indexOf(targetHeader) : columns.getHeaderIndex(targetHeader), colsToMove = dragHeader.isGroupHeader ? dragHeader.query(':not([hidden]):not([isGroupHeader])').length : 1, direction = targetHeader.isGroupHeader ? (dropLocation.pos === 'after') : columns.getHeaderIndex(targetHeader) > columns.getHeaderIndex(dragHeader), scrollerOwner, savedWidth;
    if (dropLocation.pos === 'after') 
    {
      localToIdx++;
      visibleToIdx += targetHeader.isGroupHeader ? targetHeader.query(':not([hidden]):not([isGroupHeader])').length : 1;
    }
    if (data.isLock) 
    {
      scrollerOwner = fromCt.up('[scrollerOwner]');
      scrollerOwner.lock(dragHeader, localToIdx, toCt);
    } else if (data.isUnlock) 
    {
      scrollerOwner = fromCt.up('[scrollerOwner]');
      scrollerOwner.unlock(dragHeader, localToIdx, toCt);
    } else {
      this.invalidateDrop();
      savedWidth = dragHeader.getWidth();
      if (sameCt) 
      {
        if (localToIdx > localFromIdx) 
        {
          localToIdx -= 1;
        }
        if (localToIdx === localFromIdx) 
        {
          headerCt.onHeaderMoved(dragHeader, colsToMove, visibleFromIdx, visibleToIdx);
          return;
        }
      }
      Ext.suspendLayouts();
      if (sameCt) 
      {
        toCt.move(localFromIdx, localToIdx);
      } else {
        if (direction && (visibleToIdx === localToIdx)) 
        {
          localToIdx -= 1;
        }
        fromCt.isDDMoveInGrid = toCt.isDDMoveInGrid = !data.crossPanel;
        fromCt.remove(dragHeader, false);
        toCt.insert(localToIdx, dragHeader);
        fromCt.isDDMoveInGrid = toCt.isDDMoveInGrid = false;
      }
      if (toCt.isGroupHeader) 
      {
        if (!sameCt) 
        {
          dragHeader.savedFlex = dragHeader.flex;
          delete dragHeader.flex;
          dragHeader.width = savedWidth;
        }
      } else {
        if (dragHeader.savedFlex) 
        {
          dragHeader.flex = dragHeader.savedFlex;
          delete dragHeader.width;
        }
      }
      Ext.resumeLayouts(true);
      if (!sameCt) 
      {
        headerCt.onHeaderMoved(dragHeader, colsToMove, visibleFromIdx, visibleToIdx);
      }
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.grid.header, 'DropZone'], 0));
;

(Ext.cmd.derive('Ext.grid.plugin.HeaderReorderer', Ext.AbstractPlugin, {init: function(headerCt) {
  this.headerCt = headerCt;
  headerCt.on({render: this.onHeaderCtRender, single: true, scope: this});
}, destroy: function() {
  Ext.destroy(this.dragZone, this.dropZone);
}, onHeaderCtRender: function() {
  var me = this;
  me.dragZone = new Ext.grid.header.DragZone(me.headerCt);
  me.dropZone = new Ext.grid.header.DropZone(me.headerCt);
  if (me.disabled) 
  {
    me.dragZone.disable();
  }
}, enable: function() {
  this.disabled = false;
  if (this.dragZone) 
  {
    this.dragZone.enable();
  }
}, disable: function() {
  this.disabled = true;
  if (this.dragZone) 
  {
    this.dragZone.disable();
  }
}}, 0, 0, 0, 0, ["plugin.gridheaderreorderer"], 0, [Ext.grid.plugin, 'HeaderReorderer'], 0));
;

(Ext.cmd.derive('Ext.grid.header.Container', Ext.container.Container, {border: true, baseCls: Ext.baseCSSPrefix + 'grid-header-ct', dock: 'top', weight: 100, defaultType: 'gridcolumn', detachOnRemove: false, defaultWidth: 100, sortAscText: 'Sort Ascending', sortDescText: 'Sort Descending', sortClearText: 'Clear Sort', columnsText: 'Columns', headerOpenCls: Ext.baseCSSPrefix + 'column-header-open', menuSortAscCls: Ext.baseCSSPrefix + 'hmenu-sort-asc', menuSortDescCls: Ext.baseCSSPrefix + 'hmenu-sort-desc', menuColsIcon: Ext.baseCSSPrefix + 'cols-icon', ddLock: false, dragging: false, sortable: true, enableColumnHide: true, initComponent: function() {
  var me = this;
  me.headerCounter = 0;
  me.plugins = me.plugins || [];
  me.defaults = me.defaults || {};
  if (!me.isColumn) 
  {
    if (me.enableColumnResize) 
    {
      me.resizer = new Ext.grid.plugin.HeaderResizer();
      me.plugins.push(me.resizer);
    }
    if (me.enableColumnMove) 
    {
      me.reorderer = new Ext.grid.plugin.HeaderReorderer();
      me.plugins.push(me.reorderer);
    }
  }
  if (me.isColumn && !me.isGroupHeader) 
  {
    if (!me.items || me.items.length === 0) 
    {
      me.isContainer = false;
      me.layout = {type: 'container', calculate: Ext.emptyFn};
    }
  } else {
    me.layout = Ext.apply({type: 'gridcolumn', align: 'stretch'}, me.initialConfig.layout);
    me.defaults.columnLines = me.columnLines;
    if (!me.isGroupHeader) 
    {
      me.isRootHeader = true;
      me.columnManager = new Ext.grid.ColumnManager(false, me);
      me.visibleColumnManager = new Ext.grid.ColumnManager(true, me);
      if (me.grid) 
      {
        me.grid.columnManager = me.columnManager;
        me.grid.visibleColumnManager = me.visibleColumnManager;
      }
    } else {
      me.visibleColumnManager = new Ext.grid.ColumnManager(true, me);
      me.columnManager = new Ext.grid.ColumnManager(false, me);
    }
  }
  Ext.applyIf(me.defaults, {sortable: me.sortable});
  me.menuTask = new Ext.util.DelayedTask(me.updateMenuDisabledState, me);
  me.callParent();
  me.addEvents('columnresize', 'headerclick', 'headercontextmenu', 'headertriggerclick', 'columnmove', 'columnhide', 'columnshow', 'columnschanged', 'sortchange', 'menucreate');
}, initEvents: function() {
  var me = this;
  me.callParent();
  if (!me.isColumn && !me.isGroupHeader) 
  {
    me.mon(me.el, {click: me.onHeaderCtEvent, dblclick: me.onHeaderCtEvent, contextmenu: me.onHeaderCtEvent, mouseover: me.onHeaderCtMouseOver, mouseout: me.onHeaderCtMouseOut, scope: me});
  }
}, onHeaderCtEvent: function(e, t) {
  var me = this, headerEl = e.getTarget('.' + Ext.grid.column.Column.prototype.baseCls), header, targetEl, isTriggerClick;
  if (headerEl && !me.ddLock) 
  {
    header = Ext.getCmp(headerEl.id);
    if (header) 
    {
      targetEl = header[header.clickTargetName];
      if (e.within(targetEl)) 
      {
        if (e.type === 'click') 
        {
          isTriggerClick = header.onTitleElClick(e, targetEl);
          if (isTriggerClick) 
          {
            me.onHeaderTriggerClick(header, e, t);
          } else {
            me.onHeaderClick(header, e, t);
          }
        } else if (e.type === 'contextmenu') 
        {
          me.onHeaderContextMenu(header, e, t);
        } else if (e.type === 'dblclick' && header.resizable) 
        {
          header.onTitleElDblClick(e, targetEl.dom);
        }
      }
    }
  }
}, onHeaderCtMouseOver: function(e, t) {
  var headerEl, header, targetEl;
  if (!e.within(this.el, true)) 
  {
    headerEl = e.getTarget('.' + Ext.grid.column.Column.prototype.baseCls);
    header = headerEl && Ext.getCmp(headerEl.id);
    if (header) 
    {
      targetEl = header[header.clickTargetName];
      if (e.within(targetEl)) 
      {
        header.onTitleMouseOver(e, targetEl.dom);
      }
    }
  }
}, onHeaderCtMouseOut: function(e, t) {
  var headerSelector = '.' + Ext.grid.column.Column.prototype.baseCls, outHeaderEl = e.getTarget(headerSelector), inHeaderEl = e.getRelatedTarget(headerSelector), header, targetEl;
  if (outHeaderEl !== inHeaderEl) 
  {
    if (outHeaderEl) 
    {
      header = Ext.getCmp(outHeaderEl.id);
      if (header) 
      {
        targetEl = header[header.clickTargetName];
        header.onTitleMouseOut(e, targetEl.dom);
      }
    }
    if (inHeaderEl) 
    {
      header = Ext.getCmp(inHeaderEl.id);
      if (header) 
      {
        targetEl = header[header.clickTargetName];
        header.onTitleMouseOver(e, targetEl.dom);
      }
    }
  }
}, isLayoutRoot: function() {
  if (this.hiddenHeaders) 
  {
    return false;
  }
  return this.callParent();
}, getOwnerHeaderCt: function() {
  var me = this;
  return me.isRootHeader ? me : me.up('[isRootHeader]');
}, onDestroy: function() {
  var me = this;
  if (me.menu) 
  {
    me.menu.un('hide', me.onMenuHide, me);
  }
  me.menuTask.cancel();
  me.callParent();
  Ext.destroy(me.visibleColumnManager, me.columnManager, me.menu);
  me.columnManager = me.visibleColumnManager = null;
}, applyColumnsState: function(columns) {
  if (!columns || !columns.length) 
  {
    return;
  }
  var me = this, items = me.items.items, count = items.length, i = 0, length = columns.length, c, col, columnState, index, moved = false;
  for (c = 0; c < length; c++) 
    {
      columnState = columns[c];
      for (index = count; index--; ) 
        {
          col = items[index];
          if (col.getStateId && col.getStateId() == columnState.id) 
          {
            if (i !== index) 
            {
              this.items.insert(i, this.items.getAt(index));
              moved = true;
            }
            if (col.applyColumnState) 
            {
              col.applyColumnState(columnState);
            }
            ++i;
            break;
          }
        }
    }
  if (moved) 
  {
    me.purgeCache();
  }
}, getColumnsState: function() {
  var me = this, columns = [], state;
  me.items.each(function(col) {
  state = col.getColumnState && col.getColumnState();
  if (state) 
  {
    columns.push(state);
  }
});
  return columns;
}, onAdd: function(c) {
  var me = this;
  if (!c.headerId) 
  {
    c.headerId = c.initialConfig.id || Ext.id(null, 'header-');
  }
  if (!c.getStateId()) 
  {
    c.stateId = c.initialConfig.id || ('h' + (++me.headerCounter));
  }
  me.callParent(arguments);
  me.onHeadersChanged(c, me.isDDMoveInGrid);
}, move: function(fromIdx, toIdx) {
  var me = this, headerToMove = me.items.items[fromIdx];
  headerToMove.visibleFromIdx = me.getOwnerHeaderCt().visibleColumnManager.indexOf(headerToMove);
  me.callParent(arguments);
}, onMove: function(headerToMove, fromIdx, toIdx) {
  var me = this, gridHeaderCt = me.getOwnerHeaderCt(), gridVisibleColumnManager = gridHeaderCt.visibleColumnManager, numColsToMove = 1, visibleToIdx;
  me.onHeadersChanged(headerToMove, true);
  visibleToIdx = gridVisibleColumnManager.indexOf(headerToMove);
  if (visibleToIdx >= headerToMove.visibleFromIdx) 
  {
    visibleToIdx++;
  }
  me.callParent(arguments);
  if (headerToMove.isGroupHeader) 
  {
    numColsToMove = headerToMove.visibleColumnManager.getColumns().length;
  }
  gridHeaderCt.onHeaderMoved(headerToMove, numColsToMove, headerToMove.visibleFromIdx, visibleToIdx);
}, onRemove: function(c) {
  var me = this, ownerCt = me.ownerCt;
  me.callParent(arguments);
  if (!me.destroying) 
  {
    if (!me.isDDMoveInGrid) 
    {
      me.onHeadersChanged(c, false);
    }
    if (me.isGroupHeader && !me.items.getCount() && ownerCt) 
    {
      me.detachComponent(c);
      Ext.suspendLayouts();
      ownerCt.remove(me);
      Ext.resumeLayouts(true);
    }
  }
}, onHeadersChanged: function(c, isMove) {
  var gridPanel, gridHeaderCt = this.getOwnerHeaderCt();
  this.purgeHeaderCtCache(this);
  if (gridHeaderCt) 
  {
    gridHeaderCt.onColumnsChanged();
    if (!c.isGroupHeader) 
    {
      gridPanel = gridHeaderCt.ownerCt;
      if (gridPanel && !isMove) 
      {
        gridPanel.onHeadersChanged(gridHeaderCt, c);
      }
    }
  }
}, onHeaderMoved: function(header, colsToMove, fromIdx, toIdx) {
  var me = this, gridSection = me.ownerCt;
  if (me.rendered) 
  {
    if (gridSection && gridSection.onHeaderMove) 
    {
      gridSection.onHeaderMove(me, header, colsToMove, fromIdx, toIdx);
    }
    me.fireEvent('columnmove', me, header, fromIdx, toIdx);
  }
}, onColumnsChanged: function() {
  var me = this, menu = me.menu, columnItemSeparator, columnItem;
  if (me.rendered) 
  {
    me.fireEvent('columnschanged', me);
    if (menu && (columnItemSeparator = menu.child('#columnItemSeparator'))) 
    {
      columnItem = menu.child('#columnItem') , columnItemSeparator.destroy();
      columnItem.destroy();
    }
  }
}, applyDefaults: function(config) {
  var ret;
  if (config && !config.isComponent && config.xtype == 'rownumberer') 
  {
    ret = config;
  } else {
    ret = this.callParent(arguments);
    if (!config.isGroupHeader && !('width' in ret) && !ret.flex) 
    {
      ret.width = this.defaultWidth;
    }
  }
  return ret;
}, setSortState: function() {
  var store = this.up('[store]').store, columns = this.visibleColumnManager.getColumns(), len = columns.length, i, header, sorter;
  for (i = 0; i < len; i++) 
    {
      header = columns[i];
      sorter = store.sorters.get(header.getSortParam());
      header.setSortState(sorter);
    }
}, getHeaderMenu: function() {
  var menu = this.getMenu(), item;
  if (menu) 
  {
    item = menu.child('#columnItem');
    if (item) 
    {
      return item.menu;
    }
  }
  return null;
}, onHeaderVisibilityChange: function(header, visible) {
  var me = this, menu = me.getHeaderMenu(), item;
  me.purgeHeaderCtCache(header.ownerCt);
  if (menu) 
  {
    item = me.getMenuItemForHeader(menu, header);
    if (item) 
    {
      item.setChecked(visible, true);
    }
    if (menu.isVisible()) 
    {
      me.menuTask.delay(50);
    }
  }
}, updateMenuDisabledState: function(menu) {
  var me = this, columns = me.query(':not([hidden])'), i, len = columns.length, item, checkItem, method;
  if (!menu) 
  {
    menu = me.getMenu();
  }
  for (i = 0; i < len; ++i) 
    {
      item = columns[i];
      checkItem = me.getMenuItemForHeader(menu, item);
      if (checkItem) 
      {
        method = item.isHideable() ? 'enable' : 'disable';
        if (checkItem.menu) 
        {
          method += 'CheckChange';
        }
        checkItem[method]();
      }
    }
}, getMenuItemForHeader: function(menu, header) {
  return header ? menu.down('menucheckitem[headerId=' + header.id + ']') : null;
}, onHeaderShow: function(header) {
  var me = this, gridSection = me.ownerCt;
  if (me.forceFit) 
  {
    delete me.flex;
  }
  me.onHeaderVisibilityChange(header, true);
  if (!header.isGroupHeader) 
  {
    if (gridSection) 
    {
      gridSection.onHeaderShow(me, header);
    }
  }
  me.fireEvent('columnshow', me, header);
  me.fireEvent('columnschanged', this);
}, onHeaderHide: function(header) {
  var me = this, gridSection = me.ownerCt;
  me.onHeaderVisibilityChange(header, false);
  if (!header.isGroupHeader) 
  {
    if (gridSection) 
    {
      gridSection.onHeaderHide(me, header);
    }
  }
  me.fireEvent('columnhide', me, header);
  me.fireEvent('columnschanged', this);
}, tempLock: function() {
  this.ddLock = true;
  Ext.Function.defer(function() {
  this.ddLock = false;
}, 200, this);
}, onHeaderResize: function(header, w) {
  var me = this, gridSection = me.ownerCt;
  if (gridSection) 
  {
    gridSection.onHeaderResize(me, header, w);
  }
  me.fireEvent('columnresize', me, header, w);
}, onHeaderClick: function(header, e, t) {
  header.fireEvent('headerclick', this, header, e, t);
  this.fireEvent('headerclick', this, header, e, t);
}, onHeaderContextMenu: function(header, e, t) {
  header.fireEvent('headercontextmenu', this, header, e, t);
  this.fireEvent('headercontextmenu', this, header, e, t);
}, onHeaderTriggerClick: function(header, e, t) {
  var me = this;
  if (header.fireEvent('headertriggerclick', me, header, e, t) !== false && me.fireEvent('headertriggerclick', me, header, e, t) !== false) 
  {
    me.showMenuBy(t, header);
  }
}, showMenuBy: function(t, header) {
  var menu = this.getMenu(), ascItem = menu.down('#ascItem'), descItem = menu.down('#descItem'), sortableMth;
  menu.activeHeader = menu.ownerCmp = menu.ownerButton = header;
  header.setMenuActive(true);
  sortableMth = header.sortable ? 'enable' : 'disable';
  if (ascItem) 
  {
    ascItem[sortableMth]();
  }
  if (descItem) 
  {
    descItem[sortableMth]();
  }
  menu.showBy(t, 'tl-bl?');
}, onMenuHide: function(menu) {
  menu.activeHeader.setMenuActive(false);
}, moveHeader: function(fromIdx, toIdx) {
  this.tempLock();
  this.move(fromIdx, toIdx);
}, purgeHeaderCtCache: function(headerCt) {
  while (headerCt) 
    {
      headerCt.purgeCache();
      if (headerCt.isRootHeader) 
      {
        return;
      }
      headerCt = headerCt.ownerCt;
    }
}, purgeCache: function() {
  var me = this, visibleColumnManager = me.visibleColumnManager, columnManager = me.columnManager;
  me.gridVisibleColumns = me.gridDataColumns = me.hideableColumns = null;
  if (visibleColumnManager) 
  {
    visibleColumnManager.invalidate();
    columnManager.invalidate();
  }
}, getMenu: function() {
  var me = this;
  if (!me.menu) 
  {
    me.menu = new Ext.menu.Menu({hideOnParentHide: false, items: me.getMenuItems(), listeners: {beforeshow: me.beforeMenuShow, hide: me.onMenuHide, scope: me}});
    me.fireEvent('menucreate', me, me.menu);
  }
  return me.menu;
}, beforeMenuShow: function(menu) {
  var me = this, columnItem = menu.child('#columnItem'), hideableColumns, insertPoint, menu;
  if (!columnItem) 
  {
    hideableColumns = me.enableColumnHide ? me.getColumnMenu(me) : null;
    insertPoint = me.sortable ? 2 : 0;
    if (hideableColumns && hideableColumns.length) 
    {
      menu.insert(insertPoint, [{itemId: 'columnItemSeparator', xtype: 'menuseparator'}, {itemId: 'columnItem', text: me.columnsText, iconCls: me.menuColsIcon, menu: {items: hideableColumns}, hideOnClick: false}]);
    }
  }
  me.updateMenuDisabledState(me.menu);
  if (!menu.rendered) 
  {
    menu.render(this.el.up('{overflow=auto}') || document.body);
  }
}, getMenuItems: function() {
  var me = this, menuItems = [], hideableColumns = me.enableColumnHide ? me.getColumnMenu(me) : null;
  if (me.sortable) 
  {
    menuItems = [{itemId: 'ascItem', text: me.sortAscText, iconCls: me.menuSortAscCls, handler: me.onSortAscClick, scope: me}, {itemId: 'descItem', text: me.sortDescText, iconCls: me.menuSortDescCls, handler: me.onSortDescClick, scope: me}];
  }
  if (hideableColumns && hideableColumns.length) 
  {
    if (me.sortable) 
    {
      menuItems.push({itemId: 'columnItemSeparator', xtype: 'menuseparator'});
    }
    menuItems.push({itemId: 'columnItem', text: me.columnsText, iconCls: me.menuColsIcon, menu: hideableColumns, hideOnClick: false});
  }
  return menuItems;
}, onSortAscClick: function() {
  var menu = this.getMenu(), activeHeader = menu.activeHeader;
  activeHeader.sort('ASC');
}, onSortDescClick: function() {
  var menu = this.getMenu(), activeHeader = menu.activeHeader;
  activeHeader.sort('DESC');
}, getColumnMenu: function(headerContainer) {
  var menuItems = [], i = 0, item, items = headerContainer.query('>gridcolumn[hideable]'), itemsLn = items.length, menuItem;
  for (; i < itemsLn; i++) 
    {
      item = items[i];
      menuItem = new Ext.menu.CheckItem({text: item.menuText || item.text, checked: !item.hidden, hideOnClick: false, headerId: item.id, menu: item.isGroupHeader ? this.getColumnMenu(item) : undefined, checkHandler: this.onColumnCheckChange, scope: this});
      menuItems.push(menuItem);
    }
  return menuItems;
}, onColumnCheckChange: function(checkItem, checked) {
  var header = Ext.getCmp(checkItem.headerId);
  if (header.rendered) 
  {
    header[checked ? 'show' : 'hide']();
  } else {
    header.hidden = !checked;
  }
}, getColumnCount: function() {
  return this.getGridColumns().length;
}, getTableWidth: function() {
  var fullWidth = 0, headers = this.getVisibleGridColumns(), headersLn = headers.length, i;
  for (i = 0; i < headersLn; i++) 
    {
      fullWidth += headers[i].getCellWidth() || 0;
    }
  return fullWidth;
}, getVisibleGridColumns: function() {
  if (this.gridVisibleColumns) 
  {
    return this.gridVisibleColumns;
  }
  var allColumns = this.getGridColumns(), result = [], len = allColumns.length, i;
  for (i = 0; i < len; i++) 
    {
      if (!allColumns[i].hidden) 
      {
        result[result.length] = allColumns[i];
      }
    }
  this.gridVisibleColumns = result;
  return result;
}, getGridColumns: function(inResult, hiddenAncestor) {
  if (!inResult && this.gridDataColumns) 
  {
    return this.gridDataColumns;
  }
  var me = this, result = inResult || [], items, i, len, item, lastVisibleColumn;
  hiddenAncestor = hiddenAncestor || me.hidden;
  if (me.items) 
  {
    items = me.items.items;
    for (i = 0 , len = items.length; i < len; i++) 
      {
        item = items[i];
        if (item.isGroupHeader) 
        {
          item.getGridColumns(result, hiddenAncestor);
        } else {
          item.hiddenAncestor = hiddenAncestor;
          result.push(item);
        }
      }
  }
  if (!inResult) 
  {
    me.gridDataColumns = result;
  }
  if (!inResult && len) 
  {
    for (i = 0 , len = result.length; i < len; i++) 
      {
        item = result[i];
        item.isFirstVisible = item.isLastVisible = false;
        if (!(item.hidden || item.hiddenAncestor)) 
        {
          if (!lastVisibleColumn) 
          {
            item.isFirstVisible = true;
          }
          lastVisibleColumn = item;
        }
      }
    if (lastVisibleColumn) 
    {
      lastVisibleColumn.isLastVisible = true;
    }
  }
  return result;
}, getHideableColumns: function() {
  var me = this, result = me.hideableColumns;
  if (!result) 
  {
    result = me.hideableColumns = me.query('[hideable]');
  }
  return result;
}, getHeaderIndex: function(header) {
  if (!this.columnManager) 
  {
    this.columnManager = this.getOwnerHeaderCt().columnManager;
  }
  return this.columnManager.getHeaderIndex(header);
}, getHeaderAtIndex: function(index) {
  if (!this.columnManager) 
  {
    this.columnManager = this.getOwnerHeaderCt().columnManager;
  }
  return this.columnManager.getHeaderAtIndex(index);
}, getVisibleHeaderClosestToIndex: function(index) {
  if (!this.visibleColumnManager) 
  {
    this.visibleColumnManager = this.getOwnerHeaderCt().visibleColumnManager;
  }
  return this.visibleColumnManager.getVisibleHeaderClosestToIndex(index);
}, applyForceFit: function(header) {
  var me = this, view = me.view, minWidth = Ext.grid.plugin.HeaderResizer.prototype.minColWidth, useMinWidthForFlex = false, defaultWidth = Ext.grid.header.Container.prototype.defaultWidth, availFlex = me.el.getViewSize().width - (view.el.dom.scrollHeight > view.el.dom.clientHeight ? Ext.getScrollbarSize().width : 0), totalFlex = 0, items = me.getVisibleGridColumns(), hidden = header.hidden, len, i, item, maxAvailFlexOneColumn, myWidth;
  function getTotalFlex() {
    for (i = 0 , len = items.length; i < len; i++) 
      {
        item = items[i];
        if (item === header) 
        {
          continue;
        }
        item.flex = item.flex || item.width || item.getWidth();
        totalFlex += item.flex;
        item.width = null;
      }
  }
  function applyWidth() {
    var isCurrentHeader;
    for (i = 0 , len = items.length; i < len; i++) 
      {
        item = items[i];
        isCurrentHeader = (item === header);
        if (useMinWidthForFlex && !isCurrentHeader) 
        {
          item.flex = minWidth;
          item.width = null;
        } else if (!isCurrentHeader) 
        {
          myWidth = item.flex || defaultWidth;
          item.flex = Math.max(Math.ceil((myWidth / totalFlex) * availFlex), minWidth);
          item.width = null;
        }
        item.setWidth(item.width || item.flex);
      }
  }
  Ext.suspendLayouts();
  maxAvailFlexOneColumn = (availFlex - ((items.length + 1) * minWidth));
  header.flex = null;
  if (hidden) 
  {
    myWidth = header.width || header.savedWidth;
    header.savedWidth = null;
  } else {
    myWidth = view.getMaxContentWidth(header);
  }
  if (myWidth > maxAvailFlexOneColumn) 
  {
    header.width = maxAvailFlexOneColumn;
    useMinWidthForFlex = true;
  } else {
    header.width = myWidth;
    availFlex -= myWidth + defaultWidth;
    getTotalFlex();
  }
  applyWidth();
  Ext.resumeLayouts(true);
}, autoSizeColumn: function(header) {
  var view = this.view;
  if (view) 
  {
    view.autoSizeColumn(header);
    if (this.forceFit) 
    {
      this.applyForceFit(header);
    }
  }
}}, 0, ["headercontainer"], ["container", "component", "headercontainer", "box"], {"container": true, "component": true, "headercontainer": true, "box": true}, ["widget.headercontainer"], 0, [Ext.grid.header, 'Container'], 0));
;

(Ext.cmd.derive('Ext.grid.column.Column', Ext.grid.header.Container, {alternateClassName: 'Ext.grid.Column', baseCls: Ext.baseCSSPrefix + 'column-header', hoverCls: Ext.baseCSSPrefix + 'column-header-over', handleWidth: 4, ariaRole: 'columnheader', sortState: null, possibleSortStates: ['ASC', 'DESC'], childEls: ['titleEl', 'triggerEl', 'textEl'], noWrap: true, renderTpl: ['<div id="{id}-titleEl" role="presentation" {tipMarkup}class="', Ext.baseCSSPrefix, 'column-header-inner', '<tpl if="empty"> ', Ext.baseCSSPrefix, 'column-header-inner-empty</tpl>">', '<span id="{id}-textEl" class="', Ext.baseCSSPrefix, 'column-header-text', '{childElCls}">', '{text}', '</span>', '<tpl if="!menuDisabled">', '<div id="{id}-triggerEl" role="presentation" class="', Ext.baseCSSPrefix, 'column-header-trigger', '{childElCls}"></div>', '</tpl>', '</div>', '{%this.renderContainer(out,values)%}'], dataIndex: null, text: '&#160;', menuText: null, emptyCellText: '&#160;', sortable: true, resizable: true, hideable: true, menuDisabled: false, renderer: false, editRenderer: false, align: 'left', draggable: true, tooltipType: 'qtip', initDraggable: Ext.emptyFn, tdCls: '', isHeader: true, isColumn: true, ascSortCls: Ext.baseCSSPrefix + 'column-header-sort-ASC', descSortCls: Ext.baseCSSPrefix + 'column-header-sort-DESC', componentLayout: 'columncomponent', groupSubHeaderCls: Ext.baseCSSPrefix + 'group-sub-header', groupHeaderCls: Ext.baseCSSPrefix + 'group-header', clickTargetName: 'titleEl', detachOnRemove: true, initResizable: Ext.emptyFn, initComponent: function() {
  var me = this, renderer;
  if (me.header != null) 
  {
    me.text = me.header;
    me.header = null;
  }
  if (me.columns != null) 
  {
    me.isGroupHeader = true;
    me.items = me.columns;
    me.columns = me.flex = me.width = null;
    me.cls = (me.cls || '') + ' ' + me.groupHeaderCls;
    me.sortable = me.resizable = false;
    me.align = 'center';
  } else {
    if (me.flex) 
    {
      me.minWidth = me.minWidth || Ext.grid.plugin.HeaderResizer.prototype.minColWidth;
    }
  }
  me.addCls(Ext.baseCSSPrefix + 'column-header-align-' + me.align);
  renderer = me.renderer;
  if (renderer) 
  {
    if (typeof renderer == 'string') 
    {
      me.renderer = Ext.util.Format[renderer];
    }
    me.hasCustomRenderer = true;
  } else if (me.defaultRenderer) 
  {
    me.renderer = me.defaultRenderer;
    me.usingDefaultRenderer = true;
  }
  me.callParent(arguments);
}, initItems: function() {
  var me = this;
  me.callParent(arguments);
  if (me.isGroupHeader) 
  {
    if (!me.hasVisibleChildColumns()) 
    {
      me.hide();
    }
  }
}, hasVisibleChildColumns: function() {
  var items = this.items.items, len = items.length, i, item;
  for (i = 0; i < len; ++i) 
    {
      item = items[i];
      if (item.isColumn && !item.hidden) 
      {
        return true;
      }
    }
  return false;
}, onAdd: function(child) {
  var me = this, ownerHeaderCt = me.getOwnerHeaderCt();
  if (child.isColumn) 
  {
    child.isSubHeader = true;
    child.addCls(this.groupSubHeaderCls);
  }
  if (me.hidden && child.isColumn) 
  {
    if (!ownerHeaderCt) 
    {
      child.hide();
    } else if (!child.hidden) 
    {
      me.show();
    }
  }
  me.callParent(arguments);
}, onRemove: function(child) {
  var me = this;
  if (child.isSubHeader) 
  {
    child.isSubHeader = false;
    child.removeCls(me.groupSubHeaderCls);
  }
  me.callParent(arguments);
  if (me.isGroupHeader && !me.hasVisibleChildColumns()) 
  {
    me.hide();
  }
}, initRenderData: function() {
  var me = this, tipMarkup = '', tip = me.tooltip, text = me.text, attr = me.tooltipType == 'qtip' ? 'data-qtip' : 'title';
  if (!Ext.isEmpty(tip)) 
  {
    tipMarkup = attr + '="' + tip + '" ';
  }
  return Ext.applyIf(me.callParent(arguments), {text: text, empty: text === '&#160;' || text === ' ' || text === '', menuDisabled: me.menuDisabled, tipMarkup: tipMarkup});
}, applyColumnState: function(state) {
  var me = this;
  me.applyColumnsState(state.columns);
  if (state.hidden != null) 
  {
    me.hidden = state.hidden;
  }
  if (state.locked != null) 
  {
    me.locked = state.locked;
  }
  if (state.sortable != null) 
  {
    me.sortable = state.sortable;
  }
  if (state.width != null) 
  {
    me.flex = null;
    me.width = state.width;
  } else if (state.flex != null) 
  {
    me.width = null;
    me.flex = state.flex;
  }
}, getColumnState: function() {
  var me = this, items = me.items.items, iLen = items ? items.length : 0, i, columns = [], state = {id: me.getStateId()};
  me.savePropsToState(['hidden', 'sortable', 'locked', 'flex', 'width'], state);
  if (me.isGroupHeader) 
  {
    for (i = 0; i < iLen; i++) 
      {
        columns.push(items[i].getColumnState());
      }
    if (columns.length) 
    {
      state.columns = columns;
    }
  } else if (me.isSubHeader && me.ownerCt.hidden) 
  {
    delete me.hidden;
  }
  if ('width' in state) 
  {
    delete state.flex;
  }
  return state;
}, getStateId: function() {
  return this.stateId || this.headerId;
}, setText: function(text) {
  this.text = text;
  if (this.rendered) 
  {
    this.textEl.update(text);
  }
}, getIndex: function() {
  return this.isGroupColumn ? false : this.getOwnerHeaderCt().getHeaderIndex(this);
}, getVisibleIndex: function() {
  return this.isGroupColumn ? false : Ext.Array.indexOf(this.getOwnerHeaderCt().getVisibleGridColumns(), this);
}, beforeRender: function() {
  var me = this, grid = me.up('tablepanel');
  me.callParent();
  if (grid && (!me.sortable || grid.sortableColumns === false) && !me.groupable && !me.lockable && (grid.enableColumnHide === false || !me.getOwnerHeaderCt().getHideableColumns().length)) 
  {
    me.menuDisabled = true;
  }
  me.protoEl.unselectable();
}, afterRender: function() {
  var me = this, triggerEl = me.triggerEl;
  me.callParent(arguments);
  if (triggerEl && me.self.triggerElWidth === undefined) 
  {
    triggerEl.setStyle('display', 'block');
    me.self.triggerElWidth = triggerEl.getWidth();
    triggerEl.setStyle('display', '');
  }
}, afterComponentLayout: function(width, height, oldWidth, oldHeight) {
  var me = this, ownerHeaderCt = me.getOwnerHeaderCt();
  me.callParent(arguments);
  if (ownerHeaderCt && (oldWidth != null || me.flex) && width !== oldWidth) 
  {
    ownerHeaderCt.onHeaderResize(me, width);
  }
}, onDestroy: function() {
  var me = this;
  Ext.destroy(me.textEl, me.keyNav, me.field);
  me.keyNav = null;
  me.callParent(arguments);
}, onTitleMouseOver: function() {
  this.titleEl.addCls(this.hoverCls);
}, onTitleMouseOut: function() {
  this.titleEl.removeCls(this.hoverCls);
}, onDownKey: function(e) {
  if (this.triggerEl) 
  {
    this.onTitleElClick(e, this.triggerEl.dom || this.el.dom);
  }
}, onEnterKey: function(e) {
  this.onTitleElClick(e, this.el.dom);
}, onTitleElDblClick: function(e, t) {
  var me = this, prev, leafColumns, headerCt;
  if (me.isOnLeftEdge(e)) 
  {
    prev = me.previousNode('gridcolumn:not([hidden]):not([isGroupHeader])');
    if (prev && prev.getOwnerHeaderCt() === me.getOwnerHeaderCt()) 
    {
      prev.autoSize();
    }
  } else if (me.isOnRightEdge(e)) 
  {
    if (me.isGroupHeader && e.getPoint().isContainedBy(me.layout.innerCt)) 
    {
      leafColumns = me.query('gridcolumn:not([hidden]):not([isGroupHeader])');
      me.getOwnerHeaderCt().autoSizeColumn(leafColumns[leafColumns.length - 1]);
      return;
    } else {
      headerCt = me.getOwnerHeaderCt();
      if (headerCt.visibleColumnManager.getColumns().length === 1 && headerCt.forceFit) 
      {
        return;
      }
    }
    me.autoSize();
  }
}, autoSize: function() {
  var me = this, leafColumns, numLeaves, i, headerCt;
  if (me.isGroupHeader) 
  {
    leafColumns = me.query('gridcolumn:not([hidden]):not([isGroupHeader])');
    numLeaves = leafColumns.length;
    headerCt = this.getOwnerHeaderCt();
    Ext.suspendLayouts();
    for (i = 0; i < numLeaves; i++) 
      {
        headerCt.autoSizeColumn(leafColumns[i]);
      }
    Ext.resumeLayouts(true);
    return;
  }
  this.getOwnerHeaderCt().autoSizeColumn(this);
}, onTitleElClick: function(e, t) {
  var me = this, isTriggerClick;
  isTriggerClick = me.triggerEl && (e.target === me.triggerEl.dom || t === me.triggerEl.dom || e.within(me.triggerEl));
  if (!isTriggerClick && !me.isOnLeftEdge(e) && !me.isOnRightEdge(e) || e.getKey()) 
  {
    me.toggleSortState();
  }
  return isTriggerClick;
}, processEvent: function(type, view, cell, recordIndex, cellIndex, e) {
  return this.fireEvent.apply(this, arguments);
}, toggleSortState: function() {
  var me = this, idx, nextIdx;
  if (me.sortable) 
  {
    idx = Ext.Array.indexOf(me.possibleSortStates, me.sortState);
    nextIdx = (idx + 1) % me.possibleSortStates.length;
    me.sort();
  }
}, sort: function(direction) {
  var me = this, grid = me.up('tablepanel'), store = grid.store;
  if (grid.ownerLockable && store.isNodeStore) 
  {
    store = grid.ownerLockable.lockedGrid.store;
  }
  me.sorting = true;
  store.sort(me.getSortParam(), direction, grid.multiColumnSort ? 'multi' : 'replace');
  delete me.sorting;
}, getSortParam: function() {
  return this.dataIndex;
}, setSortState: function(sorter) {
  var me = this, direction = sorter && sorter.direction, ascCls = me.ascSortCls, descCls = me.descSortCls, ownerHeaderCt = me.getOwnerHeaderCt();
  switch (direction) {
    case 'DESC':
      me.addCls(descCls);
      me.removeCls(ascCls);
      break;
    case 'ASC':
      me.addCls(ascCls);
      me.removeCls(descCls);
      break;
    default:
      me.removeCls([ascCls, descCls]);
  }
  if (direction) 
  {
    ownerHeaderCt.fireEvent('sortchange', ownerHeaderCt, me, direction);
  }
}, isHideable: function() {
  var result = {hideCandidate: this, result: this.hideable};
  if (result.result) 
  {
    this.ownerCt.bubble(this.hasOtherMenuEnabledChildren, null, [result]);
  }
  return result.result;
}, hasOtherMenuEnabledChildren: function(result) {
  var visibleChildren, count;
  if (!this.isXType('headercontainer')) 
  {
    result.result = false;
    return false;
  }
  visibleChildren = this.query('>:not([hidden]):not([menuDisabled])');
  count = visibleChildren.length;
  if (Ext.Array.contains(visibleChildren, result.hideCandidate)) 
  {
    count--;
  }
  if (count) 
  {
    return false;
  }
  result.hideCandidate = this;
}, isLockable: function() {
  var result = {result: this.lockable !== false};
  if (result.result) 
  {
    this.ownerCt.bubble(this.hasMultipleVisibleChildren, null, [result]);
  }
  return result.result;
}, isLocked: function() {
  return this.locked || !!this.up('[isColumn][locked]', '[isRootHeader]');
}, hasMultipleVisibleChildren: function(result) {
  if (!this.isXType('headercontainer')) 
  {
    result.result = false;
    return false;
  }
  if (this.query('>:not([hidden])').length > 1) 
  {
    return false;
  }
}, hide: function(fromOwner) {
  var me = this, ownerHeaderCt = me.getOwnerHeaderCt(), owner = me.ownerCt, ownerIsGroup, item, items, len, i;
  if (!ownerHeaderCt) 
  {
    me.callParent();
    return me;
  }
  if (me.rendered && !me.isVisible()) 
  {
    return me;
  }
  if (ownerHeaderCt.forceFit) 
  {
    me.visibleSiblingCount = ownerHeaderCt.getVisibleGridColumns().length - 1;
    if (me.flex) 
    {
      me.savedWidth = me.getWidth();
      me.flex = null;
    }
  }
  ownerIsGroup = owner.isGroupHeader;
  if (ownerIsGroup && !fromOwner) 
  {
    items = owner.query('>:not([hidden])');
    if (items.length === 1 && items[0] === me) 
    {
      me.ownerCt.hide();
      return;
    }
  }
  Ext.suspendLayouts();
  if (me.isGroupHeader) 
  {
    items = me.items.items;
    for (i = 0 , len = items.length; i < len; i++) 
      {
        item = items[i];
        if (!item.hidden) 
        {
          item.hide(true);
        }
      }
  }
  me.callParent();
  ownerHeaderCt.onHeaderHide(me);
  Ext.resumeLayouts(true);
  return me;
}, show: function(fromOwner, fromChild) {
  var me = this, ownerHeaderCt = me.getOwnerHeaderCt(), ownerCt = me.ownerCt, items, len, i, item;
  if (me.isVisible()) 
  {
    return me;
  }
  if (me.rendered) 
  {
    if (ownerHeaderCt.forceFit) 
    {
      ownerHeaderCt.applyForceFit(me);
    }
  }
  Ext.suspendLayouts();
  if (me.isSubHeader && ownerCt.hidden) 
  {
    ownerCt.show(false, true);
  }
  me.callParent(arguments);
  if (me.isGroupHeader && fromChild !== true && !me.query(':not([hidden])').length) 
  {
    items = me.items.items;
    for (i = 0 , len = items.length; i < len; i++) 
      {
        item = items[i];
        if (item.hidden) 
        {
          item.show(true);
        }
      }
  }
  ownerCt = me.getOwnerHeaderCt();
  if (ownerCt) 
  {
    ownerCt.onHeaderShow(me);
  }
  Ext.resumeLayouts(true);
  return me;
}, getCellWidth: function() {
  var me = this, result, checkBorderBox = true;
  if (me.rendered && me.componentLayout && me.componentLayout.lastComponentSize) 
  {
    result = me.componentLayout.lastComponentSize.width;
  } else if (me.width) 
  {
    result = me.width;
  } else if (!me.isColumn) 
  {
    result = me.getTableWidth();
    checkBorderBox = false;
  }
  if (checkBorderBox && !Ext.isBorderBox && me.ownerCt.columnLines) 
  {
    if (me.columnBorderWidth == null && me.rendered) 
    {
      me.self.prototype.columnBorderWidth = me.el.getBorderWidth('lr');
    }
    result -= me.columnBorderWidth;
  }
  return result;
}, getCellId: function() {
  return Ext.baseCSSPrefix + 'grid-cell-headerId-' + this.getItemId();
}, getCellSelector: function() {
  return '.' + this.getCellId();
}, getCellInnerSelector: function() {
  return this.getCellSelector() + ' .' + Ext.baseCSSPrefix + 'grid-cell-inner';
}, isOnLeftEdge: function(e) {
  return (e.getXY()[0] - this.getX() < this.handleWidth);
}, isOnRightEdge: function(e) {
  return (this.getX() + this.getWidth() - e.getXY()[0] <= this.handleWidth);
}, setMenuActive: function(isMenuOpen) {
  this.titleEl[isMenuOpen ? 'addCls' : 'removeCls'](this.headerOpenCls);
}}, 0, ["gridcolumn"], ["container", "component", "gridcolumn", "headercontainer", "box"], {"container": true, "component": true, "gridcolumn": true, "headercontainer": true, "box": true}, ["widget.gridcolumn"], 0, [Ext.grid.column, 'Column', Ext.grid, 'Column'], 0));
;

Ext.define('Override.HeaderResizer', {override: 'Ext.grid.plugin.HeaderResizer', getConstrainRegion: function() {
  var me = this, dragHdEl = me.dragHd.el, rightAdjust = 0, nextHd, lockedGrid, columnsResize, maxColWidth = me.headerCt.getWidth() - me.headerCt.visibleColumnManager.getColumns().length * me.minColWidth;
  if (!me.markerOwner.columnsResize) 
  {
    columnsResize = 1.25;
  } else {
    columnsResize = me.markerOwner.columnsResize;
  }
  if (maxColWidth < me.minColWidth) 
  {
    var currWidth = me.dragHd.getWidth();
    maxColWidth = Math.floor(currWidth * columnsResize);
  }
  if (me.headerCt.forceFit) 
  {
    nextHd = me.dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
    if (nextHd && me.headerInSameGrid(nextHd)) 
    {
      rightAdjust = nextHd.getWidth() - me.minColWidth;
    }
  } else if ((lockedGrid = me.dragHd.up('tablepanel')).isLocked) 
  {
    rightAdjust = me.dragHd.up('[scrollerOwner]').getTargetEl().getWidth() - lockedGrid.getWidth() - (lockedGrid.ownerLockable.normalGrid.visibleColumnManager.getColumns().length * me.minColWidth + Ext.getScrollbarSize().width);
  } else {
    rightAdjust = maxColWidth - dragHdEl.getWidth();
  }
  return me.adjustConstrainRegion(dragHdEl.getRegion(), 0, rightAdjust - me.xDelta, 0, me.minColWidth - me.xDelta);
}});

(Ext.cmd.derive('Ext.grid.column.Check', Ext.grid.column.Column, {alternateClassName: ['Ext.ux.CheckColumn', 'Ext.grid.column.CheckColumn'], align: 'center', stopSelection: true, tdCls: Ext.baseCSSPrefix + 'grid-cell-checkcolumn', innerCls: Ext.baseCSSPrefix + 'grid-cell-inner-checkcolumn', clickTargetName: 'el', constructor: function() {
  this.addEvents('beforecheckchange', 'checkchange');
  this.scope = this;
  this.callParent(arguments);
}, processEvent: function(type, view, cell, recordIndex, cellIndex, e, record, row) {
  var me = this, key = type === 'keydown' && e.getKey(), mousedown = type == 'mousedown';
  if (!me.disabled && (mousedown || (key == e.ENTER || key == e.SPACE))) 
  {
    var dataIndex = me.dataIndex, checked = !record.get(dataIndex);
    if (me.fireEvent('beforecheckchange', me, recordIndex, checked) !== false) 
    {
      record.set(dataIndex, checked);
      me.fireEvent('checkchange', me, recordIndex, checked);
      if (mousedown) 
      {
        e.stopEvent();
      }
      if (!me.stopSelection) 
      {
        view.selModel.selectByPosition({row: recordIndex, column: cellIndex});
      }
      return false;
    } else {
      return !me.stopSelection;
    }
  } else {
    return me.callParent(arguments);
  }
}, onEnable: function() {
  this.callParent(arguments);
  this._setDisabled(false);
}, onDisable: function() {
  this._setDisabled(true);
}, _setDisabled: function(disabled) {
  var me = this, cls = me.disabledCls, items;
  items = me.up('tablepanel').el.select(me.getCellSelector());
  if (disabled) 
  {
    items.addCls(cls);
  } else {
    items.removeCls(cls);
  }
}, renderer: function(value, meta) {
  var cssPrefix = Ext.baseCSSPrefix, cls = cssPrefix + 'grid-checkcolumn';
  if (this.disabled) 
  {
    meta.tdCls += ' ' + this.disabledCls;
  }
  if (value) 
  {
    cls += ' ' + cssPrefix + 'grid-checkcolumn-checked';
  }
  return '<img class="' + cls + '" src="' + Ext.BLANK_IMAGE_URL + '"/>';
}}, 1, ["checkcolumn"], ["container", "component", "gridcolumn", "headercontainer", "box", "checkcolumn"], {"container": true, "component": true, "gridcolumn": true, "headercontainer": true, "box": true, "checkcolumn": true}, ["widget.checkcolumn"], 0, [Ext.grid.column, 'Check', Ext.ux, 'CheckColumn', Ext.grid.column, 'CheckColumn'], 0));
;

(Ext.cmd.derive('Ext.grid.locking.HeaderContainer', Ext.grid.header.Container, {constructor: function(lockable) {
  var me = this, events, event, eventNames = [], lockedGrid = lockable.lockedGrid, normalGrid = lockable.normalGrid;
  me.lockable = lockable;
  me.callParent();
  lockedGrid.visibleColumnManager.rootColumns = normalGrid.visibleColumnManager.rootColumns = lockable.visibleColumnManager = me.visibleColumnManager = new Ext.grid.ColumnManager(true, lockedGrid.headerCt, normalGrid.headerCt);
  lockedGrid.columnManager.rootColumns = normalGrid.columnManager.rootColumns = lockable.columnManager = me.columnManager = new Ext.grid.ColumnManager(false, lockedGrid.headerCt, normalGrid.headerCt);
  events = lockedGrid.headerCt.events;
  for (event in events) 
    {
      if (events.hasOwnProperty(event)) 
      {
        eventNames.push(event);
      }
    }
  me.relayEvents(lockedGrid.headerCt, eventNames);
  me.relayEvents(normalGrid.headerCt, eventNames);
}, getRefItems: function() {
  return this.lockable.lockedGrid.headerCt.getRefItems().concat(this.lockable.normalGrid.headerCt.getRefItems());
}, getGridColumns: function() {
  return this.lockable.lockedGrid.headerCt.getGridColumns().concat(this.lockable.normalGrid.headerCt.getGridColumns());
}, getColumnsState: function() {
  var me = this, locked = me.lockable.lockedGrid.headerCt.getColumnsState(), normal = me.lockable.normalGrid.headerCt.getColumnsState();
  return locked.concat(normal);
}, applyColumnsState: function(columns) {
  var me = this, lockedGrid = me.lockable.lockedGrid, lockedHeaderCt = lockedGrid.headerCt, normalHeaderCt = me.lockable.normalGrid.headerCt, lockedCols = Ext.Array.toValueMap(lockedHeaderCt.items.items, 'headerId'), normalCols = Ext.Array.toValueMap(normalHeaderCt.items.items, 'headerId'), locked = [], normal = [], lockedWidth = 1, length = columns.length, i, existing, lockedDefault, col;
  for (i = 0; i < length; i++) 
    {
      col = columns[i];
      lockedDefault = lockedCols[col.id];
      existing = lockedDefault || normalCols[col.id];
      if (existing) 
      {
        if (existing.applyColumnState) 
        {
          existing.applyColumnState(col);
        }
        if (existing.locked === undefined) 
        {
          existing.locked = !!lockedDefault;
        }
        if (existing.locked) 
        {
          locked.push(existing);
          if (!existing.hidden && typeof existing.width == 'number') 
          {
            lockedWidth += existing.width;
          }
        } else {
          normal.push(existing);
        }
      }
    }
  if (locked.length + normal.length == lockedHeaderCt.items.getCount() + normalHeaderCt.items.getCount()) 
  {
    lockedHeaderCt.removeAll(false);
    normalHeaderCt.removeAll(false);
    lockedHeaderCt.add(locked);
    normalHeaderCt.add(normal);
    lockedGrid.setWidth(lockedWidth);
  }
}}, 1, 0, ["container", "component", "headercontainer", "box"], {"container": true, "component": true, "headercontainer": true, "box": true}, 0, 0, [Ext.grid.locking, 'HeaderContainer'], 0));
;

(Ext.cmd.derive('Ext.grid.locking.View', Ext.Base, {alternateClassName: 'Ext.grid.LockingView', isLockingView: true, loadMask: true, eventRelayRe: /^(beforeitem|beforecontainer|item|container|cell|refresh)/, constructor: function(config) {
  var me = this, eventNames = [], eventRe = me.eventRelayRe, lockedView, normalView, events, event;
  me.panel = config.panel;
  config.locked.viewConfig.bindStore = config.normal.viewConfig.bindStore = Ext.emptyFn;
  config.locked.viewConfig.beforeLayout = config.normal.viewConfig.beforeLayout = me.beforeLayout;
  me.lockedGrid = me.panel.lockedGrid = Ext.ComponentManager.create(config.locked);
  me.lockedView = lockedView = me.lockedGrid.getView();
  if (me.lockedGrid.isTree) 
  {
    me.lockedView.animate = false;
    config.normal.store = lockedView.store;
    config.normal.viewConfig.stripeRows = me.lockedView.stripeRows;
    config.normal.rowLines = me.lockedGrid.rowLines;
  }
  me.normalGrid = me.panel.normalGrid = Ext.ComponentManager.create(config.normal);
  lockedView.lockingPartner = normalView = me.normalView = me.normalGrid.getView();
  normalView.lockingPartner = lockedView;
  me.deferInitialRefresh = normalView.deferInitialRefresh && lockedView.deferInitialRefresh;
  me.loadMask = (config.loadMask !== undefined) ? config.loadMask : me.loadMask;
  me.mixins.observable.constructor.call(me);
  events = lockedView.events;
  for (event in events) 
    {
      if (events.hasOwnProperty(event) && eventRe.test(event)) 
      {
        eventNames.push(event);
      }
    }
  me.relayEvents(lockedView, eventNames);
  me.relayEvents(normalView, eventNames);
  normalView.on({scope: me, itemmouseleave: me.onItemMouseLeave, itemmouseenter: me.onItemMouseEnter});
  lockedView.on({scope: me, itemmouseleave: me.onItemMouseLeave, itemmouseenter: me.onItemMouseEnter});
  me.panel.on({render: me.onPanelRender, scope: me});
  me.loadingText = normalView.loadingText;
  me.loadingCls = normalView.loadingCls;
  me.loadingUseMsg = normalView.loadingUseMsg;
  me.bindStore(normalView.dataSource, true, 'dataSource');
}, beforeLayout: function() {
  var me = this.ownerCt.ownerLockable.view, lockedView = me.lockedGrid.view, normalView = me.normalGrid.view;
  if (me.lockedGrid.isVisible()) 
  {
    if (lockedView.refreshNeeded) 
    {
      lockedView.doFirstRefresh(lockedView.dataSource);
    }
  }
  if (normalView.refreshNeeded) 
  {
    normalView.doFirstRefresh(normalView.dataSource);
  }
}, onPanelRender: function() {
  var me = this, mask = me.loadMask, cfg = {target: me.panel, msg: me.loadingText, msgCls: me.loadingCls, useMsg: me.loadingUseMsg, store: me.panel.store};
  me.el = me.panel.body;
  me.fireEvent('render', me);
  if (mask) 
  {
    if (Ext.isObject(mask)) 
    {
      cfg = Ext.apply(cfg, mask);
    }
    me.loadMask = new Ext.LoadMask(cfg);
  }
}, getRefOwner: function() {
  return this.panel;
}, getGridColumns: function() {
  var cols = this.lockedGrid.headerCt.getVisibleGridColumns();
  return cols.concat(this.normalGrid.headerCt.getVisibleGridColumns());
}, getEl: function(column) {
  return this.getViewForColumn(column).getEl();
}, getViewForColumn: function(column) {
  var view = this.lockedView, inLocked;
  view.headerCt.cascade(function(col) {
  if (col === column) 
  {
    inLocked = true;
    return false;
  }
});
  return inLocked ? view : this.normalView;
}, onItemMouseEnter: function(view, record) {
  var me = this, locked = me.lockedView, other = me.normalView, item;
  if (view.trackOver) 
  {
    if (view !== locked) 
    {
      other = locked;
    }
    item = other.getNode(record, false);
    other.highlightItem(item);
  }
}, onItemMouseLeave: function(view, record) {
  var me = this, locked = me.lockedView, other = me.normalView;
  if (view.trackOver) 
  {
    if (view !== locked) 
    {
      other = locked;
    }
    other.clearHighlight();
  }
}, relayFn: function(name, args) {
  args = args || [];
  var view = this.lockedView;
  view[name].apply(view, args);
  view = this.normalView;
  view[name].apply(view, args);
}, getSelectionModel: function() {
  return this.panel.getSelectionModel();
}, getStore: function() {
  return this.panel.store;
}, bindStore: function(store, initial, propName) {
  var me = this;
  me.mixins.bindable.bindStore.apply(me, arguments);
  if (!initial) 
  {
    me.getSelectionModel().bindStore(store);
  }
  if (me.componentLayoutCounter) 
  {
    Ext.suspendLayouts();
    me.normalView.doFirstRefresh(store);
    me.lockedView.doFirstRefresh(store);
    Ext.resumeLayouts(true);
  }
}, getStoreListeners: function() {
  var me = this;
  return {idchanged: me.onIdChanged, refresh: me.onDataRefresh, replace: me.onReplace, add: me.onAdd, bulkremove: me.onRemove, update: me.onUpdate, clear: me.refresh};
}, onIdChanged: function(eventName, fn, scope) {
  this.relayFn('onIdChanged', arguments);
}, onDataRefresh: function(eventName, fn, scope) {
  this.relayFn('onDataRefresh', arguments);
}, onReplace: function(eventName, fn, scope) {
  this.relayFn('onReplace', arguments);
}, onAdd: function(eventName, fn, scope) {
  this.relayFn('onAdd', arguments);
}, onRemove: function(eventName, fn, scope) {
  this.relayFn('onRemove', arguments);
}, onUpdate: function(eventName, fn, scope) {
  this.relayFn('onUpdate', arguments);
}, refresh: function(eventName, fn, scope) {
  this.relayFn('refresh', arguments);
}, getNode: function(nodeInfo, dataRow) {
  return this.normalView.getNode(nodeInfo, dataRow);
}, getCell: function(record, column) {
  var view = this.getViewForColumn(column), row = view.getNode(record, true);
  return Ext.fly(row).down(column.getCellSelector());
}, indexOf: function(record) {
  var result = this.lockedView.indexOf(record);
  if (!result) 
  {
    result = this.normalView.indexOf(record);
  }
  return result;
}, focus: function() {
  var p = this.getSelectionModel().getCurrentPosition(), v = p ? p.view : this.normalView;
  v.focus();
}, focusRow: function(row) {
  this.normalView.focusRow(row);
}, focusCell: function(position) {
  position.view.focusCell(position);
}, isVisible: function(deep) {
  return this.panel.isVisible(deep);
}, getCellByPosition: function(pos, returnDom) {
  var col = pos.column, lockedSize = this.lockedGrid.getColumnManager().getColumns().length;
  if (col >= lockedSize) 
  {
    pos = Ext.apply({}, pos);
    pos.column -= lockedSize;
    return this.normalView.getCellByPosition(pos, returnDom);
  } else {
    return this.lockedView.getCellByPosition(pos, returnDom);
  }
}, getRecord: function(node) {
  var result = this.lockedView.getRecord(node);
  if (!result) 
  {
    result = this.normalView.getRecord(node);
  }
  return result;
}, scrollBy: function() {
  var normal = this.normalView;
  normal.scrollBy.apply(normal, arguments);
}, addElListener: function(eventName, fn, scope) {
  this.relayFn('addElListener', arguments);
}, refreshNode: function() {
  this.relayFn('refreshNode', arguments);
}, addRowCls: function() {
  this.relayFn('addRowCls', arguments);
}, removeRowCls: function() {
  this.relayFn('removeRowCls', arguments);
}, destroy: function() {
  var me = this, mask = me.loadMask;
  this.isDestroyed = true;
  me.clearListeners();
  if (mask && mask.bindStore) 
  {
    mask.bindStore(null);
  }
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable], ['bindable', Ext.util.Bindable]], [Ext.grid.locking, 'View', Ext.grid, 'LockingView'], function() {
  this.borrow(Ext.AbstractComponent, ['up']);
  this.borrow(Ext.view.AbstractView, ['doFirstRefresh', 'applyFirstRefresh']);
}));
;

(Ext.cmd.derive('Ext.grid.locking.Lockable', Ext.Base, {alternateClassName: 'Ext.grid.Lockable', supportsOverflowX: 'overflow-x' in document.documentElement.style, syncRowHeight: true, headerCounter: 0, scrollDelta: 40, lockedGridCls: Ext.baseCSSPrefix + 'grid-inner-locked', normalGridCls: Ext.baseCSSPrefix + 'grid-inner-normal', unlockText: 'Unlock', lockText: 'Lock', bothCfgCopy: ['invalidateScrollerOnRefresh', 'hideHeaders', 'enableColumnHide', 'enableColumnMove', 'enableColumnResize', 'sortableColumns', 'multiColumnSort', 'columnLines', 'rowLines', 'deferRowRender'], normalCfgCopy: ['verticalScroller', 'verticalScrollDock', 'verticalScrollerType', 'scroll'], lockedCfgCopy: [], determineXTypeToCreate: function(lockedSide) {
  var me = this, typeToCreate, xtypes, xtypesLn, xtype, superxtype;
  if (me.subGridXType) 
  {
    typeToCreate = me.subGridXType;
  } else {
    if (!lockedSide) 
    {
      return 'gridpanel';
    }
    xtypes = this.getXTypes().split('/');
    xtypesLn = xtypes.length;
    xtype = xtypes[xtypesLn - 1];
    superxtype = xtypes[xtypesLn - 2];
    if (superxtype !== 'tablepanel') 
    {
      typeToCreate = superxtype;
    } else {
      typeToCreate = xtype;
    }
  }
  return typeToCreate;
}, injectLockable: function() {
  this.lockable = true;
  this.hasView = true;
  var me = this, scrollbarHeight = Ext.getScrollbarSize().height, store = me.store = Ext.StoreManager.lookup(me.store), selModel = me.getSelectionModel(), allFeatures, allPlugins, lockedGrid, normalGrid, i, columns, lockedHeaderCt, normalHeaderCt, lockedView, normalView, listeners, viewConfig = me.viewConfig, loadMaskCfg = viewConfig && viewConfig.loadMask, loadMask = (loadMaskCfg !== undefined) ? loadMaskCfg : me.loadMask, bufferedRenderer = me.findPlugin('bufferedrenderer');
  allFeatures = me.constructLockableFeatures();
  if (me.features) 
  {
    me.features = null;
  }
  allPlugins = me.constructLockablePlugins();
  me.plugins = allPlugins.topPlugins;
  lockedGrid = Ext.apply({id: me.id + '-locked', isLocked: true, ownerLockable: me, xtype: me.determineXTypeToCreate(true), store: store, scrollerOwner: false, animate: false, scroll: scrollbarHeight ? false : 'vertical', selModel: selModel, border: false, cls: me.lockedGridCls, isLayoutRoot: function() {
  return this.floatedFromCollapse || me.normalGrid.floatedFromCollapse;
}, features: allFeatures.lockedFeatures, plugins: allPlugins.lockedPlugins}, me.lockedGridConfig);
  normalGrid = Ext.apply({id: me.id + '-normal', isLocked: false, ownerLockable: me, xtype: me.determineXTypeToCreate(), store: store, scrollerOwner: false, selModel: selModel, border: false, cls: me.normalGridCls, isLayoutRoot: function() {
  return this.floatedFromCollapse || me.lockedGrid.floatedFromCollapse;
}, features: allFeatures.normalFeatures, plugins: allPlugins.normalPlugins}, me.normalGridConfig);
  me.addCls(Ext.baseCSSPrefix + 'grid-locked');
  Ext.copyTo(normalGrid, me, me.bothCfgCopy, true);
  Ext.copyTo(lockedGrid, me, me.bothCfgCopy, true);
  Ext.copyTo(normalGrid, me, me.normalCfgCopy, true);
  Ext.copyTo(lockedGrid, me, me.lockedCfgCopy, true);
  for (i = 0; i < me.normalCfgCopy.length; i++) 
    {
      delete me[me.normalCfgCopy[i]];
    }
  for (i = 0; i < me.lockedCfgCopy.length; i++) 
    {
      delete me[me.lockedCfgCopy[i]];
    }
  me.addEvents('processcolumns', 'lockcolumn', 'unlockcolumn');
  me.addStateEvents(['lockcolumn', 'unlockcolumn']);
  columns = me.processColumns(me.columns, lockedGrid);
  lockedGrid.columns = columns.locked;
  if (!lockedGrid.columns.items.length) 
  {
    lockedGrid.hidden = true;
  }
  normalGrid.columns = columns.normal;
  normalGrid.flex = 1;
  lockedGrid.viewConfig = me.lockedViewConfig || {};
  normalGrid.viewConfig = me.normalViewConfig || {};
  lockedGrid.viewConfig.loadingUseMsg = false;
  lockedGrid.viewConfig.loadMask = false;
  if (scrollbarHeight && !me.supportsOverflowX) 
  {
    lockedGrid.viewConfig.style = 'border-bottom:' + scrollbarHeight + 'px solid #f6f6f6;' + (lockedGrid.viewConfig.style || '');
    normalGrid.viewConfig.style = 'border-bottom:' + scrollbarHeight + 'px solid #f6f6f6;' + (lockedGrid.viewConfig.style || '');
  }
  normalGrid.viewConfig.loadMask = false;
  Ext.applyIf(lockedGrid.viewConfig, viewConfig);
  Ext.applyIf(normalGrid.viewConfig, viewConfig);
  if (!me.initialConfig.layout) 
  {
    me.layout = {type: 'hbox', align: 'stretch'};
  }
  me.getLayout();
  if (me.layout.type === 'border') 
  {
    if (me.split) 
    {
      lockedGrid.split = true;
    }
    if (!normalGrid.title) 
    {
      lockedGrid.header = false;
    }
    if (!lockedGrid.region) 
    {
      lockedGrid.region = 'west';
    }
    if (!normalGrid.region) 
    {
      normalGrid.region = 'center';
    }
    me.addCls(Ext.baseCSSPrefix + 'grid-locked-split');
  }
  if (!(me.layout instanceof Ext.layout.container.Box)) 
  {
    me.split = false;
  }
  me.view = new Ext.grid.locking.View({loadMask: loadMask, locked: lockedGrid, normal: normalGrid, panel: me});
  lockedView = me.lockedGrid.getView();
  normalView = me.normalGrid.getView();
  listeners = bufferedRenderer ? {} : {scroll: {fn: me.onLockedViewScroll, element: 'el', scope: me}};
  if (scrollbarHeight) 
  {
    me.lockedGrid.on({afterlayout: me.afterLockedViewLayout, scope: me});
    lockedView.getOverflowStyle();
    if (lockedView.scrollFlags.y) 
    {
      me.lockedGrid.headerCt.forceFit = true;
    } else {
      listeners.mousewheel = {fn: me.onLockedViewMouseWheel, element: 'el', scope: me};
    }
  }
  lockedView.on(listeners);
  listeners = bufferedRenderer ? {} : {scroll: {fn: me.onNormalViewScroll, element: 'el', scope: me}, scope: me};
  normalView.on(listeners);
  lockedHeaderCt = me.lockedGrid.headerCt;
  normalHeaderCt = me.normalGrid.headerCt;
  me.headerCt = me.view.headerCt = new Ext.grid.locking.HeaderContainer(me);
  lockedHeaderCt.lockedCt = true;
  lockedHeaderCt.lockableInjected = true;
  normalHeaderCt.lockableInjected = true;
  lockedHeaderCt.on({add: {buffer: 1, scope: me, fn: me.onLockedHeaderAdd}, columnshow: me.onLockedHeaderShow, columnhide: me.onLockedHeaderHide, sortchange: me.onLockedHeaderSortChange, columnresize: me.onLockedHeaderResize, scope: me});
  normalHeaderCt.on({sortchange: me.onNormalHeaderSortChange, scope: me});
  me.modifyHeaderCt();
  me.items = [me.lockedGrid];
  if (me.split) 
  {
    me.addCls(Ext.baseCSSPrefix + 'grid-locked-split');
    me.items[1] = {xtype: 'splitter'};
  }
  me.items.push(me.normalGrid);
  me.relayHeaderCtEvents(lockedHeaderCt);
  me.relayHeaderCtEvents(normalHeaderCt);
  me.storeRelayers = me.relayEvents(store, ['filterchange', 'groupchange']);
  me.gridRelayers = me.relayEvents(me.normalGrid, ['viewready']);
}, getLockingViewConfig: function() {
  return {xclass: 'Ext.grid.locking.View', locked: this.lockedGrid, normal: this.normalGrid, panel: this};
}, processColumns: function(columns, lockedGrid) {
  var me = this, i, len, column, cp = new Ext.grid.header.Container(), lockedHeaders = [], normalHeaders = [], lockedHeaderCt = {itemId: 'lockedHeaderCt', stretchMaxPartner: '^^>>#normalHeaderCt', items: lockedHeaders}, normalHeaderCt = {itemId: 'normalHeaderCt', stretchMaxPartner: '^^>>#lockedHeaderCt', items: normalHeaders}, result = {lockedWidth: lockedGrid.width || 0, locked: lockedHeaderCt, normal: normalHeaderCt}, shrinkWrapLocked = me.shrinkWrapLocked = !(lockedGrid.width || lockedGrid.flex), copy;
  if (Ext.isObject(columns)) 
  {
    Ext.applyIf(lockedHeaderCt, columns);
    Ext.applyIf(normalHeaderCt, columns);
    copy = Ext.apply({}, columns);
    delete copy.items;
    Ext.apply(cp, copy);
    columns = columns.items;
  }
  for (i = 0 , len = columns.length; i < len; ++i) 
    {
      column = columns[i];
      if (!column.isComponent) 
      {
        column = cp.lookupComponent(cp.applyDefaults(column));
      }
      column.processed = true;
      if (column.locked || column.autoLock) 
      {
        if (shrinkWrapLocked && !column.hidden) 
        {
          result.lockedWidth += me.getColumnWidth(column) || cp.defaultWidth;
        }
        lockedHeaders.push(column);
      } else {
        normalHeaders.push(column);
      }
      if (!column.headerId) 
      {
        column.headerId = (column.initialConfig || column).id || ('h' + (++me.headerCounter));
      }
    }
  me.fireEvent('processcolumns', me, lockedHeaders, normalHeaders);
  cp.destroy();
  if (shrinkWrapLocked) 
  {
    lockedGrid.width = (result.lockedWidth += Ext.num(me.getSelectionModel().headerWidth, 0) + (lockedHeaders.length ? 1 : 0));
  }
  return result;
}, getColumnWidth: function(column) {
  var result = column.width || 0, subcols, len, i;
  if (!result && column.isGroupHeader) 
  {
    subcols = column.items.items;
    len = subcols.length;
    for (i = 0; i < len; i++) 
      {
        result += this.getColumnWidth(subcols[i]);
      }
  }
  return result;
}, afterLockedViewLayout: function() {
  var me = this, lockedView = me.lockedGrid.getView(), normalView = me.normalGrid.getView(), lockedViewEl = lockedView.el, normalViewEl = normalView.el, spacerHeight = Ext.getScrollbarSize().height, lockedViewHorizScrollBar = (lockedView.scrollFlags.x && me.lockedGrid.headerCt.tooNarrow ? spacerHeight : 0), normalViewHorizScrollBar = (normalView.scrollFlags.x && me.normalGrid.headerCt.tooNarrow ? spacerHeight : 0);
  if (lockedViewHorizScrollBar !== normalViewHorizScrollBar) 
  {
    if (lockedViewHorizScrollBar) 
    {
      if (me.supportsOverflowX) 
      {
        normalViewEl.dom.style.overflowX = 'scroll';
        lockedView.getOverflowEl().setStyle(lockedView.getOverflowStyle());
      } else {
        normalViewEl.dom.style.borderBottomWidth = lockedViewHorizScrollBar + 'px';
        lockedViewEl.dom.style.borderBottomWidth = '0px';
      }
    } else {
      if (me.supportsOverflowX) 
      {
        lockedViewEl.dom.style.overflowX = 'scroll';
        normalView.getOverflowEl().setStyle(normalView.getOverflowStyle());
      } else {
        lockedViewEl.dom.style.borderBottomWidth = normalViewHorizScrollBar + 'px';
        normalViewEl.dom.style.borderBottomWidth = '0px';
      }
    }
  } else {
    if (me.supportsOverflowX) 
    {
      lockedView.getOverflowEl().dom.style.overflowX = normalViewHorizScrollBar ? 'scroll' : '';
      normalView.getOverflowEl().setStyle(normalView.getOverflowStyle());
    } else {
      normalViewEl.dom.style.borderBottomWidth = lockedViewEl.dom.style.borderBottomWidth = '0px';
    }
  }
  if (!Ext.isBorderBox && !me.supportsOverflowX) 
  {
    lockedViewEl.setHeight(lockedView.lastBox.height);
    normalViewEl.setHeight(normalView.lastBox.height);
  }
}, onLockedViewMouseWheel: function(e) {
  var me = this, deltaY = -me.scrollDelta * e.getWheelDeltas().y, vertScrollerEl = me.lockedGrid.getView().el.dom, verticalCanScrollDown, verticalCanScrollUp;
  if (!me.ignoreMousewheel) 
  {
    if (vertScrollerEl) 
    {
      verticalCanScrollDown = vertScrollerEl.scrollTop !== vertScrollerEl.scrollHeight - vertScrollerEl.clientHeight;
      verticalCanScrollUp = vertScrollerEl.scrollTop !== 0;
    }
    if ((deltaY < 0 && verticalCanScrollUp) || (deltaY > 0 && verticalCanScrollDown)) 
    {
      e.stopEvent();
      vertScrollerEl.scrollTop += deltaY;
      me.normalGrid.getView().el.dom.scrollTop = vertScrollerEl.scrollTop;
      me.onNormalViewScroll();
    }
  }
}, onLockedViewScroll: function() {
  var me = this, normalDom = me.normalGrid.getView().el.dom, lockedDom = me.lockedGrid.getView().el.dom;
  if (normalDom.scrollTop !== lockedDom.scrollTop) 
  {
    normalDom.scrollTop = lockedDom.scrollTop;
  }
}, onNormalViewScroll: function() {
  var me = this, normalDom = me.normalGrid.getView().el.dom, lockedDom = me.lockedGrid.getView().el.dom;
  if (normalDom.scrollTop !== lockedDom.scrollTop) 
  {
    lockedDom.scrollTop = normalDom.scrollTop;
  }
}, syncRowHeights: function() {
  var me = this, i, lockedView = me.lockedGrid.getView(), normalView = me.normalGrid.getView(), lockedRowEls = lockedView.all.slice(), normalRowEls = normalView.all.slice(), ln = lockedRowEls.length, scrollTop;
  if (normalRowEls.length === ln) 
  {
    for (i = 0; i < ln; i++) 
      {
        normalView.syncRowHeights(lockedRowEls[i], normalRowEls[i]);
      }
    scrollTop = normalView.el.dom.scrollTop;
    normalView.el.dom.scrollTop = scrollTop;
    lockedView.el.dom.scrollTop = scrollTop;
  }
}, modifyHeaderCt: function() {
  var me = this;
  me.lockedGrid.headerCt.getMenuItems = me.getMenuItems(me.lockedGrid.headerCt.getMenuItems, true);
  me.normalGrid.headerCt.getMenuItems = me.getMenuItems(me.normalGrid.headerCt.getMenuItems, false);
  me.lockedGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(me.lockedGrid.headerCt.showMenuBy, me.showMenuBy);
  me.normalGrid.headerCt.showMenuBy = Ext.Function.createInterceptor(me.normalGrid.headerCt.showMenuBy, me.showMenuBy);
}, onUnlockMenuClick: function() {
  this.unlock();
}, onLockMenuClick: function() {
  this.lock();
}, showMenuBy: function(t, header) {
  var menu = this.getMenu(), unlockItem = menu.down('#unlockItem'), lockItem = menu.down('#lockItem'), sep = unlockItem.prev();
  if (header.lockable === false) 
  {
    sep.hide();
    unlockItem.hide();
    lockItem.hide();
  } else {
    sep.show();
    unlockItem.show();
    lockItem.show();
    if (!unlockItem.initialConfig.disabled) 
    {
      unlockItem.setDisabled(header.lockable === false);
    }
    if (!lockItem.initialConfig.disabled) 
    {
      lockItem.setDisabled(!header.isLockable());
    }
  }
}, getMenuItems: function(getMenuItems, locked) {
  var me = this, unlockText = me.unlockText, lockText = me.lockText, unlockCls = Ext.baseCSSPrefix + 'hmenu-unlock', lockCls = Ext.baseCSSPrefix + 'hmenu-lock', unlockHandler = Ext.Function.bind(me.onUnlockMenuClick, me), lockHandler = Ext.Function.bind(me.onLockMenuClick, me);
  return function() {
  var o = getMenuItems.call(this);
  o.push('-', {itemId: 'unlockItem', iconCls: unlockCls, text: unlockText, handler: unlockHandler, disabled: !locked});
  o.push({itemId: 'lockItem', iconCls: lockCls, text: lockText, handler: lockHandler, disabled: locked});
  return o;
};
}, syncLockedWidth: function() {
  var me = this, locked = me.lockedGrid, lockedView = locked.view, lockedViewEl = lockedView.el.dom, normal = me.normalGrid, lockedColCount = locked.headerCt.getVisibleGridColumns().length, normalColCount = normal.headerCt.getVisibleGridColumns().length;
  Ext.suspendLayouts();
  if (normalColCount) 
  {
    normal.show();
    if (lockedColCount) 
    {
      if (me.shrinkWrapLocked && !locked.headerCt.forceFit) 
      {
        delete locked.flex;
        locked.setWidth(locked.headerCt.getTableWidth() + locked.el.getBorderWidth('lr'));
      }
      locked.addCls(me.lockedGridCls);
      locked.show();
      if (me.split) 
      {
        me.child('splitter').show();
      }
    } else {
      locked.getView().clearViewEl();
      locked.hide();
      if (me.split) 
      {
        me.child('splitter').hide();
      }
    }
    lockedView.el.setStyle(lockedView.getOverflowStyle());
    me.ignoreMousewheel = lockedView.scrollFlags.y;
  } else {
    normal.hide();
    lockedViewEl.style.borderBottomWidth = '0';
    locked.flex = 1;
    delete locked.width;
    locked.removeCls(me.lockedGridCls);
    locked.show();
    lockedView.el.setStyle(normal.view.getOverflowStyle());
    me.ignoreMousewheel = true;
  }
  Ext.resumeLayouts(true);
  return [lockedColCount, normalColCount];
}, onLockedHeaderAdd: function() {
  if (!this.ignoreAddLockedColumn) 
  {
    this.syncLockedWidth();
  }
}, onLockedHeaderResize: function() {
  this.syncLockedWidth();
}, onLockedHeaderHide: function() {
  this.syncLockedWidth();
}, onLockedHeaderShow: function() {
  this.syncLockedWidth();
}, onLockedHeaderSortChange: Ext.emptyFn, onNormalHeaderSortChange: Ext.emptyFn, lock: function(activeHd, toIdx, toCt) {
  var me = this, normalGrid = me.normalGrid, lockedGrid = me.lockedGrid, normalView = normalGrid.view, lockedView = lockedGrid.view, normalHCt = normalGrid.headerCt, refreshFlags, ownerCt;
  activeHd = activeHd || normalHCt.getMenu().activeHeader;
  toCt = toCt || lockedGrid.headerCt;
  ownerCt = activeHd.ownerCt;
  if (!activeHd.isLockable()) 
  {
    return;
  }
  if (activeHd.flex) 
  {
    activeHd.width = activeHd.getWidth();
    activeHd.flex = null;
  }
  Ext.suspendLayouts();
  normalView.blockRefresh = lockedView.blockRefresh = true;
  ownerCt.remove(activeHd, false);
  activeHd.locked = true;
  me.ignoreAddLockedColumn = true;
  if (Ext.isDefined(toIdx)) 
  {
    toCt.insert(toIdx, activeHd);
  } else {
    toCt.add(activeHd);
  }
  me.ignoreAddLockedColumn = false;
  normalView.blockRefresh = lockedView.blockRefresh = false;
  refreshFlags = me.syncLockedWidth();
  if (refreshFlags[0]) 
  {
    lockedGrid.getView().refresh();
  }
  if (refreshFlags[1]) 
  {
    normalGrid.getView().refresh();
  }
  Ext.resumeLayouts(true);
  me.fireEvent('lockcolumn', me, activeHd);
}, unlock: function(activeHd, toIdx, toCt) {
  var me = this, normalGrid = me.normalGrid, lockedGrid = me.lockedGrid, normalView = normalGrid.view, lockedView = lockedGrid.view, lockedHCt = lockedGrid.headerCt, refreshFlags;
  if (!Ext.isDefined(toIdx)) 
  {
    toIdx = 0;
  }
  activeHd = activeHd || lockedHCt.getMenu().activeHeader;
  toCt = toCt || normalGrid.headerCt;
  Ext.suspendLayouts();
  normalView.blockRefresh = lockedView.blockRefresh = true;
  activeHd.ownerCt.remove(activeHd, false);
  activeHd.locked = false;
  toCt.insert(toIdx, activeHd);
  normalView.blockRefresh = lockedView.blockRefresh = false;
  refreshFlags = me.syncLockedWidth();
  if (refreshFlags[0]) 
  {
    lockedGrid.getView().refresh();
  }
  if (refreshFlags[1]) 
  {
    normalGrid.getView().refresh();
  }
  Ext.resumeLayouts(true);
  me.fireEvent('unlockcolumn', me, activeHd);
}, reconfigureLockable: function(store, columns) {
  var me = this, oldStore = me.store, lockedGrid = me.lockedGrid, normalGrid = me.normalGrid;
  Ext.suspendLayouts();
  if (columns) 
  {
    lockedGrid.headerCt.removeAll();
    normalGrid.headerCt.removeAll();
    columns = me.processColumns(columns, lockedGrid);
    me.ignoreAddLockedColumn = true;
    lockedGrid.headerCt.add(columns.locked.items);
    me.ignoreAddLockedColumn = false;
    normalGrid.headerCt.add(columns.normal.items);
    me.syncLockedWidth();
  }
  if (store && store !== oldStore) 
  {
    store = Ext.data.StoreManager.lookup(store);
    me.store = store;
    lockedGrid.bindStore(store);
    normalGrid.bindStore(store);
  } else {
    lockedGrid.getView().refresh();
    normalGrid.getView().refresh();
  }
  Ext.resumeLayouts(true);
}, constructLockableFeatures: function() {
  var features = this.features, feature, featureClone, lockedFeatures, normalFeatures, i = 0, len;
  if (features) 
  {
    if (!Ext.isArray(features)) 
    {
      features = [features];
    }
    lockedFeatures = [];
    normalFeatures = [];
    len = features.length;
    for (; i < len; i++) 
      {
        feature = features[i];
        if (!feature.isFeature) 
        {
          feature = Ext.create('feature.' + feature.ftype, feature);
        }
        switch (feature.lockableScope) {
          case 'locked':
            lockedFeatures.push(feature);
            break;
          case 'normal':
            normalFeatures.push(feature);
            break;
          default:
            feature.lockableScope = 'both';
            lockedFeatures.push(feature);
            normalFeatures.push(featureClone = feature.clone());
            featureClone.lockingPartner = feature;
            feature.lockingPartner = featureClone;
        }
      }
  }
  return {normalFeatures: normalFeatures, lockedFeatures: lockedFeatures};
}, constructLockablePlugins: function() {
  var plugins = this.plugins, plugin, normalPlugin, lockedPlugin, topPlugins, lockedPlugins, normalPlugins, i = 0, len, lockableScope, pluginCls;
  if (plugins) 
  {
    if (!Ext.isArray(plugins)) 
    {
      plugins = [plugins];
    }
    topPlugins = [];
    lockedPlugins = [];
    normalPlugins = [];
    len = plugins.length;
    for (; i < len; i++) 
      {
        plugin = plugins[i];
        if (plugin.init) 
        {
          lockableScope = plugin.lockableScope;
        } else {
          pluginCls = plugin.ptype ? Ext.ClassManager.getByAlias(('plugin.' + plugin.ptype)) : Ext.ClassManager.get(plugin.xclass);
          lockableScope = pluginCls.prototype.lockableScope;
        }
        switch (lockableScope) {
          case 'both':
            lockedPlugins.push(lockedPlugin = plugin.clonePlugin());
            normalPlugins.push(normalPlugin = plugin.clonePlugin());
            lockedPlugin.lockingPartner = normalPlugin;
            normalPlugin.lockingPartner = lockedPlugin;
            Ext.destroy(plugin);
            break;
          case 'locked':
            lockedPlugins.push(plugin);
            break;
          case 'normal':
            normalPlugins.push(plugin);
            break;
          default:
            topPlugins.push(plugin);
        }
      }
  }
  return {topPlugins: topPlugins, normalPlugins: normalPlugins, lockedPlugins: lockedPlugins};
}, destroyLockable: function() {
  Ext.destroy(this.view, this.headerCt);
}}, 0, 0, 0, 0, 0, 0, [Ext.grid.locking, 'Lockable', Ext.grid, 'Lockable'], function() {
  this.borrow(Ext.AbstractComponent, ['constructPlugin']);
}));
;

(Ext.cmd.derive('Ext.grid.plugin.BufferedRenderer', Ext.AbstractPlugin, {lockableScope: 'both', percentageFromEdge: 0.35, variableRowHeight: false, numFromEdge: 8, trailingBufferZone: 10, leadingBufferZone: 20, synchronousRender: true, scrollToLoadBuffer: 200, viewSize: 0, rowHeight: 21, position: 0, lastScrollDirection: 1, bodyTop: 0, init: function(grid) {
  var me = this, view = grid.view, viewListeners = {scroll: {fn: me.onViewScroll, element: 'el', scope: me}, boxready: me.onViewResize, resize: me.onViewResize, refresh: me.onViewRefresh, scope: me, destroyable: true}, initialConfig = view.initialConfig;
  if (!me.variableRowHeight && grid.ownerLockable) 
  {
    grid.ownerLockable.syncRowHeight = false;
  }
  if (grid.isTree || (grid.ownerLockable && grid.ownerLockable.isTree)) 
  {
    view.blockRefresh = false;
    if (initialConfig && initialConfig.loadMask === undefined) 
    {
      view.loadMask = true;
    }
  }
  if (view.positionBody) 
  {
    viewListeners.refresh = me.onViewRefresh;
  }
  me.grid = grid;
  me.view = view;
  me.isRTL = view.getHierarchyState().rtl;
  view.bufferedRenderer = me;
  view.preserveScrollOnRefresh = true;
  view.animate = false;
  me.bindStore(view.dataSource);
  view.getViewRange = function() {
  return me.getViewRange();
};
  me.position = 0;
  me.gridListeners = grid.on('reconfigure', me.onReconfigure, me);
  me.viewListeners = view.on(viewListeners);
}, bindStore: function(store) {
  var me = this, view = me.view, dataSource = view.dataSource, hasFeatureStore = dataSource && dataSource.isFeatureStore;
  if (hasFeatureStore === store.isFeatureStore) 
  {
    if (me.store) 
    {
      me.unbindStore();
    }
    me.storeListeners = store.on({scope: me, clear: me.onStoreClear, destroyable: true});
    me.store = store;
  }
  if (me.view.componentLayout.layoutCount) 
  {
    me.onViewResize(me.view, 0, me.view.getHeight());
  }
}, onReconfigure: function(grid, store) {
  if (store && store !== this.store) 
  {
    this.bindStore(store);
  }
}, unbindStore: function() {
  this.storeListeners.destroy();
  this.store = null;
}, onStoreClear: function() {
  var me = this;
  if (me.view.rendered && !me.store.isDestroyed) 
  {
    if (me.scrollTop !== 0) 
    {
      me.ignoreNextScrollEvent = true;
      me.view.el.dom.scrollTop = 0;
    }
    me.bodyTop = me.scrollTop = me.position = me.scrollHeight = 0;
    me.lastScrollDirection = me.scrollOffset = null;
    delete me.rowHeight;
  }
}, onViewRefresh: function() {
  var me = this, view = me.view, oldScrollHeight = me.scrollHeight, scrollHeight;
  if (view.all.getCount()) 
  {
    delete me.rowHeight;
  }
  scrollHeight = me.getScrollHeight();
  if (!oldScrollHeight || scrollHeight != oldScrollHeight) 
  {
    me.stretchView(view, scrollHeight);
  }
  if (me.scrollTop !== view.el.dom.scrollTop) 
  {
    me.onViewScroll();
  } else {
    if (!me.hasOwnProperty('bodyTop')) 
    {
      me.bodyTop = view.all.startIndex * me.rowHeight;
      view.el.dom.scrollTop = me.bodyTop;
    }
    me.setBodyTop(me.bodyTop);
    if (view.all.getCount()) 
    {
      me.viewSize = 0;
      me.onViewResize(view, null, view.getHeight());
    }
  }
}, onViewResize: function(view, width, height, oldWidth, oldHeight) {
  var me = this, newViewSize;
  me.tableTopBorderWidth = view.body.getBorderWidth('t');
  if (!oldHeight || height !== oldHeight) 
  {
    newViewSize = Math.ceil(height / me.rowHeight) + me.trailingBufferZone + me.leadingBufferZone;
    me.viewSize = me.setViewSize(newViewSize);
  }
}, stretchView: function(view, scrollRange) {
  var me = this, recordCount = (me.store.buffered ? me.store.getTotalCount() : me.store.getCount()), stretcherSpec, el;
  if (me.stretcher) 
  {
    me.stretcher.dom.style.marginTop = (recordCount <= me.viewSize ? 0 : (scrollRange - 1)) + 'px';
  } else {
    el = view.el;
    if (view.refreshCounter) 
    {
      view.fixedNodes++;
    }
    if (recordCount && (me.view.all.endIndex === recordCount - 1)) 
    {
      scrollRange = me.bodyTop + view.body.dom.offsetHeight;
    }
    stretcherSpec = {style: {width: '1px', height: '1px', 'marginTop': (scrollRange - 1) + 'px', position: 'absolute'}};
    stretcherSpec.style[me.isRTL ? 'right' : 'left'] = 0;
    this.stretcher = el.createChild(stretcherSpec, el.dom.firstChild);
  }
}, setViewSize: function(viewSize) {
  if (viewSize !== this.viewSize) 
  {
    this.scrollTop = this.view.el.dom.scrollTop;
    var me = this, store = me.store, elCount = me.view.all.getCount(), start, end, lockingPartner = me.lockingPartner;
    me.viewSize = store.viewSize = viewSize;
    if (elCount) 
    {
      start = me.view.all.startIndex;
      end = Math.min(start + viewSize - 1, (store.buffered ? store.getTotalCount() : store.getCount()) - 1);
      if (lockingPartner) 
      {
        lockingPartner.disable();
      }
      me.renderRange(start, end);
      if (lockingPartner) 
      {
        lockingPartner.enable();
      }
    }
  }
  return viewSize;
}, getViewRange: function() {
  var me = this, rows = me.view.all, store = me.store, startIndex = rows.getCount() ? rows.startIndex : rows.startIndex = (store.currentPage - 1) * store.pageSize;
  if (rows.getCount()) 
  {
    startIndex = rows.startIndex;
  } else {
    if (!store.currentPage) 
    {
      store.currentPage = 1;
    }
    startIndex = rows.startIndex = (store.currentPage - 1) * (store.pageSize || 1);
    store.currentPage = 1;
  }
  if (store.data.getCount()) 
  {
    return store.getRange(startIndex, startIndex + (me.viewSize || store.defaultViewSize) - 1);
  } else {
    return [];
  }
}, onReplace: function(store, startIndex, oldRecords, newRecords) {
  var me = this, view = me.view, rows = view.all, viewSize = me.viewSize, overflow, shortfall, endIndex;
  me.position = view.el.dom.scrollTop;
  endIndex = startIndex + ((oldRecords && oldRecords.length) ? (oldRecords.length - 1) : 0);
  if (endIndex < rows.startIndex || startIndex > (rows.startIndex + viewSize - 1)) 
  {
    me.stretchView(view, me.getScrollHeight());
    return;
  }
  if (startIndex <= rows.startIndex && endIndex >= rows.endIndex) 
  {
    me.refreshView();
  } else if (startIndex < rows.startIndex) 
  {
    shortfall = endIndex - rows.startIndex + 1;
    if (shortfall <= 0) 
    {
      me.refreshView();
    } else {
      startIndex = Math.max(startIndex - shortfall - me.trailingBufferZone, 0);
      endIndex = Math.min(startIndex + viewSize, store.getCount()) - 1;
      me.setBodyTop(startIndex * me.rowHeight);
      me.renderRange(startIndex, endIndex);
    }
  } else {
    overflow = startIndex + newRecords.length - 1 - rows.endIndex;
    if (overflow > 0) 
    {
      startIndex = Math.max(me.getFirstVisibleRowIndex() - me.trailingBufferZone, 0);
      endIndex = Math.min(startIndex + viewSize, store.getCount() - 1);
      rows.removeRange(null, null, true);
      me.renderRange(startIndex, endIndex);
      view.selModel.onLastFocusChanged(null, view.selModel.lastFocused, true);
    } else {
      me.refreshView();
    }
  }
  me.stretchView(view, me.getScrollHeight());
}, scrollTo: function(recordIdx, doSelect, callback, scope) {
  var me = this, view = me.view, viewDom = view.el.dom, store = me.store, total = store.buffered ? store.getTotalCount() : store.getCount(), startIdx, endIdx, targetRec, targetRow, tableTop, groupingFeature, group, record;
  if ((groupingFeature = view.dataSource.groupingFeature) && (groupingFeature.collapsible !== false)) 
  {
    recordIdx = Math.min(Math.max(recordIdx, 0), view.store.getCount() - 1);
    record = view.store.getAt(recordIdx);
    group = groupingFeature.getGroup(record);
    if (group.isCollapsed) 
    {
      groupingFeature.expand(group.name);
      total = store.buffered ? store.getTotalCount() : store.getCount();
    }
    recordIdx = groupingFeature.indexOf(record);
  } else {
    recordIdx = Math.min(Math.max(recordIdx, 0), total - 1);
  }
  startIdx = Math.max(Math.min(recordIdx - (Math.floor((me.leadingBufferZone + me.trailingBufferZone) / 2)), total - me.viewSize + 1), 0);
  tableTop = Math.max(startIdx * me.rowHeight - me.tableTopBorderWidth, 0);
  endIdx = Math.min(startIdx + me.viewSize - 1, total - 1);
  store.getRange(startIdx, endIdx, {callback: function(range, start, end) {
  me.renderRange(start, end, true);
  targetRec = store.data.getRange(recordIdx, recordIdx)[0];
  targetRow = view.getNode(targetRec, false);
  view.body.dom.style.top = tableTop + 'px';
  me.position = me.scrollTop = viewDom.scrollTop = tableTop = Math.min(Math.max(0, tableTop - view.body.getOffsetsTo(targetRow)[1]), viewDom.scrollHeight - viewDom.clientHeight);
  if (Ext.isIE) 
  {
    viewDom.scrollTop = tableTop;
  }
  if (doSelect) 
  {
    view.selModel.select(targetRec);
  }
  if (callback) 
  {
    callback.call(scope || me, recordIdx, targetRec);
  }
}});
}, onViewScroll: function(e, t) {
  var me = this, store = me.store, totalCount = (store.buffered ? store.getTotalCount() : store.getCount()), vscrollDistance, scrollDirection, scrollTop = me.scrollTop = me.view.el.dom.scrollTop, scrollHandled = false;
  if (me.ignoreNextScrollEvent) 
  {
    me.ignoreNextScrollEvent = false;
    return;
  }
  if (!(me.disabled || totalCount < me.viewSize)) 
  {
    vscrollDistance = scrollTop - me.position;
    scrollDirection = vscrollDistance > 0 ? 1 : -1;
    if (Math.abs(vscrollDistance) >= 20 || (scrollDirection !== me.lastScrollDirection)) 
    {
      me.lastScrollDirection = scrollDirection;
      me.handleViewScroll(me.lastScrollDirection);
      scrollHandled = true;
    }
  }
  if (!scrollHandled) 
  {
    if (me.lockingPartner && me.lockingPartner.scrollTop !== scrollTop) 
    {
      me.lockingPartner.view.el.dom.scrollTop = scrollTop;
    }
  }
}, handleViewScroll: function(direction) {
  var me = this, rows = me.view.all, store = me.store, viewSize = me.viewSize, totalCount = (store.buffered ? store.getTotalCount() : store.getCount()), requestStart, requestEnd;
  if (direction == -1) 
  {
    if (rows.startIndex) 
    {
      if ((me.getFirstVisibleRowIndex() - rows.startIndex) < me.numFromEdge) 
      {
        requestStart = Math.max(0, me.getLastVisibleRowIndex() + me.trailingBufferZone - viewSize);
      }
    }
  } else {
    if (rows.endIndex < totalCount - 1) 
    {
      if ((rows.endIndex - me.getLastVisibleRowIndex()) < me.numFromEdge) 
      {
        requestStart = Math.max(0, me.getFirstVisibleRowIndex() - me.trailingBufferZone);
      }
    }
  }
  if (requestStart != null) 
  {
    requestEnd = Math.min(requestStart + viewSize - 1, totalCount - 1);
    if (requestStart !== rows.startIndex || requestEnd !== rows.endIndex) 
    {
      me.renderRange(requestStart, requestEnd);
      return;
    }
  }
  if (me.lockingPartner && me.lockingPartner.view.el && me.lockingPartner.scrollTop !== me.scrollTop) 
  {
    me.lockingPartner.view.el.dom.scrollTop = me.scrollTop;
  }
}, refreshView: function() {
  var me = this, selModel = me.view.selModel, rows = me.view.all, store = me.store, maxIndex = store.getCount() - 1, startIndex = Math.max(0, Math.min(rows.startIndex, maxIndex - me.viewSize + 1)), endIndex = Math.min(rows.startIndex + me.viewSize - 1, maxIndex);
  rows.removeRange(null, null, true);
  me.renderRange(startIndex, endIndex, true);
  selModel.onLastFocusChanged(null, selModel.lastFocused, true);
}, renderRange: function(start, end, forceSynchronous) {
  var me = this, rows = me.view.all, store = me.store;
  if (!(start === rows.startIndex && end === rows.endIndex)) 
  {
    if (store.rangeCached(start, end)) 
    {
      me.cancelLoad();
      if (me.synchronousRender || forceSynchronous) 
      {
        me.onRangeFetched(null, start, end);
      } else {
        if (!me.renderTask) 
        {
          me.renderTask = new Ext.util.DelayedTask(me.onRangeFetched, me, null, false);
        }
        me.renderTask.delay(1, null, null, [null, start, end]);
      }
    } else {
      me.attemptLoad(start, end);
    }
  }
}, onRangeFetched: function(range, start, end, fromLockingPartner) {
  var me = this, view = me.view, oldStart, rows = view.all, removeCount, increment = 0, calculatedTop = start * me.rowHeight - me.tableTopBorderWidth, top, lockingPartner = me.lockingPartner, newRows, topAdditionSize, i;
  if (view.isDestroyed) 
  {
    return;
  }
  if (!range) 
  {
    range = me.store.getRange(start, end);
    if (!range) 
    {
      return;
    }
  }
  if (start < rows.startIndex && end > rows.endIndex) 
  {
    topAdditionSize = rows.startIndex - start;
    rows.clear(true);
    newRows = Ext.Array.slice(view.doAdd(range, start), 0, topAdditionSize);
    for (i = 0; i < newRows.length; i++) 
      {
        increment -= newRows[i].offsetHeight;
      }
    me.setBodyTop(me.bodyTop + increment);
    return;
  }
  if (start > rows.endIndex || end < rows.startIndex) 
  {
    rows.clear(true);
    top = calculatedTop;
  }
  if (!rows.getCount()) 
  {
    view.doAdd(range, start);
  } else if (end > rows.endIndex) 
  {
    removeCount = Math.max(start - rows.startIndex, 0);
    if (me.variableRowHeight) 
    {
      increment = rows.item(rows.startIndex + removeCount, true).offsetTop;
    }
    rows.scroll(Ext.Array.slice(range, rows.endIndex + 1 - start), 1, removeCount, start, end);
    if (me.variableRowHeight) 
    {
      top = me.bodyTop + increment;
    } else {
      top = calculatedTop;
    }
  } else {
    removeCount = Math.max(rows.endIndex - end, 0);
    oldStart = rows.startIndex;
    rows.scroll(Ext.Array.slice(range, 0, rows.startIndex - start), -1, removeCount, start, end);
    if (me.variableRowHeight) 
    {
      top = me.bodyTop - rows.item(oldStart, true).offsetTop;
    } else {
      top = calculatedTop;
    }
  }
  me.position = me.scrollTop;
  if (view.positionBody) 
  {
    me.setBodyTop(top, calculatedTop);
  }
  if (lockingPartner && !lockingPartner.disabled && !fromLockingPartner) 
  {
    lockingPartner.onRangeFetched(range, start, end, true);
    if (lockingPartner.scrollTop !== me.scrollTop) 
    {
      lockingPartner.view.el.dom.scrollTop = me.scrollTop;
    }
  }
}, setBodyTop: function(bodyTop, calculatedTop) {
  var me = this, view = me.view, store = me.store, body = view.body.dom, delta;
  bodyTop = Math.floor(bodyTop);
  if (calculatedTop !== undefined) 
  {
    delta = bodyTop - calculatedTop;
    bodyTop = calculatedTop;
  }
  body.style.position = 'absolute';
  body.style.top = (me.bodyTop = Math.max(bodyTop, 0)) + 'px';
  if (me.isRTL && Ext.supports.xOriginBug && view.scrollFlags.y) 
  {
    body.style.right = -Ext.getScrollbarSize().width + 'px';
  }
  if (delta) 
  {
    me.scrollTop = me.position = view.el.dom.scrollTop -= delta;
  }
  if (view.all.endIndex === (store.buffered ? store.getTotalCount() : store.getCount()) - 1) 
  {
    me.stretchView(view, me.bodyTop + body.offsetHeight);
  }
}, getFirstVisibleRowIndex: function(startRow, endRow, viewportTop, viewportBottom) {
  var me = this, view = me.view, rows = view.all, elements = rows.elements, clientHeight = view.el.dom.clientHeight, target, targetTop;
  if (rows.getCount() && me.variableRowHeight) 
  {
    if (!arguments.length) 
    {
      startRow = rows.startIndex;
      endRow = rows.endIndex;
      viewportTop = me.scrollTop;
      viewportBottom = viewportTop + clientHeight;
      if (me.bodyTop > viewportBottom || me.bodyTop + view.body.getHeight() < viewportTop) 
      {
        return Math.floor(me.scrollTop / me.rowHeight);
      }
      target = startRow + Math.min(me.numFromEdge + ((me.lastScrollDirection == -1) ? me.leadingBufferZone : me.trailingBufferZone), Math.floor((endRow - startRow) / 2));
    } else {
      target = startRow + Math.floor((endRow - startRow) / 2);
    }
    targetTop = me.bodyTop + elements[target].offsetTop;
    if (targetTop + elements[target].offsetHeight < viewportTop) 
    {
      return me.getFirstVisibleRowIndex(target + 1, endRow, viewportTop, viewportBottom);
    }
    if (targetTop <= viewportTop) 
    {
      return target;
    } else if (target !== startRow) 
    {
      return me.getFirstVisibleRowIndex(startRow, target - 1, viewportTop, viewportBottom);
    }
  }
  return Math.floor(me.scrollTop / me.rowHeight);
}, getLastVisibleRowIndex: function(startRow, endRow, viewportTop, viewportBottom) {
  var me = this, view = me.view, rows = view.all, elements = rows.elements, clientHeight = view.el.dom.clientHeight, target, targetTop, targetBottom;
  if (rows.getCount() && me.variableRowHeight) 
  {
    if (!arguments.length) 
    {
      startRow = rows.startIndex;
      endRow = rows.endIndex;
      viewportTop = me.scrollTop;
      viewportBottom = viewportTop + clientHeight;
      if (me.bodyTop > viewportBottom || me.bodyTop + view.body.getHeight() < viewportTop) 
      {
        return Math.floor(me.scrollTop / me.rowHeight) + Math.ceil(clientHeight / me.rowHeight);
      }
      target = endRow - Math.min(me.numFromEdge + ((me.lastScrollDirection == 1) ? me.leadingBufferZone : me.trailingBufferZone), Math.floor((endRow - startRow) / 2));
    } else {
      target = startRow + Math.floor((endRow - startRow) / 2);
    }
    targetTop = me.bodyTop + elements[target].offsetTop;
    if (targetTop > viewportBottom) 
    {
      return me.getLastVisibleRowIndex(startRow, target - 1, viewportTop, viewportBottom);
    }
    targetBottom = targetTop + elements[target].offsetHeight;
    if (targetBottom >= viewportBottom) 
    {
      return target;
    } else if (target !== endRow) 
    {
      return me.getLastVisibleRowIndex(target + 1, endRow, viewportTop, viewportBottom);
    }
  }
  return me.getFirstVisibleRowIndex() + Math.ceil(clientHeight / me.rowHeight);
}, getScrollHeight: function() {
  var me = this, view = me.view, store = me.store, doCalcHeight = !me.hasOwnProperty('rowHeight'), storeCount = me.store.getCount();
  if (!storeCount) 
  {
    return 0;
  }
  if (doCalcHeight) 
  {
    if (view.all.getCount()) 
    {
      me.rowHeight = Math.floor(view.body.getHeight() / view.all.getCount());
    }
  }
  return this.scrollHeight = Math.floor((store.buffered ? store.getTotalCount() : store.getCount()) * me.rowHeight);
}, attemptLoad: function(start, end) {
  var me = this;
  if (me.scrollToLoadBuffer) 
  {
    if (!me.loadTask) 
    {
      me.loadTask = new Ext.util.DelayedTask(me.doAttemptLoad, me, []);
    }
    me.loadTask.delay(me.scrollToLoadBuffer, me.doAttemptLoad, me, [start, end]);
  } else {
    me.store.getRange(start, end, {callback: me.onRangeFetched, scope: me, fireEvent: false});
  }
}, cancelLoad: function() {
  if (this.loadTask) 
  {
    this.loadTask.cancel();
  }
}, doAttemptLoad: function(start, end) {
  this.store.getRange(start, end, {callback: this.onRangeFetched, scope: this, fireEvent: false});
}, destroy: function() {
  var me = this, view = me.view;
  if (view && view.el) 
  {
    view.el.un('scroll', me.onViewScroll, me);
  }
  Ext.destroy(me.viewListeners, me.storeListeners, me.gridListeners);
}}, 0, 0, 0, 0, ["plugin.bufferedrenderer"], 0, [Ext.grid.plugin, 'BufferedRenderer'], 0));
;

(Ext.cmd.derive('Ext.grid.plugin.Editing', Ext.AbstractPlugin, {clicksToEdit: 2, triggerEvent: undefined, relayedEvents: ['beforeedit', 'edit', 'validateedit', 'canceledit'], defaultFieldXType: 'textfield', editStyle: '', constructor: function(config) {
  var me = this;
  me.addEvents('beforeedit', 'edit', 'validateedit', 'canceledit');
  me.callParent(arguments);
  me.mixins.observable.constructor.call(me);
  me.on("edit", function(editor, e) {
  me.fireEvent("afteredit", editor, e);
});
}, init: function(grid) {
  var me = this;
  me.grid = grid;
  me.view = grid.view;
  me.initEvents();
  me.mon(grid, {beforereconfigure: me.onBeforeReconfigure, reconfigure: me.onReconfigure, scope: me, beforerender: {fn: me.onReconfigure, single: true, scope: me}});
  grid.relayEvents(me, me.relayedEvents);
  if (me.grid.ownerLockable) 
  {
    me.grid.ownerLockable.relayEvents(me, me.relayedEvents);
  }
  grid.isEditable = true;
  grid.editingPlugin = grid.view.editingPlugin = me;
}, onBeforeReconfigure: function() {
  this.reconfiguring = true;
}, onReconfigure: function() {
  this.initFieldAccessors(this.grid.getTopLevelColumnManager().getColumns());
  delete this.reconfiguring;
}, destroy: function() {
  var me = this, grid = me.grid;
  Ext.destroy(me.keyNav);
  me.clearListeners();
  if (grid) 
  {
    grid.editingPlugin = grid.view.editingPlugin = me.grid = me.view = me.editor = me.keyNav = null;
  }
}, getEditStyle: function() {
  return this.editStyle;
}, initFieldAccessors: function(columns) {
  if (columns.isGroupHeader) 
  {
    columns = columns.getGridColumns();
  } else if (!Ext.isArray(columns)) 
  {
    columns = [columns];
  }
  var me = this, c, cLen = columns.length, column;
  for (c = 0; c < cLen; c++) 
    {
      column = columns[c];
      if (!column.getEditor) 
      {
        column.getEditor = function(record, defaultField) {
  return me.getColumnField(this, defaultField);
};
      }
      if (!column.hasEditor) 
      {
        column.hasEditor = function() {
  return me.hasColumnField(this);
};
      }
      if (!column.setEditor) 
      {
        column.setEditor = function(field) {
  me.setColumnField(this, field);
};
      }
    }
}, removeFieldAccessors: function(columns) {
  if (columns.isGroupHeader) 
  {
    columns = columns.getGridColumns();
  } else if (!Ext.isArray(columns)) 
  {
    columns = [columns];
  }
  var c, cLen = columns.length, column;
  for (c = 0; c < cLen; c++) 
    {
      column = columns[c];
      column.getEditor = column.hasEditor = column.setEditor = column.field = column.editor = null;
    }
}, getColumnField: function(columnHeader, defaultField) {
  var field = columnHeader.field;
  if (!(field && field.isFormField)) 
  {
    field = columnHeader.field = this.createColumnField(columnHeader, defaultField);
  }
  return field;
}, hasColumnField: function(columnHeader) {
  return !!(columnHeader.field && columnHeader.field.isComponent);
}, setColumnField: function(columnHeader, field) {
  columnHeader.field = field;
  columnHeader.field = this.createColumnField(columnHeader);
}, createColumnField: function(columnHeader, defaultField) {
  var field = columnHeader.field, dataIndex;
  if (!field && columnHeader.editor) 
  {
    field = columnHeader.editor;
    columnHeader.editor = null;
  }
  if (!field && defaultField) 
  {
    field = defaultField;
  }
  if (field) 
  {
    dataIndex = columnHeader.dataIndex;
    if (field.isComponent) 
    {
      field.column = columnHeader;
    } else {
      if (Ext.isString(field)) 
      {
        field = {name: dataIndex, xtype: field, column: columnHeader};
      } else {
        field = Ext.apply({name: dataIndex, column: columnHeader}, field);
      }
      field = Ext.ComponentManager.create(field, this.defaultFieldXType);
    }
    field.dataIndex = dataIndex;
    field.isEditorComponent = true;
    columnHeader.field = field;
  }
  return field;
}, initEvents: function() {
  var me = this;
  me.initEditTriggers();
  me.initCancelTriggers();
}, initCancelTriggers: Ext.emptyFn, initEditTriggers: function() {
  var me = this, view = me.view;
  if (me.triggerEvent == 'cellfocus') 
  {
    me.mon(view, 'cellfocus', me.onCellFocus, me);
  } else if (me.triggerEvent == 'rowfocus') 
  {
    me.mon(view, 'rowfocus', me.onRowFocus, me);
  } else {
    if (view.getSelectionModel().isCellModel) 
    {
      view.onCellFocus = Ext.Function.bind(me.beforeViewCellFocus, me);
    }
    me.mon(view, me.triggerEvent || ('cell' + (me.clicksToEdit === 1 ? 'click' : 'dblclick')), me.onCellClick, me);
  }
  me.initAddRemoveHeaderEvents();
  view.on('render', me.initKeyNavHeaderEvents, me, {single: true});
}, beforeViewCellFocus: function(position) {
  if (this.view.selModel.keyNavigation || !this.editing || !this.isCellEditable || !this.isCellEditable(position.row, position.columnHeader)) 
  {
    this.view.focusCell.apply(this.view, arguments);
  }
}, onRowFocus: function(record, row, rowIdx) {
  this.startEdit(row, 0);
}, onCellFocus: function(record, cell, position) {
  this.startEdit(position.row, position.column);
}, onCellClick: function(view, cell, colIdx, record, row, rowIdx, e) {
  var expanderSelector = view.expanderSelector, columnHeader = view.ownerCt.getColumnManager().getHeaderAtIndex(colIdx), editor = columnHeader.getEditor(record);
  if (this.shouldStartEdit(editor) && (!expanderSelector || !e.getTarget(expanderSelector))) 
  {
    this.startEdit(record, columnHeader);
  }
}, initAddRemoveHeaderEvents: function() {
  var me = this, headerCt = me.grid.headerCt;
  me.mon(headerCt, {scope: me, add: me.onColumnAdd, columnmove: me.onColumnMove, beforedestroy: me.beforeGridHeaderDestroy});
}, initKeyNavHeaderEvents: function() {
  var me = this;
  me.keyNav = Ext.create('Ext.util.KeyNav', me.view.el, {enter: me.onEnterKey, esc: me.onEscKey, scope: me});
}, onColumnAdd: function(ct, column) {
  this.initFieldAccessors(column);
}, onColumnMove: Ext.emptyFn, onEnterKey: function(e) {
  var me = this, grid = me.grid, selModel = grid.getSelectionModel(), record, pos, columnHeader;
  if (selModel.getCurrentPosition && (pos = selModel.getCurrentPosition())) 
  {
    record = pos.record;
    columnHeader = pos.columnHeader;
  } else {
    record = selModel.getLastSelected();
    columnHeader = grid.getColumnManager().getHeaderAtIndex(0);
  }
  if (record && columnHeader) 
  {
    me.startEdit(record, columnHeader);
  }
}, onEscKey: function(e) {
  return this.cancelEdit();
}, beforeEdit: Ext.emptyFn, shouldStartEdit: function(editor) {
  return !!editor;
}, startEdit: function(record, columnHeader) {
  var me = this, context, layoutView = me.grid.lockable ? me.grid : me.view;
  if (!layoutView.componentLayoutCounter) 
  {
    layoutView.on({boxready: Ext.Function.bind(me.startEdit, me, [record, columnHeader]), single: true});
    return false;
  }
  if (me.grid.collapsed || !me.grid.view.isVisible(true)) 
  {
    return false;
  }
  context = me.getEditingContext(record, columnHeader);
  if (context == null) 
  {
    return false;
  }
  if (!me.preventBeforeCheck) 
  {
    if (me.beforeEdit(context) === false || me.fireEvent('beforeedit', me, context) === false || context.cancel) 
    {
      return false;
    }
  }
  return context;
}, getEditingContext: function(record, columnHeader) {
  var me = this, grid = me.grid, colMgr = grid.columnManager, view, gridRow, rowIdx, colIdx;
  if (Ext.isNumber(columnHeader)) 
  {
    columnHeader = colMgr.getHeaderAtIndex(columnHeader);
  }
  if (!columnHeader) 
  {
    return;
  }
  if (columnHeader.hidden) 
  {
    columnHeader = columnHeader.next(':not([hidden])') || columnHeader.prev(':not([hidden])');
  }
  view = columnHeader.getOwnerHeaderCt().view;
  gridRow = view.getNode(record, true);
  if (!gridRow) 
  {
    return;
  }
  colIdx = colMgr.getHeaderIndex(columnHeader);
  if (Ext.isNumber(record)) 
  {
    rowIdx = record;
    record = view.getRecord(gridRow);
  } else {
    rowIdx = view.indexOf(gridRow);
  }
  if (!record) 
  {
    return;
  }
  return {grid: grid, view: view, store: view.dataSource, record: record, field: columnHeader.dataIndex, value: record.get(columnHeader.dataIndex), row: gridRow, column: columnHeader, rowIdx: rowIdx, colIdx: colIdx};
}, cancelEdit: function() {
  var me = this;
  me.editing = false;
  me.fireEvent('canceledit', me, me.context);
}, completeEdit: function() {
  var me = this;
  if (me.editing && me.validateEdit()) 
  {
    me.fireEvent('edit', me, me.context);
  }
  me.context = null;
  me.editing = false;
}, validateEdit: function() {
  var me = this, context = me.context;
  return me.fireEvent('validateedit', me, context) !== false && !context.cancel;
}}, 1, 0, 0, 0, ["editing.editing"], [['observable', Ext.util.Observable]], [Ext.grid.plugin, 'Editing'], 0));
;

(Ext.cmd.derive('Ext.grid.plugin.CellEditing', Ext.grid.plugin.Editing, {lockableScope: 'both', init: function(grid) {
  var me = this, lockingPartner = me.lockingPartner;
  me.callParent(arguments);
  if (lockingPartner) 
  {
    if (lockingPartner.editors) 
    {
      me.editors = lockingPartner.editors;
    } else {
      me.editors = lockingPartner.editors = new Ext.util.MixedCollection(false, function(editor) {
  return editor.editorId;
});
    }
  } else {
    me.editors = new Ext.util.MixedCollection(false, function(editor) {
  return editor.editorId;
});
  }
}, beforeGridHeaderDestroy: function(headerCt) {
  var me = this, columns = me.grid.getColumnManager().getColumns(), len = columns.length, i, column, editor;
  for (i = 0; i < len; i++) 
    {
      column = columns[i];
      editor = me.editors.getByKey(column.getItemId());
      if (!editor && column.hasEditor && column.hasEditor()) 
      {
        editor = column.getEditor();
      }
      Ext.destroy(editor);
      me.removeFieldAccessors(column);
    }
}, onReconfigure: function(grid, store, columns) {
  if (columns) 
  {
    this.editors.clear();
  }
  this.callParent();
}, destroy: function() {
  var me = this;
  if (me.editors) 
  {
    me.editors.each(Ext.destroy, Ext);
    me.editors.clear();
  }
  me.callParent(arguments);
}, initCancelTriggers: function() {
  var me = this, grid = me.grid, view = grid.view;
  me.mon(grid, {columnresize: me.cancelEdit, columnmove: me.cancelEdit, scope: me});
}, isCellEditable: function(record, columnHeader) {
  var me = this, context = me.getEditingContext(record, columnHeader);
  if (me.grid.view.isVisible(true) && context) 
  {
    columnHeader = context.column;
    record = context.record;
    if (columnHeader && me.getEditor(record, columnHeader)) 
    {
      return true;
    }
  }
}, startEdit: function(record, columnHeader, context) {
  var me = this, isEditorEditing, isFieldEditable, ed;
  if (!context) 
  {
    me.preventBeforeCheck = true;
    context = me.callParent(arguments);
    delete me.preventBeforeCheck;
    if (context === false) 
    {
      return false;
    }
  }
  if (context && me.grid.view.isVisible(true)) 
  {
    record = context.record;
    columnHeader = context.column;
    context.originalValue = context.value = record.get(columnHeader.dataIndex);
    isFieldEditable = (columnHeader && columnHeader.getEditor(record)) && !(me.beforeEdit(context) === false || me.fireEvent('beforeedit', me, context) === false || context.cancel);
    if (isFieldEditable) 
    {
      ed = me.getEditor(record, columnHeader);
      isEditorEditing = ed.editing;
    } else {
      return false;
    }
    me.completeEdit(isEditorEditing);
    me.context = context;
    me.grid.view.cancelFocus();
    me.view.scrollCellIntoView(me.getCell(record, columnHeader));
    if (ed) 
    {
      if (Ext.isIE && isEditorEditing) 
      {
        ed.selectSameEditor = true;
      }
      me.showEditor(ed, context, context.value);
      return true;
    }
    return false;
  }
}, showEditor: function(ed, context, value) {
  var me = this, record = context.record, columnHeader = context.column, sm = me.grid.getSelectionModel(), preventFocus = sm.preventFocus, selection = sm.getCurrentPosition();
  if (!columnHeader.up(me.view.ownerCt)) 
  {
    return me.lockingPartner.showEditor(ed, me.lockingPartner.getEditingContext(selection.record, selection.columnHeader), value);
  }
  me.setEditingContext(context);
  me.setActiveEditor(ed);
  me.setActiveRecord(record);
  me.setActiveColumn(columnHeader);
  if (!selection || !sm.isCellSelected(me.view, record, columnHeader)) 
  {
    sm.preventFocus = true;
    sm.selectByPosition({row: record, column: columnHeader, view: me.view}, true);
    sm.preventFocus = preventFocus;
  }
  if (Ext.isIE && Ext.EventObject.type === 'click') 
  {
    Ext.Function.defer(ed.startEdit, 1, ed, [me.getCell(record, columnHeader), value, context]);
  } else {
    ed.startEdit(me.getCell(record, columnHeader), value, context);
  }
  me.editing = true;
  me.scroll = me.view.el.getScroll();
}, completeEdit: function(remainVisible) {
  var activeEd = this.getActiveEditor();
  if (activeEd) 
  {
    activeEd.completeEdit(remainVisible);
    this.editing = false;
  }
}, setEditingContext: function(context) {
  this.context = context;
  if (this.lockingPartner) 
  {
    this.lockingPartner.context = context;
  }
}, setActiveEditor: function(ed) {
  this.activeEditor = ed;
  if (this.lockingPartner) 
  {
    this.lockingPartner.activeEditor = ed;
  }
}, getActiveEditor: function() {
  return this.activeEditor;
}, setActiveColumn: function(column) {
  this.activeColumn = column;
  if (this.lockingPartner) 
  {
    this.lockingPartner.activeColumn = column;
  }
}, getActiveColumn: function() {
  return this.activeColumn;
}, setActiveRecord: function(record) {
  this.activeRecord = record;
  if (this.lockingPartner) 
  {
    this.lockingPartner.activeRecord = record;
  }
}, getActiveRecord: function() {
  return this.activeRecord;
}, getEditor: function(record, column) {
  var me = this, editors = me.editors, editorId = column.getItemId(), editor = editors.getByKey(editorId), editorOwner = me.grid.ownerLockable || me.grid;
  if (!editor) 
  {
    editor = column.getEditor(record);
    if (!editor) 
    {
      return false;
    }
    if (editor instanceof Ext.grid.CellEditor) 
    {
      editor.floating = true;
    } else {
      editor = new Ext.grid.CellEditor({floating: true, editorId: editorId, field: editor});
    }
    editor.field.excludeForm = true;
    editorOwner.add(editor);
    editor.on({scope: me, specialkey: me.onSpecialKey, complete: me.onEditComplete, canceledit: me.cancelEdit});
    column.on('removed', me.cancelActiveEdit, me);
    editors.add(editor);
  }
  if (column.isTreeColumn) 
  {
    editor.isForTree = column.isTreeColumn;
    editor.addCls(Ext.baseCSSPrefix + 'tree-cell-editor');
  }
  editor.setGrid(me.grid);
  editor.editingPlugin = me;
  return editor;
}, cancelActiveEdit: function(column) {
  var context = this.context;
  if (context && context.column === column) 
  {
    this.cancelEdit();
  }
}, setColumnField: function(column, field) {
  var ed = this.editors.getByKey(column.getItemId());
  Ext.destroy(ed, column.field);
  this.editors.removeAtKey(column.getItemId());
  this.callParent(arguments);
}, getCell: function(record, column) {
  return this.grid.getView().getCell(record, column);
}, onSpecialKey: function(ed, field, e) {
  var sm;
  if (e.getKey() === e.TAB) 
  {
    e.stopEvent();
    if (ed) 
    {
      ed.onEditorTab(e);
    }
    sm = ed.up('tablepanel').getSelectionModel();
    if (sm.onEditorTab) 
    {
      return sm.onEditorTab(ed.editingPlugin, e);
    }
  }
}, onEditComplete: function(ed, value, startValue) {
  var me = this, activeColumn = me.getActiveColumn(), context = me.context, record;
  if (activeColumn) 
  {
    record = context.record;
    me.setActiveEditor(null);
    me.setActiveColumn(null);
    me.setActiveRecord(null);
    context.value = value;
    if (!me.validateEdit()) 
    {
      me.editing = false;
      return;
    }
    if (!record.isEqual(value, startValue)) 
    {
      record.set(activeColumn.dataIndex, value);
    }
    context.view.focusRow(context.rowIdx, 100);
    me.fireEvent('edit', me, context);
    me.editing = false;
  }
}, cancelEdit: function() {
  var me = this, context = me.context, activeEd = me.getActiveEditor();
  me.setActiveEditor(null);
  me.setActiveColumn(null);
  me.setActiveRecord(null);
  if (activeEd) 
  {
    if (activeEd.field) 
    {
      me.context.value = ('editedValue' in activeEd) ? activeEd.editedValue : activeEd.getValue();
      activeEd.cancelEdit();
    }
    context.view.focusRow(context.rowIdx, 100);
    me.callParent(arguments);
    return;
  }
  return true;
}, startEditByPosition: function(position) {
  var cm = this.grid.getColumnManager(), index, col;
  if (!position.isCellContext) 
  {
    position = new Ext.grid.CellContext(this.view).setPosition(position);
  }
  index = cm.getHeaderIndex(position.columnHeader);
  position.setColumn(cm.getVisibleHeaderClosestToIndex(index));
  return this.startEdit(position.record, position.columnHeader);
}}, 0, 0, 0, 0, ["plugin.cellediting"], 0, [Ext.grid.plugin, 'CellEditing'], 0));
;

(Ext.cmd.derive('Ext.grid.plugin.DragDrop', Ext.AbstractPlugin, {dragText: '{0} selected row{1}', ddGroup: "GridDD", enableDrop: true, enableDrag: true, containerScroll: false, init: function(view) {
  view.on('render', this.onViewRender, this, {single: true});
}, destroy: function() {
  Ext.destroy(this.dragZone, this.dropZone);
}, enable: function() {
  var me = this;
  if (me.dragZone) 
  {
    me.dragZone.unlock();
  }
  if (me.dropZone) 
  {
    me.dropZone.unlock();
  }
  me.callParent();
}, disable: function() {
  var me = this;
  if (me.dragZone) 
  {
    me.dragZone.lock();
  }
  if (me.dropZone) 
  {
    me.dropZone.lock();
  }
  me.callParent();
}, onViewRender: function(view) {
  var me = this, scrollEl;
  if (me.enableDrag) 
  {
    if (me.containerScroll) 
    {
      scrollEl = view.getEl();
    }
    me.dragZone = new Ext.view.DragZone(Ext.apply({view: view, ddGroup: me.dragGroup || me.ddGroup, dragText: me.dragText, containerScroll: me.containerScroll, scrollEl: scrollEl}, me.dragZone));
  }
  if (me.enableDrop) 
  {
    me.dropZone = new Ext.grid.ViewDropZone(Ext.apply({view: view, ddGroup: me.dropGroup || me.ddGroup}, me.dropZone));
  }
}}, 0, 0, 0, 0, ["plugin.gridviewdragdrop"], 0, [Ext.grid.plugin, 'DragDrop'], 0));
;

(Ext.cmd.derive('Ext.resizer.Splitter', Ext.Component, {childEls: ['collapseEl'], renderTpl: ['<tpl if="collapsible===true">', '<div id="{id}-collapseEl" role="presentation" class="', Ext.baseCSSPrefix, 'collapse-el ', Ext.baseCSSPrefix, 'layout-split-{collapseDir}{childElCls}">&#160;', '</div>', '</tpl>'], baseCls: Ext.baseCSSPrefix + 'splitter', collapsedClsInternal: Ext.baseCSSPrefix + 'splitter-collapsed', canResize: true, collapsible: false, collapseOnDblClick: true, defaultSplitMin: 40, defaultSplitMax: 1000, collapseTarget: 'next', horizontal: false, vertical: false, size: 5, tracker: null, ariaRole: 'separator', getTrackerConfig: function() {
  return Ext.apply({xclass: 'Ext.resizer.SplitterTracker', el: this.el, splitter: this}, this.tracker);
}, beforeRender: function() {
  var me = this, target = me.getCollapseTarget();
  me.callParent();
  if (target.collapsed) 
  {
    me.addCls(me.collapsedClsInternal);
  }
  if (!me.canResize) 
  {
    me.addCls(me.baseCls + '-noresize');
  }
  Ext.applyIf(me.renderData, {collapseDir: me.getCollapseDirection(), collapsible: me.collapsible || target.collapsible});
  me.protoEl.unselectable();
}, onRender: function() {
  var me = this, collapseEl, cfg;
  me.callParent(arguments);
  if (me.performCollapse !== false) 
  {
    if (me.renderData.collapsible) 
    {
      me.mon(me.collapseEl, 'click', me.toggleTargetCmp, me);
    }
    if (me.collapseOnDblClick) 
    {
      me.mon(me.el, 'dblclick', me.toggleTargetCmp, me);
    }
  }
  me.mon(me.getCollapseTarget(), {collapse: me.onTargetCollapse, expand: me.onTargetExpand, beforeexpand: me.onBeforeTargetExpand, beforecollapse: me.onBeforeTargetCollapse, scope: me});
  if (me.canResize) 
  {
    me.tracker = Ext.create(me.getTrackerConfig());
    me.relayEvents(me.tracker, ['beforedragstart', 'dragstart', 'dragend']);
  }
  collapseEl = me.collapseEl;
  if (collapseEl) 
  {
    collapseEl.lastCollapseDirCls = me.collapseDirProps[me.collapseDirection].cls;
  }
}, getCollapseDirection: function() {
  var me = this, dir = me.collapseDirection, collapseTarget, idx, items, type;
  if (!dir) 
  {
    collapseTarget = me.collapseTarget;
    if (collapseTarget.isComponent) 
    {
      dir = collapseTarget.collapseDirection;
    }
    if (!dir) 
    {
      type = me.ownerCt.layout.type;
      if (collapseTarget.isComponent) 
      {
        items = me.ownerCt.items;
        idx = Number(items.indexOf(collapseTarget) === items.indexOf(me) - 1) << 1 | Number(type === 'hbox');
      } else {
        idx = Number(me.collapseTarget === 'prev') << 1 | Number(type === 'hbox');
      }
      dir = ['bottom', 'right', 'top', 'left'][idx];
    }
    me.collapseDirection = dir;
  }
  me.setOrientation((dir === 'top' || dir === 'bottom') ? 'horizontal' : 'vertical');
  return dir;
}, getCollapseTarget: function() {
  var me = this;
  return me.collapseTarget.isComponent ? me.collapseTarget : me.collapseTarget === 'prev' ? me.previousSibling() : me.nextSibling();
}, setCollapseEl: function(display) {
  var el = this.collapseEl;
  if (el) 
  {
    el.setDisplayed(display);
  }
}, onBeforeTargetExpand: function(target) {
  this.setCollapseEl('none');
}, onBeforeTargetCollapse: function() {
  this.setCollapseEl('none');
}, onTargetCollapse: function(target) {
  this.el.addCls([this.collapsedClsInternal, this.collapsedCls]);
  this.setCollapseEl('');
}, onTargetExpand: function(target) {
  this.el.removeCls([this.collapsedClsInternal, this.collapsedCls]);
  this.setCollapseEl('');
}, collapseDirProps: {top: {cls: Ext.baseCSSPrefix + 'layout-split-top'}, right: {cls: Ext.baseCSSPrefix + 'layout-split-right'}, bottom: {cls: Ext.baseCSSPrefix + 'layout-split-bottom'}, left: {cls: Ext.baseCSSPrefix + 'layout-split-left'}}, orientationProps: {horizontal: {opposite: 'vertical', fixedAxis: 'height', stretchedAxis: 'width'}, vertical: {opposite: 'horizontal', fixedAxis: 'width', stretchedAxis: 'height'}}, applyCollapseDirection: function() {
  var me = this, collapseEl = me.collapseEl, collapseDirProps = me.collapseDirProps[me.collapseDirection], cls;
  if (collapseEl) 
  {
    cls = collapseEl.lastCollapseDirCls;
    if (cls) 
    {
      collapseEl.removeCls(cls);
    }
    collapseEl.addCls(collapseEl.lastCollapseDirCls = collapseDirProps.cls);
  }
}, applyOrientation: function() {
  var me = this, orientation = me.orientation, orientationProps = me.orientationProps[orientation], defaultSize = me.size, fixedSizeProp = orientationProps.fixedAxis, stretchSizeProp = orientationProps.stretchedAxis, cls = me.baseCls + '-';
  me[orientation] = true;
  me[orientationProps.opposite] = false;
  if (!me.hasOwnProperty(fixedSizeProp) || me[fixedSizeProp] === '100%') 
  {
    me[fixedSizeProp] = defaultSize;
  }
  if (!me.hasOwnProperty(stretchSizeProp) || me[stretchSizeProp] === defaultSize) 
  {
    me[stretchSizeProp] = '100%';
  }
  me.removeCls(cls + orientationProps.opposite);
  me.addCls(cls + orientation);
}, setOrientation: function(orientation) {
  var me = this;
  if (me.orientation !== orientation) 
  {
    me.orientation = orientation;
    me.applyOrientation();
  }
}, updateOrientation: function() {
  delete this.collapseDirection;
  this.getCollapseDirection();
  this.applyCollapseDirection();
}, toggleTargetCmp: function(e, t) {
  var cmp = this.getCollapseTarget(), placeholder = cmp.placeholder, toggle;
  if (Ext.isFunction(cmp.expand) && Ext.isFunction(cmp.collapse)) 
  {
    if (placeholder && !placeholder.hidden) 
    {
      toggle = true;
    } else {
      toggle = !cmp.hidden;
    }
    if (toggle) 
    {
      if (cmp.collapsed) 
      {
        cmp.expand();
      } else if (cmp.collapseDirection) 
      {
        cmp.collapse();
      } else {
        cmp.collapse(this.renderData.collapseDir);
      }
    }
  }
}, setSize: function() {
  var me = this;
  me.callParent(arguments);
  if (Ext.isIE && me.el) 
  {
    me.el.repaint();
  }
}, beforeDestroy: function() {
  Ext.destroy(this.tracker);
  this.callParent();
}}, 0, ["splitter"], ["component", "box", "splitter"], {"component": true, "box": true, "splitter": true}, ["widget.splitter"], 0, [Ext.resizer, 'Splitter'], 0));
;

(Ext.cmd.derive('Ext.resizer.BorderSplitter', Ext.resizer.Splitter, {collapseTarget: null, getTrackerConfig: function() {
  var trackerConfig = this.callParent();
  trackerConfig.xclass = 'Ext.resizer.BorderSplitterTracker';
  return trackerConfig;
}}, 0, ["bordersplitter"], ["component", "bordersplitter", "box", "splitter"], {"component": true, "bordersplitter": true, "box": true, "splitter": true}, ["widget.bordersplitter"], 0, [Ext.resizer, 'BorderSplitter'], 0));
;

(Ext.cmd.derive('Ext.layout.container.Border', Ext.layout.container.Container, {alternateClassName: 'Ext.layout.BorderLayout', targetCls: Ext.baseCSSPrefix + 'border-layout-ct', itemCls: [Ext.baseCSSPrefix + 'border-item', Ext.baseCSSPrefix + 'box-item'], type: 'border', isBorderLayout: true, padding: undefined, percentageRe: /(\d+)%/, horzPositionProp: 'left', padOnContainerProp: 'left', padNotOnContainerProp: 'right', axisProps: {horz: {borderBegin: 'west', borderEnd: 'east', horizontal: true, posProp: 'x', sizeProp: 'width', sizePropCap: 'Width'}, vert: {borderBegin: 'north', borderEnd: 'south', horizontal: false, posProp: 'y', sizeProp: 'height', sizePropCap: 'Height'}}, centerRegion: null, manageMargins: true, panelCollapseAnimate: true, panelCollapseMode: 'placeholder', regionWeights: {north: 20, south: 10, center: 0, west: -10, east: -20}, beginAxis: function(ownerContext, regions, name) {
  var me = this, props = me.axisProps[name], isVert = !props.horizontal, sizeProp = props.sizeProp, totalFlex = 0, childItems = ownerContext.childItems, length = childItems.length, center, i, childContext, centerFlex, comp, region, match, size, type, target, placeholder;
  for (i = 0; i < length; ++i) 
    {
      childContext = childItems[i];
      comp = childContext.target;
      childContext.layoutPos = {};
      if (comp.region) 
      {
        childContext.region = region = comp.region;
        childContext.isCenter = comp.isCenter;
        childContext.isHorz = comp.isHorz;
        childContext.isVert = comp.isVert;
        childContext.weight = comp.weight || me.regionWeights[region] || 0;
        regions[comp.id] = childContext;
        if (comp.isCenter) 
        {
          center = childContext;
          centerFlex = comp.flex;
          ownerContext.centerRegion = center;
          continue;
        }
        if (isVert !== childContext.isVert) 
        {
          continue;
        }
        childContext.reverseWeighting = (region == props.borderEnd);
        size = comp[sizeProp];
        type = typeof size;
        if (!comp.collapsed) 
        {
          if (type == 'string' && (match = me.percentageRe.exec(size))) 
          {
            childContext.percentage = parseInt(match[1], 10);
          } else if (comp.flex) 
          {
            totalFlex += childContext.flex = comp.flex;
          }
        }
      }
    }
  if (center) 
  {
    target = center.target;
    if ((placeholder = target.placeholderFor)) 
    {
      if (!centerFlex && isVert === placeholder.collapsedVertical()) 
      {
        centerFlex = 0;
        center.collapseAxis = name;
      }
    } else if (target.collapsed && (isVert === target.collapsedVertical())) 
    {
      centerFlex = 0;
      center.collapseAxis = name;
    }
  }
  if (centerFlex == null) 
  {
    centerFlex = 1;
  }
  totalFlex += centerFlex;
  return Ext.apply({before: isVert ? 'top' : 'left', totalFlex: totalFlex}, props);
}, beginLayout: function(ownerContext) {
  var me = this, items = me.getLayoutItems(), pad = me.padding, type = typeof pad, padOnContainer = false, childContext, item, length, i, regions, collapseTarget, doShow, hidden, region;
  if (pad) 
  {
    if (type == 'string' || type == 'number') 
    {
      pad = Ext.util.Format.parseBox(pad);
    }
  } else {
    pad = ownerContext.getEl('getTargetEl').getPaddingInfo();
    padOnContainer = true;
  }
  ownerContext.outerPad = pad;
  ownerContext.padOnContainer = padOnContainer;
  for (i = 0 , length = items.length; i < length; ++i) 
    {
      item = items[i];
      collapseTarget = me.getSplitterTarget(item);
      if (collapseTarget) 
      {
        doShow = undefined;
        hidden = !!item.hidden;
        if (!collapseTarget.split) 
        {
          if (collapseTarget.isCollapsingOrExpanding) 
          {
            doShow = !!collapseTarget.collapsed;
          }
        } else if (hidden !== collapseTarget.hidden) 
        {
          doShow = !collapseTarget.hidden;
        }
        if (doShow) 
        {
          item.show();
        } else if (doShow === false) 
        {
          item.hide();
        }
      }
    }
  me.callParent(arguments);
  items = ownerContext.childItems;
  length = items.length;
  regions = {};
  ownerContext.borderAxisHorz = me.beginAxis(ownerContext, regions, 'horz');
  ownerContext.borderAxisVert = me.beginAxis(ownerContext, regions, 'vert');
  for (i = 0; i < length; ++i) 
    {
      childContext = items[i];
      collapseTarget = me.getSplitterTarget(childContext.target);
      if (collapseTarget) 
      {
        region = regions[collapseTarget.id];
        if (!region) 
        {
          region = ownerContext.getEl(collapseTarget.el, me);
          region.region = collapseTarget.region;
        }
        childContext.collapseTarget = collapseTarget = region;
        childContext.weight = collapseTarget.weight;
        childContext.reverseWeighting = collapseTarget.reverseWeighting;
        collapseTarget.splitter = childContext;
        childContext.isHorz = collapseTarget.isHorz;
        childContext.isVert = collapseTarget.isVert;
      }
    }
  me.sortWeightedItems(items, 'reverseWeighting');
  me.setupSplitterNeighbors(items);
}, calculate: function(ownerContext) {
  var me = this, containerSize = me.getContainerSize(ownerContext), childItems = ownerContext.childItems, length = childItems.length, horz = ownerContext.borderAxisHorz, vert = ownerContext.borderAxisVert, pad = ownerContext.outerPad, padOnContainer = ownerContext.padOnContainer, i, childContext, childMargins, size, horzPercentTotal, vertPercentTotal;
  horz.begin = pad[me.padOnContainerProp];
  vert.begin = pad.top;
  horzPercentTotal = horz.end = horz.flexSpace = containerSize.width + (padOnContainer ? pad[me.padOnContainerProp] : -pad[me.padNotOnContainerProp]);
  vertPercentTotal = vert.end = vert.flexSpace = containerSize.height + (padOnContainer ? pad.top : -pad.bottom);
  for (i = 0; i < length; ++i) 
    {
      childContext = childItems[i];
      childMargins = childContext.getMarginInfo();
      if (childContext.isHorz || childContext.isCenter) 
      {
        horz.addUnflexed(childMargins.width);
        horzPercentTotal -= childMargins.width;
      }
      if (childContext.isVert || childContext.isCenter) 
      {
        vert.addUnflexed(childMargins.height);
        vertPercentTotal -= childMargins.height;
      }
      if (!childContext.flex && !childContext.percentage) 
      {
        if (childContext.isHorz || (childContext.isCenter && childContext.collapseAxis === 'horz')) 
        {
          size = childContext.getProp('width');
          horz.addUnflexed(size);
          if (childContext.collapseTarget) 
          {
            horzPercentTotal -= size;
          }
        } else if (childContext.isVert || (childContext.isCenter && childContext.collapseAxis === 'vert')) 
        {
          size = childContext.getProp('height');
          vert.addUnflexed(size);
          if (childContext.collapseTarget) 
          {
            vertPercentTotal -= size;
          }
        }
      }
    }
  for (i = 0; i < length; ++i) 
    {
      childContext = childItems[i];
      childMargins = childContext.getMarginInfo();
      if (childContext.percentage) 
      {
        if (childContext.isHorz) 
        {
          size = Math.ceil(horzPercentTotal * childContext.percentage / 100);
          size = childContext.setWidth(size);
          horz.addUnflexed(size);
        } else if (childContext.isVert) 
        {
          size = Math.ceil(vertPercentTotal * childContext.percentage / 100);
          size = childContext.setHeight(size);
          vert.addUnflexed(size);
        }
      }
    }
  for (i = 0; i < length; ++i) 
    {
      childContext = childItems[i];
      if (!childContext.isCenter) 
      {
        me.calculateChildAxis(childContext, horz);
        me.calculateChildAxis(childContext, vert);
      }
    }
  if (me.finishAxis(ownerContext, vert) + me.finishAxis(ownerContext, horz) < 2) 
  {
    me.done = false;
  } else {
    me.finishPositions(childItems);
  }
}, calculateChildAxis: function(childContext, axis) {
  var collapseTarget = childContext.collapseTarget, setSizeMethod = 'set' + axis.sizePropCap, sizeProp = axis.sizeProp, childMarginSize = childContext.getMarginInfo()[sizeProp], region, isBegin, flex, pos, size;
  if (collapseTarget) 
  {
    region = collapseTarget.region;
  } else {
    region = childContext.region;
    flex = childContext.flex;
  }
  isBegin = region == axis.borderBegin;
  if (!isBegin && region != axis.borderEnd) 
  {
    childContext[setSizeMethod](axis.end - axis.begin - childMarginSize);
    pos = axis.begin;
  } else {
    if (flex) 
    {
      size = Math.ceil(axis.flexSpace * (flex / axis.totalFlex));
      size = childContext[setSizeMethod](size);
    } else if (childContext.percentage) 
    {
      size = childContext.peek(sizeProp);
    } else {
      size = childContext.getProp(sizeProp);
    }
    size += childMarginSize;
    if (isBegin) 
    {
      pos = axis.begin;
      axis.begin += size;
    } else {
      axis.end = pos = axis.end - size;
    }
  }
  childContext.layoutPos[axis.posProp] = pos;
}, finishAxis: function(ownerContext, axis) {
  var size = axis.end - axis.begin, center = ownerContext.centerRegion;
  if (center) 
  {
    center['set' + axis.sizePropCap](size - center.getMarginInfo()[axis.sizeProp]);
    center.layoutPos[axis.posProp] = axis.begin;
  }
  return Ext.isNumber(size) ? 1 : 0;
}, finishPositions: function(childItems) {
  var length = childItems.length, index, childContext, marginProp = this.horzPositionProp;
  for (index = 0; index < length; ++index) 
    {
      childContext = childItems[index];
      childContext.setProp('x', childContext.layoutPos.x + childContext.marginInfo[marginProp]);
      childContext.setProp('y', childContext.layoutPos.y + childContext.marginInfo.top);
    }
}, getLayoutItems: function() {
  var owner = this.owner, ownerItems = (owner && owner.items && owner.items.items) || [], length = ownerItems.length, items = [], i = 0, ownerItem, placeholderFor;
  for (; i < length; i++) 
    {
      ownerItem = ownerItems[i];
      placeholderFor = ownerItem.placeholderFor;
      if (ownerItem.hidden || ((!ownerItem.floated || ownerItem.isCollapsingOrExpanding === 2) && !(placeholderFor && placeholderFor.isCollapsingOrExpanding === 2))) 
      {
        items.push(ownerItem);
      }
    }
  return items;
}, getPlaceholder: function(comp) {
  return comp.getPlaceholder && comp.getPlaceholder();
}, getSplitterTarget: function(splitter) {
  var collapseTarget = splitter.collapseTarget;
  if (collapseTarget && collapseTarget.collapsed) 
  {
    return collapseTarget.placeholder || collapseTarget;
  }
  return collapseTarget;
}, isItemBoxParent: function(itemContext) {
  return true;
}, isItemShrinkWrap: function(item) {
  return true;
}, insertSplitter: function(item, index, hidden, splitterCfg) {
  var region = item.region, splitter = Ext.apply({xtype: 'bordersplitter', collapseTarget: item, id: item.id + '-splitter', hidden: hidden, canResize: item.splitterResize !== false, splitterFor: item}, splitterCfg), at = index + ((region === 'south' || region === 'east') ? 0 : 1);
  if (item.collapseMode === 'mini') 
  {
    splitter.collapsedCls = item.collapsedCls;
  }
  item.splitter = this.owner.add(at, splitter);
}, onAdd: function(item, index) {
  var me = this, placeholderFor = item.placeholderFor, region = item.region, isCenter, split, hidden, cfg;
  me.callParent(arguments);
  if (region) 
  {
    Ext.apply(item, me.regionFlags[region]);
    if (item.initBorderRegion) 
    {
      item.initBorderRegion();
    }
    isCenter = region === 'center';
    if (isCenter) 
    {
      me.centerRegion = item;
    } else {
      split = item.split;
      hidden = !!item.hidden;
      if (typeof split === 'object') 
      {
        cfg = split;
        split = true;
      }
      if ((item.isHorz || item.isVert) && (split || item.collapseMode == 'mini')) 
      {
        me.insertSplitter(item, index, hidden || !split, cfg);
      }
    }
    if (!isCenter && !item.hasOwnProperty('collapseMode')) 
    {
      item.collapseMode = me.panelCollapseMode;
    }
    if (!item.hasOwnProperty('animCollapse')) 
    {
      if (item.collapseMode !== 'placeholder') 
      {
        item.animCollapse = false;
      } else {
        item.animCollapse = me.panelCollapseAnimate;
      }
    }
  } else if (placeholderFor) 
  {
    Ext.apply(item, me.regionFlags[placeholderFor.region]);
    item.region = placeholderFor.region;
    item.weight = placeholderFor.weight;
  }
}, onDestroy: function() {
  this.centerRegion = null;
  this.callParent();
}, onRemove: function(comp, isDestroying) {
  var me = this, region = comp.region, splitter = comp.splitter, owner = me.owner, destroying = owner.destroying, el;
  if (region) 
  {
    if (comp.isCenter) 
    {
      me.centerRegion = null;
    }
    delete comp.isCenter;
    delete comp.isHorz;
    delete comp.isVert;
    if (splitter && !owner.destroying) 
    {
      owner.doRemove(splitter, true);
    }
    delete comp.splitter;
  }
  me.callParent(arguments);
  if (!destroying && !isDestroying && comp.rendered) 
  {
    el = comp.getEl();
    el.setStyle('top', '');
    el.setStyle(me.horzPositionProp, '');
  }
}, regionMeta: {center: {splitterDelta: 0}, north: {splitterDelta: 1}, south: {splitterDelta: -1}, west: {splitterDelta: 1}, east: {splitterDelta: -1}}, regionFlags: {center: {isCenter: true, isHorz: false, isVert: false}, north: {isCenter: false, isHorz: false, isVert: true, collapseDirection: 'top'}, south: {isCenter: false, isHorz: false, isVert: true, collapseDirection: 'bottom'}, west: {isCenter: false, isHorz: true, isVert: false, collapseDirection: 'left'}, east: {isCenter: false, isHorz: true, isVert: false, collapseDirection: 'right'}}, setupSplitterNeighbors: function(items) {
  var edgeRegions = {}, length = items.length, touchedRegions = this.touchedRegions, i, j, center, count, edge, comp, region, splitter, touched;
  for (i = 0; i < length; ++i) 
    {
      comp = items[i].target;
      region = comp.region;
      if (comp.isCenter) 
      {
        center = comp;
      } else if (region) 
      {
        touched = touchedRegions[region];
        for (j = 0 , count = touched.length; j < count; ++j) 
          {
            edge = edgeRegions[touched[j]];
            if (edge) 
            {
              edge.neighbors.push(comp);
            }
          }
        if (comp.placeholderFor) 
        {
          splitter = comp.placeholderFor.splitter;
        } else {
          splitter = comp.splitter;
        }
        if (splitter) 
        {
          splitter.neighbors = [];
        }
        edgeRegions[region] = splitter;
      }
    }
  if (center) 
  {
    touched = touchedRegions.center;
    for (j = 0 , count = touched.length; j < count; ++j) 
      {
        edge = edgeRegions[touched[j]];
        if (edge) 
        {
          edge.neighbors.push(center);
        }
      }
  }
}, touchedRegions: {center: ['north', 'south', 'east', 'west'], north: ['north', 'east', 'west'], south: ['south', 'east', 'west'], east: ['east', 'north', 'south'], west: ['west', 'north', 'south']}, sizePolicies: {vert: {readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0}, horz: {readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1}, flexAll: {readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1}}, getItemSizePolicy: function(item) {
  var me = this, policies = this.sizePolicies, collapseTarget, size, policy, placeholderFor;
  if (item.isCenter) 
  {
    placeholderFor = item.placeholderFor;
    if (placeholderFor) 
    {
      if (placeholderFor.collapsedVertical()) 
      {
        return policies.vert;
      }
      return policies.horz;
    }
    if (item.collapsed) 
    {
      if (item.collapsedVertical()) 
      {
        return policies.vert;
      }
      return policies.horz;
    }
    return policies.flexAll;
  }
  collapseTarget = item.collapseTarget;
  if (collapseTarget) 
  {
    return collapseTarget.isVert ? policies.vert : policies.horz;
  }
  if (item.region) 
  {
    if (item.isVert) 
    {
      size = item.height;
      policy = policies.vert;
    } else {
      size = item.width;
      policy = policies.horz;
    }
    if (item.flex || (typeof size == 'string' && me.percentageRe.test(size))) 
    {
      return policies.flexAll;
    }
    return policy;
  }
  return me.autoSizePolicy;
}}, 0, 0, 0, 0, ["layout.border"], 0, [Ext.layout.container, 'Border', Ext.layout, 'BorderLayout'], function() {
  var methods = {addUnflexed: function(px) {
  this.flexSpace = Math.max(this.flexSpace - px, 0);
}}, props = this.prototype.axisProps;
  Ext.apply(props.horz, methods);
  Ext.apply(props.vert, methods);
}));
;

(Ext.cmd.derive('Ext.menu.Item', Ext.Component, {alternateClassName: 'Ext.menu.TextItem', isMenuItem: true, activeCls: Ext.baseCSSPrefix + 'menu-item-active', ariaRole: 'menuitem', canActivate: true, clickHideDelay: 0, destroyMenu: true, disabledCls: Ext.baseCSSPrefix + 'menu-item-disabled', hideOnClick: true, menuAlign: 'tl-tr?', menuExpandDelay: 200, menuHideDelay: 200, tooltipType: 'qtip', arrowCls: Ext.baseCSSPrefix + 'menu-item-arrow', baseIconCls: Ext.baseCSSPrefix + 'menu-item-icon', textCls: Ext.baseCSSPrefix + 'menu-item-text', indentCls: Ext.baseCSSPrefix + 'menu-item-indent', indentNoSeparatorCls: Ext.baseCSSPrefix + 'menu-item-indent-no-separator', indentRightIconCls: Ext.baseCSSPrefix + 'menu-item-indent-right-icon', indentRightArrowCls: Ext.baseCSSPrefix + 'menu-item-indent-right-arrow', linkCls: Ext.baseCSSPrefix + 'menu-item-link', childEls: ['itemEl', 'iconEl', 'textEl', 'arrowEl'], renderTpl: ['<tpl if="plain">', '{text}', '<tpl else>', '<a id="{id}-itemEl"', ' class="{linkCls} {childElCls}"', ' href="{href}" role="presentation" ', '<tpl if="hrefTarget"> target="{hrefTarget}"</tpl>', ' hidefocus="true"', ' unselectable="on"', '<tpl if="tabIndex">', ' tabIndex="{tabIndex}"', '</tpl>', '>', '<span id="{id}-textEl" class="{textCls} {indentCls}{childElCls}" unselectable="on">{text}</span>', '<tpl if="hasIcon">', '<div role="presentation" id="{id}-iconEl" class="{baseIconCls}', '{[values.rightIcon ? "-right" : ""]} {iconCls}', '{childElCls} {glyphCls}" style="<tpl if="icon">background-image:url({icon});</tpl>', '<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">', '<tpl if="glyph">&#{glyph};</tpl>', '</div>', '</tpl>', '<tpl if="showCheckbox">', '<div role="presentation" id="{id}-checkEl" class="{baseIconCls}', '{[(values.hasIcon && !values.rightIcon) ? "-right" : ""]} ', '{groupCls} {checkboxCls}{childElCls}">', '</div>', '</tpl>', '<tpl if="hasMenu">', '<div role="presentation" id="{id}-arrowEl" class="{arrowCls}{childElCls}"></div>', '</tpl>', '</a>', '</tpl>'], maskOnDisable: false, iconAlign: 'left', activate: function(skipCheck) {
  var me = this;
  if (skipCheck || (!me.activated && me.canActivate && me.rendered && !me.isDisabled() && me.isVisible())) 
  {
    if (!me.plain) 
    {
      me.el.addCls(me.activeCls);
    }
    me.focus(false, true);
    me.activated = true;
    if (me.hasListeners.activate) 
    {
      me.fireEvent('activate', me);
    }
  }
}, getFocusEl: function() {
  return this.itemEl;
}, deactivate: function() {
  var me = this, parent;
  if (me.activated) 
  {
    parent = me.up('');
    if (!me.plain) 
    {
      me.el.removeCls(me.activeCls);
    }
    if (parent) 
    {
      parent.focus(false, true);
    }
    me.hideMenu();
    me.activated = false;
    if (me.hasListeners.deactivate) 
    {
      me.fireEvent('deactivate', me);
    }
  }
}, deferHideMenu: function() {
  if (this.menu.isVisible()) 
  {
    this.menu.hide();
  }
}, cancelDeferHide: function() {
  clearTimeout(this.hideMenuTimer);
}, deferHideParentMenus: function() {
  var ancestor;
  Ext.menu.Manager.hideAll();
  if (!Ext.Element.getActiveElement()) 
  {
    ancestor = this.up(':not([hidden])');
    if (ancestor) 
    {
      ancestor.focus();
    }
  }
}, expandMenu: function(delay) {
  var me = this;
  if (me.menu) 
  {
    me.cancelDeferHide();
    if (delay === 0) 
    {
      me.doExpandMenu();
    } else {
      clearTimeout(me.expandMenuTimer);
      me.expandMenuTimer = Ext.defer(me.doExpandMenu, Ext.isNumber(delay) ? delay : me.menuExpandDelay, me);
    }
  }
}, doExpandMenu: function() {
  var me = this, menu = me.menu;
  if (me.activated && (!menu.rendered || !menu.isVisible())) 
  {
    me.parentMenu.activeChild = menu;
    menu.ownerCmp = menu.ownerItem = me;
    menu.parentMenu = me.parentMenu;
    menu.constrainTo = document.body;
    menu.showBy(me, me.menuAlign);
  }
}, getRefItems: function(deep) {
  var menu = this.menu, items;
  if (menu) 
  {
    items = menu.getRefItems(deep);
    items.unshift(menu);
  }
  return items || [];
}, hideMenu: function(delay) {
  var me = this;
  if (me.menu) 
  {
    clearTimeout(me.expandMenuTimer);
    me.hideMenuTimer = Ext.defer(me.deferHideMenu, Ext.isNumber(delay) ? delay : me.menuHideDelay, me);
  }
}, initComponent: function() {
  var me = this, prefix = Ext.baseCSSPrefix, cls = [prefix + 'menu-item'], menu;
  me.addEvents('activate', 'click', 'deactivate', 'textchange', 'iconchange');
  if (me.plain) 
  {
    cls.push(prefix + 'menu-item-plain');
  }
  if (me.cls) 
  {
    cls.push(me.cls);
  }
  me.cls = cls.join(' ');
  if (me.menu) 
  {
    menu = me.menu;
    delete me.menu;
    me.setMenu(menu);
  }
  me.callParent(arguments);
}, onClick: function(e) {
  var me = this, clickHideDelay = me.clickHideDelay, browserEvent = e.browserEvent, preventDefault;
  if (!me.href || me.disabled) 
  {
    e.stopEvent();
  }
  if (me.disabled || me.handlingClick) 
  {
    return;
  }
  if (me.hideOnClick) 
  {
    if (!clickHideDelay) 
    {
      me.deferHideParentMenus();
    } else {
      me.deferHideParentMenusTimer = Ext.defer(me.deferHideParentMenus, clickHideDelay, me);
    }
  }
  Ext.callback(me.handler, me.scope || me, [me, e]);
  me.fireEvent('click', me, e);
  if (Ext.isIE9m || Ext.isIEQuirks) 
  {
    preventDefault = (browserEvent.returnValue === false) ? true : false;
  } else {
    preventDefault = !!browserEvent.defaultPrevented;
  }
  if (me.href && !preventDefault) 
  {
    me.handlingClick = true;
    me.itemEl.dom.click();
    delete me.handlingClick;
  }
  if (!me.hideOnClick) 
  {
    me.focus();
  }
}, onRemoved: function() {
  var me = this;
  if (me.activated && me.parentMenu.activeItem === me) 
  {
    me.parentMenu.deactivateActiveItem();
  }
  me.callParent(arguments);
  me.parentMenu = me.ownerCmp = me.ownerButton = null;
}, beforeDestroy: function() {
  var me = this;
  if (me.rendered) 
  {
    me.clearTip();
  }
  me.callParent();
}, onDestroy: function() {
  var me = this;
  clearTimeout(me.expandMenuTimer);
  me.cancelDeferHide();
  clearTimeout(me.deferHideParentMenusTimer);
  me.setMenu(null);
  me.callParent(arguments);
}, beforeRender: function() {
  var me = this, glyph = me.glyph, glyphFontFamily = Ext._glyphFontFamily, hasIcon = !!(me.icon || me.iconCls || glyph), hasMenu = !!me.menu, rightIcon = ((me.iconAlign === 'right') && !hasMenu), isCheckItem = me.isMenuCheckItem, indentCls = [], ownerCt = me.ownerCt, isOwnerPlain = ownerCt.plain, glyphParts;
  me.callParent();
  if (hasIcon) 
  {
    if (hasMenu && me.showCheckbox) 
    {
      hasIcon = false;
    }
  }
  if (typeof glyph === 'string') 
  {
    glyphParts = glyph.split('@');
    glyph = glyphParts[0];
    glyphFontFamily = glyphParts[1];
  }
  if (!isOwnerPlain || (hasIcon && !rightIcon) || isCheckItem) 
  {
    if (ownerCt.showSeparator && !isOwnerPlain) 
    {
      indentCls.push(me.indentCls);
    } else {
      indentCls.push(me.indentNoSeparatorCls);
    }
  }
  if (hasMenu) 
  {
    indentCls.push(me.indentRightArrowCls);
  } else if (hasIcon && (rightIcon || isCheckItem)) 
  {
    indentCls.push(me.indentRightIconCls);
  }
  Ext.applyIf(me.renderData, {href: me.href || '#', hrefTarget: me.hrefTarget, icon: me.icon, iconCls: me.iconCls, glyph: glyph, glyphCls: glyph ? Ext.baseCSSPrefix + 'menu-item-glyph' : undefined, glyphFontFamily: glyphFontFamily, hasIcon: hasIcon, hasMenu: hasMenu, indent: !isOwnerPlain || hasIcon || isCheckItem, isCheckItem: isCheckItem, rightIcon: rightIcon, plain: me.plain, text: me.text, arrowCls: me.arrowCls, baseIconCls: me.baseIconCls, textCls: me.textCls, indentCls: indentCls.join(' '), linkCls: me.linkCls, groupCls: me.group ? me.groupCls : '', tabIndex: me.tabIndex});
}, onRender: function() {
  var me = this;
  me.callParent(arguments);
  if (me.tooltip) 
  {
    me.setTooltip(me.tooltip, true);
  }
}, setMenu: function(menu, destroyMenu) {
  var me = this, oldMenu = me.menu, arrowEl = me.arrowEl;
  if (oldMenu) 
  {
    oldMenu.ownerCmp = oldMenu.ownerItem = oldMenu.parentMenu = null;
    if (destroyMenu === true || (destroyMenu !== false && me.destroyMenu)) 
    {
      Ext.destroy(oldMenu);
    }
  }
  if (menu) 
  {
    me.menu = Ext.menu.Manager.get(menu);
    me.menu.ownerCmp = me.menu.ownerItem = me;
  } else {
    me.menu = null;
  }
  if (me.rendered && !me.destroying && arrowEl) 
  {
    arrowEl[me.menu ? 'addCls' : 'removeCls'](me.arrowCls);
  }
}, setHandler: function(fn, scope) {
  this.handler = fn || null;
  this.scope = scope;
}, setIcon: function(icon) {
  var iconEl = this.iconEl, oldIcon = this.icon;
  if (iconEl) 
  {
    iconEl.src = icon || Ext.BLANK_IMAGE_URL;
  }
  this.icon = icon;
  this.fireEvent('iconchange', this, oldIcon, icon);
}, setIconCls: function(iconCls) {
  var me = this, iconEl = me.iconEl, oldCls = me.iconCls;
  if (iconEl) 
  {
    if (me.iconCls) 
    {
      iconEl.removeCls(me.iconCls);
    }
    if (iconCls) 
    {
      iconEl.addCls(iconCls);
    }
  }
  me.iconCls = iconCls;
  me.fireEvent('iconchange', me, oldCls, iconCls);
}, setText: function(text) {
  var me = this, el = me.textEl || me.el, oldText = me.text;
  me.text = text;
  if (me.rendered) 
  {
    el.update(text || '');
    me.ownerCt.updateLayout();
  }
  me.fireEvent('textchange', me, oldText, text);
}, getTipAttr: function() {
  return this.tooltipType == 'qtip' ? 'data-qtip' : 'title';
}, clearTip: function() {
  if (Ext.quickTipsActive && Ext.isObject(this.tooltip)) 
  {
    Ext.tip.QuickTipManager.unregister(this.itemEl);
  }
}, setTooltip: function(tooltip, initial) {
  var me = this;
  if (me.rendered) 
  {
    if (!initial) 
    {
      me.clearTip();
    }
    if (Ext.quickTipsActive && Ext.isObject(tooltip)) 
    {
      Ext.tip.QuickTipManager.register(Ext.apply({target: me.itemEl.id}, tooltip));
      me.tooltip = tooltip;
    } else {
      me.itemEl.dom.setAttribute(me.getTipAttr(), tooltip);
    }
  } else {
    me.tooltip = tooltip;
  }
  return me;
}}, 0, ["menuitem"], ["component", "box", "menuitem"], {"component": true, "box": true, "menuitem": true}, ["widget.menuitem"], [['queryable', Ext.Queryable]], [Ext.menu, 'Item', Ext.menu, 'TextItem'], 0));
;

(Ext.cmd.derive('Ext.menu.CheckItem', Ext.menu.Item, {checkedCls: Ext.baseCSSPrefix + 'menu-item-checked', uncheckedCls: Ext.baseCSSPrefix + 'menu-item-unchecked', groupCls: Ext.baseCSSPrefix + 'menu-group-icon', hideOnClick: false, checkChangeDisabled: false, ariaRole: 'menuitemcheckbox', childEls: ['itemEl', 'iconEl', 'textEl', 'checkEl'], showCheckbox: true, isMenuCheckItem: true, checkboxCls: Ext.baseCSSPrefix + 'menu-item-checkbox', initComponent: function() {
  var me = this;
  me.checked = !!me.checked;
  me.addEvents('beforecheckchange', 'checkchange');
  me.callParent(arguments);
  Ext.menu.Manager.registerCheckable(me);
  if (me.group) 
  {
    if (me.initialConfig.hideOnClick !== false) 
    {
      me.hideOnClick = true;
    }
  }
}, beforeRender: function() {
  var me = this;
  me.callParent();
  Ext.apply(me.renderData, {checkboxCls: me.checkboxCls, showCheckbox: me.showCheckbox});
}, afterRender: function() {
  var me = this;
  me.callParent();
  me.checked = !me.checked;
  me.setChecked(!me.checked, true);
  if (me.checkChangeDisabled) 
  {
    me.disableCheckChange();
  }
}, disableCheckChange: function() {
  var me = this, checkEl = me.checkEl;
  if (checkEl) 
  {
    checkEl.addCls(me.disabledCls);
  }
  if (!(Ext.isIE10p || (Ext.isIE9 && Ext.isStrict)) && me.rendered) 
  {
    me.el.repaint();
  }
  me.checkChangeDisabled = true;
}, enableCheckChange: function() {
  var me = this, checkEl = me.checkEl;
  if (checkEl) 
  {
    checkEl.removeCls(me.disabledCls);
  }
  me.checkChangeDisabled = false;
}, onClick: function(e) {
  var me = this;
  if (!me.disabled && !me.checkChangeDisabled && !(me.checked && me.group)) 
  {
    me.setChecked(!me.checked);
  }
  this.callParent([e]);
}, onDestroy: function() {
  Ext.menu.Manager.unregisterCheckable(this);
  this.callParent(arguments);
}, setChecked: function(checked, suppressEvents) {
  var me = this, checkedCls = me.checkedCls, uncheckedCls = me.uncheckedCls, el = me.el;
  if (me.checked !== checked && (suppressEvents || me.fireEvent('beforecheckchange', me, checked) !== false)) 
  {
    if (el) 
    {
      if (checked) 
      {
        el.addCls(checkedCls);
        el.removeCls(uncheckedCls);
      } else {
        el.addCls(uncheckedCls);
        el.removeCls(checkedCls);
      }
    }
    me.checked = checked;
    Ext.menu.Manager.onCheckChange(me, checked);
    if (!suppressEvents) 
    {
      Ext.callback(me.checkHandler, me.scope || me, [me, checked]);
      me.fireEvent('checkchange', me, checked);
    }
  }
}}, 0, ["menucheckitem"], ["component", "box", "menucheckitem", "menuitem"], {"component": true, "box": true, "menucheckitem": true, "menuitem": true}, ["widget.menucheckitem"], 0, [Ext.menu, 'CheckItem'], 0));
;

(Ext.cmd.derive('Ext.menu.KeyNav', Ext.util.KeyNav, {constructor: function(config) {
  var me = this;
  me.menu = config.target;
  me.callParent([Ext.apply({down: me.down, enter: me.enter, esc: me.escape, left: me.left, right: me.right, space: me.enter, tab: me.tab, up: me.up}, config)]);
}, down: function(e) {
  var me = this, fi = me.menu.focusedItem;
  if (fi && e.getKey() == Ext.EventObject.DOWN && me.isWhitelisted(fi)) 
  {
    return true;
  }
  me.focusNextItem(1);
}, enter: function(e) {
  var menu = this.menu, focused = menu.focusedItem;
  if (menu.activeItem) 
  {
    menu.onClick(e);
  } else if (focused && focused.isFormField) 
  {
    return true;
  }
}, escape: function(e) {
  Ext.menu.Manager.hideAll();
}, focusNextItem: function(step) {
  var menu = this.menu, items = menu.items, focusedItem = menu.focusedItem, startIdx = focusedItem ? items.indexOf(focusedItem) : -1, idx = startIdx + step, len = items.length, count = 0, item;
  while (count < len && idx !== startIdx) 
    {
      if (idx < 0) 
      {
        idx = len - 1;
      } else if (idx >= len) 
      {
        idx = 0;
      }
      item = items.getAt(idx);
      if (menu.canActivateItem(item)) 
      {
        menu.setActiveItem(item);
        break;
      }
      idx += step;
      ++count;
    }
}, isWhitelisted: function(item) {
  var mgr = Ext['FocusManager'];
  return mgr && mgr.isWhitelisted(item);
}, left: function(e) {
  var menu = this.menu, fi = menu.focusedItem;
  if (fi && this.isWhitelisted(fi)) 
  {
    return true;
  }
  if (menu.parentMenu) 
  {
    menu.hide();
    menu.parentMenu.focus();
  }
}, right: function(e) {
  var menu = this.menu, fi = menu.focusedItem, ai = menu.activeItem, am;
  if (fi && this.isWhitelisted(fi)) 
  {
    return true;
  }
  if (ai) 
  {
    am = menu.activeItem.menu;
    if (am) 
    {
      ai.expandMenu(0);
      am.setActiveItem(am.child(':focusable'));
    }
  }
}, tab: function(e) {
  var me = this;
  if (e.shiftKey) 
  {
    me.up(e);
  } else {
    me.down(e);
  }
}, up: function(e) {
  var me = this, fi = me.menu.focusedItem;
  if (fi && e.getKey() == Ext.EventObject.UP && me.isWhitelisted(fi)) 
  {
    return true;
  }
  me.focusNextItem(-1);
}}, 1, 0, 0, 0, 0, 0, [Ext.menu, 'KeyNav'], 0));
;

(Ext.cmd.derive('Ext.menu.Separator', Ext.menu.Item, {canActivate: false, focusable: false, hideOnClick: false, plain: true, separatorCls: Ext.baseCSSPrefix + 'menu-item-separator', text: '&#160;', ariaRole: 'separator', beforeRender: function(ct, pos) {
  var me = this;
  me.callParent();
  me.addCls(me.separatorCls);
}}, 0, ["menuseparator"], ["component", "menuseparator", "box", "menuitem"], {"component": true, "menuseparator": true, "box": true, "menuitem": true}, ["widget.menuseparator"], 0, [Ext.menu, 'Separator'], 0));
;

(Ext.cmd.derive('Ext.menu.Menu', Ext.panel.Panel, {enableKeyNav: true, allowOtherMenus: false, ariaRole: 'menu', floating: true, constrain: true, hidden: true, hideMode: 'visibility', ignoreParentClicks: false, isMenu: true, showSeparator: true, minWidth: undefined, defaultMinWidth: 120, defaultAlign: 'tl-bl?', initComponent: function() {
  var me = this, prefix = Ext.baseCSSPrefix, cls = [prefix + 'menu'], bodyCls = me.bodyCls ? [me.bodyCls] : [], isFloating = me.floating !== false;
  me.addEvents('click', 'mouseenter', 'mouseleave', 'mouseover');
  Ext.menu.Manager.register(me);
  if (me.plain) 
  {
    cls.push(prefix + 'menu-plain');
  }
  me.cls = cls.join(' ');
  bodyCls.push(prefix + 'menu-body', Ext.dom.Element.unselectableCls);
  me.bodyCls = bodyCls.join(' ');
  if (!me.layout) 
  {
    me.layout = {type: 'vbox', align: 'stretchmax', overflowHandler: 'Scroller'};
  }
  if (isFloating) 
  {
    if (me.minWidth === undefined) 
    {
      me.minWidth = me.defaultMinWidth;
    }
  } else {
    me.hidden = !!me.initialConfig.hidden;
    me.constrain = false;
  }
  me.callParent(arguments);
  Ext.override(me.getLayout(), {configureItem: me.configureItem});
}, initFloatConstrain: Ext.emptyFn, initHierarchyEvents: Ext.emptyFn, getHierarchyState: function() {
  var result = this.callParent();
  result.hidden = this.hidden;
  return result;
}, beforeRender: function() {
  this.callParent(arguments);
  if (!this.getSizeModel().width.shrinkWrap) 
  {
    this.layout.align = 'stretch';
  }
}, onBoxReady: function() {
  var me = this;
  me.callParent(arguments);
  if (me.showSeparator) 
  {
    me.iconSepEl = me.layout.getElementTarget().insertFirst({role: 'presentation', cls: Ext.baseCSSPrefix + 'menu-icon-separator', html: '&#160;'});
  }
  me.mon(me.el, {click: me.onClick, mouseover: me.onMouseOver, scope: me});
  me.mouseMonitor = me.el.monitorMouseLeave(100, me.onMouseLeave, me);
  if (me.enableKeyNav) 
  {
    me.keyNav = new Ext.menu.KeyNav({target: me, keyMap: me.getKeyMap()});
  }
}, canActivateItem: function(item) {
  return item && !item.isDisabled() && item.isVisible() && (item.canActivate || !item.isMenuItem);
}, deactivateActiveItem: function(andBlurFocusedItem) {
  var me = this, activeItem = me.activeItem, focusedItem = me.focusedItem;
  if (activeItem) 
  {
    activeItem.deactivate();
    if (!activeItem.activated) 
    {
      delete me.activeItem;
    }
  }
  if (focusedItem && andBlurFocusedItem) 
  {
    focusedItem.blur();
    delete me.focusedItem;
  }
}, getFocusEl: function() {
  return this.focusedItem || this.items.items[0];
}, hide: function() {
  this.deactivateActiveItem(true);
  this.callParent(arguments);
}, getItemFromEvent: function(e) {
  var me = this, renderTarget = me.layout.getRenderTarget().dom, toEl = e.getTarget();
  while (toEl.parentNode !== renderTarget) 
    {
      toEl = toEl.parentNode;
      if (!toEl) 
      {
        return;
      }
    }
  return Ext.getCmp(toEl.id);
}, lookupComponent: function(cmp) {
  var me = this;
  if (typeof cmp == 'string') 
  {
    cmp = me.lookupItemFromString(cmp);
  } else if (Ext.isObject(cmp)) 
  {
    cmp = me.lookupItemFromObject(cmp);
  }
  cmp.minWidth = cmp.minWidth || me.minWidth;
  return cmp;
}, lookupItemFromObject: function(cmp) {
  var me = this;
  if (!cmp.isComponent) 
  {
    if (!cmp.xtype) 
    {
      cmp = Ext.create('Ext.menu.' + (Ext.isBoolean(cmp.checked) ? 'Check' : '') + 'Item', cmp);
    } else {
      cmp = Ext.ComponentManager.create(cmp, cmp.xtype);
    }
  }
  if (cmp.isMenuItem) 
  {
    cmp.parentMenu = me;
  }
  return cmp;
}, lookupItemFromString: function(cmp) {
  return (cmp == 'separator' || cmp == '-') ? new Ext.menu.Separator() : new Ext.menu.Item({canActivate: false, hideOnClick: false, plain: true, text: cmp});
}, configureItem: function(cmp) {
  var me = this, owner = me.owner, prefix = Ext.baseCSSPrefix, cls;
  if (me.owner.items.getCount() > 1 && !cmp.rendered && !cmp.isMenuItem && !cmp.dock) 
  {
    cls = [prefix + 'menu-item-cmp'];
    if (!owner.plain && (cmp.indent !== false || cmp.iconCls === 'no-icon')) 
    {
      cls.push(prefix + 'menu-item-indent');
    }
    if (cmp.rendered) 
    {
      cmp.el.addCls(cls);
    } else {
      cmp.cls = (cmp.cls || '') + ' ' + cls.join(' ');
    }
  }
  this.callParent(arguments);
}, onClick: function(e) {
  var me = this, item;
  if (me.disabled) 
  {
    e.stopEvent();
    return;
  }
  item = (e.type === 'click') ? me.getItemFromEvent(e) : me.activeItem;
  if (item && item.isMenuItem) 
  {
    if (!item.menu || !me.ignoreParentClicks) 
    {
      item.onClick(e);
    } else {
      e.stopEvent();
    }
  }
  if (!item || item.disabled) 
  {
    item = undefined;
  }
  me.fireEvent('click', me, item, e);
}, onDestroy: function() {
  var me = this;
  Ext.menu.Manager.unregister(me);
  me.parentMenu = me.ownerCmp = me.ownerButton = null;
  if (me.rendered) 
  {
    me.el.un(me.mouseMonitor);
    Ext.destroy(me.keyNav);
    me.keyNav = null;
  }
  me.callParent(arguments);
}, onMouseLeave: function(e) {
  var me = this;
  me.deactivateActiveItem();
  if (me.disabled) 
  {
    return;
  }
  me.fireEvent('mouseleave', me, e);
}, onMouseOver: function(e) {
  var me = this, fromEl = e.getRelatedTarget(), mouseEnter = !me.el.contains(fromEl), item = me.getItemFromEvent(e), parentMenu = me.parentMenu, ownerCmp = me.ownerCmp;
  if (mouseEnter && parentMenu) 
  {
    parentMenu.setActiveItem(ownerCmp);
    ownerCmp.cancelDeferHide();
    parentMenu.mouseMonitor.mouseenter();
  }
  if (me.disabled) 
  {
    return;
  }
  if (item && !item.activated) 
  {
    me.setActiveItem(item);
    if (item.activated && item.expandMenu) 
    {
      item.expandMenu();
    }
  }
  if (mouseEnter) 
  {
    me.fireEvent('mouseenter', me, e);
  }
  me.fireEvent('mouseover', me, item, e);
}, setActiveItem: function(item) {
  var me = this;
  if (item && (item != me.activeItem)) 
  {
    me.deactivateActiveItem();
    if (me.canActivateItem(item)) 
    {
      if (item.activate) 
      {
        item.activate(true);
        if (item.activated) 
        {
          me.activeItem = item;
          me.focusedItem = item;
        }
      } else {
        item.focus();
        me.focusedItem = item;
      }
    }
  }
}, beforeShow: function() {
  var me = this, viewHeight;
  if (me.floating) 
  {
    me.savedMaxHeight = me.maxHeight;
    viewHeight = me.container.getViewSize().height;
    me.maxHeight = Math.min(me.maxHeight || viewHeight, viewHeight);
  }
  me.callParent(arguments);
}, afterShow: function() {
  var me = this;
  me.callParent(arguments);
  if (me.floating) 
  {
    me.maxHeight = me.savedMaxHeight;
  }
}}, 0, ["menu"], ["container", "component", "box", "panel", "menu"], {"container": true, "component": true, "box": true, "panel": true, "menu": true}, ["widget.menu"], 0, [Ext.menu, 'Menu'], 0));
;

(Ext.cmd.derive('Ext.panel.Tool', Ext.Component, {isTool: true, baseCls: Ext.baseCSSPrefix + 'tool', disabledCls: Ext.baseCSSPrefix + 'tool-disabled', toolPressedCls: Ext.baseCSSPrefix + 'tool-pressed', toolOverCls: Ext.baseCSSPrefix + 'tool-over', ariaRole: 'button', childEls: ['toolEl'], renderTpl: ['<img id="{id}-toolEl" src="{blank}" class="{baseCls}-img {baseCls}-{type}' + '{childElCls}" role="presentation"/>'], toolOwner: null, tooltipType: 'qtip', stopEvent: true, height: 15, width: 15, initComponent: function() {
  var me = this;
  me.addEvents('click');
  me.type = me.type || me.id;
  Ext.applyIf(me.renderData, {baseCls: me.baseCls, blank: Ext.BLANK_IMAGE_URL, type: me.type});
  me.tooltip = me.tooltip || me.qtip;
  me.callParent();
}, afterRender: function() {
  var me = this, attr;
  me.callParent(arguments);
  me.el.on({click: me.onClick, mousedown: me.onMouseDown, mouseover: me.onMouseOver, mouseout: me.onMouseOut, scope: me});
  if (me.tooltip) 
  {
    if (Ext.quickTipsActive && Ext.isObject(me.tooltip)) 
    {
      Ext.tip.QuickTipManager.register(Ext.apply({target: me.id}, me.tooltip));
    } else {
      attr = me.tooltipType == 'qtip' ? 'data-qtip' : 'title';
      me.el.dom.setAttribute(attr, me.tooltip);
    }
  }
}, getFocusEl: function() {
  return this.el;
}, setType: function(type) {
  var me = this, oldType = me.type;
  me.type = type;
  if (me.rendered) 
  {
    if (oldType) 
    {
      me.toolEl.removeCls(me.baseCls + '-' + oldType);
    }
    me.toolEl.addCls(me.baseCls + '-' + type);
  } else {
    me.renderData.type = type;
  }
  return me;
}, onClick: function(e, target) {
  var me = this;
  if (me.disabled) 
  {
    return false;
  }
  me.el.removeCls(me.toolPressedCls);
  me.el.removeCls(me.toolOverCls);
  if (me.stopEvent !== false) 
  {
    e.stopEvent();
  }
  if (me.handler) 
  {
    Ext.callback(me.handler, me.scope || me, [e, target, me.ownerCt, me]);
  } else if (me.callback) 
  {
    Ext.callback(me.callback, me.scope || me, [me.toolOwner || me.ownerCt, me, e]);
  }
  me.fireEvent('click', me, e);
  return true;
}, onDestroy: function() {
  var me = this;
  if (Ext.quickTipsActive && Ext.isObject(me.tooltip)) 
  {
    Ext.tip.QuickTipManager.unregister(me.id);
  }
  if (me.keyMap) 
  {
    me.keyMap.destroy();
  }
  delete me.toolOwner;
  me.callParent();
}, onMouseDown: function() {
  if (this.disabled) 
  {
    return false;
  }
  this.el.addCls(this.toolPressedCls);
}, onMouseOver: function() {
  if (this.disabled) 
  {
    return false;
  }
  this.el.addCls(this.toolOverCls);
}, onMouseOut: function() {
  this.el.removeCls(this.toolOverCls);
}}, 0, ["tool"], ["component", "box", "tool"], {"component": true, "box": true, "tool": true}, ["widget.tool"], 0, [Ext.panel, 'Tool'], 0));
;

(Ext.cmd.derive('Ext.resizer.SplitterTracker', Ext.dd.DragTracker, {enabled: true, overlayCls: Ext.baseCSSPrefix + 'resizable-overlay', createDragOverlay: function() {
  var overlay;
  overlay = this.overlay = Ext.getBody().createChild({role: 'presentation', cls: this.overlayCls, html: '&#160;'});
  overlay.unselectable();
  overlay.setSize(Ext.Element.getViewWidth(true), Ext.Element.getViewHeight(true));
  overlay.show();
}, getPrevCmp: function() {
  var splitter = this.getSplitter();
  return splitter.previousSibling(':not([hidden])');
}, getNextCmp: function() {
  var splitter = this.getSplitter();
  return splitter.nextSibling(':not([hidden])');
}, onBeforeStart: function(e) {
  var me = this, prevCmp = me.getPrevCmp(), nextCmp = me.getNextCmp(), collapseEl = me.getSplitter().collapseEl, target = e.getTarget(), box;
  if (!prevCmp || !nextCmp) 
  {
    return false;
  }
  if (collapseEl && target === me.getSplitter().collapseEl.dom) 
  {
    return false;
  }
  if (nextCmp.collapsed || prevCmp.collapsed) 
  {
    return false;
  }
  me.prevBox = prevCmp.getEl().getBox();
  me.nextBox = nextCmp.getEl().getBox();
  me.constrainTo = box = me.calculateConstrainRegion();
  if (!box) 
  {
    return false;
  }
  return box;
}, onStart: function(e) {
  var splitter = this.getSplitter();
  this.createDragOverlay();
  splitter.addCls(splitter.baseCls + '-active');
}, calculateConstrainRegion: function() {
  var me = this, splitter = me.getSplitter(), splitWidth = splitter.getWidth(), defaultMin = splitter.defaultSplitMin, orient = splitter.orientation, prevBox = me.prevBox, prevCmp = me.getPrevCmp(), nextBox = me.nextBox, nextCmp = me.getNextCmp(), prevConstrainRegion, nextConstrainRegion, constrainOptions;
  if (orient === 'vertical') 
  {
    constrainOptions = {prevCmp: prevCmp, nextCmp: nextCmp, prevBox: prevBox, nextBox: nextBox, defaultMin: defaultMin, splitWidth: splitWidth};
    prevConstrainRegion = new Ext.util.Region(prevBox.y, me.getVertPrevConstrainRight(constrainOptions), prevBox.bottom, me.getVertPrevConstrainLeft(constrainOptions));
    nextConstrainRegion = new Ext.util.Region(nextBox.y, me.getVertNextConstrainRight(constrainOptions), nextBox.bottom, me.getVertNextConstrainLeft(constrainOptions));
  } else {
    prevConstrainRegion = new Ext.util.Region(prevBox.y + (prevCmp.minHeight || defaultMin), prevBox.right, (prevCmp.maxHeight ? prevBox.y + prevCmp.maxHeight : nextBox.bottom - (nextCmp.minHeight || defaultMin)) + splitWidth, prevBox.x);
    nextConstrainRegion = new Ext.util.Region((nextCmp.maxHeight ? nextBox.bottom - nextCmp.maxHeight : prevBox.y + (prevCmp.minHeight || defaultMin)) - splitWidth, nextBox.right, nextBox.bottom - (nextCmp.minHeight || defaultMin), nextBox.x);
  }
  return prevConstrainRegion.intersect(nextConstrainRegion);
}, performResize: function(e, offset) {
  var me = this, splitter = me.getSplitter(), orient = splitter.orientation, prevCmp = me.getPrevCmp(), nextCmp = me.getNextCmp(), owner = splitter.ownerCt, flexedSiblings = owner.query('>[flex]'), len = flexedSiblings.length, vertical = orient === 'vertical', i = 0, dimension = vertical ? 'width' : 'height', totalFlex = 0, item, size;
  for (; i < len; i++) 
    {
      item = flexedSiblings[i];
      size = vertical ? item.getWidth() : item.getHeight();
      totalFlex += size;
      item.flex = size;
    }
  offset = vertical ? offset[0] : offset[1];
  if (prevCmp) 
  {
    size = me.prevBox[dimension] + offset;
    if (prevCmp.flex) 
    {
      prevCmp.flex = size;
    } else {
      prevCmp[dimension] = size;
    }
  }
  if (nextCmp) 
  {
    size = me.nextBox[dimension] - offset;
    if (nextCmp.flex) 
    {
      nextCmp.flex = size;
    } else {
      nextCmp[dimension] = size;
    }
  }
  owner.updateLayout();
}, endDrag: function() {
  var me = this;
  if (me.overlay) 
  {
    me.overlay.remove();
    delete me.overlay;
  }
  me.callParent(arguments);
}, onEnd: function(e) {
  var me = this, splitter = me.getSplitter();
  splitter.removeCls(splitter.baseCls + '-active');
  me.performResize(e, me.getResizeOffset());
}, onDrag: function(e) {
  var me = this, offset = me.getOffset('dragTarget'), splitter = me.getSplitter(), splitEl = splitter.getEl(), orient = splitter.orientation;
  if (orient === "vertical") 
  {
    splitEl.setX(me.startRegion.left + offset[0]);
  } else {
    splitEl.setY(me.startRegion.top + offset[1]);
  }
}, getSplitter: function() {
  return this.splitter;
}, getVertPrevConstrainRight: function(o) {
  return (o.prevCmp.maxWidth ? o.prevBox.x + o.prevCmp.maxWidth : o.nextBox.right - (o.nextCmp.minWidth || o.defaultMin)) + o.splitWidth;
}, getVertPrevConstrainLeft: function(o) {
  return o.prevBox.x + (o.prevCmp.minWidth || o.defaultMin);
}, getVertNextConstrainRight: function(o) {
  return o.nextBox.right - (o.nextCmp.minWidth || o.defaultMin);
}, getVertNextConstrainLeft: function(o) {
  return (o.nextCmp.maxWidth ? o.nextBox.right - o.nextCmp.maxWidth : o.prevBox.x + (o.prevBox.minWidth || o.defaultMin)) - o.splitWidth;
}, getResizeOffset: function() {
  return this.getOffset('dragTarget');
}}, 0, 0, 0, 0, 0, 0, [Ext.resizer, 'SplitterTracker'], 0));
;

(Ext.cmd.derive('Ext.resizer.BorderSplitterTracker', Ext.resizer.SplitterTracker, {getPrevCmp: null, getNextCmp: null, calculateConstrainRegion: function() {
  var me = this, splitter = me.splitter, collapseTarget = splitter.collapseTarget, defaultSplitMin = splitter.defaultSplitMin, sizePropCap = splitter.vertical ? 'Width' : 'Height', minSizeProp = 'min' + sizePropCap, maxSizeProp = 'max' + sizePropCap, getSizeMethod = 'get' + sizePropCap, neighbors = splitter.neighbors, length = neighbors.length, box = collapseTarget.el.getBox(), left = box.x, top = box.y, right = box.right, bottom = box.bottom, size = splitter.vertical ? (right - left) : (bottom - top), i, neighbor, minRange, maxRange, maxGrowth, maxShrink, targetSize;
  minRange = (collapseTarget[minSizeProp] || Math.min(size, defaultSplitMin)) - size;
  maxRange = collapseTarget[maxSizeProp];
  if (!maxRange) 
  {
    maxRange = 1000000000;
  } else {
    maxRange -= size;
  }
  targetSize = size;
  for (i = 0; i < length; ++i) 
    {
      neighbor = neighbors[i];
      size = neighbor[getSizeMethod]();
      maxGrowth = size - neighbor[maxSizeProp];
      maxShrink = size - (neighbor[minSizeProp] || Math.min(size, defaultSplitMin));
      if (!isNaN(maxGrowth)) 
      {
        if (minRange < maxGrowth) 
        {
          minRange = maxGrowth;
        }
      }
      if (maxRange > maxShrink) 
      {
        maxRange = maxShrink;
      }
    }
  if (maxRange - minRange < 2) 
  {
    return null;
  }
  box = new Ext.util.Region(top, right, bottom, left);
  me.constraintAdjusters[me.getCollapseDirection()](box, minRange, maxRange, splitter);
  me.dragInfo = {minRange: minRange, maxRange: maxRange, targetSize: targetSize};
  return box;
}, constraintAdjusters: {left: function(box, minRange, maxRange, splitter) {
  box[0] = box.x = box.left = box.right + minRange;
  box.right += maxRange + splitter.getWidth();
}, top: function(box, minRange, maxRange, splitter) {
  box[1] = box.y = box.top = box.bottom + minRange;
  box.bottom += maxRange + splitter.getHeight();
}, bottom: function(box, minRange, maxRange, splitter) {
  box.bottom = box.top - minRange;
  box.top -= maxRange + splitter.getHeight();
}, right: function(box, minRange, maxRange, splitter) {
  box.right = box.left - minRange;
  box[0] = box.x = box.left = box.x - maxRange + splitter.getWidth();
}}, onBeforeStart: function(e) {
  var me = this, splitter = me.splitter, collapseTarget = splitter.collapseTarget, neighbors = splitter.neighbors, collapseEl = me.getSplitter().collapseEl, target = e.getTarget(), length = neighbors.length, i, neighbor;
  if (collapseEl && target === splitter.collapseEl.dom) 
  {
    return false;
  }
  if (collapseTarget.collapsed) 
  {
    return false;
  }
  for (i = 0; i < length; ++i) 
    {
      neighbor = neighbors[i];
      if (neighbor.collapsed && neighbor.isHorz === collapseTarget.isHorz) 
      {
        return false;
      }
    }
  if (!(me.constrainTo = me.calculateConstrainRegion())) 
  {
    return false;
  }
  return true;
}, performResize: function(e, offset) {
  var me = this, splitter = me.splitter, collapseDirection = splitter.getCollapseDirection(), collapseTarget = splitter.collapseTarget, adjusters = me.splitAdjusters[splitter.vertical ? 'horz' : 'vert'], delta = offset[adjusters.index], dragInfo = me.dragInfo, owner;
  if (collapseDirection == 'right' || collapseDirection == 'bottom') 
  {
    delta = -delta;
  }
  delta = Math.min(Math.max(dragInfo.minRange, delta), dragInfo.maxRange);
  if (delta) 
  {
    (owner = splitter.ownerCt).suspendLayouts();
    adjusters.adjustTarget(collapseTarget, dragInfo.targetSize, delta);
    owner.resumeLayouts(true);
  }
}, splitAdjusters: {horz: {index: 0, adjustTarget: function(target, size, delta) {
  target.flex = null;
  target.setSize(size + delta);
}}, vert: {index: 1, adjustTarget: function(target, targetSize, delta) {
  target.flex = null;
  target.setSize(undefined, targetSize + delta);
}}}, getCollapseDirection: function() {
  return this.splitter.getCollapseDirection();
}}, 0, 0, 0, 0, 0, 0, [Ext.resizer, 'BorderSplitterTracker'], 0));
;

(Ext.cmd.derive('Ext.resizer.ResizeTracker', Ext.dd.DragTracker, {dynamic: true, preserveRatio: false, constrainTo: null, proxyCls: Ext.baseCSSPrefix + 'resizable-proxy', constructor: function(config) {
  var me = this, widthRatio, heightRatio, throttledResizeFn;
  if (!config.el) 
  {
    if (config.target.isComponent) 
    {
      me.el = config.target.getEl();
    } else {
      me.el = config.target;
    }
  }
  this.callParent(arguments);
  if (me.preserveRatio && me.minWidth && me.minHeight) 
  {
    widthRatio = me.minWidth / me.el.getWidth();
    heightRatio = me.minHeight / me.el.getHeight();
    if (heightRatio > widthRatio) 
    {
      me.minWidth = me.el.getWidth() * heightRatio;
    } else {
      me.minHeight = me.el.getHeight() * widthRatio;
    }
  }
  if (me.throttle) 
  {
    throttledResizeFn = Ext.Function.createThrottled(function() {
  Ext.resizer.ResizeTracker.prototype.resize.apply(me, arguments);
}, me.throttle);
    me.resize = function(box, direction, atEnd) {
  if (atEnd) 
  {
    Ext.resizer.ResizeTracker.prototype.resize.apply(me, arguments);
  } else {
    throttledResizeFn.apply(null, arguments);
  }
};
  }
}, onBeforeStart: function(e) {
  this.startBox = this.target.getBox();
}, getProxy: function() {
  var me = this;
  if (!me.dynamic && !me.proxy) 
  {
    me.proxy = me.createProxy(me.target || me.el);
    me.hideProxy = true;
  }
  if (me.proxy) 
  {
    me.proxy.show();
    return me.proxy;
  }
}, createProxy: function(target) {
  var proxy, cls = this.proxyCls;
  if (target.isComponent) 
  {
    proxy = target.getProxy().addCls(cls);
  } else {
    proxy = target.createProxy({tag: 'div', role: 'presentation', cls: cls, id: target.id + '-rzproxy'}, Ext.getBody());
  }
  proxy.removeCls(Ext.baseCSSPrefix + 'proxy-el');
  return proxy;
}, onStart: function(e) {
  this.activeResizeHandle = Ext.get(this.getDragTarget().id);
  if (!this.dynamic) 
  {
    this.resize(this.startBox);
  }
}, onDrag: function(e) {
  if (this.dynamic || this.proxy) 
  {
    this.updateDimensions(e);
  }
}, updateDimensions: function(e, atEnd) {
  var me = this, region = me.activeResizeHandle.region, offset = me.getOffset(me.constrainTo ? 'dragTarget' : null), box = me.startBox, ratio, widthAdjust = 0, heightAdjust = 0, snappedWidth, snappedHeight, adjustX = 0, adjustY = 0, dragRatio, oppositeCorner, axis, newBox, newHeight, newWidth;
  region = me.convertRegionName(region);
  switch (region) {
    case 'south':
      heightAdjust = offset[1];
      axis = 2;
      break;
    case 'north':
      heightAdjust = -offset[1];
      adjustY = -heightAdjust;
      axis = 2;
      break;
    case 'east':
      widthAdjust = offset[0];
      axis = 1;
      break;
    case 'west':
      widthAdjust = -offset[0];
      adjustX = -widthAdjust;
      axis = 1;
      break;
    case 'northeast':
      heightAdjust = -offset[1];
      adjustY = -heightAdjust;
      widthAdjust = offset[0];
      oppositeCorner = [box.x, box.y + box.height];
      axis = 3;
      break;
    case 'southeast':
      heightAdjust = offset[1];
      widthAdjust = offset[0];
      oppositeCorner = [box.x, box.y];
      axis = 3;
      break;
    case 'southwest':
      widthAdjust = -offset[0];
      adjustX = -widthAdjust;
      heightAdjust = offset[1];
      oppositeCorner = [box.x + box.width, box.y];
      axis = 3;
      break;
    case 'northwest':
      heightAdjust = -offset[1];
      adjustY = -heightAdjust;
      widthAdjust = -offset[0];
      adjustX = -widthAdjust;
      oppositeCorner = [box.x + box.width, box.y + box.height];
      axis = 3;
      break;
  }
  newBox = {width: box.width + widthAdjust, height: box.height + heightAdjust, x: box.x + adjustX, y: box.y + adjustY};
  snappedWidth = Ext.Number.snap(newBox.width, me.widthIncrement);
  snappedHeight = Ext.Number.snap(newBox.height, me.heightIncrement);
  if (snappedWidth != newBox.width || snappedHeight != newBox.height) 
  {
    switch (region) {
      case 'northeast':
        newBox.y -= snappedHeight - newBox.height;
        break;
      case 'north':
        newBox.y -= snappedHeight - newBox.height;
        break;
      case 'southwest':
        newBox.x -= snappedWidth - newBox.width;
        break;
      case 'west':
        newBox.x -= snappedWidth - newBox.width;
        break;
      case 'northwest':
        newBox.x -= snappedWidth - newBox.width;
        newBox.y -= snappedHeight - newBox.height;
    }
    newBox.width = snappedWidth;
    newBox.height = snappedHeight;
  }
  if (newBox.width < me.minWidth || newBox.width > me.maxWidth) 
  {
    newBox.width = Ext.Number.constrain(newBox.width, me.minWidth, me.maxWidth);
    if (adjustX) 
    {
      newBox.x = box.x + (box.width - newBox.width);
    }
  } else {
    me.lastX = newBox.x;
  }
  if (newBox.height < me.minHeight || newBox.height > me.maxHeight) 
  {
    newBox.height = Ext.Number.constrain(newBox.height, me.minHeight, me.maxHeight);
    if (adjustY) 
    {
      newBox.y = box.y + (box.height - newBox.height);
    }
  } else {
    me.lastY = newBox.y;
  }
  if (me.preserveRatio || e.shiftKey) 
  {
    ratio = me.startBox.width / me.startBox.height;
    newHeight = Math.min(Math.max(me.minHeight, newBox.width / ratio), me.maxHeight);
    newWidth = Math.min(Math.max(me.minWidth, newBox.height * ratio), me.maxWidth);
    if (axis == 1) 
    {
      newBox.height = newHeight;
    } else if (axis == 2) 
    {
      newBox.width = newWidth;
    } else {
      dragRatio = Math.abs(oppositeCorner[0] - this.lastXY[0]) / Math.abs(oppositeCorner[1] - this.lastXY[1]);
      if (dragRatio > ratio) 
      {
        newBox.height = newHeight;
      } else {
        newBox.width = newWidth;
      }
      if (region == 'northeast') 
      {
        newBox.y = box.y - (newBox.height - box.height);
      } else if (region == 'northwest') 
      {
        newBox.y = box.y - (newBox.height - box.height);
        newBox.x = box.x - (newBox.width - box.width);
      } else if (region == 'southwest') 
      {
        newBox.x = box.x - (newBox.width - box.width);
      }
    }
  }
  me.setPosition = newBox.x !== me.startBox.x || newBox.y !== me.startBox.y;
  me.resize(newBox, atEnd);
}, resize: function(box, atEnd) {
  var me = this, target, setPosition = me.setPosition;
  if (me.dynamic || (!me.dynamic && atEnd)) 
  {
    if (setPosition) 
    {
      me.target.setBox(box);
    } else {
      me.target.setSize(box.width, box.height);
    }
  }
  if (!atEnd) 
  {
    target = me.getProxy();
    if (target && target !== me.target) 
    {
      if (setPosition || me.hideProxy) 
      {
        target.setBox(box);
      } else {
        target.setSize(box.width, box.height);
      }
    }
  }
}, onEnd: function(e) {
  this.updateDimensions(e, true);
  if (this.proxy && this.hideProxy) 
  {
    this.proxy.hide();
  }
}, convertRegionName: function(name) {
  return name;
}}, 1, 0, 0, 0, 0, 0, [Ext.resizer, 'ResizeTracker'], 0));
;

(Ext.cmd.derive('Ext.resizer.Resizer', Ext.Base, {alternateClassName: 'Ext.Resizable', handleCls: Ext.baseCSSPrefix + 'resizable-handle', overCls: Ext.baseCSSPrefix + 'resizable-handle-over', pinnedCls: Ext.baseCSSPrefix + 'resizable-pinned', wrapCls: Ext.baseCSSPrefix + 'resizable-wrap', wrappedCls: Ext.baseCSSPrefix + 'resizable-wrapped', delimiterRe: /(?:\s*[,;]\s*)|\s+/, dynamic: true, handles: 's e se', height: null, width: null, heightIncrement: 0, widthIncrement: 0, minHeight: 20, minWidth: 20, maxHeight: 10000, maxWidth: 10000, pinned: false, preserveRatio: false, transparent: false, possiblePositions: {n: 'north', s: 'south', e: 'east', w: 'west', se: 'southeast', sw: 'southwest', nw: 'northwest', ne: 'northeast'}, ariaRole: 'presentation', constructor: function(config) {
  var me = this, resizeTarget, tag, handles = me.handles, handleCls, possibles, len, i = 0, pos, el, handleEls = [], eastWestStyle, style, targetBaseCls, wrapTarget, unselectableCls = Ext.dom.Element.unselectableCls;
  me.addEvents('beforeresize', 'resizedrag', 'resize');
  if (Ext.isString(config) || Ext.isElement(config) || config.dom) 
  {
    resizeTarget = config;
    config = arguments[1] || {};
    config.target = resizeTarget;
  }
  me.mixins.observable.constructor.call(me, config);
  resizeTarget = me.target;
  if (resizeTarget) 
  {
    if (resizeTarget.isComponent) 
    {
      resizeTarget.addClsWithUI('resizable');
      if (resizeTarget.minWidth) 
      {
        me.minWidth = resizeTarget.minWidth;
      }
      if (resizeTarget.minHeight) 
      {
        me.minHeight = resizeTarget.minHeight;
      }
      if (resizeTarget.maxWidth) 
      {
        me.maxWidth = resizeTarget.maxWidth;
      }
      if (resizeTarget.maxHeight) 
      {
        me.maxHeight = resizeTarget.maxHeight;
      }
      if (resizeTarget.floating) 
      {
        if (!me.hasOwnProperty('handles')) 
        {
          me.handles = 'n ne e se s sw w nw';
        }
      }
      me.el = resizeTarget.getEl();
    } else {
      resizeTarget = me.el = me.target = Ext.get(resizeTarget);
    }
  } else {
    resizeTarget = me.target = me.el = Ext.get(me.el);
  }
  me.el.addCls(Ext.AbstractComponent.prototype.borderBoxCls);
  if (Ext.isNumber(me.width)) 
  {
    me.width = Ext.Number.constrain(me.width, me.minWidth, me.maxWidth);
  }
  if (Ext.isNumber(me.height)) 
  {
    me.height = Ext.Number.constrain(me.height, me.minHeight, me.maxHeight);
  }
  if (me.width !== null || me.height !== null) 
  {
    me.target.setSize(me.width, me.height);
  }
  tag = me.el.dom.tagName.toUpperCase();
  if (tag === 'TEXTAREA' || tag === 'IMG' || tag === 'TABLE') 
  {
    me.originalTarget = me.target;
    wrapTarget = resizeTarget.isComponent ? resizeTarget.getEl() : resizeTarget;
    me.el.addCls(me.wrappedCls);
    me.target = me.el = me.el.wrap({role: 'presentation', cls: me.wrapCls, id: me.el.id + '-rzwrap', style: wrapTarget.getStyles('margin-top', 'margin-bottom')});
    me.el.setPositioning(wrapTarget.getPositioning());
    wrapTarget.clearPositioning();
    me.el.setBox(wrapTarget.getBox());
    wrapTarget.setStyle('position', 'absolute');
    me.isTargetWrapped = true;
  }
  me.el.position();
  if (me.pinned) 
  {
    me.el.addCls(me.pinnedCls);
  }
  me.resizeTracker = new Ext.resizer.ResizeTracker({disabled: me.disabled, target: resizeTarget, el: me.el, constrainTo: me.constrainTo, handleCls: me.handleCls, overCls: me.overCls, throttle: me.throttle, proxy: me.originalTarget ? me.el : null, dynamic: me.originalTarget ? true : me.dynamic, originalTarget: me.originalTarget, delegate: '.' + me.handleCls, preserveRatio: me.preserveRatio, heightIncrement: me.heightIncrement, widthIncrement: me.widthIncrement, minHeight: me.minHeight, maxHeight: me.maxHeight, minWidth: me.minWidth, maxWidth: me.maxWidth});
  me.resizeTracker.on({mousedown: me.onBeforeResize, drag: me.onResize, dragend: me.onResizeEnd, scope: me});
  if (me.handles == 'all') 
  {
    me.handles = 'n s e w ne nw se sw';
  }
  handles = me.handles = me.handles.split(me.delimiterRe);
  possibles = me.possiblePositions;
  len = handles.length;
  handleCls = me.handleCls + ' ' + me.handleCls + '-{0}';
  if (me.target.isComponent) 
  {
    targetBaseCls = me.target.baseCls;
    handleCls += ' ' + targetBaseCls + '-handle ' + targetBaseCls + '-handle-{0}';
    if (Ext.supports.CSS3BorderRadius) 
    {
      handleCls += ' ' + targetBaseCls + '-handle-{0}-br';
    }
  }
  eastWestStyle = Ext.isIE6 ? ' style="height:' + me.el.getHeight() + 'px"' : '';
  for (; i < len; i++) 
    {
      if (handles[i] && possibles[handles[i]]) 
      {
        pos = possibles[handles[i]];
        if (pos === 'east' || pos === 'west') 
        {
          style = eastWestStyle;
        } else {
          style = '';
        }
        handleEls.push('<div id="', me.el.id, '-', pos, '-handle" class="', Ext.String.format(handleCls, pos), ' ', unselectableCls, '" unselectable="on" role="presentation"', style, '></div>');
      }
    }
  Ext.DomHelper.append(me.el, handleEls.join(''));
  handleEls.length = 0;
  for (i = 0; i < len; i++) 
    {
      if (handles[i] && possibles[handles[i]]) 
      {
        pos = possibles[handles[i]];
        el = me[pos] = me.el.getById(me.el.id + '-' + pos + '-handle');
        handleEls.push(el);
        el.region = pos;
        if (me.transparent) 
        {
          el.setOpacity(0);
        }
      }
    }
  me.resizeTracker.handleEls = handleEls;
  me.forceHandlesHeight();
}, disable: function() {
  this.resizeTracker.disable();
}, enable: function() {
  this.resizeTracker.enable();
}, onBeforeResize: function(tracker, e) {
  var box = this.el.getBox();
  return this.fireEvent('beforeresize', this, box.width, box.height, e);
}, onResize: function(tracker, e) {
  var me = this, box;
  me.forceHandlesHeight();
  if (me.hasListeners.resizeDrag) 
  {
    box = tracker.getResizeTarget().getBox();
    return me.fireEvent('resizedrag', me, box.width, box.height, e);
  }
}, onResizeEnd: function(tracker, e) {
  var me = this, box = me.el.getBox();
  me.forceHandlesHeight();
  return me.fireEvent('resize', me, box.width, box.height, e);
}, resizeTo: function(width, height) {
  var me = this;
  me.target.setSize(width, height);
  me.fireEvent('resize', me, width, height, null);
}, getEl: function() {
  return this.el;
}, getTarget: function() {
  return this.target;
}, destroy: function() {
  var me = this, i, handles = me.handles, len = handles.length, positions = me.possiblePositions, handle;
  me.resizeTracker.destroy();
  if (me.isTargetWrapped) 
  {
    me.target.destroy();
  }
  for (i = 0; i < len; i++) 
    {
      if (handle = me[positions[handles[i]]]) 
      {
        handle.remove();
      }
    }
}, forceHandlesHeight: function() {
  var me = this, handle;
  if (Ext.isIE6) 
  {
    handle = me.east;
    if (handle) 
    {
      handle.setHeight(me.el.getHeight());
    }
    handle = me.west;
    if (handle) 
    {
      handle.setHeight(me.el.getHeight());
    }
    me.el.repaint();
  }
}}, 1, 0, 0, 0, 0, [['observable', Ext.util.Observable]], [Ext.resizer, 'Resizer', Ext, 'Resizable'], 0));
;

(Ext.cmd.derive('Ext.selection.CellModel', Ext.selection.Model, {isCellModel: true, enableKeyNav: true, preventWrap: false, noSelection: {row: -1, column: -1}, constructor: function() {
  this.addEvents('deselect', 'select');
  this.callParent(arguments);
}, bindComponent: function(view) {
  var me = this, grid = view.ownerCt;
  me.primaryView = view;
  me.views = me.views || [];
  me.views.push(view);
  me.bindStore(view.getStore(), true);
  view.on({cellclick: me.onCellClick, refresh: me.onViewRefresh, scope: me});
  if (grid.optimizedColumnMove !== false) 
  {
    grid.on('columnmove', me.onColumnMove, me);
  }
  if (me.enableKeyNav) 
  {
    me.initKeyNav(view);
  }
}, initKeyNav: function(view) {
  var me = this;
  if (!view.rendered) 
  {
    view.on('render', Ext.Function.bind(me.initKeyNav, me, [view], 0), me, {single: true});
    return;
  }
  view.el.set({tabIndex: -1});
  me.keyNav = new Ext.util.KeyNav({target: view.el, ignoreInputFields: true, up: me.onKeyUp, down: me.onKeyDown, right: me.onKeyRight, left: me.onKeyLeft, tab: me.onKeyTab, scope: me});
}, getHeaderCt: function() {
  var selection = this.getCurrentPosition(), view = selection ? selection.view : this.primaryView;
  return view.headerCt;
}, onKeyUp: function(e) {
  this.doMove('up', e);
}, onKeyDown: function(e) {
  this.doMove('down', e);
}, onKeyLeft: function(e) {
  this.doMove('left', e);
}, onKeyRight: function(e) {
  this.doMove('right', e);
}, doMove: function(direction, e) {
  this.keyNavigation = true;
  this.move(direction, e);
  this.keyNavigation = false;
}, selectWithEvent: function(record, e) {
  this.select(record);
}, select: function(pos, keepExisting, suppressEvent) {
  var me = this, row, oldPos = me.getCurrentPosition(), store = me.view.store;
  if (pos || pos === 0) 
  {
    if (pos.isModel) 
    {
      row = store.indexOf(pos);
      if (row !== -1) 
      {
        pos = {row: row, column: oldPos ? oldPos.column : 0};
      } else {
        pos = null;
      }
    } else if (typeof pos === 'number') 
    {
      pos = {row: pos, column: 0};
    }
  }
  if (pos) 
  {
    me.selectByPosition(pos, suppressEvent);
  } else {
    me.deselect();
  }
}, deselect: function(record, suppressEvent) {
  this.selectByPosition(null, suppressEvent);
}, move: function(dir, e) {
  var me = this, pos = me.getCurrentPosition(), newPos;
  if (pos) 
  {
    newPos = pos.view.walkCells(pos, dir, e, me.preventWrap);
    if (newPos) 
    {
      return me.setCurrentPosition(newPos);
    }
  }
}, getCurrentPosition: function() {
  return this.selecting ? this.nextSelection : this.selection;
}, setCurrentPosition: function(pos, suppressEvent, preventCheck) {
  var me = this, last = me.selection;
  me.lastSelection = last;
  if (pos) 
  {
    pos = pos.isCellContext ? pos : new Ext.grid.CellContext(me.primaryView).setPosition(pos);
  }
  if (!preventCheck && last) 
  {
    if (pos && (pos.record === last.record && pos.columnHeader === last.columnHeader && pos.view === last.view)) 
    {
      pos = null;
    } else {
      me.onCellDeselect(me.selection, suppressEvent);
    }
  }
  if (pos) 
  {
    me.nextSelection = pos;
    me.selecting = true;
    me.onCellSelect(me.nextSelection, suppressEvent);
    me.selecting = false;
    return (me.selection = pos);
  }
}, isCellSelected: function(view, row, column) {
  var me = this, testPos, pos = me.getCurrentPosition();
  if (pos && pos.view === view) 
  {
    testPos = new Ext.grid.CellContext(view).setPosition({row: row, column: column});
    return (testPos.record === pos.record) && (testPos.columnHeader === pos.columnHeader);
  }
}, onStoreRemove: function(store, records, indexes) {
  var me = this, pos = me.getCurrentPosition();
  me.callParent(arguments);
  if (pos && store.getCount() && store.indexOf(pos.record) !== -1) 
  {
    me.setCurrentPosition({row: pos.record, column: pos.columnHeader}, true, true);
  } else {
    me.selection = null;
  }
}, onStoreAdd: function() {
  var me = this, pos = me.getCurrentPosition();
  me.callParent(arguments);
  if (pos) 
  {
    me.setCurrentPosition({row: pos.record, column: pos.columnHeader}, true, true);
  } else {
    me.selection = null;
  }
}, onCellClick: function(view, cell, cellIndex, record, row, recordIndex, e) {
  var newPos;
  if (recordIndex !== -1) 
  {
    newPos = new Ext.grid.CellContext(view).setPosition({view: view, row: row, column: view.ownerCt.getColumnManager().getHeaderAtIndex(cellIndex)});
    this.setCurrentPosition(newPos);
  }
}, onCellSelect: function(position, supressEvent) {
  if (position && position.row !== undefined && position.row > -1) 
  {
    this.doSelect(position.record, false, supressEvent);
  }
}, onCellDeselect: function(position, supressEvent) {
  if (position && position.row !== undefined) 
  {
    this.doDeselect(position.record, supressEvent);
  }
}, onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
  var me = this, pos, eventName, view;
  if (isSelected) 
  {
    pos = me.nextSelection;
    eventName = 'select';
  } else {
    pos = me.lastSelection || me.noSelection;
    eventName = 'deselect';
  }
  view = pos.view || me.primaryView;
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record, pos.row, pos.column)) !== false && commitFn() !== false) 
  {
    if (isSelected) 
    {
      if (!me.preventFocus) 
      {
        view.focusCell(pos, true);
      }
      view.onCellSelect(pos);
    } else {
      view.onCellDeselect(pos);
      delete me.selection;
    }
    if (!suppressEvent) 
    {
      me.fireEvent(eventName, me, record, pos.row, pos.column);
    }
  }
}, onKeyTab: function(e, t) {
  var me = this, pos = me.getCurrentPosition(), editingPlugin;
  if (pos) 
  {
    editingPlugin = pos.view.editingPlugin;
    if (editingPlugin && me.wasEditing) 
    {
      me.onEditorTab(editingPlugin, e);
    } else {
      me.move(e.shiftKey ? 'left' : 'right', e);
    }
  }
}, onEditorTab: function(editingPlugin, e) {
  var me = this, direction = e.shiftKey ? 'left' : 'right', pos = me.getCurrentPosition(), position = pos.view.walkCells(pos, direction, e, me.preventWrap);
  if (position) 
  {
    if (editingPlugin.startEdit(position.record, position.columnHeader)) 
    {
      me.wasEditing = false;
    } else {
      me.setCurrentPosition(position);
      me.wasEditing = true;
    }
  }
}, refresh: function() {
  var pos = this.getCurrentPosition(), selRowIdx;
  if (pos && (selRowIdx = this.store.indexOf(this.selected.last())) !== -1) 
  {
    pos.row = selRowIdx;
  }
}, onColumnMove: function(headerCt, header, fromIdx, toIdx) {
  var grid = headerCt.up('tablepanel');
  if (grid) 
  {
    this.onViewRefresh(grid.view);
  }
}, onUpdate: function(record) {
  var me = this, pos;
  if (me.isSelected(record)) 
  {
    pos = me.selecting ? me.nextSelection : me.selection;
    me.view.onCellSelect(pos);
  }
}, onViewRefresh: function(view) {
  var me = this, pos = me.getCurrentPosition(), newPos, headerCt = view.headerCt, record, columnHeader;
  if (pos && pos.view === view) 
  {
    record = pos.record;
    columnHeader = pos.columnHeader;
    if (!columnHeader.isDescendantOf(headerCt)) 
    {
      columnHeader = headerCt.queryById(columnHeader.id) || headerCt.down('[text="' + columnHeader.text + '"]') || headerCt.down('[dataIndex="' + columnHeader.dataIndex + '"]');
    }
    if (pos.record) 
    {
      if (columnHeader && (view.store.indexOfId(record.getId()) !== -1)) 
      {
        newPos = new Ext.grid.CellContext(view).setPosition({row: record, column: columnHeader});
        me.setCurrentPosition(newPos);
      }
    } else {
      me.selection = null;
    }
  }
}, selectByPosition: function(position, suppressEvent) {
  this.setCurrentPosition(position, suppressEvent);
}}, 1, 0, 0, 0, ["selection.cellmodel"], 0, [Ext.selection, 'CellModel'], 0));
;

(Ext.cmd.derive('Ext.selection.RowModel', Ext.selection.Model, {deltaScroll: 5, enableKeyNav: true, ignoreRightMouseSelection: false, isRowModel: true, constructor: function() {
  this.addEvents('beforedeselect', 'beforeselect', 'deselect', 'select');
  this.views = [];
  this.callParent(arguments);
}, bindComponent: function(view) {
  var me = this;
  view.on({itemcontextmenu: me.onRowClick, itemclick: me.onRowClick, scope: me});
  if (me.enableKeyNav) 
  {
    me.initKeyNav(view);
  }
}, initKeyNav: function(view) {
  var me = this;
  if (!view.rendered) 
  {
    view.on('render', Ext.Function.bind(me.initKeyNav, me, [view], 0), me, {single: true});
    return;
  }
  view.el.set({tabIndex: -1});
  me.keyNav = new Ext.util.KeyNav({target: view, ignoreInputFields: true, eventName: 'itemkeydown', processEvent: function(view, record, node, index, event) {
  event.record = record;
  event.recordIndex = index;
  return event;
}, up: me.onKeyUp, down: me.onKeyDown, right: me.onKeyRight, left: me.onKeyLeft, pageDown: me.onKeyPageDown, pageUp: me.onKeyPageUp, home: me.onKeyHome, end: me.onKeyEnd, space: me.onKeySpace, enter: me.onKeyEnter, A: {ctrl: true, handler: me.selectAll}, scope: me});
}, onUpdate: function(record) {
  var me = this, view = me.view, index;
  if (view && me.isSelected(record)) 
  {
    index = view.indexOf(record);
    view.onRowSelect(index);
    if (record === me.lastFocused) 
    {
      view.onRowFocus(index, true);
    }
  }
}, getRowsVisible: function() {
  var rowsVisible = false, view = this.views[0], firstRow = view.all.first(), rowHeight, gridViewHeight;
  if (firstRow) 
  {
    rowHeight = firstRow.getHeight();
    gridViewHeight = view.el.getHeight();
    rowsVisible = Math.floor(gridViewHeight / rowHeight);
  }
  return rowsVisible;
}, onKeyEnd: function(e) {
  var me = this, view = me.views[0];
  if (view.bufferedRenderer) 
  {
    view.bufferedRenderer.scrollTo(me.store.getCount() - 1, false, function(newIdx, newRecord) {
  me.afterKeyNavigate(e, newRecord);
});
  } else {
    me.afterKeyNavigate(e, view.walkRecs(e.record, view.dataSource.getCount() - 1 - view.dataSource.indexOf(e.record)));
  }
}, onKeyHome: function(e) {
  var me = this, view = me.views[0];
  if (view.bufferedRenderer) 
  {
    view.bufferedRenderer.scrollTo(0, false, function(newIdx, newRecord) {
  me.afterKeyNavigate(e, newRecord);
});
  } else {
    me.afterKeyNavigate(e, view.walkRecs(e.record, -view.dataSource.indexOf(e.record)));
  }
}, onKeyPageUp: function(e) {
  var me = this, view = me.views[0], rowsVisible = me.getRowsVisible(), newIdx, newRecord;
  if (rowsVisible) 
  {
    if (view.bufferedRenderer) 
    {
      newIdx = Math.max(e.recordIndex - rowsVisible, 0);
      (me.lastKeyEvent || (me.lastKeyEvent = new Ext.EventObjectImpl())).setEvent(e.browserEvent);
      view.bufferedRenderer.scrollTo(newIdx, false, me.afterBufferedScrollTo, me);
    } else {
      newRecord = view.walkRecs(e.record, -rowsVisible);
      me.afterKeyNavigate(e, newRecord);
    }
  }
}, onKeyPageDown: function(e) {
  var me = this, view = me.views[0], rowsVisible = me.getRowsVisible(), newIdx, newRecord;
  if (rowsVisible) 
  {
    if (view.bufferedRenderer) 
    {
      newIdx = Math.min(e.recordIndex + rowsVisible, me.store.getCount() - 1);
      (me.lastKeyEvent || (me.lastKeyEvent = new Ext.EventObjectImpl())).setEvent(e.browserEvent);
      view.bufferedRenderer.scrollTo(newIdx, false, me.afterBufferedScrollTo, me);
    } else {
      newRecord = view.walkRecs(e.record, rowsVisible);
      me.afterKeyNavigate(e, newRecord);
    }
  }
}, onKeySpace: function(e) {
  var record = e.record || this.lastFocused;
  if (record) 
  {
    this.afterKeyNavigate(e, record);
  }
}, onKeyEnter: Ext.emptyFn, onKeyUp: function(e) {
  var newRecord = this.views[0].walkRecs(e.record, -1);
  if (newRecord) 
  {
    this.afterKeyNavigate(e, newRecord);
  }
}, onKeyDown: function(e) {
  var newRecord = e.record.isExpandingOrCollapsing ? null : this.views[0].walkRecs(e.record, 1);
  if (newRecord) 
  {
    this.afterKeyNavigate(e, newRecord);
  }
}, afterBufferedScrollTo: function(newIdx, newRecord) {
  this.afterKeyNavigate(this.lastKeyEvent, newRecord);
}, scrollByDeltaX: function(delta) {
  var view = this.views[0], section = view.up(), hScroll = section.horizontalScroller;
  if (hScroll) 
  {
    hScroll.scrollByDeltaX(delta);
  }
}, onKeyLeft: function(e) {
  this.scrollByDeltaX(-this.deltaScroll);
}, onKeyRight: function(e) {
  this.scrollByDeltaX(this.deltaScroll);
}, onRowClick: function(view, record, item, index, e) {
  if (index !== -1) 
  {
    if (!this.allowRightMouseSelection(e)) 
    {
      return;
    }
    if (!(e.type === 'contextmenu' && this.isSelected(record))) 
    {
      this.processSelection(view, record, item, index, e);
    }
  }
}, processSelection: function(view, record, item, index, e) {
  this.selectWithEvent(record, e);
}, allowRightMouseSelection: function(e) {
  var disallow = this.ignoreRightMouseSelection && e.button !== 0;
  if (disallow) 
  {
    disallow = this.hasSelection();
  }
  return !disallow;
}, onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
  var me = this, views = me.views, viewsLn = views.length, rowIdx = views[0].indexOf(record), eventName = isSelected ? 'select' : 'deselect', i = 0;
  if ((suppressEvent || me.fireEvent('before' + eventName, me, record, rowIdx)) !== false && commitFn() !== false) 
  {
    for (; i < viewsLn; i++) 
      {
        if (isSelected) 
        {
          views[i].onRowSelect(rowIdx, suppressEvent);
        } else {
          views[i].onRowDeselect(rowIdx, suppressEvent);
        }
      }
    if (!suppressEvent) 
    {
      me.fireEvent(eventName, me, record, rowIdx);
    }
  }
}, onLastFocusChanged: function(oldFocused, newFocused, supressFocus) {
  var views = this.views, viewsLn = views.length, rowIdx, i = 0;
  if (oldFocused) 
  {
    rowIdx = views[0].indexOf(oldFocused);
    if (rowIdx !== -1) 
    {
      for (; i < viewsLn; i++) 
        {
          views[i].onRowFocus(rowIdx, false, true);
        }
    }
  }
  if (newFocused) 
  {
    rowIdx = views[0].indexOf(newFocused);
    if (rowIdx !== -1) 
    {
      for (i = 0; i < viewsLn; i++) 
        {
          views[i].onRowFocus(rowIdx, true, supressFocus);
        }
    }
  }
  this.callParent(arguments);
}, onEditorTab: function(editingPlugin, e) {
  var me = this, view = editingPlugin.context.view, record = editingPlugin.getActiveRecord(), header = editingPlugin.getActiveColumn(), position = view.getPosition(record, header), direction = e.shiftKey ? 'left' : 'right', lastPos;
  do {
    lastPos = position;
    position = view.walkCells(position, direction, e, me.preventWrap);
    if (lastPos && lastPos.isEqual(position)) 
    {
      return;
    }
  } while (position && (!position.columnHeader.getEditor(record) || !editingPlugin.startEditByPosition(position)));
}, getCurrentPosition: function() {
  var firstSelection = this.selected.getAt(0);
  if (firstSelection) 
  {
    return new Ext.grid.CellContext(this.view).setPosition(this.store.indexOf(firstSelection), 0);
  }
}, selectByPosition: function(position, keepExisting) {
  var context = new Ext.grid.CellContext(this.view);
  context.setPosition(position.row, position.column);
  this.select(context.record, keepExisting);
}, selectNext: function(keepExisting, suppressEvent) {
  var me = this, store = me.store, selection = me.getSelection(), record = selection[selection.length - 1], index = me.views[0].indexOf(record) + 1, success;
  if (index === store.getCount() || index === 0) 
  {
    success = false;
  } else {
    me.doSelect(index, keepExisting, suppressEvent);
    success = true;
  }
  return success;
}, selectPrevious: function(keepExisting, suppressEvent) {
  var me = this, selection = me.getSelection(), record = selection[0], index = me.views[0].indexOf(record) - 1, success;
  if (index < 0) 
  {
    success = false;
  } else {
    me.doSelect(index, keepExisting, suppressEvent);
    success = true;
  }
  return success;
}, isRowSelected: function(record) {
  return this.isSelected(record);
}, isCellSelected: function(view, record, columnHeader) {
  return this.isSelected(record);
}}, 1, 0, 0, 0, ["selection.rowmodel"], 0, [Ext.selection, 'RowModel'], 0));
;

(Ext.cmd.derive('Ext.util.Point', Ext.util.Region, {statics: {fromEvent: function(e) {
  e = e.browserEvent || e;
  e = (e.changedTouches && e.changedTouches.length > 0) ? e.changedTouches[0] : e;
  return new this(e.pageX, e.pageY);
}}, constructor: function(x, y) {
  this.callParent([y, x, y, x]);
}, toString: function() {
  return "Point[" + this.x + "," + this.y + "]";
}, equals: function(p) {
  return (this.x == p.x && this.y == p.y);
}, isWithin: function(p, threshold) {
  if (!Ext.isObject(threshold)) 
  {
    threshold = {x: threshold, y: threshold};
  }
  return (this.x <= p.x + threshold.x && this.x >= p.x - threshold.x && this.y <= p.y + threshold.y && this.y >= p.y - threshold.y);
}, isContainedBy: function(region) {
  if (!(region instanceof Ext.util.Region)) 
  {
    region = Ext.get(region.el || region).getRegion();
  }
  return region.contains(this);
}, roundedEquals: function(p) {
  return (Math.round(this.x) == Math.round(p.x) && Math.round(this.y) == Math.round(p.y));
}}, 3, 0, 0, 0, 0, 0, [Ext.util, 'Point'], function() {
  this.prototype.translate = Ext.util.Region.prototype.translateBy;
}));
;

(Ext.cmd.derive('Ext.selection.CheckboxModel', Ext.selection.RowModel, {mode: 'MULTI', injectCheckbox: 0, checkOnly: false, showHeaderCheckbox: undefined, checkSelector: '.' + Ext.baseCSSPrefix + 'grid-row-checker', headerWidth: 24, checkerOnCls: Ext.baseCSSPrefix + 'grid-hd-checker-on', tdCls: Ext.baseCSSPrefix + 'grid-cell-special ' + Ext.baseCSSPrefix + 'grid-cell-row-checker', constructor: function() {
  var me = this;
  me.callParent(arguments);
  if (me.mode === 'SINGLE' && me.showHeaderCheckbox !== true) 
  {
    me.showHeaderCheckbox = false;
  }
}, beforeViewRender: function(view) {
  var me = this, owner;
  me.callParent(arguments);
  if (!me.hasLockedHeader() || view.headerCt.lockedCt) 
  {
    if (me.showHeaderCheckbox !== false) 
    {
      view.headerCt.on('headerclick', me.onHeaderClick, me);
    }
    me.addCheckbox(view, true);
    owner = view.ownerCt;
    if (view.headerCt.lockedCt) 
    {
      owner = owner.ownerCt;
    }
    me.mon(owner, 'reconfigure', me.onReconfigure, me);
  }
}, bindComponent: function(view) {
  var me = this;
  me.sortable = false;
  me.callParent(arguments);
}, hasLockedHeader: function() {
  var views = this.views, vLen = views.length, v;
  for (v = 0; v < vLen; v++) 
    {
      if (views[v].headerCt.lockedCt) 
      {
        return true;
      }
    }
  return false;
}, addCheckbox: function(view, initial) {
  var me = this, checkbox = me.injectCheckbox, headerCt = view.headerCt;
  if (checkbox !== false) 
  {
    if (checkbox == 'first') 
    {
      checkbox = 0;
    } else if (checkbox == 'last') 
    {
      checkbox = headerCt.getColumnCount();
    }
    Ext.suspendLayouts();
    if (view.getStore().buffered) 
    {
      me.showHeaderCheckbox = false;
    }
    headerCt.add(checkbox, me.getHeaderConfig());
    Ext.resumeLayouts();
  }
  if (initial !== true) 
  {
    view.refresh();
  }
}, onReconfigure: function(grid, store, columns) {
  if (columns) 
  {
    this.addCheckbox(this.views[0]);
  }
}, toggleUiHeader: function(isChecked) {
  var view = this.views[0], headerCt = view.headerCt, checkHd = headerCt.child('gridcolumn[isCheckerHd]'), cls = this.checkerOnCls;
  if (checkHd) 
  {
    if (isChecked) 
    {
      checkHd.addCls(cls);
    } else {
      checkHd.removeCls(cls);
    }
  }
}, onHeaderClick: function(headerCt, header, e) {
  if (header.isCheckerHd) 
  {
    e.stopEvent();
    var me = this, isChecked = header.el.hasCls(Ext.baseCSSPrefix + 'grid-hd-checker-on');
    me.preventFocus = true;
    if (isChecked) 
    {
      me.deselectAll();
    } else {
      me.selectAll();
    }
    delete me.preventFocus;
  }
}, getHeaderConfig: function() {
  var me = this, showCheck = me.showHeaderCheckbox !== false;
  return {isCheckerHd: showCheck, text: '&#160;', clickTargetName: 'el', width: me.headerWidth, sortable: false, draggable: false, resizable: false, hideable: false, menuDisabled: true, dataIndex: '', tdCls: me.tdCls, cls: showCheck ? Ext.baseCSSPrefix + 'column-header-checkbox ' : '', renderer: Ext.Function.bind(me.renderer, me), editRenderer: me.editRenderer || me.renderEmpty, locked: me.hasLockedHeader()};
}, renderEmpty: function() {
  return '&#160;';
}, refresh: function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {
  return '<div class="' + Ext.baseCSSPrefix + 'grid-row-checker" role="presentation">&#160;</div>';
}, processSelection: function(view, record, item, index, e) {
  var me = this, checker = e.getTarget(me.checkSelector), mode;
  if (me.checkOnly && !checker) 
  {
    return;
  }
  if (checker) 
  {
    mode = me.getSelectionMode();
    if (mode !== 'SINGLE') 
    {
      me.setSelectionMode('SIMPLE');
    }
    me.selectWithEvent(record, e);
    me.setSelectionMode(mode);
  } else {
    me.selectWithEvent(record, e);
  }
}, onSelectChange: function() {
  this.callParent(arguments);
  if (!this.suspendChange) 
  {
    this.updateHeaderState();
  }
}, onStoreLoad: function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, onStoreAdd: function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, onStoreRemove: function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, onStoreRefresh: function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, maybeFireSelectionChange: function(fireEvent) {
  if (fireEvent && !this.suspendChange) 
  {
    this.updateHeaderState();
  }
  this.callParent(arguments);
}, resumeChanges: function() {
  this.callParent();
  if (!this.suspendChange) 
  {
    this.updateHeaderState();
  }
}, updateHeaderState: function() {
  var me = this, store = me.store, storeCount = store.getCount(), views = me.views, hdSelectStatus = false, selectedCount = 0, selected, len, i;
  if (!store.buffered && storeCount > 0) 
  {
    selected = me.selected;
    hdSelectStatus = true;
    for (i = 0 , len = selected.getCount(); i < len; ++i) 
      {
        if (!me.getStoreRecord(selected.getAt(i))) 
        {
          break;
        }
        ++selectedCount;
      }
    hdSelectStatus = storeCount === selectedCount;
  }
  if (views && views.length) 
  {
    me.toggleUiHeader(hdSelectStatus);
  }
}}, 1, 0, 0, 0, ["selection.checkboxmodel"], 0, [Ext.selection, 'CheckboxModel'], 0));
;

(Ext.cmd.derive('Ext.view.DragZone', Ext.dd.DragZone, {containerScroll: false, constructor: function(config) {
  var me = this, view, ownerCt, el;
  Ext.apply(me, config);
  if (!me.ddGroup) 
  {
    me.ddGroup = 'view-dd-zone-' + me.view.id;
  }
  view = me.view;
  ownerCt = view.ownerCt;
  if (ownerCt) 
  {
    el = ownerCt.getTargetEl().dom;
  } else {
    el = view.el.dom.parentNode;
  }
  me.callParent([el]);
  me.ddel = Ext.get(document.createElement('div'));
  me.ddel.addCls(Ext.baseCSSPrefix + 'grid-dd-wrap');
}, init: function(id, sGroup, config) {
  var me = this;
  me.initTarget(id, sGroup, config);
  me.view.on('itemmousedown', me.onItemMouseDown, me);
}, onValidDrop: function(target, e, id) {
  this.callParent();
  target.el.focus();
}, onItemMouseDown: function(view, record, item, index, e) {
  if (!this.isPreventDrag(e, record, item, index)) 
  {
    if (view.focusRow) 
    {
      view.focusRow(record);
    }
    this.handleMouseDown(e);
  }
}, isPreventDrag: function(e, record, item, index) {
  return false;
}, getDragData: function(e) {
  var view = this.view, item = e.getTarget(view.getItemSelector());
  if (item) 
  {
    return {copy: view.copy || (view.allowCopy && e.ctrlKey), event: new Ext.EventObjectImpl(e), view: view, ddel: this.ddel, item: item, records: view.getSelectionModel().getSelection(), fromPosition: Ext.fly(item).getXY()};
  }
}, onInitDrag: function(x, y) {
  var me = this, data = me.dragData, view = data.view, selectionModel = view.getSelectionModel(), record = view.getRecord(data.item);
  if (!selectionModel.isSelected(record)) 
  {
    selectionModel.selectWithEvent(record, me.DDMInstance.mousedownEvent);
  }
  data.records = selectionModel.getSelection();
  me.ddel.update(me.getDragText());
  me.proxy.update(me.ddel.dom);
  me.onStartDrag(x, y);
  return true;
}, getDragText: function() {
  var count = this.dragData.records.length;
  return Ext.String.format(this.dragText, count, count === 1 ? '' : 's');
}, getRepairXY: function(e, data) {
  return data ? data.fromPosition : false;
}}, 1, 0, 0, 0, 0, 0, [Ext.view, 'DragZone'], 0));
;

(Ext.cmd.derive('Ext.util.Grouper', Ext.util.Sorter, {isGrouper: true, getGroupString: function(instance) {
  return instance.get(this.property);
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Grouper'], 0));
;

(Ext.cmd.derive('Sch.locale.Locale', Ext.Base, {l10n: null, legacyMode: true, localeName: null, namespaceId: null, constructor: function() {
  if (!Sch.locale.Active) 
  {
    Sch.locale.Active = {};
    this.bindRequire();
  }
  var name = this.self.getName().split('.');
  var localeName = this.localeName = name.pop();
  this.namespaceId = name.join('.');
  var currentLocale = Sch.locale.Active[this.namespaceId];
  if (!(localeName == 'En' && currentLocale && currentLocale.localeName != 'En')) 
  this.apply();
}, bindRequire: function() {
  var _triggerCreated = Ext.ClassManager.triggerCreated;
  Ext.ClassManager.triggerCreated = function(className) {
  _triggerCreated.apply(this, arguments);
  var cls = Ext.ClassManager.get(className);
  for (var namespaceId in Sch.locale.Active) 
    {
      Sch.locale.Active[namespaceId].apply(cls);
    }
};
}, apply: function(classNames) {
  if (this.l10n) 
  {
    var me = this, i, l;
    var localeId = this.self.getName();
    var applyToClass = function(clsName, cls) {
  cls = cls || Ext.ClassManager.get(clsName);
  if (cls && (cls.activeLocaleId !== localeId)) 
  {
    var locale = me.l10n[clsName];
    if (typeof locale === 'function') 
    {
      locale(clsName);
    } else if (cls.singleton) 
    {
      cls.l10n = Ext.apply({}, locale, cls.prototype && cls.prototype.l10n);
    } else {
      Ext.override(cls, {l10n: locale});
    }
    if (me.legacyMode) 
    {
      var target;
      if (cls.prototype) 
      {
        target = cls.prototype;
      } else if (cls.singleton) 
      {
        target = cls;
      }
      if (target && target.legacyMode) 
      {
        if (target.legacyHolderProp) 
        {
          if (!target[target.legacyHolderProp]) 
          target[target.legacyHolderProp] = {};
          target = target[target.legacyHolderProp];
        }
        for (var p in locale) 
          {
            if (typeof target[p] !== 'function') 
            target[p] = locale[p];
          }
      }
    }
    cls.activeLocaleId = localeId;
    if (cls.onLocalized) 
    cls.onLocalized();
  }
};
    if (classNames) 
    {
      if (!Ext.isArray(classNames)) 
      classNames = [classNames];
      var name, cls;
      for (i = 0 , l = classNames.length; i < l; i++) 
        {
          if (Ext.isObject(classNames[i])) 
          {
            if (classNames[i].singleton) 
            {
              cls = classNames[i];
              name = Ext.getClassName(Ext.getClass(cls));
            } else {
              cls = Ext.getClass(classNames[i]);
              name = Ext.getClassName(cls);
            }
          } else {
            cls = null;
            name = 'string' === typeof classNames[i] ? classNames[i] : Ext.getClassName(classNames[i]);
          }
          if (name && name in this.l10n) 
          {
            applyToClass(name, cls);
          }
        }
    } else {
      Sch.locale.Active[this.namespaceId] = this;
      for (var clsName in this.l10n) 
        {
          applyToClass(clsName);
        }
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Sch.locale, 'Locale'], 0));
;

(Ext.cmd.derive('Sch.locale.En', Sch.locale.Locale, {singleton: true, constructor: function(config) {
  Ext.apply(this, {l10n: {'Sch.util.Date': {unitNames: {YEAR: {single: 'year', plural: 'years', abbrev: 'yr'}, QUARTER: {single: 'quarter', plural: 'quarters', abbrev: 'q'}, MONTH: {single: 'month', plural: 'months', abbrev: 'mon'}, WEEK: {single: 'week', plural: 'weeks', abbrev: 'w'}, DAY: {single: 'day', plural: 'days', abbrev: 'd'}, HOUR: {single: 'hour', plural: 'hours', abbrev: 'h'}, MINUTE: {single: 'minute', plural: 'minutes', abbrev: 'min'}, SECOND: {single: 'second', plural: 'seconds', abbrev: 's'}, MILLI: {single: 'ms', plural: 'ms', abbrev: 'ms'}}}, 'Sch.panel.TimelineGridPanel': {loadingText: 'Loading, please wait...', savingText: 'Saving changes, please wait...'}, 'Sch.panel.TimelineTreePanel': {loadingText: 'Loading, please wait...', savingText: 'Saving changes, please wait...'}, 'Sch.mixin.SchedulerView': {loadingText: 'Loading events...'}, 'Sch.plugin.CurrentTimeLine': {tooltipText: 'Current time'}, 'Sch.plugin.EventEditor': {saveText: 'Save', deleteText: 'Delete', cancelText: 'Cancel'}, 'Sch.plugin.SimpleEditor': {newEventText: 'New booking...'}, 'Sch.widget.ExportDialog': {generalError: 'An error occured, try again.', title: 'Export Settings', formatFieldLabel: 'Paper format', orientationFieldLabel: 'Orientation', rangeFieldLabel: 'Export range', showHeaderLabel: 'Add page number', showFooterLabel: 'Add footer', orientationPortraitText: 'Portrait', orientationLandscapeText: 'Landscape', completeViewText: 'Complete schedule', currentViewText: 'Current view', dateRangeText: 'Date range', dateRangeFromText: 'Export from', pickerText: 'Resize column/rows to desired value', dateRangeToText: 'Export to', exportButtonText: 'Export', cancelButtonText: 'Cancel', progressBarText: 'Exporting...', exportersFieldLabel: 'Export mode', adjustCols: 'Adjust column width', adjustColsAndRows: 'Adjust column width and row height', specifyDateRange: 'Specify date range'}, 'Sch.plugin.Export': {fetchingRows: 'Fetching row {0} of {1}', builtPage: 'Built page {0} of {1}', requestingPrintServer: 'Please wait...'}, 'Sch.plugin.exporter.AbstractExporter': {name: 'Exporter'}, 'Sch.plugin.exporter.SinglePage': {name: 'Single page'}, 'Sch.plugin.exporter.MultiPageVertical': {name: 'Multiple pages (vertically)'}, 'Sch.plugin.exporter.MultiPage': {name: 'Multiple pages'}, 'Sch.preset.Manager': {hourAndDay: {displayDateFormat: 'G:i', middleDateFormat: 'G:i', topDateFormat: 'D d/m'}, secondAndMinute: {displayDateFormat: 'g:i:s', topDateFormat: 'D, d g:iA'}, dayAndWeek: {displayDateFormat: 'm/d h:i A', middleDateFormat: 'D d M'}, weekAndDay: {displayDateFormat: 'm/d', bottomDateFormat: 'd M', middleDateFormat: 'Y F d'}, weekAndMonth: {displayDateFormat: 'm/d/Y', middleDateFormat: 'm/d', topDateFormat: 'm/d/Y'}, weekAndDayLetter: {displayDateFormat: 'm/d/Y', middleDateFormat: 'D d M Y'}, weekDateAndMonth: {displayDateFormat: 'm/d/Y', middleDateFormat: 'd', topDateFormat: 'Y F'}, monthAndYear: {displayDateFormat: 'm/d/Y', middleDateFormat: 'M Y', topDateFormat: 'Y'}, year: {displayDateFormat: 'm/d/Y', middleDateFormat: 'Y'}, manyYears: {displayDateFormat: 'm/d/Y', middleDateFormat: 'Y'}}}});
  this.callParent(arguments);
}}, 1, 0, 0, 0, 0, 0, [Sch.locale, 'En'], 0));
;

(Ext.cmd.derive('Sch.mixin.Localizable', Ext.Base, {legacyMode: true, activeLocaleId: '', l10n: null, isLocaleApplied: function() {
  var activeLocaleId = (this.singleton && this.activeLocaleId) || this.self.activeLocaleId;
  if (!activeLocaleId) 
  return false;
  for (var ns in Sch.locale.Active) 
    {
      if (activeLocaleId === Sch.locale.Active[ns].self.getName()) 
      return true;
    }
  return false;
}, applyLocale: function() {
  for (var ns in Sch.locale.Active) 
    {
      Sch.locale.Active[ns].apply(this.singleton ? this : this.self.getName());
    }
}, L: function() {
  return this.localize.apply(this, arguments);
}, localize: function(id, legacyHolderProp, skipLocalizedCheck) {
  if (!this.isLocaleApplied() && !skipLocalizedCheck) 
  {
    this.applyLocale();
  }
  if (this.hasOwnProperty('l10n') && this.l10n.hasOwnProperty(id) && 'function' != typeof this.l10n[id]) 
  return this.l10n[id];
  var clsProto = this.self && this.self.prototype;
  if (this.legacyMode) 
  {
    var prop = legacyHolderProp || this.legacyHolderProp;
    var instHolder = prop ? this[prop] : this;
    if (instHolder && instHolder.hasOwnProperty(id) && 'function' != typeof instHolder[id]) 
    return instHolder[id];
    if (clsProto) 
    {
      var clsHolder = prop ? clsProto[prop] : clsProto;
      if (clsHolder && clsHolder.hasOwnProperty(id) && 'function' != typeof clsHolder[id]) 
      return clsHolder[id];
    }
  }
  var result = clsProto.l10n && clsProto.l10n[id];
  if (result === null || result === undefined) 
  {
    var superClass = clsProto && clsProto.superclass;
    if (superClass && superClass.localize) 
    {
      result = superClass.localize(id, legacyHolderProp, skipLocalizedCheck);
    }
    if (result === null || result === undefined) 
    throw 'Cannot find locale: ' + id + ' [' + this.self.getName() + ']';
  }
  return result;
}}, 0, 0, 0, 0, 0, 0, [Sch.mixin, 'Localizable'], 0));
;

(Ext.cmd.derive('Sch.util.Date', Ext.Base, {singleton: true, stripEscapeRe: /(\\.)/g, hourInfoRe: /([gGhHisucUOPZ]|MS)/, unitHash: null, unitsByName: {}, constructor: function() {
  var ED = Ext.Date;
  var unitHash = this.unitHash = {MILLI: ED.MILLI, SECOND: ED.SECOND, MINUTE: ED.MINUTE, HOUR: ED.HOUR, DAY: ED.DAY, WEEK: "w", MONTH: ED.MONTH, QUARTER: "q", YEAR: ED.YEAR};
  Ext.apply(this, unitHash);
  var me = this;
  this.units = [me.MILLI, me.SECOND, me.MINUTE, me.HOUR, me.DAY, me.WEEK, me.MONTH, me.QUARTER, me.YEAR];
}, onLocalized: function() {
  this.setUnitNames(this.L('unitNames'));
}, setUnitNames: function(unitNames, preserveLocales) {
  var unitsByName = this.unitsByName = {};
  this.l10n.unitNames = unitNames;
  this._unitNames = Ext.apply({}, unitNames);
  var unitHash = this.unitHash;
  for (var name in unitHash) 
    {
      if (unitHash.hasOwnProperty(name)) 
      {
        var unitValue = unitHash[name];
        this._unitNames[unitValue] = this._unitNames[name];
        unitsByName[name] = unitValue;
        unitsByName[unitValue] = unitValue;
      }
    }
}, betweenLesser: function(date, start, end) {
  var t = date.getTime();
  return start.getTime() <= t && t < end.getTime();
}, constrain: function(date, min, max) {
  return this.min(this.max(date, min), max);
}, compareUnits: function(u1, u2) {
  var ind1 = Ext.Array.indexOf(this.units, u1), ind2 = Ext.Array.indexOf(this.units, u2);
  return ind1 > ind2 ? 1 : (ind1 < ind2 ? -1 : 0);
}, isUnitGreater: function(u1, u2) {
  return this.compareUnits(u1, u2) > 0;
}, copyTimeValues: function(targetDate, sourceDate) {
  targetDate.setHours(sourceDate.getHours());
  targetDate.setMinutes(sourceDate.getMinutes());
  targetDate.setSeconds(sourceDate.getSeconds());
  targetDate.setMilliseconds(sourceDate.getMilliseconds());
}, add: function(date, unit, value) {
  var d = Ext.Date.clone(date);
  if (!unit || value === 0) 
  return d;
  switch (unit.toLowerCase()) {
    case this.MILLI:
      d = new Date(date.getTime() + value);
      break;
    case this.SECOND:
      d = new Date(date.getTime() + (value * 1000));
      break;
    case this.MINUTE:
      d = new Date(date.getTime() + (value * 60000));
      break;
    case this.HOUR:
      d = new Date(date.getTime() + (value * 3600000));
      break;
    case this.DAY:
      d.setDate(date.getDate() + value);
      if (d.getHours() === 23 && date.getHours() === 0) 
      {
        d = Ext.Date.add(d, Ext.Date.HOUR, 1);
      }
      break;
    case this.WEEK:
      d.setDate(date.getDate() + value * 7);
      break;
    case this.MONTH:
      var day = date.getDate();
      if (day > 28) 
      {
        day = Math.min(day, Ext.Date.getLastDateOfMonth(this.add(Ext.Date.getFirstDateOfMonth(date), this.MONTH, value)).getDate());
      }
      d.setDate(day);
      d.setMonth(d.getMonth() + value);
      break;
    case this.QUARTER:
      d = this.add(date, this.MONTH, value * 3);
      break;
    case this.YEAR:
      d.setFullYear(date.getFullYear() + value);
      break;
  }
  return d;
}, getUnitDurationInMs: function(unit) {
  return this.add(new Date(1, 0, 1), unit, 1) - new Date(1, 0, 1);
}, getMeasuringUnit: function(unit) {
  if (unit === this.WEEK) 
  {
    return this.DAY;
  }
  return unit;
}, getDurationInUnit: function(start, end, unit, doNotRound) {
  var units;
  switch (unit) {
    case this.YEAR:
      units = this.getDurationInYears(start, end);
      break;
    case this.QUARTER:
      units = this.getDurationInMonths(start, end) / 3;
      break;
    case this.MONTH:
      units = this.getDurationInMonths(start, end);
      break;
    case this.WEEK:
      units = this.getDurationInDays(start, end) / 7;
      break;
    case this.DAY:
      units = this.getDurationInDays(start, end);
      break;
    case this.HOUR:
      units = this.getDurationInHours(start, end);
      break;
    case this.MINUTE:
      units = this.getDurationInMinutes(start, end);
      break;
    case this.SECOND:
      units = this.getDurationInSeconds(start, end);
      break;
    case this.MILLI:
      units = this.getDurationInMilliseconds(start, end);
      break;
  }
  return doNotRound ? units : Math.round(units);
}, getUnitToBaseUnitRatio: function(baseUnit, unit) {
  if (baseUnit === unit) 
  {
    return 1;
  }
  switch (baseUnit) {
    case this.YEAR:
      switch (unit) {
        case this.QUARTER:
          return 1 / 4;
        case this.MONTH:
          return 1 / 12;
      }
      break;
    case this.QUARTER:
      switch (unit) {
        case this.YEAR:
          return 4;
        case this.MONTH:
          return 1 / 3;
      }
      break;
    case this.MONTH:
      switch (unit) {
        case this.YEAR:
          return 12;
        case this.QUARTER:
          return 3;
      }
      break;
    case this.WEEK:
      switch (unit) {
        case this.DAY:
          return 1 / 7;
        case this.HOUR:
          return 1 / 168;
      }
      break;
    case this.DAY:
      switch (unit) {
        case this.WEEK:
          return 7;
        case this.HOUR:
          return 1 / 24;
        case this.MINUTE:
          return 1 / 1440;
      }
      break;
    case this.HOUR:
      switch (unit) {
        case this.DAY:
          return 24;
        case this.MINUTE:
          return 1 / 60;
      }
      break;
    case this.MINUTE:
      switch (unit) {
        case this.HOUR:
          return 60;
        case this.SECOND:
          return 1 / 60;
        case this.MILLI:
          return 1 / 60000;
      }
      break;
    case this.SECOND:
      switch (unit) {
        case this.MILLI:
          return 1 / 1000;
      }
      break;
    case this.MILLI:
      switch (unit) {
        case this.SECOND:
          return 1000;
      }
      break;
  }
  return -1;
}, getDurationInMilliseconds: function(start, end) {
  return (end - start);
}, getDurationInSeconds: function(start, end) {
  return (end - start) / 1000;
}, getDurationInMinutes: function(start, end) {
  return (end - start) / 60000;
}, getDurationInHours: function(start, end) {
  return (end - start) / 3600000;
}, getDurationInDays: function(start, end) {
  var dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
  return (end - start + dstDiff * 60 * 1000) / 86400000;
}, getDurationInBusinessDays: function(start, end) {
  var nbrDays = Math.round((end - start) / 86400000), nbrBusinessDays = 0, d;
  for (var i = 0; i < nbrDays; i++) 
    {
      d = this.add(start, this.DAY, i).getDay();
      if (d !== 6 && d !== 0) 
      {
        nbrBusinessDays++;
      }
    }
  return nbrBusinessDays;
}, getDurationInMonths: function(start, end) {
  return ((end.getFullYear() - start.getFullYear()) * 12) + (end.getMonth() - start.getMonth());
}, getDurationInYears: function(start, end) {
  return this.getDurationInMonths(start, end) / 12;
}, min: function(d1, d2) {
  return d1 < d2 ? d1 : d2;
}, max: function(d1, d2) {
  return d1 > d2 ? d1 : d2;
}, intersectSpans: function(date1Start, date1End, date2Start, date2End) {
  return this.betweenLesser(date1Start, date2Start, date2End) || this.betweenLesser(date2Start, date1Start, date1End);
}, getNameOfUnit: function(unit) {
  unit = this.getUnitByName(unit);
  switch (unit.toLowerCase()) {
    case this.YEAR:
      return 'YEAR';
    case this.QUARTER:
      return 'QUARTER';
    case this.MONTH:
      return 'MONTH';
    case this.WEEK:
      return 'WEEK';
    case this.DAY:
      return 'DAY';
    case this.HOUR:
      return 'HOUR';
    case this.MINUTE:
      return 'MINUTE';
    case this.SECOND:
      return 'SECOND';
    case this.MILLI:
      return 'MILLI';
  }
  throw "Incorrect UnitName";
}, getReadableNameOfUnit: function(unit, plural) {
  if (!this.isLocaleApplied()) 
  this.applyLocale();
  return this._unitNames[unit][plural ? 'plural' : 'single'];
}, getShortNameOfUnit: function(unit) {
  if (!this.isLocaleApplied()) 
  this.applyLocale();
  return this._unitNames[unit].abbrev;
}, getUnitByName: function(name) {
  if (!this.isLocaleApplied()) 
  this.applyLocale();
  if (!this.unitsByName[name]) 
  {
    Ext.Error.raise('Unknown unit name: ' + name);
  }
  return this.unitsByName[name];
}, getNext: function(date, unit, increment, weekStartDay) {
  var dt = Ext.Date.clone(date);
  weekStartDay = arguments.length < 4 ? 1 : weekStartDay;
  increment = increment == null ? 1 : increment;
  switch (unit) {
    case this.MILLI:
      dt = this.add(date, unit, increment);
      break;
    case this.SECOND:
      dt = this.add(date, unit, increment);
      if (dt.getMilliseconds() > 0) 
      {
        dt.setMilliseconds(0);
      }
      break;
    case this.MINUTE:
      dt = this.add(date, unit, increment);
      if (dt.getSeconds() > 0) 
      {
        dt.setSeconds(0);
      }
      if (dt.getMilliseconds() > 0) 
      {
        dt.setMilliseconds(0);
      }
      break;
    case this.HOUR:
      dt = this.add(date, unit, increment);
      if (dt.getMinutes() > 0) 
      {
        dt.setMinutes(0);
      }
      if (dt.getSeconds() > 0) 
      {
        dt.setSeconds(0);
      }
      if (dt.getMilliseconds() > 0) 
      {
        dt.setMilliseconds(0);
      }
      break;
    case this.DAY:
      var midnightNotInTimeScale = date.getHours() === 23 && this.add(dt, this.HOUR, 1).getHours() === 1;
      if (midnightNotInTimeScale) 
      {
        dt = this.add(dt, this.DAY, 2);
        this.clearTime(dt);
        return dt;
      }
      this.clearTime(dt);
      dt = this.add(dt, this.DAY, increment);
      if (dt.getHours() === 1) 
      {
        this.clearTime(dt);
      }
      break;
    case this.WEEK:
      this.clearTime(dt);
      var day = dt.getDay();
      dt = this.add(dt, this.DAY, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)));
      if (dt.getDay() !== weekStartDay) 
      {
        dt = this.add(dt, this.HOUR, 1);
      } else {
        this.clearTime(dt);
      }
      break;
    case this.MONTH:
      dt = this.add(dt, this.MONTH, increment);
      dt.setDate(1);
      this.clearTime(dt);
      break;
    case this.QUARTER:
      dt = this.add(dt, this.MONTH, ((increment - 1) * 3) + (3 - (dt.getMonth() % 3)));
      this.clearTime(dt);
      dt.setDate(1);
      break;
    case this.YEAR:
      dt = new Date(dt.getFullYear() + increment, 0, 1);
      break;
    default:
      throw 'Invalid date unit';
  }
  return dt;
}, getNumberOfMsFromTheStartOfDay: function(date) {
  return date - this.clearTime(date, true) || 86400000;
}, getNumberOfMsTillTheEndOfDay: function(date) {
  return this.getStartOfNextDay(date, true) - date;
}, getStartOfNextDay: function(date, clone, noNeedToClearTime) {
  var nextDay = this.add(noNeedToClearTime ? date : this.clearTime(date, clone), this.DAY, 1);
  if (nextDay.getDate() == date.getDate()) 
  {
    var offsetNextDay = this.add(this.clearTime(date, clone), this.DAY, 2).getTimezoneOffset();
    var offsetDate = date.getTimezoneOffset();
    nextDay = this.add(nextDay, this.MINUTE, offsetDate - offsetNextDay);
  }
  return nextDay;
}, getEndOfPreviousDay: function(date, noNeedToClearTime) {
  var dateOnly = noNeedToClearTime ? date : this.clearTime(date, true);
  if (dateOnly - date) 
  {
    return dateOnly;
  } else {
    return this.add(dateOnly, this.DAY, -1);
  }
}, timeSpanContains: function(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
  return (otherSpanStart - spanStart) >= 0 && (spanEnd - otherSpanEnd) >= 0;
}, compareWithPrecision: function(date1, date2, precisionUnit) {
  var D = Sch.util.Date, ED = Ext.Date, result;
  switch (precisionUnit) {
    case D.DAY:
      date1 = Number(ED.format(date1, 'Ymd'));
      date2 = Number(ED.format(date2, 'Ymd'));
      break;
    case D.WEEK:
      date1 = Number(ED.format(date1, 'YmW'));
      date2 = Number(ED.format(date2, 'YmW'));
      break;
    case D.MONTH:
      date1 = Number(ED.format(date1, 'Ym'));
      date2 = Number(ED.format(date2, 'Ym'));
      break;
    case D.QUARTER:
      date1 = date1.getFullYear() * 4 + Math.floor(date1.getMonth() / 3);
      date2 = date2.getFullYear() * 4 + Math.floor(date2.getMonth() / 3);
      break;
    case D.YEAR:
      date1 = date1.getFullYear();
      date2 = date2.getFullYear();
      break;
    default:
    case D.MILLI:
    case D.SECOND:
    case D.MINUTE:
    case D.HOUR:
      precisionUnit = precisionUnit && this.getUnitDurationInMs(precisionUnit) || 1;
      date1 = Math.floor(date1.valueOf() / precisionUnit);
      date2 = Math.floor(date2.valueOf() / precisionUnit);
      break;
  }
  ((date1 < date2) && (result = -1)) || ((date1 > date2) && (result = +1)) || (result = 0);
  return result;
}, getValueInUnits: function(date, unit) {
  switch (unit) {
    case this.MONTH:
      return date.getMonth();
    case this.DAY:
      return date.getDate();
    case this.HOUR:
      return date.getHours();
    case this.MINUTE:
      return date.getMinutes();
    case this.SECOND:
      return date.getSeconds();
  }
}, setValueInUnits: function(date, unit, value) {
  var result = Ext.Date.clone(date), f;
  switch (unit) {
    case this.YEAR:
      f = 'setFullYear';
      break;
    case this.MONTH:
      f = 'setMonth';
      break;
    case this.DAY:
      f = 'setDate';
      break;
    case this.HOUR:
      f = 'setHours';
      break;
    case this.MINUTE:
      f = 'setMinutes';
      break;
    case this.SECOND:
      f = 'setSeconds';
      break;
    case this.MILLI:
      f = 'setMilliseconds';
      break;
  }
  result[f](value);
  return result;
}, getSubUnit: function(unit) {
  switch (unit) {
    case this.YEAR:
      return this.MONTH;
    case this.MONTH:
      return this.DAY;
    case this.DAY:
      return this.HOUR;
    case this.HOUR:
      return this.MINUTE;
    case this.MINUTE:
      return this.SECOND;
    case this.SECOND:
      return this.MILLI;
  }
}, setValueInSubUnits: function(date, unit, value) {
  unit = this.getSubUnit(unit);
  return this.setValueInUnits(date, unit, value);
}, mergeDates: function(target, source, unit) {
  var copy = Ext.Date.clone(target);
  switch (unit) {
    case this.YEAR:
      copy.setFullYear(source.getFullYear());
    case this.MONTH:
      copy.setMonth(source.getMonth());
    case this.WEEK:
    case this.DAY:
      if (unit === this.WEEK) 
      {
        copy = this.add(copy, this.DAY, source.getDay() - copy.getDay());
      } else {
        copy.setDate(source.getDate());
      }
    case this.HOUR:
      copy.setHours(source.getHours());
    case this.MINUTE:
      copy.setMinutes(source.getMinutes());
    case this.SECOND:
      copy.setSeconds(source.getSeconds());
    case this.MILLI:
      copy.setMilliseconds(source.getMilliseconds());
  }
  return copy;
}, splitToSubUnits: function(start, unit, increment, weekStartDay) {
  increment = increment || 1;
  weekStartDay = arguments.length < 4 ? 1 : weekStartDay;
  switch (unit) {
    case this.MONTH:
      return this.splitMonth(start, increment, weekStartDay);
    case this.WEEK:
    case this.DAY:
      return this.splitDay(start, increment);
    default:
      break;
  }
}, splitYear: function(start, increment) {
  var newStart = this.clearTime(start, true);
  newStart.setMonth(0);
  newStart.setDate(1);
  var result = [];
  for (var i = 0; i <= 12; i = i + increment) 
    {
      result.push(this.add(newStart, this.MONTH, i));
    }
  return result;
}, splitMonth: function(start, increment, weekStartDay) {
  var newStart = this.clearTime(start, true);
  newStart.setDate(1);
  newStart = this.add(newStart, this.DAY, weekStartDay - newStart.getDay());
  var currentDate = Ext.Date.clone(newStart);
  var monthEnd = this.add(newStart, this.MONTH, 1);
  var result = [];
  for (var i = 0; currentDate.getTime() < monthEnd.getTime(); i = i + increment) 
    {
      currentDate = this.add(newStart, this.WEEK, i);
      result.push(currentDate);
    }
  return result;
}, splitWeek: function(start, increment, weekStartDay) {
  var newStart = this.add(start, this.DAY, weekStartDay - start.getDay());
  newStart = this.clearTime(newStart);
  var result = [];
  for (var i = 0; i <= 7; i = i + increment) 
    {
      result.push(this.add(newStart, this.DAY, i));
    }
  return result;
}, splitDay: function(start, increment) {
  var copy = this.clearTime(start, true);
  var result = [];
  for (var i = 0; i <= 24; i = i + increment) 
    {
      result.push(this.add(copy, this.HOUR, i));
    }
  return result;
}, splitHour: function(start, increment) {
  var copy = new Date(start.getTime());
  copy.setMinutes(0);
  copy.setSeconds(0);
  copy.setMilliseconds(0);
  var result = [];
  for (var i = 0; i <= 60; i = i + increment) 
    {
      result.push(this.add(copy, this.MINUTE, i));
    }
  return result;
}, splitMinute: function(start, increment) {
  var copy = Ext.Date.clone(start);
  copy.setSeconds(0);
  copy.setMilliseconds(0);
  var result = [];
  for (var i = 0; i <= 60; i = i + increment) 
    {
      result.push(this.add(copy, this.SECOND, i));
    }
  return result;
}, clearTime: function(dt, clone) {
  if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0) 
  {
    return Ext.Date.clearTime(dt, clone);
  }
  return clone ? Ext.Date.clone(dt) : dt;
}}, 1, 0, 0, 0, 0, [[Sch.mixin.Localizable.prototype.mixinId || Sch.mixin.Localizable.$className, Sch.mixin.Localizable]], [Sch.util, 'Date'], 0));
;

if (!Ext.ClassManager.get("Sch.model.Customizable")) 
{
  (Ext.cmd.derive('Sch.model.Customizable', Ext.data.Model, {idProperty: null, customizableFields: null, previous: null, __editing: null, __editCounter: 0, constructor: function() {
  var retVal = this.callParent(arguments);
  return retVal;
}, onClassExtended: function(cls, data, hooks) {
  var onBeforeCreated = hooks.onBeforeCreated;
  hooks.onBeforeCreated = function(cls, data) {
  onBeforeCreated.apply(this, arguments);
  var proto = cls.prototype;
  if (!proto.customizableFields) 
  {
    return;
  }
  proto.customizableFields = (cls.superclass.customizableFields || []).concat(proto.customizableFields);
  var customizableFields = proto.customizableFields;
  var customizableFieldsByName = {};
  Ext.Array.each(customizableFields, function(field) {
  if (typeof field == 'string') 
  field = {name: field};
  customizableFieldsByName[field.name] = field;
});
  var fields = proto.fields;
  var toRemove = [];
  fields.each(function(field) {
  if (field.isCustomizableField) 
  toRemove.push(field);
});
  fields.removeAll(toRemove);
  Ext.Object.each(customizableFieldsByName, function(name, customizableField) {
  customizableField.isCustomizableField = true;
  var stableFieldName = customizableField.name || customizableField.getName();
  var fieldProperty = stableFieldName === 'Id' ? 'idProperty' : stableFieldName.charAt(0).toLowerCase() + stableFieldName.substr(1) + 'Field';
  var overrideFieldName = proto[fieldProperty];
  var realFieldName = overrideFieldName || stableFieldName;
  var field;
  if (fields.containsKey(realFieldName)) 
  {
    field = Ext.applyIf({name: stableFieldName, isCustomizableField: true}, fields.getByKey(realFieldName));
    fields.getByKey(realFieldName).isCustomizableField = true;
    field = new Ext.data.Field(field);
    customizableFields.push(field);
  } else {
    field = Ext.applyIf({name: realFieldName, isCustomizableField: true}, customizableField);
    field = new Ext.data.Field(field);
    fields.add(realFieldName, field);
  }
  var capitalizedStableName = Ext.String.capitalize(stableFieldName);
  if (capitalizedStableName != 'Id') 
  {
    var getter = 'get' + capitalizedStableName;
    var setter = 'set' + capitalizedStableName;
    if (!proto[getter] || proto[getter].__getterFor__ && proto[getter].__getterFor__ != realFieldName) 
    {
      proto[getter] = function() {
  return this.get(realFieldName);
};
      proto[getter].__getterFor__ = realFieldName;
    }
    if (!proto[setter] || proto[setter].__setterFor__ && proto[setter].__setterFor__ != realFieldName) 
    {
      proto[setter] = function(value) {
  return this.set(realFieldName, value);
};
      proto[setter].__setterFor__ = realFieldName;
    }
  }
});
};
}, set: function(fieldName, value) {
  var currentValue;
  var field;
  var retVal;
  this.previous = this.previous || {};
  if (arguments.length > 1) 
  {
    currentValue = this.get(fieldName);
    if (currentValue instanceof Date && !(value instanceof Date)) 
    {
      field = this.fields.get(fieldName);
      value = (field.convert || field.getConvert()).call(field, value, this);
    }
    if ((currentValue instanceof Date && (currentValue - value)) || !(currentValue instanceof Date) && currentValue !== value) 
    {
      this.previous[fieldName] = currentValue;
    }
  } else {
    for (var o in fieldName) 
      {
        currentValue = this.get(o);
        var newValue = fieldName[o];
        if (currentValue instanceof Date && !(newValue instanceof Date)) 
        {
          field = this.fields.get(o);
          newValue = (field.convert || field.getConvert()).call(field, newValue, this);
        }
        if ((currentValue instanceof Date && (currentValue - newValue)) || !(currentValue instanceof Date) && currentValue !== newValue) 
        {
          this.previous[o] = currentValue;
        }
      }
  }
  retVal = this.callParent(arguments);
  if (!this.__editing) 
  {
    delete this.previous;
  }
  return retVal;
}, reject: function() {
  var me = this, modified = me.modified, field;
  me.__editing = true;
  me.previous = me.previous || {};
  for (field in modified) 
    {
      if (modified.hasOwnProperty(field)) 
      {
        if (typeof modified[field] != "function") 
        {
          me.previous[field] = me.get(field);
        }
      }
    }
  me.callParent(arguments);
  delete me.previous;
  me.__editing = false;
}, beginEdit: function() {
  this.__editCounter++;
  this.__editing = true;
  this.callParent(arguments);
}, cancelEdit: function() {
  this.__editCounter = 0;
  this.__editing = false;
  this.callParent(arguments);
  delete this.previous;
}, endEdit: function(silent, modifiedFieldNames) {
  if (--this.__editCounter === 0) 
  {
    if (!silent && this.getModifiedFieldNames) 
    {
      if (!modifiedFieldNames) 
      {
        modifiedFieldNames = this.getModifiedFieldNames();
      }
      if (modifiedFieldNames && modifiedFieldNames.length === 0) 
      {
        silent = true;
      }
    }
    this.callParent([silent].concat(Array.prototype.slice.call(arguments, 1)));
    this.__editing = false;
    delete this.previous;
  }
}}, 1, 0, 0, 0, 0, 0, [Sch.model, 'Customizable'], 0));
;
}

(Ext.cmd.derive('Sch.model.Range', Sch.model.Customizable, {idProperty: 'Id', config: Ext.versions.touch ? {idProperty: 'Id'} : null, startDateField: 'StartDate', endDateField: 'EndDate', nameField: 'Name', clsField: 'Cls', customizableFields: [{name: 'StartDate', type: 'date', dateFormat: 'c'}, {name: 'EndDate', type: 'date', dateFormat: 'c'}, {name: 'Cls', type: 'string'}, {name: 'Name', type: 'string'}], setStartDate: function(date, keepDuration) {
  var endDate = this.getEndDate();
  var oldStart = this.getStartDate();
  this.set(this.startDateField, date);
  if (keepDuration === true && endDate && oldStart) 
  {
    this.setEndDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, endDate - oldStart));
  }
}, setEndDate: function(date, keepDuration) {
  var startDate = this.getStartDate();
  var oldEnd = this.getEndDate();
  this.set(this.endDateField, date);
  if (keepDuration === true && startDate && oldEnd) 
  {
    this.setStartDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, -(oldEnd - startDate)));
  }
}, setStartEndDate: function(start, end) {
  var needToWrap = !this.editing;
  needToWrap && this.beginEdit();
  this.set(this.startDateField, start);
  this.set(this.endDateField, end);
  needToWrap && this.endEdit();
}, getDates: function() {
  var dates = [], endDate = this.getEndDate();
  for (var date = Sch.util.Date.clearTime(this.getStartDate(), true); date < endDate; date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1)) 
    {
      dates.push(date);
    }
  return dates;
}, forEachDate: function(func, scope) {
  return Ext.each(this.getDates(), func, scope);
}, isValid: function() {
  var valid = this.callParent(arguments);
  if (valid) 
  {
    var start = this.getStartDate(), end = this.getEndDate();
    valid = !start || !end || (end - start >= 0);
  }
  return valid;
}, shift: function(unit, amount) {
  this.setStartEndDate(Sch.util.Date.add(this.getStartDate(), unit, amount), Sch.util.Date.add(this.getEndDate(), unit, amount));
}, fullCopy: function() {
  return this.copy.apply(this, arguments);
}}, 0, 0, 0, 0, 0, 0, [Sch.model, 'Range'], 0));
;

(Ext.cmd.derive('Sch.model.Event', Sch.model.Range, {customizableFields: [{name: 'Id'}, {name: 'ResourceId'}, {name: 'Draggable', type: 'boolean', persist: false, defaultValue: true}, {name: 'Resizable', persist: false, defaultValue: true}], resourceIdField: 'ResourceId', draggableField: 'Draggable', resizableField: 'Resizable', getResource: function(resourceId, eventStore) {
  if (this.stores && this.stores.length > 0 || eventStore) 
  {
    var rs = (eventStore || this.stores[0]).getResourceStore();
    resourceId = resourceId || this.get(this.resourceIdField);
    if (Ext.data.TreeStore && rs instanceof Ext.data.TreeStore) 
    {
      return rs.getNodeById(resourceId) || rs.getRootNode().findChildBy(function(r) {
  return r.internalId === resourceId;
});
    } else {
      return rs.getById(resourceId) || rs.data.map[resourceId];
    }
  }
  return null;
}, setResource: function(resourceOrId) {
  this.set(this.resourceIdField, (resourceOrId instanceof Ext.data.Model) ? resourceOrId.getId() || resourceOrId.internalId : resourceOrId);
}, assign: function(resourceOrId) {
  this.setResource.apply(this, arguments);
}, unassign: function(resourceOrId) {
}, isDraggable: function() {
  return this.getDraggable();
}, isAssignedTo: function(resource) {
  return this.getResource() === resource;
}, isResizable: function() {
  return this.getResizable();
}, isPersistable: function() {
  var resources = this.getResources();
  var persistable = true;
  Ext.each(resources, function(r) {
  if (r.phantom) 
  {
    persistable = false;
    return false;
  }
});
  return persistable;
}, forEachResource: function(fn, scope) {
  var rs = this.getResources();
  for (var i = 0; i < rs.length; i++) 
    {
      if (fn.call(scope || this, rs[i]) === false) 
      {
        return;
      }
    }
}, getResources: function(eventStore) {
  var resource = this.getResource(null, eventStore);
  return resource ? [resource] : [];
}}, 0, 0, 0, 0, 0, 0, [Sch.model, 'Event'], 0));
;

(Ext.cmd.derive('Sdc.locale.UrlValidator', Ext.Base, {baseUrl: null, webMethodUrl: null, url: {}, constructor: function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
}, setBaseUrl: function(baseUrl) {
  var me = this;
  if (!baseUrl) 
  {
    return false;
  }
  me.baseUrl = baseUrl;
  return true;
}, setWebMethodUrl: function(webMethodUrl) {
  var me = this;
  if (!webMethodUrl) 
  {
    return false;
  }
  me.webMethodUrl = webMethodUrl;
  return true;
}, getUrlPath: function(urlKey, params) {
  var me = this;
  var result = '', queryString = '';
  var clsProto = this.self && this.self.prototype;
  if (clsProto.url && clsProto.url[urlKey]) 
  {
    var urlCfg = clsProto.url[urlKey], firstElement = true;
    if (urlCfg) 
    {
      var queryStringKey = urlCfg.queryStringKey;
      for (var key in params) 
        {
          if (queryStringKey.hasOwnProperty(key) && queryStringKey[key]) 
          {
            if (firstElement) 
            {
              firstElement = false;
            } else {
              queryString = queryString + '&';
            }
            queryString = queryString + key + '=' + params[key];
          }
        }
    }
    if (urlCfg.webMethod) 
    {
      if (me.webMethodUrl) 
      {
        result = me.webMethodUrl;
      }
    } else {
      if (me.baseUrl) 
      {
        result = me.baseUrl;
      }
    }
    result = result + urlCfg.path;
    if (queryString) 
    {
      result = result + '?' + queryString;
    }
  }
  return result;
}}, 1, 0, 0, 0, 0, 0, [Sdc.locale, 'UrlValidator'], 0));
;

(Ext.cmd.derive('Sdc.locale.Url', Sdc.locale.UrlValidator, {singleton: true, baseUrl: null, url: {serviceOrder: {path: 'pages/FS/fs300100.aspx', queryStringKey: {SrvOrdType: true, RefNbr: true}}, crmCases: {path: 'pages/CR/cr306000.aspx', queryStringKey: {CaseCD: true}}, saleOrder: {path: 'pages/SO/so301000.aspx', queryStringKey: {OrderType: true, OrderNbr: true}}, cloneAppointment: {path: 'pages/FS/fs500201.aspx', queryStringKey: {SrvOrdType: true, RefNbr: true}}, appointment: {path: 'pages/FS/fs300200.aspx', queryStringKey: {SrvOrdType: true, sORefNbr: true, RefNbr: true}}, employee: {path: 'pages/EP/ep203000.aspx', queryStringKey: {bAccountID: true}}, singleEmpDispatch: {path: 'pages/FS/calendars/SingleEmpDispatch/fs300400.aspx', queryStringKey: {bAccountID: true, Date: true}}, appointmentInquiry: {path: 'pages/FS/fs400100.aspx', queryStringKey: {}}, employeeScheduler: {path: 'pages/FS/fs202200.aspx', queryStringKey: {EmployeeID: true, RecordID: true, DateStart: true, TimeStart: true, DateEnd: true, TimeEnd: true}}, appointmentBridge: {path: 'pages/FS/fs200000.aspx', queryStringKey: {ProcessID: true}}, newAppointmentBridge: {path: '/NewAppointmentBridge', webMethod: true, queryStringKey: {appointment: true, sODetIDList: true, employeeIDList: true}}, newWrkSchedulerBridge: {path: '/NewWrkSchedulerBridge', webMethod: true, queryStringKey: {wrkEmployeeSchedule: true}}, getSetup: {path: '/GetSetups', webMethod: true, queryStringKey: {}}, getCalendarFieldPreferences: {path: '/GetCustomFieldAppointments', webMethod: true, queryStringKey: {isActive: true}}, getCalendarStatusPreferences: {path: '/GetCustomAppointmentStatuses', webMethod: true, queryStringKey: {isActive: true}}}, constructor: function() {
  var me = this;
  me.callParent(arguments);
}}, 1, 0, 0, 0, 0, 0, [Sdc.locale, 'Url'], 0));
;

(Ext.cmd.derive('Sdc.data.mixin.AbstractDecodeMessages', Ext.Base, {decodeErrors: function(response, defaultMessage) {
  try {
    var jsonResponse = Ext.decode(response), responseData = jsonResponse, errors = responseData.Messages.ErrorMessages, i, message = "";
    for (i = 0; i < errors.length; ++i) 
      {
        message += "- " + errors[i] + "<br/>";
      }
  }  catch (error) {
  message = defaultMessage;
}
  Ext.MessageBox.show({title: Titles.error, msg: message, buttons: Ext.MessageBox.OK, icon: Ext.MessageBox.ERROR});
}, decodeWarnings: function(response, window) {
  try {
    var jsonResponse = Ext.decode(response), responseData = jsonResponse, warnings = responseData.Messages.WarningMessages, i, message = "";
    for (i = 0; i < warnings.length; ++i) 
      {
        message += "- " + warnings[i] + "<br/>";
      }
  }  catch (error) {
}
  if (message === "") 
  {
    if (window && window.hide) 
    {
      window.hide();
    }
  } else {
    Ext.MessageBox.show({title: Titles.warning, msg: message, buttons: Ext.MessageBox.OK, icon: Ext.MessageBox.WARNING, fn: function(button, text) {
  Ext.MessageBox.hide();
  if (window && window.hide) 
  {
    window.hide();
  }
}});
  }
}}, 0, 0, 0, 0, 0, 0, [Sdc.data.mixin, 'AbstractDecodeMessages'], 0));
;

(Ext.cmd.derive('Sdc.util.PopUpManager', Ext.Base, {singleton: true, paramsOptions: {toolbar: 0, location: 0, menubar: 0, width: 960, height: 700}, lastAppointment: null, lastAvailability: null, sODetIDList: [], employeeIDList: [], constructor: function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
}, getWindowConfiguration: function(config) {
  var me = this, result = '', option, i = 1, length;
  length = (me.paramsOptions) ? Object.keys(me.paramsOptions).length : 0;
  for (var key in me.paramsOptions) 
    {
      option = key + '=' + ((config && config.hasOwnProperty(key)) ? config[key] : me.paramsOptions[key]);
      result = result + option + ((length > i) ? ',' : '');
      ++i;
    }
  return result;
}, openPageUrl: function(pageID, params, popupCfg, fn, refreshParams) {
  if (!pageID) 
  {
    throw 'Cannot Open Page, missing Url ID';
  }
  if (pageID === 'newAppointmentBridgeID') 
  {
    me.newAppointmentBridgeID(params, popupCfg, fn, refreshParams);
    return;
  }
  var me = this;
  var urlPath = Sdc.locale.Url.getUrlPath(pageID, params);
  if (!urlPath) 
  {
    throw 'Url ID cannot be found in the system: ' + pageID;
  }
  var newWindow = window.open(urlPath, 'pop', me.getWindowConfiguration(popupCfg));
  if (!fn) 
  {
    return;
  }
  var interval = window.setInterval(function() {
  try {
    if (newWindow == null || newWindow.closed) 
    {
      window.clearInterval(interval);
      fn(refreshParams);
    }
  }  catch (e) {
}
}, 1000);
}, newAppointmentBridgeID: function(params, popupCfg, fn, refreshParams) {
  var me = this;
  var values = me.getAppointmentPageParams(params);
  if (values) 
  {
    Ext.Ajax.request({url: Sdc.locale.Url.getUrlPath('newAppointmentBridge', null), method: 'POST', headers: {'Content-Type': 'application/json'}, jsonData: values, success: function(response) {
  var jsonResponse = Ext.decode(response.responseText);
  if (jsonResponse.Result && jsonResponse.Result.Rows.length > 0) 
  {
    var wrkProcess = jsonResponse.Result.Rows[0];
    var callParams = {ProcessID: wrkProcess.ProcessID};
    Sdc.util.PopUpManager.openPageUrl('appointmentBridge', callParams, popupCfg, fn, refreshParams);
  }
}, failure: function(response) {
  console.log('server-side failure with status code ' + response.status);
  me.decodeErrors(response, response.statusText);
}});
  }
}, newWrkSchedulerBridgeID: function(params, popupCfg, fn, refreshParams) {
  var me = this;
  var values = me.getWrkSchedulerPageParams(params);
  if (values) 
  {
    Ext.Ajax.request({url: Sdc.locale.Url.getUrlPath('newWrkSchedulerBridge', null), method: 'POST', headers: {'Content-Type': 'application/json'}, jsonData: values, success: function(response) {
  var jsonResponse = Ext.decode(response.responseText);
  if (jsonResponse.Result && jsonResponse.Result.Rows.length > 0) 
  {
    var wrkProcess = jsonResponse.Result.Rows[0];
    var callParams = {ProcessID: wrkProcess.ProcessID};
    Sdc.util.PopUpManager.openPageUrl('appointmentBridge', callParams, popupCfg, fn, refreshParams);
  }
}, failure: function(response) {
  console.log('server-side failure with status code ' + response.status);
}});
  }
}, getWrkSchedulerPageParams: function(values) {
  var me = this;
  if (values) 
  {
    var obj = null;
    if (!me.lastAvailability) 
    {
      me.lastAvailability = Ext.create('Sdc.model.Availability');
    } else {
      me.lastAvailability.reject();
    }
    var availability = me.lastAvailability;
    if (values.TimeStart) 
    {
      availability.set('TimeStart', new Date(values.TimeStart));
    }
    if (values.TimeEnd) 
    {
      availability.set('TimeEnd', new Date(values.TimeEnd));
    }
    if (values.EmployeeID) 
    {
      availability.set('EmployeeID', values.EmployeeID);
    }
    if (values.BranchID) 
    {
      availability.set('BranchID', values.BranchID);
    }
    if (values.BranchLocationID) 
    {
      availability.set('BranchLocationID', values.BranchLocationID);
    }
    obj = {wrkEmployeeSchedule: availability.data};
    return obj;
  } else {
    return null;
  }
}, getAppointmentPageParams: function(values) {
  var me = this;
  if (values) 
  {
    var obj = null;
    if (!me.lastAppointment) 
    {
      me.lastAppointment = Ext.create('Sdc.model.Appointment');
    } else {
      me.lastAppointment.reject();
      me.sODetIDList = [];
      me.employeeIDList = [];
    }
    var appointment = me.lastAppointment;
    if (values.SOID) 
    {
      appointment.set('SOID', values.SOID);
    }
    if (values.RoomID) 
    {
      appointment.set('RoomID', values.RoomID);
    }
    if (values.SrvOrdType) 
    {
      appointment.set('SrvOrdType', values.SrvOrdType);
    }
    if (values.ScheduledDateTimeBegin && (values.ScheduledDateTimeBegin instanceof Date)) 
    {
      appointment.set('ScheduledDateTimeBegin', values.ScheduledDateTimeBegin);
    }
    if (values.ScheduledDateTimeEnd && (values.ScheduledDateTimeEnd instanceof Date)) 
    {
      appointment.set('ScheduledDateTimeEnd', values.ScheduledDateTimeEnd);
    }
    if (values.SODetIDList && (values.SODetIDList instanceof Array)) 
    {
      me.sODetIDList = values.SODetIDList;
    }
    if (values.BranchID) 
    {
      appointment.set('BranchID', values.BranchID);
    }
    if (values.BranchLocationID) 
    {
      appointment.set('BranchLocationID', values.BranchLocationID);
    }
    if (values.CustomerID) 
    {
      appointment.set('CustomerID', values.CustomerID);
    }
    if (values.SMequipmentID) 
    {
      appointment.set('SMequipmentID', values.SMequipmentID);
    }
    if (values.EmployeeIDList && (values.EmployeeIDList instanceof Array)) 
    {
      me.employeeIDList = values.EmployeeIDList;
    }
    obj = {appointment: appointment.data, sODetIDList: me.sODetIDList, employeeIDList: me.employeeIDList};
    return obj;
  } else {
    return null;
  }
}}, 1, 0, 0, 0, 0, [['DecodeMessages', Sdc.data.mixin.AbstractDecodeMessages]], [Sdc.util, 'PopUpManager'], 0));
;

(Ext.cmd.derive('Sdc.util.AbstractColor', Ext.Base, {constructor: function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
}, hsvToRgb: function(h, s, v) {
  var me = this;
  if (h instanceof Array) 
  {
    return me.hsvToRgb.call(this, h[0], h[1], h[2]);
  }
  if (h == 360) 
  h = 0;
  var computedR = 0;
  var computedG = 0;
  var computedB = 0;
  var i, f, p, q, t;
  i = Math.floor((h / 60) % 6);
  f = (h / 60) - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);
  switch (i) {
    case 0:
      computedR = v , computedG = t , computedB = p;
      break;
    case 1:
      computedR = q , computedG = v , computedB = p;
      break;
    case 2:
      computedR = p , computedG = v , computedB = t;
      break;
    case 3:
      computedR = p , computedG = q , computedB = v;
      break;
    case 4:
      computedR = t , computedG = p , computedB = v;
      break;
    case 5:
      computedR = v , computedG = p , computedB = q;
      break;
  }
  return [me.realToDec(computedR), me.realToDec(computedG), me.realToDec(computedB)];
}, realToDec: function(n) {
  return Math.round(n * 255);
}, invert: function(r, g, b) {
  if (r instanceof Array) 
  {
    return this.invert.call(this, r[0], r[1], r[2]);
  }
  return [255 - r, 255 - g, 255 - b];
}, hexToRgb: function(hex) {
  var me = this;
  var r, g, b;
  r = parseInt((me.cutHex(hex)).substring(0, 2), 16);
  g = parseInt((me.cutHex(hex)).substring(2, 4), 16);
  b = parseInt((me.cutHex(hex)).substring(4, 6), 16);
  return [r, g, b];
}, cutHex: function(hex) {
  return (hex.charAt(0) == "#") ? hex.substring(1, 7) : hex;
}, rgbToHex: function(r, g, b) {
  var me = this;
  if (r instanceof Array) 
  return me.rgbToHex.call(me, r[0], r[1], r[2]);
  return me.toHex(r) + me.toHex(g) + me.toHex(b);
}, toHex: function(n) {
  n = parseInt(n, 10);
  if (isNaN(n)) 
  return "00";
  n = Math.max(0, Math.min(n, 255));
  return "0123456789ABCDEF".charAt((n - n % 16) / 16) + "0123456789ABCDEF".charAt(n % 16);
}, rgbToHsv: function(r, g, b) {
  if (r instanceof Array) 
  return this.rgbToHsv.call(this, r[0], r[1], r[2]);
  var me = this;
  var computedH = 0;
  var computedS = 0;
  var computedV = 0;
  var r = parseInt(('' + r).replace(/\s/g, ''), 10);
  var g = parseInt(('' + g).replace(/\s/g, ''), 10);
  var b = parseInt(('' + b).replace(/\s/g, ''), 10);
  if (!me.isValidRgbColor(r, g, b)) 
  {
    return;
  }
  r = r / 255;
  g = g / 255;
  b = b / 255;
  var minRGB = Math.min(r, Math.min(g, b));
  var maxRGB = Math.max(r, Math.max(g, b));
  if (minRGB == maxRGB) 
  {
    computedV = minRGB;
    return [0, 0, computedV];
  }
  var d = (r == minRGB) ? g - b : ((b == minRGB) ? r - g : b - r);
  var h = (r == minRGB) ? 3 : ((b == minRGB) ? 1 : 5);
  computedH = 60 * (h - d / (maxRGB - minRGB));
  computedS = (maxRGB - minRGB) / maxRGB;
  computedV = maxRGB;
  return [computedH, computedS, computedV];
}, isValidRgbColor: function(r, g, b) {
  var me = this;
  if (r instanceof Array) 
  return me.isValidRgbColor.call(this, r[0], r[1], r[2]);
  var r = parseInt(('' + r).replace(/\s/g, ''), 10);
  var g = parseInt(('' + g).replace(/\s/g, ''), 10);
  var b = parseInt(('' + b).replace(/\s/g, ''), 10);
  if (r == null || g == null || b == null || isNaN(r) || isNaN(g) || isNaN(b)) 
  {
    return false;
  }
  if (r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255) 
  {
    return false;
  }
  return true;
}, isValidHsvComponent: function(h, s, v) {
  var me = this;
  if (h instanceof Array) 
  return me.isValidHsvComponent.call(this, h[0], s[1], v[2]);
  var h = parseFloat(('' + h).replace(/\s/g, ''));
  var s = parseFloat(('' + s).replace(/\s/g, ''));
  var v = parseFloat(('' + v).replace(/\s/g, ''));
  if (h == null || s == null || v == null || isNaN(h) || isNaN(s) || isNaN(v)) 
  {
    return false;
  }
  if (h < 0 || s < 0 || v < 0 || h > 360 || s > 1 || v > 1) 
  {
    return false;
  }
  return true;
}}, 1, 0, 0, 0, 0, 0, [Sdc.util, 'AbstractColor'], 0));
;

(Ext.cmd.derive('Sdc.locale.SchedulerSetup', Ext.Base, {singleton: true, baseUrl: null, appResizePrecision: 30, dfltBranchID: null, dfltCalendarStartTime: null, calendarFieldPreferences: null, calendarStatusPreferences: null, showServiceOrderDaysGap: null, constructor: function(cfg) {
  var me = this;
  Ext.apply(me, cfg || {});
  me.callParent(arguments);
}, loadCalendarPreferences: function() {
  var me = this;
  Ext.Ajax.request({url: Sdc.locale.Url.getUrlPath('getCalendarFieldPreferences', {isActive: true}), async: false, headers: {'Content-type': 'application/json; charset=utf-8'}, success: function(response, opts) {
  var jsonResponse = Ext.decode(response.responseText);
  me.calendarFieldPreferences = null;
  if (jsonResponse && jsonResponse.Result && jsonResponse.Result.Rows) 
  {
    me.calendarFieldPreferences = jsonResponse.Result.Rows;
  }
}, failure: function(response, opts) {
  console.log('server-side failure with status code ' + response.status);
}});
  Ext.Ajax.request({url: Sdc.locale.Url.getUrlPath('getCalendarStatusPreferences'), async: false, headers: {'Content-type': 'application/json; charset=utf-8'}, success: function(response, opts) {
  var jsonResponse = Ext.decode(response.responseText);
  me.calendarStatusPreferences = null;
  if (jsonResponse && jsonResponse.Result && jsonResponse.Result.Rows) 
  {
    me.calendarStatusPreferences = jsonResponse.Result.Rows;
  }
}, failure: function(response, opts) {
  console.log('server-side failure with status code ' + response.status);
}});
}, loadSetupConfiguration: function() {
  var me = this;
  Ext.Ajax.request({url: Sdc.locale.Url.getUrlPath('getSetup', null), async: false, headers: {'Content-type': 'application/json; charset=utf-8'}, success: function(response, opts) {
  var jsonResponse = Ext.decode(response.responseText), setup = null, userPreferences = null;
  if (jsonResponse && jsonResponse.Result && jsonResponse.Result.Rows[0]) 
  {
    setup = jsonResponse.Result.Rows[0];
    if (jsonResponse.Result.Rows[1]) 
    {
      userPreferences = jsonResponse.Result.Rows[1];
    }
  }
  if (setup) 
  {
    var appointment = setup.CustomAppointmentName, employee = setup.CustomEmployeeName, branchLocation = setup.CustomBranchLocationName;
    me.updateCustomNames(appointment, employee, branchLocation);
    if (setup.AppResizePrecision > 0) 
    {
      Sdc.locale.SchedulerSetup.appResizePrecision = setup.AppResizePrecision;
    }
    if (userPreferences) 
    {
      Sdc.locale.SchedulerSetup.dfltBranchLocationID = userPreferences.DfltBranchLocationID;
    }
    Sdc.locale.SchedulerSetup.dfltBranchID = setup.DfltBranchID;
    Sdc.locale.SchedulerSetup.dfltCalendarStartTime = setup.CustomDfltCalendarStartTime;
    Sdc.locale.SchedulerSetup.showServiceOrderDaysGap = setup.ShowServiceOrderDaysGap;
  } else {
    Ext.MessageBox.show({title: Titles.alert, msg: Messages.alertSetupNotDefined, minWidth: 500, icon: Ext.MessageBox.WARNING, buttons: Ext.Msg.YES});
  }
}, failure: function(response, opts) {
  console.log('server-side failure with status code ' + response.status);
}});
}, getCalendarStatusColor: function(status) {
  var me = this;
  var color;
  var textColor;
  var i;
  var style;
  for (i = 0; i < me.calendarStatusPreferences.length; i++) 
    {
      if (status == me.calendarStatusPreferences[i].FieldName.toLowerCase()) 
      break;
    }
  ;
  var a = me.hexToRgb(me.calendarStatusPreferences[i].BackgroundColor.substring(1, 7));
  var b = me.hexToRgb(me.calendarStatusPreferences[i].TextColor.substring(1, 7));
  var style = 'background: rgba({0}, {1}, {2}, 0.75) !important;' + 'background-color: rgba({0}, {1}, {2}, 0.75) !important;' + 'border-top-color : #ffffff;' + 'border-bottom-color : #ffffff;' + 'border-left-color : #ffffff !important;' + 'border-right-color : #ffffff !important;' + 'color: rgba({3}, {4}, {5}, 1) !important;';
  return Ext.String.format(style, a[0], a[1], a[2], b[0], b[1], b[2]);
}, updateCustomNames: function(appointmentText, employeeText, branchLocationText) {
  var me = this;
  var appointment = 'Appointment';
  var employee = 'Staff';
  var branchLocation = 'Branch Location';
  var maxLength = 20;
  if (appointmentText && appointmentText != '') 
  {
    me.replaceCustomName(appointmentText, Ext.util.Format.ellipsis(appointment, maxLength), FieldsLabel);
    me.replaceCustomName(appointmentText, Ext.util.Format.ellipsis(appointment, maxLength), Titles);
    me.replaceCustomName(appointmentText, appointment, Messages);
  }
  if (employeeText && employeeText != '') 
  {
    me.replaceCustomName(employeeText, Ext.util.Format.ellipsis(employee, maxLength), FieldsLabel);
    me.replaceCustomName(employeeText, Ext.util.Format.ellipsis(employee, maxLength), Titles);
    me.replaceCustomName(employeeText, employee, Messages);
  }
  if (branchLocationText && branchLocationText != '') 
  {
    me.replaceCustomName(branchLocationText, Ext.util.Format.ellipsis(branchLocation, maxLength), FieldsLabel);
    me.replaceCustomName(branchLocationText, Ext.util.Format.ellipsis(branchLocation, maxLength), Titles);
    me.replaceCustomName(branchLocationText, branchLocation, Messages);
  }
}, replaceCustomName: function(newValue, oldValue, object) {
  var me = this;
  for (var key in object) 
    {
      var value = object[key];
      if ((typeof value) == 'string') 
      {
        object[key] = value.replace(oldValue, newValue);
      }
    }
  if (me.title) 
  {
    me.title = me.title.replace(oldValue, newValue);
  }
}}, 1, 0, 0, 0, 0, [[Sdc.util.AbstractColor.prototype.mixinId || Sdc.util.AbstractColor.$className, Sdc.util.AbstractColor]], [Sdc.locale, 'SchedulerSetup'], 0));
;

(Ext.cmd.derive('Sdc.controller.SchedulerController', Ext.app.Controller, {initComponent: function() {
  var me = this;
  me.callParent(arguments);
}, constructor: function(cfg) {
  var me = this;
  Sdc.locale.Url.setBaseUrl(baseUrl);
  Sdc.locale.Url.setWebMethodUrl(pageUrl);
  Ext.apply(me, cfg || {});
  me.callParent(cfg);
  Sdc.locale.SchedulerSetup.title = me.title;
  Sdc.locale.SchedulerSetup.loadSetupConfiguration();
  Sdc.locale.SchedulerSetup.loadCalendarPreferences();
}}, 1, 0, 0, 0, 0, 0, [Sdc.controller, 'SchedulerController'], 0));
;

Ext.override(Ext.form.field.ComboBox, {findRecord: function(field, value) {
  var foundRec = null;
  Ext.each(this.lastSelection, function(rec) {
  if (rec.get(field) === value) 
  {
    foundRec = rec;
    return false;
  }
});
  if (foundRec) 
  {
    return foundRec;
  } else {
    return this.callParent(arguments);
  }
}});
(Ext.cmd.derive('Ext.ux.form.field.BoxSelect', Ext.form.field.ComboBox, {multiSelect: true, forceSelection: true, createNewOnEnter: false, createNewOnBlur: false, encodeSubmitValue: false, triggerOnClick: true, stacked: false, pinList: true, filterPickList: false, selectOnFocus: true, grow: true, growMin: false, growMax: false, fieldSubTpl: ['<div id="{cmpId}-listWrapper" class="x-boxselect {fieldCls} {typeCls}">', '<ul id="{cmpId}-itemList" class="x-boxselect-list">', '<li id="{cmpId}-inputElCt" class="x-boxselect-input">', '<input id="{cmpId}-inputEl" type="{type}" ', '<tpl if="name">name="{name}" </tpl>', '<tpl if="value"> value="{[Ext.util.Format.htmlEncode(values.value)]}"</tpl>', '<tpl if="size">size="{size}" </tpl>', '<tpl if="tabIdx">tabIndex="{tabIdx}" </tpl>', '<tpl if="disabled"> disabled="disabled"</tpl>', 'class="x-boxselect-input-field {inputElCls}" autocomplete="off">', '</li>', '</ul>', '</div>', {compiled: true, disableFormats: true}], childEls: ['listWrapper', 'itemList', 'inputEl', 'inputElCt'], componentLayout: 'boxselectfield', initComponent: function() {
  var me = this, typeAhead = me.typeAhead;
  if (typeAhead && !me.editable) 
  {
    Ext.Error.raise('If typeAhead is enabled the combo must be editable: true -- please change one of those settings.');
  }
  Ext.apply(me, {typeAhead: false});
  me.callParent();
  me.typeAhead = typeAhead;
  me.selectionModel = new Ext.selection.Model({store: me.valueStore, mode: 'MULTI', lastFocused: null, onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
  commitFn();
}});
  if (!Ext.isEmpty(me.delimiter) && me.multiSelect) 
  {
    me.delimiterRegexp = new RegExp(String(me.delimiter).replace(/[$%()*+.?\[\\\]{|}]/g, "\\$&"));
  }
}, initEvents: function() {
  var me = this;
  me.callParent(arguments);
  if (!me.enableKeyEvents) 
  {
    me.mon(me.inputEl, 'keydown', me.onKeyDown, me);
  }
  me.mon(me.inputEl, 'paste', me.onPaste, me);
  me.mon(me.listWrapper, 'click', me.onItemListClick, me);
  me.mon(me.selectionModel, {'selectionchange': function(selModel, selectedRecs) {
  me.applyMultiselectItemMarkup();
  me.fireEvent('valueselectionchange', me, selectedRecs);
}, 'focuschange': function(selectionModel, oldFocused, newFocused) {
  me.fireEvent('valuefocuschange', me, oldFocused, newFocused);
}, scope: me});
}, onBindStore: function(store, initial) {
  var me = this;
  if (store) 
  {
    me.valueStore = new Ext.data.Store({model: store.model, proxy: {type: 'memory'}});
    me.mon(me.valueStore, 'datachanged', me.applyMultiselectItemMarkup, me);
    if (me.selectionModel) 
    {
      me.selectionModel.bindStore(me.valueStore);
    }
  }
}, onUnbindStore: function(store) {
  var me = this, valueStore = me.valueStore;
  if (valueStore) 
  {
    if (me.selectionModel) 
    {
      me.selectionModel.setLastFocused(null);
      me.selectionModel.deselectAll();
      me.selectionModel.bindStore(null);
    }
    me.mun(valueStore, 'datachanged', me.applyMultiselectItemMarkup, me);
    valueStore.destroy();
    me.valueStore = null;
  }
  me.callParent(arguments);
}, createPicker: function() {
  var me = this, picker = me.callParent(arguments);
  me.mon(picker, {'beforerefresh': me.onBeforeListRefresh, scope: me});
  if (me.filterPickList) 
  {
    picker.addCls('x-boxselect-hideselections');
  }
  return picker;
}, onDestroy: function() {
  var me = this;
  Ext.destroyMembers(me, 'valueStore', 'selectionModel');
  me.callParent(arguments);
}, getSubTplData: function() {
  var me = this, data = me.callParent(), isEmpty = me.emptyText && data.value.length < 1;
  if (isEmpty) 
  {
    data.value = me.emptyText;
  } else {
    data.value = '';
  }
  data.inputElCls = data.fieldCls.match(me.emptyCls) ? me.emptyCls : '';
  return data;
}, afterRender: function() {
  var me = this;
  if (Ext.supports.Placeholder && me.inputEl && me.emptyText) 
  {
    delete me.inputEl.dom.placeholder;
  }
  me.bodyEl.applyStyles('vertical-align:top');
  if (me.grow) 
  {
    if (Ext.isNumber(me.growMin) && (me.growMin > 0)) 
    {
      me.listWrapper.applyStyles('min-height:' + me.growMin + 'px');
    }
    if (Ext.isNumber(me.growMax) && (me.growMax > 0)) 
    {
      me.listWrapper.applyStyles('max-height:' + me.growMax + 'px');
    }
  }
  if (me.stacked === true) 
  {
    me.itemList.addCls('x-boxselect-stacked');
  }
  if (!me.multiSelect) 
  {
    me.itemList.addCls('x-boxselect-singleselect');
  }
  me.applyMultiselectItemMarkup();
  me.callParent(arguments);
}, findRecord: function(field, value) {
  var ds = this.store, matches;
  if (!ds) 
  {
    return false;
  }
  matches = ds.queryBy(function(rec, id) {
  return rec.isEqual(rec.get(field), value);
});
  return (matches.getCount() > 0) ? matches.first() : false;
}, onLoad: function() {
  var me = this, valueField = me.valueField, valueStore = me.valueStore, changed = false;
  if (valueStore) 
  {
    if (!Ext.isEmpty(me.value) && (valueStore.getCount() == 0)) 
    {
      me.setValue(me.value, false, true);
    }
    valueStore.suspendEvents();
    valueStore.each(function(rec) {
  var r = me.findRecord(valueField, rec.get(valueField)), i = r ? valueStore.indexOf(rec) : -1;
  if (i >= 0) 
  {
    valueStore.removeAt(i);
    valueStore.insert(i, r);
    changed = true;
  }
});
    valueStore.resumeEvents();
    if (changed) 
    {
      valueStore.fireEvent('datachanged', valueStore);
    }
  }
  me.callParent(arguments);
}, isFilteredRecord: function(record) {
  var me = this, store = me.store, valueField = me.valueField, storeRecord, filtered = false;
  storeRecord = store.findExact(valueField, record.get(valueField));
  filtered = ((storeRecord === -1) && (!store.snapshot || (me.findRecord(valueField, record.get(valueField)) !== false)));
  filtered = filtered || (!filtered && (storeRecord === -1) && (me.forceSelection !== true) && (me.valueStore.findExact(valueField, record.get(valueField)) >= 0));
  return filtered;
}, doRawQuery: function() {
  var me = this, rawValue = me.inputEl.dom.value;
  if (me.multiSelect) 
  {
    rawValue = rawValue.split(me.delimiter).pop();
  }
  this.doQuery(rawValue, false, true);
}, onBeforeListRefresh: function() {
  this.ignoreSelection++;
}, onListRefresh: function() {
  this.callParent(arguments);
  if (this.ignoreSelection > 0) 
  {
    --this.ignoreSelection;
  }
}, onListSelectionChange: function(list, selectedRecords) {
  var me = this, valueStore = me.valueStore, mergedRecords = [], i;
  if ((me.ignoreSelection <= 0) && me.isExpanded) 
  {
    valueStore.each(function(rec) {
  if (Ext.Array.contains(selectedRecords, rec) || me.isFilteredRecord(rec)) 
  {
    mergedRecords.push(rec);
  }
});
    mergedRecords = Ext.Array.merge(mergedRecords, selectedRecords);
    i = Ext.Array.intersect(mergedRecords, valueStore.getRange()).length;
    if ((i != mergedRecords.length) || (i != me.valueStore.getCount())) 
    {
      me.setValue(mergedRecords, false);
      if (!me.multiSelect || !me.pinList) 
      {
        Ext.defer(me.collapse, 1, me);
      }
      if (valueStore.getCount() > 0) 
      {
        me.fireEvent('select', me, valueStore.getRange());
      }
    }
    me.inputEl.focus();
    if (!me.pinList) 
    {
      me.inputEl.dom.value = '';
    }
    if (me.selectOnFocus) 
    {
      me.inputEl.dom.select();
    }
  }
}, syncSelection: function() {
  var me = this, picker = me.picker, valueField = me.valueField, pickStore, selection, selModel;
  if (picker) 
  {
    pickStore = picker.store;
    selection = [];
    if (me.valueStore) 
    {
      me.valueStore.each(function(rec) {
  var i = pickStore.findExact(valueField, rec.get(valueField));
  if (i >= 0) 
  {
    selection.push(pickStore.getAt(i));
  }
});
    }
    me.ignoreSelection++;
    selModel = picker.getSelectionModel();
    selModel.deselectAll();
    if (selection.length > 0) 
    {
      selModel.select(selection);
    }
    if (me.ignoreSelection > 0) 
    {
      --me.ignoreSelection;
    }
  }
}, doAlign: function() {
  var me = this, picker = me.picker, aboveSfx = '-above', isAbove;
  me.picker.alignTo(me.listWrapper, me.pickerAlign, me.pickerOffset);
  isAbove = picker.el.getY() < me.inputEl.getY();
  me.bodyEl[isAbove ? 'addCls' : 'removeCls'](me.openCls + aboveSfx);
  picker[isAbove ? 'addCls' : 'removeCls'](picker.baseCls + aboveSfx);
}, alignPicker: function() {
  var me = this, picker = me.picker, pickerScrollPos = picker.getTargetEl().dom.scrollTop;
  me.callParent(arguments);
  if (me.isExpanded) 
  {
    if (me.matchFieldWidth) 
    {
      picker.setWidth(me.listWrapper.getWidth());
    }
    picker.getTargetEl().dom.scrollTop = pickerScrollPos;
  }
}, getCursorPosition: function() {
  var cursorPos;
  if (Ext.isIE) 
  {
    cursorPos = document.selection.createRange();
    cursorPos.collapse(true);
    cursorPos.moveStart("character", -this.inputEl.dom.value.length);
    cursorPos = cursorPos.text.length;
  } else {
    cursorPos = this.inputEl.dom.selectionStart;
  }
  return cursorPos;
}, hasSelectedText: function() {
  var sel, range;
  if (Ext.isIE) 
  {
    sel = document.selection;
    range = sel.createRange();
    return (range.parentElement() == this.inputEl.dom);
  } else {
    return this.inputEl.dom.selectionStart != this.inputEl.dom.selectionEnd;
  }
}, onKeyDown: function(e, t) {
  var me = this, key = e.getKey(), rawValue = me.inputEl.dom.value, valueStore = me.valueStore, selModel = me.selectionModel, stopEvent = false;
  if (me.readOnly || me.disabled || !me.editable) 
  {
    return;
  }
  if (me.isExpanded && (key == e.A && e.ctrlKey)) 
  {
    me.select(me.getStore().getRange());
    selModel.setLastFocused(null);
    selModel.deselectAll();
    me.collapse();
    me.inputEl.focus();
    stopEvent = true;
  } else if ((valueStore.getCount() > 0) && ((rawValue == '') || ((me.getCursorPosition() === 0) && !me.hasSelectedText()))) 
  {
    var lastSelectionIndex = (selModel.getCount() > 0) ? valueStore.indexOf(selModel.getLastSelected() || selModel.getLastFocused()) : -1;
    if ((key == e.BACKSPACE) || (key == e.DELETE)) 
    {
      if (lastSelectionIndex > -1) 
      {
        if (selModel.getCount() > 1) 
        {
          lastSelectionIndex = -1;
        }
        me.valueStore.remove(selModel.getSelection());
      } else {
        me.valueStore.remove(me.valueStore.last());
      }
      selModel.clearSelections();
      me.setValue(me.valueStore.getRange());
      if (lastSelectionIndex > 0) 
      {
        selModel.select(lastSelectionIndex - 1);
      }
      stopEvent = true;
    } else if ((key == e.RIGHT) || (key == e.LEFT)) 
    {
      if ((lastSelectionIndex == -1) && (key == e.LEFT)) 
      {
        selModel.select(valueStore.last());
        stopEvent = true;
      } else if (lastSelectionIndex > -1) 
      {
        if (key == e.RIGHT) 
        {
          if (lastSelectionIndex < (valueStore.getCount() - 1)) 
          {
            selModel.select(lastSelectionIndex + 1, e.shiftKey);
            stopEvent = true;
          } else if (!e.shiftKey) 
          {
            selModel.setLastFocused(null);
            selModel.deselectAll();
            stopEvent = true;
          }
        } else if ((key == e.LEFT) && (lastSelectionIndex > 0)) 
        {
          selModel.select(lastSelectionIndex - 1, e.shiftKey);
          stopEvent = true;
        }
      }
    } else if (key == e.A && e.ctrlKey) 
    {
      selModel.selectAll();
      stopEvent = e.A;
    }
    me.inputEl.focus();
  }
  if (stopEvent) 
  {
    me.preventKeyUpEvent = stopEvent;
    e.stopEvent();
    return;
  }
  if (me.isExpanded && (key == e.ENTER) && me.picker.highlightedItem) 
  {
    me.preventKeyUpEvent = true;
  }
  if (me.enableKeyEvents) 
  {
    me.callParent(arguments);
  }
  if (!e.isSpecialKey() && !e.hasModifier()) 
  {
    me.selectionModel.setLastFocused(null);
    me.selectionModel.deselectAll();
    me.inputEl.focus();
  }
}, onKeyUp: function(e, t) {
  var me = this, rawValue = me.inputEl.dom.value;
  if (me.preventKeyUpEvent) 
  {
    e.stopEvent();
    if ((me.preventKeyUpEvent === true) || (e.getKey() === me.preventKeyUpEvent)) 
    {
      delete me.preventKeyUpEvent;
    }
    return;
  }
  if (me.multiSelect && (me.delimiterRegexp && me.delimiterRegexp.test(rawValue)) || ((me.createNewOnEnter === true) && e.getKey() == e.ENTER)) 
  {
    rawValue = Ext.Array.clean(rawValue.split(me.delimiterRegexp));
    me.inputEl.dom.value = '';
    me.setValue(me.valueStore.getRange().concat(rawValue));
    me.inputEl.focus();
  }
  me.callParent([e, t]);
}, onPaste: function(e, t) {
  var me = this, rawValue = me.inputEl.dom.value, clipboard = (e && e.browserEvent && e.browserEvent.clipboardData) ? e.browserEvent.clipboardData : false;
  if (me.multiSelect && (me.delimiterRegexp && me.delimiterRegexp.test(rawValue))) 
  {
    if (clipboard && clipboard.getData) 
    {
      if (/text\/plain/.test(clipboard.types)) 
      {
        rawValue = clipboard.getData('text/plain');
      } else if (/text\/html/.test(clipboard.types)) 
      {
        rawValue = clipboard.getData('text/html');
      }
    }
    rawValue = Ext.Array.clean(rawValue.split(me.delimiterRegexp));
    me.inputEl.dom.value = '';
    me.setValue(me.valueStore.getRange().concat(rawValue));
    me.inputEl.focus();
  }
}, onExpand: function() {
  var me = this, keyNav = me.listKeyNav;
  me.callParent(arguments);
  if (keyNav || !me.filterPickList) 
  {
    return;
  }
  keyNav = me.listKeyNav;
  keyNav.highlightAt = function(index) {
  var boundList = this.boundList, item = boundList.all.item(index), len = boundList.all.getCount(), direction;
  if (item && item.hasCls('x-boundlist-selected')) 
  {
    if ((index == 0) || !boundList.highlightedItem || (boundList.indexOf(boundList.highlightedItem) < index)) 
    {
      direction = 1;
    } else {
      direction = -1;
    }
    do {
      index = index + direction;
      item = boundList.all.item(index);
    } while ((index > 0) && (index < len) && item.hasCls('x-boundlist-selected'));
    if (item.hasCls('x-boundlist-selected')) 
    {
      return;
    }
  }
  if (item) 
  {
    item = item.dom;
    boundList.highlightItem(item);
    boundList.getTargetEl().scrollChildIntoView(item, false);
  }
};
}, onTypeAhead: function() {
  var me = this, displayField = me.displayField, inputElDom = me.inputEl.dom, valueStore = me.valueStore, boundList = me.getPicker(), record, newValue, len, selStart;
  if (me.filterPickList) 
  {
    var fn = this.createFilterFn(displayField, inputElDom.value);
    record = me.store.findBy(function(rec) {
  return ((valueStore.indexOfId(rec.getId()) === -1) && fn(rec));
});
    record = (record === -1) ? false : me.store.getAt(record);
  } else {
    record = me.store.findRecord(displayField, inputElDom.value);
  }
  if (record) 
  {
    newValue = record.get(displayField);
    len = newValue.length;
    selStart = inputElDom.value.length;
    boundList.highlightItem(boundList.getNode(record));
    if (selStart !== 0 && selStart !== len) 
    {
      inputElDom.value = newValue;
      me.selectText(selStart, newValue.length);
    }
  }
}, onItemListClick: function(evt, el, o) {
  var me = this, itemEl = evt.getTarget('.x-boxselect-item'), closeEl = itemEl ? evt.getTarget('.x-boxselect-item-close') : false;
  if (me.readOnly || me.disabled) 
  {
    return;
  }
  evt.stopPropagation();
  if (itemEl) 
  {
    if (closeEl) 
    {
      me.removeByListItemNode(itemEl);
      if (me.valueStore.getCount() > 0) 
      {
        me.fireEvent('select', me, me.valueStore.getRange());
      }
    } else {
      me.toggleSelectionByListItemNode(itemEl, evt.shiftKey);
    }
    me.inputEl.focus();
  } else {
    if (me.selectionModel.getCount() > 0) 
    {
      me.selectionModel.setLastFocused(null);
      me.selectionModel.deselectAll();
    }
    if (me.triggerOnClick) 
    {
      me.onTriggerClick();
    }
  }
}, getMultiSelectItemMarkup: function() {
  var me = this;
  if (!me.multiSelectItemTpl) 
  {
    if (!me.labelTpl) 
    {
      me.labelTpl = Ext.create('Ext.XTemplate', '{[values.' + me.displayField + ']}');
    } else if (Ext.isString(me.labelTpl) || Ext.isArray(me.labelTpl)) 
    {
      me.labelTpl = Ext.create('Ext.XTemplate', me.labelTpl);
    }
    me.multiSelectItemTpl = ['<tpl for=".">', '<li class="x-boxselect-item ', '<tpl if="this.isSelected(values.' + me.valueField + ')">', ' selected', '</tpl>', '" qtip="{[typeof values === "string" ? values : values.' + me.displayField + ']}">', '<div class="x-boxselect-item-text">{[typeof values === "string" ? values : this.getItemLabel(values)]}</div>', '<div class="x-tab-close-btn x-boxselect-item-close"></div>', '</li>', '</tpl>', {compile: true, disableFormats: true, isSelected: function(value) {
  var i = me.valueStore.findExact(me.valueField, value);
  if (i >= 0) 
  {
    return me.selectionModel.isSelected(me.valueStore.getAt(i));
  }
  return false;
}, getItemLabel: function(values) {
  return me.getTpl('labelTpl').apply(values);
}}];
  }
  return this.getTpl('multiSelectItemTpl').apply(Ext.Array.pluck(this.valueStore.getRange(), 'data'));
}, applyMultiselectItemMarkup: function() {
  var me = this, itemList = me.itemList, item;
  if (itemList) 
  {
    while ((item = me.inputElCt.prev()) != null) 
      {
        item.remove();
      }
    me.inputElCt.insertHtml('beforeBegin', me.getMultiSelectItemMarkup());
  }
  Ext.Function.defer(function() {
  if (me.picker && me.isExpanded) 
  {
    me.alignPicker();
  }
  if (me.hasFocus) 
  {
    me.inputElCt.scrollIntoView(me.listWrapper);
  }
}, 15);
}, getRecordByListItemNode: function(itemEl) {
  var me = this, itemIdx = 0, searchEl = me.itemList.dom.firstChild;
  while (searchEl && searchEl.nextSibling) 
    {
      if (searchEl == itemEl) 
      {
        break;
      }
      itemIdx++;
      searchEl = searchEl.nextSibling;
    }
  itemIdx = (searchEl == itemEl) ? itemIdx : false;
  if (itemIdx === false) 
  {
    return false;
  }
  return me.valueStore.getAt(itemIdx);
}, toggleSelectionByListItemNode: function(itemEl, keepExisting) {
  var me = this, rec = me.getRecordByListItemNode(itemEl), selModel = me.selectionModel;
  if (rec) 
  {
    if (selModel.isSelected(rec)) 
    {
      if (selModel.isFocused(rec)) 
      {
        selModel.setLastFocused(null);
      }
      selModel.deselect(rec);
    } else {
      selModel.select(rec, keepExisting);
    }
  }
}, removeByListItemNode: function(itemEl) {
  var me = this, rec = me.getRecordByListItemNode(itemEl);
  if (rec) 
  {
    me.valueStore.remove(rec);
    me.setValue(me.valueStore.getRange());
  }
}, getRawValue: function() {
  var me = this, inputEl = me.inputEl, result;
  me.inputEl = false;
  result = me.callParent(arguments);
  me.inputEl = inputEl;
  return result;
}, setRawValue: function(value) {
  var me = this, inputEl = me.inputEl, result;
  me.inputEl = false;
  result = me.callParent([value]);
  me.inputEl = inputEl;
  return result;
}, addValue: function(value) {
  var me = this;
  if (value) 
  {
    me.setValue(Ext.Array.merge(me.value, Ext.Array.from(value)));
  }
}, removeValue: function(value) {
  var me = this;
  if (value) 
  {
    me.setValue(Ext.Array.difference(me.value, Ext.Array.from(value)));
  }
}, setValue: function(value, doSelect, skipLoad) {
  var me = this, valueStore = me.valueStore, valueField = me.valueField, record, len, i, valueRecord, h, unknownValues = [];
  if (Ext.isEmpty(value)) 
  {
    value = null;
  }
  if (Ext.isString(value) && me.multiSelect) 
  {
    value = value.split(me.delimiter);
  }
  value = Ext.Array.from(value, true);
  for (i = 0 , len = value.length; i < len; i++) 
    {
      record = value[i];
      if (!record || !record.isModel) 
      {
        valueRecord = valueStore.findExact(valueField, record);
        if (valueRecord >= 0) 
        {
          value[i] = valueStore.getAt(valueRecord);
        } else {
          valueRecord = me.findRecord(valueField, record);
          if (!valueRecord) 
          {
            if (me.forceSelection) 
            {
              unknownValues.push(record);
            } else {
              valueRecord = {};
              valueRecord[me.valueField] = record;
              valueRecord[me.displayField] = record;
              valueRecord = new me.valueStore.model(valueRecord);
            }
          }
          if (valueRecord) 
          {
            value[i] = valueRecord;
          }
        }
      }
    }
  if ((skipLoad !== true) && (unknownValues.length > 0) && (me.queryMode === 'remote')) 
  {
    var params = {};
    params[me.valueField] = unknownValues.join(me.delimiter);
    me.store.load({params: params, callback: function() {
  if (me.itemList) 
  {
    me.itemList.unmask();
  }
  me.setValue(value, doSelect, true);
  me.autoSize();
}});
    return false;
  }
  if (!me.multiSelect && (value.length > 0)) 
  {
    for (i = value.length - 1; i >= 0; i--) 
      {
        if (value[i].isModel) 
        {
          value = value[i];
          break;
        }
      }
    if (Ext.isArray(value)) 
    {
      value = value[value.length - 1];
    }
  }
  return me.callParent([value, doSelect]);
}, getValueRecords: function() {
  return this.valueStore.getRange();
}, getSubmitData: function() {
  var me = this, val = me.callParent(arguments);
  if (me.multiSelect && me.encodeSubmitValue && val && val[me.name]) 
  {
    val[me.name] = Ext.encode(val[me.name]);
  }
  return val;
}, mimicBlur: function() {
  var me = this;
  if (me.selectOnTab && me.picker && me.picker.highlightedItem) 
  {
    me.inputEl.dom.value = '';
  }
  me.callParent(arguments);
}, assertValue: function() {
  var me = this, rawValue = me.inputEl.dom.value, rec = !Ext.isEmpty(rawValue) ? me.findRecordByDisplay(rawValue) : false, value = false;
  if (!rec && !me.forceSelection && me.createNewOnBlur && !Ext.isEmpty(rawValue)) 
  {
    value = rawValue;
  } else if (rec) 
  {
    value = rec;
  }
  if (value) 
  {
    me.addValue(value);
  }
  me.inputEl.dom.value = '';
  me.collapse();
}, checkChange: function() {
  if (!this.suspendCheckChange && !this.isDestroyed) 
  {
    var me = this, valueStore = me.valueStore, lastValue = me.lastValue, valueField = me.valueField, newValue = Ext.Array.map(Ext.Array.from(me.value), function(val) {
  if (val.isModel) 
  {
    return val.get(valueField);
  }
  return val;
}, this).join(this.delimiter), isEqual = me.isEqual(newValue, lastValue);
    if (!isEqual || ((newValue.length > 0 && valueStore.getCount() < newValue.length))) 
    {
      valueStore.suspendEvents();
      valueStore.removeAll();
      if (Ext.isArray(me.valueModels)) 
      {
        valueStore.add(me.valueModels);
      }
      valueStore.resumeEvents();
      valueStore.fireEvent('datachanged', valueStore);
      if (!isEqual) 
      {
        me.lastValue = newValue;
        me.fireEvent('change', me, newValue, lastValue);
        me.onChange(newValue, lastValue);
      }
    }
  }
}, isEqual: function(v1, v2) {
  var fromArray = Ext.Array.from, valueField = this.valueField, i, len, t1, t2;
  v1 = fromArray(v1);
  v2 = fromArray(v2);
  len = v1.length;
  if (len !== v2.length) 
  {
    return false;
  }
  for (i = 0; i < len; i++) 
    {
      t1 = v1[i].isModel ? v1[i].get(valueField) : v1[i];
      t2 = v2[i].isModel ? v2[i].get(valueField) : v2[i];
      if (t1 !== t2) 
      {
        return false;
      }
    }
  return true;
}, applyEmptyText: function() {
  var me = this, emptyText = me.emptyText, inputEl, isEmpty;
  if (me.rendered && emptyText) 
  {
    isEmpty = Ext.isEmpty(me.value) && !me.hasFocus;
    inputEl = me.inputEl;
    if (isEmpty) 
    {
      inputEl.dom.value = emptyText;
      inputEl.addCls(me.emptyCls);
      me.listWrapper.addCls(me.emptyCls);
    } else {
      if (inputEl.dom.value === emptyText) 
      {
        inputEl.dom.value = '';
      }
      me.listWrapper.removeCls(me.emptyCls);
      inputEl.removeCls(me.emptyCls);
    }
    me.autoSize();
  }
}, preFocus: function() {
  var me = this, inputEl = me.inputEl, emptyText = me.emptyText, isEmpty;
  if (emptyText && inputEl.dom.value === emptyText) 
  {
    inputEl.dom.value = '';
    isEmpty = true;
    inputEl.removeCls(me.emptyCls);
    me.listWrapper.removeCls(me.emptyCls);
  }
  if (me.selectOnFocus || isEmpty) 
  {
    inputEl.dom.select();
  }
}, onFocus: function() {
  var me = this, focusCls = me.focusCls, itemList = me.itemList;
  if (focusCls && itemList) 
  {
    itemList.addCls(focusCls);
  }
  me.callParent(arguments);
}, onBlur: function() {
  var me = this, focusCls = me.focusCls, itemList = me.itemList;
  if (focusCls && itemList) 
  {
    itemList.removeCls(focusCls);
  }
  me.callParent(arguments);
}, renderActiveError: function() {
  var me = this, invalidCls = me.invalidCls, itemList = me.itemList, listWrapper = me.listWrapper, hasError = me.hasActiveError();
  if (invalidCls && itemList) 
  {
    itemList[hasError ? 'addCls' : 'removeCls'](me.invalidCls + '-field');
    listWrapper[hasError ? 'addCls' : 'removeCls'](me.invalidCls + '-field');
  }
  me.callParent(arguments);
}, autoSize: function() {
  var me = this, height;
  if (me.grow && me.rendered) 
  {
    me.autoSizing = true;
    me.updateLayout();
  }
  return me;
}, afterComponentLayout: function() {
  var me = this, width;
  if (me.autoSizing) 
  {
    height = me.getHeight();
    if (height !== me.lastInputHeight) 
    {
      if (me.isExpanded) 
      {
        me.alignPicker();
      }
      me.fireEvent('autosize', me, height);
      me.lastInputHeight = height;
      delete me.autoSizing;
    }
  }
}}, 0, ["comboboxselect", "boxselect"], ["component", "pickerfield", "field", "comboboxselect", "triggerfield", "textfield", "boxselect", "combo", "box", "trigger", "combobox"], {"component": true, "pickerfield": true, "field": true, "comboboxselect": true, "triggerfield": true, "textfield": true, "boxselect": true, "combo": true, "box": true, "trigger": true, "combobox": true}, ["widget.boxselect", "widget.comboboxselect"], 0, [Ext.ux.form.field, 'BoxSelect'], 0));
;
(Ext.cmd.derive('Ext.ux.layout.component.field.BoxSelectField', Ext.layout.component.field.Trigger, {type: 'boxselectfield', waitForOuterWidthInDom: true, beginLayout: function(ownerContext) {
  var me = this, owner = me.owner;
  me.callParent(arguments);
  ownerContext.inputElCtContext = ownerContext.getEl('inputElCt');
  owner.inputElCt.setStyle('width', '');
  me.skipInputGrowth = !owner.grow || !owner.multiSelect;
}, beginLayoutFixed: function(ownerContext, width, suffix) {
  var me = this, owner = ownerContext.target;
  owner.triggerEl.setStyle('height', '24px');
  me.callParent(arguments);
  if (ownerContext.heightModel.fixed && ownerContext.lastBox) 
  {
    owner.listWrapper.setStyle('height', ownerContext.lastBox.height + 'px');
    owner.itemList.setStyle('height', '100%');
  }
}, publishInnerWidth: function(ownerContext) {
  var me = this, owner = me.owner, width = owner.itemList.getWidth(true) - 10, lastEntry = owner.inputElCt.prev(null, true);
  if (lastEntry && !owner.stacked) 
  {
    lastEntry = Ext.fly(lastEntry);
    width = width - lastEntry.getOffsetsTo(lastEntry.up(''))[0] - lastEntry.getWidth();
  }
  if (!me.skipInputGrowth && (width < 35)) 
  {
    width = width - 10;
  } else if (width < 1) 
  {
    width = 1;
  }
  ownerContext.inputElCtContext.setWidth(width);
}}, 0, 0, 0, 0, ["layout.boxselectfield"], 0, [Ext.ux.layout.component.field, 'BoxSelectField'], 0));
;

(Ext.cmd.derive('Sdc.model.Appointment', Sch.model.Event, {resourceIdField: 'EmployeeID', idProperty: 'CustomID', startDateField: 'ScheduledDateTimeBegin', endDateField: 'ScheduledDateTimeEnd', nameField: 'RefNbr', fields: [{name: 'SOID', type: 'int', useNull: true}, {name: 'EmployeeID', type: 'int'}, {name: 'CanDeleteAppointment', type: 'bool'}, {name: 'AppointmentID', type: 'int'}, {name: 'AutoDocDesc', type: 'string'}, {name: 'Confirmed', type: 'bool'}, {name: 'BranchLocationID', type: 'int'}, {name: 'BranchID', type: 'int', useNull: true}, {name: 'BranchLocationID', type: 'int', useNull: true}, {name: 'CustomerID', type: 'int', useNull: true}, {name: 'CustomerID', type: 'string'}, {name: 'DocDesc', type: 'string'}, {name: 'LongDescr', type: 'string'}, {name: 'ScheduledDateTimeBegin', type: 'date', dateFormat: 'm/d/Y g:i A', mapping: 'CustomDateTimeStart', convert: function(value, record) {
  return new Date(value);
}, serialize: function(value, record) {
  return Ext.Date.format(value, 'l, F d, Y g:i:s A');
}}, {name: 'ScheduledDateTimeEnd', type: 'date', dateFormat: 'm/d/Y g:i A', mapping: 'CustomDateTimeEnd', convert: function(value, record) {
  return new Date(value);
}, serialize: function(value, record) {
  return Ext.Date.format(value, 'l, F d, Y g:i:s A');
}}, {name: 'Status', type: 'string'}, {name: 'SORefNbr', type: 'string'}, {name: 'SrvOrdType', type: 'string'}, {name: 'SrvOrdTypeDescr', type: 'string'}, {name: 'CustomID', type: 'string'}, {name: 'CustomerLocation', type: 'string'}, {name: 'OldEmployeeID', type: 'int'}, {name: 'CustomerName', type: 'string'}, {name: 'ContactName', type: 'string'}, {name: 'ContactEmail', type: 'string'}, {name: 'ContactPhone', type: 'string'}, {name: 'LocationDesc', type: 'string'}, {name: 'FirstResourceName', type: 'string'}, {name: 'FirstServiceDesc', type: 'string'}, {name: 'ServiceCount', type: 'int'}, {name: 'RoomDesc', type: 'string'}, {name: 'RoomID', type: 'string'}, {name: 'EstimatedDurationTotal', type: 'float'}, {name: 'TravelTime', type: 'string'}, {name: 'ServiceDuration', type: 'float'}, {name: 'DriverName', type: 'string'}, {name: 'LocationCD', type: 'string'}, {name: 'PostalCode', type: 'string'}, {name: 'Address', type: 'string'}, {name: 'EmployeeCount', type: 'int'}, {name: 'ValidatedByDispatcher', type: 'bool'}, {name: 'WarningResourceAvailableFlag', type: 'bool', defaultValue: false}, {name: 'WarningAppointmentValidFlag', type: 'bool', defaultValue: false}, {name: 'AttendeeCount', type: 'int'}, {name: 'Draggable', type: 'bool', convert: function(newValue, model) {
  return true;
}}, {name: 'Resizable', type: 'bool', convert: function(newValue, model) {
  return true;
}}, {name: 'WFStageCD', type: 'string'}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'Appointment'], 0));
;

(Ext.cmd.derive('Sdc.model.Availability', Sch.model.Event, {resourceIdField: 'EmployeeID', startDateField: 'TimeStart', endDateField: 'TimeEnd', fields: [{name: 'TimeStart', type: 'date', dateFormat: 'm/d/Y g:i A', mapping: 'CustomDateTimeStart', convert: function(value, record) {
  return new Date(value);
}, serialize: function(value, record) {
  return Ext.Date.format(new Date(value), 'l, F d, Y g:i:s A');
}}, {name: 'TimeEnd', type: 'date', dateFormat: 'm/d/Y g:i A', mapping: 'CustomDateTimeEnd', convert: function(value, record) {
  return new Date(value);
}, serialize: function(value, record) {
  return Ext.Date.format(new Date(value), 'l, F d, Y g:i:s A');
}}, {name: 'CompanyID', type: 'int'}, {name: 'BranchID', type: 'int'}, {name: 'BranchLocationID', type: 'int', useNull: true}, {name: 'EmployeeID', type: 'int', useNull: true}, {name: 'RecordID', type: 'int', useNull: true}, {name: 'TimeSlotID', type: 'int', useNull: true}, {name: 'RecordCount', type: 'int'}, {name: 'ScheduleType', type: 'string'}, {name: 'ScheduleRefNbr', type: 'string'}, {name: 'TimeDiff', type: 'float'}, {name: 'BranchLocationDesc', type: 'string'}, {name: 'BranchLocationCD', type: 'string'}, {name: 'Cls', type: 'string', convert: function(newValue, model) {
  var value = newValue, scheduleType = model.get('ScheduleType');
  if (scheduleType == 'A') 
  {
    value = 'availability-scheduler';
  }
  if (scheduleType == 'U') 
  {
    value = 'unavailability-scheduler';
  }
  return value;
}}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'Availability'], 0));
;

(Ext.cmd.derive('Sdc.model.CustomAppointmentStatus', Ext.data.Model, {fields: [{name: 'CustomAppointmentStatusID', type: 'int'}, {name: 'FieldName', type: 'string'}, {name: 'FieldDescr', type: 'string'}, {name: 'BackgroundColor', type: 'string'}, {name: 'TextColor', type: 'string'}, {name: 'HideStatus', type: 'bool'}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'CustomAppointmentStatus'], 0));
;

(Ext.cmd.derive('Sdc.model.CustomFieldAppointment', Ext.data.Model, {fields: [{name: 'CompanyID', type: 'int'}, {name: 'CustomFieldAppointmentID', type: 'int'}, {name: 'Active', type: 'bool'}, {name: 'FieldDescr', type: 'string'}, {name: 'FieldImg', type: 'string'}, {name: 'FieldName', type: 'string'}, {name: 'Position', type: 'int'}]}, 0, 0, 0, 0, 0, 0, [Sdc.model, 'CustomFieldAppointment'], 0));
;

(Ext.cmd.derive('Sdc.ux.ColorPicker', Ext.container.Container, {width: 350, config: {hsv: {h: 0, s: 0, v: 0}}, constructor: function(config) {
  var me = this;
  me.initConfig(config);
  me.addEvents('select');
  me.callParent(arguments);
  return me;
}, initComponent: function() {
  var me = this;
  var svContainer = Ext.create('Ext.container.Container', {itemId: 'svContainer', cls: 'x-cp-svcontainer noselect'});
  var svColor = Ext.create('Ext.container.Container', {itemId: 'svColor', cls: 'x-cp-svcolor noselect'});
  var svSlider = Ext.create('Ext.container.Container', {itemId: 'svSlider', cls: 'x-cp-svslider noselect', width: 15, height: 15, listeners: {afterrender: function(container) {
  container.el.dd = Ext.create('Ext.dd.DD', container.el, 'svContainerGroup', {isTarget: false});
  var endDragOverwriteFunction = {endDrag: function(e) {
  var svColor = me.down('#svColor').getEl();
  var positionX = container.getEl().getLeft() - svColor.getLeft() + 7;
  var positionY = container.getEl().getTop() - svColor.getTop() + 7;
  if (me.moveSvSlider(positionX, positionY)) 
  {
    me.updateMode = 'click';
    me.updateColor();
  }
}, onDrag: function(e) {
  var svColor = me.down('#svColor').getEl();
  var positionX = container.getEl().getLeft() - svColor.getLeft() + 7;
  var positionY = container.getEl().getTop() - svColor.getTop() + 7;
  if (me.moveSvSlider(positionX, positionY, true)) 
  {
    me.updateMode = 'click';
    me.updateColor();
  }
}};
  Ext.apply(container.el.dd, endDragOverwriteFunction);
}}});
  var hueContainer = Ext.create('Ext.container.Container', {itemId: 'hueContainer', cls: 'x-cp-huecontainer noselect'});
  var hueColor = Ext.create('Ext.container.Container', {itemId: 'hueColor', cls: 'x-cp-huecolor noselect'});
  var hueSlider = Ext.create('Ext.container.Container', {itemId: 'hueSlider', cls: 'x-cp-hueslider noselect', width: 15, height: 15, listeners: {afterrender: function(container) {
  container.el.dd = Ext.create('Ext.dd.DD', container.el, 'hueContainerGroup', {isTarget: false});
  var endDragOverwriteFunction = {endDrag: function(e) {
  var hueColor = me.down('#hueColor').getEl();
  var positionY = container.getEl().getTop() - hueColor.getTop() + 7;
  if (me.moveHueSlider(positionY)) 
  {
    me.updateMode = 'click';
    me.updateSvColor();
    me.updateColor();
  }
}, onDrag: function(e) {
  var hueColor = me.down('#hueColor').getEl();
  var positionY = container.getEl().getTop() - hueColor.getTop() + 7;
  if (me.moveHueSlider(positionY, true)) 
  {
    me.updateMode = 'click';
    me.updateSvColor();
    me.updateColor();
  }
}};
  Ext.apply(container.el.dd, endDragOverwriteFunction);
}}});
  svContainer.add(svColor);
  svContainer.add(svSlider);
  hueContainer.add(hueColor);
  hueContainer.add(hueSlider);
  var config = {items: [svContainer, hueContainer, {xtype: 'form', itemId: 'cForm', border: false, cls: 'x-cp-formcontainer noselect', items: [{layout: 'anchor', border: false, defaultType: 'numberfield', defaults: {anchor: '99%', labelWidth: 10, value: 0, minValue: 0, maxValue: 255, labelSeparator: '', hideTrigger: true}, columnWidth: 0.5, items: [{fieldLabel: 'R', itemId: 'redComponent', invalidText: Messages.errorRGBNumber}, {fieldLabel: 'G', itemId: 'greenComponent', invalidText: Messages.errorRGBNumber}, {fieldLabel: 'B', itemId: 'blueComponent', invalidText: Messages.errorRGBNumber}]}, {layout: 'anchor', border: false, defaults: {anchor: '99%', labelWidth: 10, labelSeparator: ''}, items: [{xtype: 'textfield', fieldLabel: '#', itemId: 'hexaColor', regex: /^[0-9a-fA-F]{6}$/, regexText: Messages.errorHexaField}]}, {defaultType: 'container', border: false, items: [{width: 20, height: 20, itemId: 'colorResult'}, {xtype: 'button', text: 'Select Color', itemId: 'selectColorButton', flex: 1}]}]}]};
  Ext.apply(me, config);
  me.callParent(arguments);
}, afterRender: function(component) {
  var me = this;
  me.callParent(arguments);
  if (me.value) 
  me.setColor(me.value);
}, initEvents: function() {
  var me = this;
  me.callParent();
  me.down('#svColor').getEl().on('mousedown', me.svClick, me);
  me.down('#hueColor').getEl().on('mousedown', me.hueClick, me);
  me.down('#hexaColor').on('blur', me.hexaChange, me);
  me.down('#redComponent').on('blur', me.rgbChange, me);
  me.down('#greenComponent').on('blur', me.rgbChange, me);
  me.down('#blueComponent').on('blur', me.rgbChange, me);
  me.down('#selectColorButton').on('click', me.selectClick, me);
}, setConstrain: function() {
  var me = this;
  var svSlider = me.down('#svSlider');
  var hueSlider = me.down('#hueSlider');
  svSlider.el.dd.constrainTo(me.down('#svContainer').getEl());
  hueSlider.el.dd.constrainTo(me.down('#hueContainer').getEl());
}, getColor: function() {
  var me = this;
  var hsv = me.getHsv();
  return me.hsvToRgb(hsv.h, hsv.s, hsv.v);
}, setValue: function(v) {
  var me = this;
  me.value = v;
  me.setColor(v);
}, setColor: function(c) {
  var me = this;
  if (me.rendered) 
  {
    c = c.replace('#', '');
    if (!/^[0-9a-fA-F]{6}$/.test(c)) 
    return;
    me.down('#hexaColor').setValue(c);
    me.hexaChange();
  }
}, selectClick: function() {
  var me = this;
  var color;
  color = me.down('#colorResult').getEl().getColor('backgroundColor', '', '');
  this.fireEvent('select', this, color.toUpperCase());
}, rgbChange: function(input) {
  var me = this;
  if (!me.rgbValid()) 
  {
    return;
  }
  var temp = me.rgbToHsv(me.down('#redComponent').getValue(), me.down('#greenComponent').getValue(), me.down('#blueComponent').getValue());
  me.updateMode = 'rgb';
  me.setHsv({h: temp[0], s: temp[1], v: temp[2]});
  me.updateColor();
}, rgbValid: function() {
  var me = this;
  return (me.down('#redComponent').isValid() && me.down('#greenComponent').isValid() && me.down('#blueComponent').isValid());
}, hexaChange: function(input) {
  var me = this;
  if (input && !me.down('#hexaColor').isValid()) 
  {
    return;
  }
  var temp = me.rgbToHsv(me.hexToRgb(me.down('#hexaColor').getValue()));
  me.updateMode = 'hexa';
  me.setHsv({h: temp[0], s: temp[1], v: temp[2]});
  me.updateColor();
}, hueClick: function(event, el) {
  var me = this;
  me.updateMode = 'click';
  if (me.moveHueSlider(event.getXY()[1] - me.down('#hueColor').getEl().getTop())) 
  {
    me.updateSvColor();
    me.updateColor();
  }
}, moveHueSlider: function(positionY, onDrag) {
  var me = this;
  var hsv = me.getHsv();
  var hueSlider = me.down('#hueSlider').getEl();
  var h = Math.round(360 / 181 * (181 - positionY));
  if (!me.isValidPosition(null, positionY) || !me.isValidHsvComponent(h, hsv.s, hsv.v)) 
  {
    return false;
  }
  hsv.h = h;
  if (!onDrag) 
  hueSlider.moveTo(me.down('#hueColor').getEl().getLeft() - 3, me.down('#hueColor').getEl().getTop() + positionY - 7, true);
  return true;
}, setHueSlider: function(sync) {
  var me = this;
  var hsv = me.getHsv();
  var positionY = me.getHPos(hsv.h);
  me.moveHueSlider(positionY);
  me.updateSvColor();
  sync = typeof sync !== 'undefined' ? sync : true;
  if (sync) 
  {
    me.updateColor();
  }
}, svClick: function(event, el) {
  var me = this;
  var svColor = me.down('#svColor').getEl();
  me.updateMode = 'click';
  if (me.moveSvSlider(event.getXY()[0] - svColor.getLeft(), event.getXY()[1] - svColor.getTop())) 
  me.updateColor();
}, moveSvSlider: function(positionX, positionY, onDrag) {
  var me = this;
  var hsv = me.getHsv();
  var svColor = me.down('#svColor').getEl();
  var s = me.getSaturation(positionX);
  var v = me.getVal(positionY);
  if (!me.isValidPosition(positionX, positionY) || !me.isValidHsvComponent(hsv.h, s, v)) 
  {
    return false;
  }
  hsv.s = s;
  hsv.v = v;
  if (!onDrag) 
  me.down('#svSlider').getEl().moveTo(svColor.getLeft() + positionX - 7, svColor.getTop() + positionY - 7, true);
  return true;
}, setSvSlider: function(sync) {
  var me = this;
  var hsv = me.getHsv();
  positionX = me.getSPos(hsv.s);
  positionY = me.getVPos(hsv.v);
  me.moveSvSlider(positionX, positionY);
  sync = typeof sync !== 'undefined' ? sync : true;
  if (sync) 
  me.updateColor();
}, updateSvColor: function() {
  var me = this;
  var hsv = me.getHsv();
  me.down('#svColor').getEl().applyStyles({'backgroundColor': '#' + me.rgbToHex(me.hsvToRgb(hsv.h, 1, 1))});
}, updateColor: function() {
  var me = this;
  var hsv = me.getHsv();
  var rgb = me.hsvToRgb(hsv.h, hsv.s, hsv.v);
  if (me.updateMode != 'hexa') 
  {
    me.down('#hexaColor').setValue(me.rgbToHex(rgb));
  }
  if (me.updateMode != 'rgb') 
  {
    me.down('#redComponent').setValue(rgb[0]);
    me.down('#greenComponent').setValue(rgb[1]);
    me.down('#blueComponent').setValue(rgb[2]);
  }
  if (me.updateMode != 'click') 
  {
    me.setHueSlider(false);
    me.setSvSlider(false);
  }
  me.setButtonColor('#colorResult', rgb);
}, setButtonColor: function(id, rgb) {
  var me = this;
  me.down(id).getEl().applyStyles({'background': '#' + me.rgbToHex(rgb)});
}, getSaturation: function(x) {
  return x / 181;
}, getVal: function(y) {
  return (181 - y) / 181;
}, getSPos: function(saturation) {
  return saturation * 181;
}, getVPos: function(value) {
  return 181 - (value * 181);
}, getHPos: function(hue) {
  return 181 - hue * (181 / 360);
}, isValidPosition: function(positionX, positionY) {
  if (positionX && positionX < 0) 
  {
    return false;
  }
  if (positionY && positionY < 0) 
  {
    return false;
  }
  if (!positionY && !positionX && (positionX != 0 && positionY != 0)) 
  {
    return false;
  }
  return true;
}}, 1, ["ux.colorpicker"], ["container", "component", "box", "ux.colorpicker"], {"container": true, "component": true, "box": true, "ux.colorpicker": true}, ["widget.ux.colorpicker"], [[Sdc.util.AbstractColor.prototype.mixinId || Sdc.util.AbstractColor.$className, Sdc.util.AbstractColor]], [Sdc.ux, 'ColorPicker'], 0));
;

(Ext.cmd.derive('Sdc.ux.ColorPickerField', Ext.form.field.Picker, {matchFieldWidth: false, regex: /^(#)?[0-9a-fA-F]{6}$/, regexText: Messages.errorHexaField, createPicker: function() {
  var me = this;
  return Ext.create('Sdc.ux.ColorPicker', {floating: true, focusOnShow: true, baseCls: Ext.baseCSSPrefix + 'colorpicker', listeners: {scope: me, select: me.onSelect}});
}, onSelect: function(picker, value) {
  var me = this;
  var hex = '#' + value;
  me.setValue(hex);
  me.fireEvent('select', me, hex);
  me.collapse();
}, onExpand: function(picker) {
  var me = this, value = me.getValue();
  me.picker.setValue(me.getValue());
  me.picker.setConstrain();
}}, 0, ["ux.colorpickerfield"], ["component", "pickerfield", "field", "triggerfield", "textfield", "ux.colorpickerfield", "box", "trigger"], {"component": true, "pickerfield": true, "field": true, "triggerfield": true, "textfield": true, "ux.colorpickerfield": true, "box": true, "trigger": true}, ["widget.ux.colorpickerfield"], 0, [Sdc.ux, 'ColorPickerField'], 0));
;

(Ext.cmd.derive('Sdc.ux.DisableCheckColumn', Ext.ux.CheckColumn, {processEvent: function(type, view, cell, recordIndex, cellIndex, e) {
  var me = this;
  var element = Ext.get(cell);
  if (!element.hasCls(me.disabledCls)) 
  {
    me.callParent(arguments);
  }
}}, 0, ["disablecheckcolumn"], ["container", "component", "gridcolumn", "headercontainer", "box", "checkcolumn", "disablecheckcolumn"], {"container": true, "component": true, "gridcolumn": true, "headercontainer": true, "box": true, "checkcolumn": true, "disablecheckcolumn": true}, ["widget.disablecheckcolumn"], 0, [Sdc.ux, 'DisableCheckColumn'], 0));
;

Array.prototype.compare = function(array) {
  if (!array) 
  return false;
  if (this.length != array.length) 
  return false;
  for (var i = 0; i < this.length; i++) 
    {
      if (this[i] instanceof Array && array[i] instanceof Array) 
      {
        if (!this[i].compare(array[i])) 
        return false;
      } else if (this[i] != array[i]) 
      {
        return false;
      }
    }
  return true;
};
Array.prototype.clone = function() {
  var result = [];
  for (var key in this) 
    {
      result[key] = this[key];
    }
  return result;
};
Array.prototype.hasValue = function(value) {
  var i;
  for (i = 0; i < this.length; i++) 
    {
      if (this[i] === value) 
      return true;
    }
  return false;
};

var dateFormat = function() {
  var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g, timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, timezoneClip = /[^-+\dA-Z]/g, pad = function(val, len) {
  val = String(val);
  len = len || 2;
  while (val.length < len) 
    val = "0" + val;
  return val;
};
  return function(date, mask, utc) {
  var dF = dateFormat;
  if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) 
  {
    mask = date;
    date = undefined;
  }
  date = date ? new Date(date) : new Date();
  if (isNaN(date)) 
  throw SyntaxError("invalid date");
  mask = String(dF.masks[mask] || mask || dF.masks["default"]);
  if (mask.slice(0, 4) == "UTC:") 
  {
    mask = mask.slice(4);
    utc = true;
  }
  var _ = utc ? "getUTC" : "get", d = date[_ + "Date"](), D = date[_ + "Day"](), m = date[_ + "Month"](), y = date[_ + "FullYear"](), H = date[_ + "Hours"](), M = date[_ + "Minutes"](), s = date[_ + "Seconds"](), L = date[_ + "Milliseconds"](), o = utc ? 0 : date.getTimezoneOffset(), flags = {d: d, dd: pad(d), ddd: dF.i18n.dayNames[D], dddd: dF.i18n.dayNames[D + 7], m: m + 1, mm: pad(m + 1), mmm: dF.i18n.monthNames[m], mmmm: dF.i18n.monthNames[m + 12], yy: String(y).slice(2), yyyy: y, h: H % 12 || 12, hh: pad(H % 12 || 12), H: H, HH: pad(H), M: M, MM: pad(M), s: s, ss: pad(s), l: pad(L, 3), L: pad(L > 99 ? Math.round(L / 10) : L), t: H < 12 ? "a" : "p", tt: H < 12 ? "am" : "pm", T: H < 12 ? "A" : "P", TT: H < 12 ? "AM" : "PM", Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""), o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4), S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]};
  return mask.replace(token, function($0) {
  return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
});
};
}();
dateFormat.masks = {"default": "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:ss", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"};
dateFormat.i18n = {dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]};
Date.prototype.format = function(mask, utc) {
  return dateFormat(this, mask, utc);
};
Date.prototype.addDays = function(days) {
  this.setDate(this.getDate() + days);
  return this;
};
Date.prototype.endWeek = function() {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (6 - this.getDay()));
};
Date.prototype.startWeek = function() {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() - this.getDay());
};
Date.prototype.endMonth = function() {
  return new Date(this.getFullYear(), this.getMonth() + 1, 0).addDays(1);
};
Date.prototype.startMonth = function() {
  return new Date(this.getFullYear(), this.getMonth(), 0).addDays(1);
};
Date.prototype.monthDays = function() {
  return new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate();
};
Date.prototype.getWeek = function() {
  var onejan = new Date(this.getFullYear(), 0, 1);
  return Math.ceil((((this - onejan) / 86400000) + onejan.getDay() + 1) / 7);
};
Number.prototype.durationFormat = function() {
  var number = this;
  var hours = Math.floor(number / 60);
  var minutes = (number % 60);
  return hours + "h " + minutes + "m";
};

(Ext.cmd.derive('Ext.ux.form.DurationField', Ext.form.field.Number, {currencySymbol: 'h', useThousandSeparator: false, thousandSeparator: ',', alwaysDisplayDecimals: false, fieldStyle: 'text-align: right;', initComponent: function() {
  if (this.useThousandSeparator && this.decimalSeparator == ',' && this.thousandSeparator == ',') 
  this.thousandSeparator = '.'; else if (this.allowDecimals && this.thousandSeparator == '.' && this.decimalSeparator == '.') 
  this.decimalSeparator = ',';
  this.callParent(arguments);
}, setValue: function(value) {
  Ext.ux.form.DurationField.superclass.setValue.call(this, value != null ? value.toString().replace('.', this.decimalSeparator) : value);
  this.setRawValue(this.getFormattedValue(this.getValue()));
}, getFormattedValue: function(value) {
  if (Ext.isEmpty(value) || !this.hasFormat()) 
  return value; else {
    var neg = null;
    value = (neg = value < 0) ? value * -1 : value;
    value = this.allowDecimals && this.alwaysDisplayDecimals ? value.toFixed(this.decimalPrecision) : value;
    if (this.useThousandSeparator) 
    {
      if (this.useThousandSeparator && Ext.isEmpty(this.thousandSeparator)) 
      throw ('NumberFormatException: invalid thousandSeparator, property must has a valid character.');
      if (this.thousandSeparator == this.decimalSeparator) 
      throw ('NumberFormatException: invalid thousandSeparator, thousand separator must be different from decimalSeparator.');
      value = value.toString();
      var ps = value.split('.');
      ps[1] = ps[1] ? ps[1] : null;
      var whole = ps[0];
      var r = /(\d+)(\d{3})/;
      var ts = this.thousandSeparator;
      while (r.test(whole)) 
        whole = whole.replace(r, '$1' + ts + '$2');
      value = whole + (ps[1] ? this.decimalSeparator + ps[1] : '');
    }
    return Ext.String.format('{0}{1}{2}', (neg ? '-' : ''), value, (Ext.isEmpty(this.currencySymbol) ? '' : ' ' + this.currencySymbol));
  }
}, getSubmitValue: function() {
  var me = this, value = me.callParent();
  if (!me.submitLocaleSeparator) 
  {
    value = value.replace(me.decimalSeparator, '.');
  }
  return me.removeFormat(value);
}, parseValue: function(value) {
  return Ext.ux.form.DurationField.superclass.parseValue.call(this, this.removeFormat(value));
}, removeFormat: function(value) {
  if (Ext.isEmpty(value) || !this.hasFormat()) 
  return value; else {
    value = value.toString().replace(' ' + this.currencySymbol, '');
    value = this.useThousandSeparator ? value.replace(new RegExp('[' + this.thousandSeparator + ']', 'g'), '') : value;
    return value;
  }
}, getErrors: function(value) {
  return Ext.ux.form.DurationField.superclass.getErrors.call(this, this.removeFormat(value));
}, hasFormat: function() {
  return this.decimalSeparator != '.' || (this.useThousandSeparator == true && this.getRawValue() != null) || !Ext.isEmpty(this.currencySymbol) || this.alwaysDisplayDecimals;
}, onFocus: function() {
  this.setRawValue(this.removeFormat(this.getRawValue()));
  this.callParent(arguments);
}}, 0, ["durationfield"], ["spinnerfield", "component", "field", "triggerfield", "textfield", "numberfield", "durationfield", "box", "trigger"], {"spinnerfield": true, "component": true, "field": true, "triggerfield": true, "textfield": true, "numberfield": true, "durationfield": true, "box": true, "trigger": true}, ["widget.durationfield"], 0, [Ext.ux.form, 'DurationField'], 0));
;

(Ext.cmd.derive('CalendarPreferences.view.MainContainer', Ext.Panel, {id: ID.mainContainer, layout: 'border', width: 750, height: 550, initComponent: function() {
  var me = this;
  var config = {border: false, items: [{region: 'center', layout: 'border', title: Titles.appointmentPreferences, id: ID.preferenceContainerGrid, border: true, items: [{xtype: 'activegrid', mainContainer: me, region: 'center', margin: '0 10 10 10', width: 180, height: 350}, {xtype: 'inactivegrid', mainContainer: me, region: 'west', margin: '0 0 10 10', width: 240, height: 350}, {region: 'north', id: ID.previewContainer, width: 125, height: 240, border: false, layout: {type: 'border'}, items: [{region: 'center', xtype: 'statusgrid', mainContainer: me, margin: '10 10 10 10', width: 125, height: 240}]}]}, {region: 'east', id: ID.previewAppointmentGrid, border: false, width: 220, height: 10, items: [{xtype: 'previewpreferences', mainContainer: me, margin: '0 0 0 30', width: 187, height: 247}]}]};
  Ext.apply(me, config);
  me.callParent(arguments);
}, getPreviewColorPreference: function() {
  var me = this;
  return me.getComponent(ID.previewAppointmentGrid).getComponent(ID.previewPreferences);
}, getActiveGrid: function() {
  var me = this;
  return me.getComponent(ID.preferenceContainerGrid).getComponent(ID.activeGrid);
}, getInActiveGrid: function() {
  var me = this;
  return me.getComponent(ID.preferenceContainerGrid).getComponent(ID.inactiveGrid);
}}, 0, ["appcontainer"], ["container", "appcontainer", "component", "box", "panel"], {"container": true, "appcontainer": true, "component": true, "box": true, "panel": true}, ["widget.appcontainer"], 0, [CalendarPreferences.view, 'MainContainer'], 0));
;

(Ext.cmd.derive('CalendarPreferences.controller.Main', Sdc.controller.SchedulerController, {views: ['MainContainer'], title: 'Calendar Preferences', init: function() {
}}, 0, 0, 0, 0, 0, 0, [CalendarPreferences.controller, 'Main'], 0));
;

(Ext.cmd.derive('CalendarPreferences.store.CustomAppointmentStatusStore', Ext.data.Store, {model: 'Sdc.model.CustomAppointmentStatus', autoSync: true, proxy: {type: 'ajax', api: {create: pageUrl + '/CreateCustomAppointmentStatuses', read: pageUrl + '/GetCustomAppointmentStatuses', update: pageUrl + '/PutCustomAppointmentStatuses', destroy: pageUrl + '/DeleteCustomAppointmentStatuses'}, headers: {'Content-type': 'application/json; charset=utf-8'}, reader: {type: 'json', root: 'Result.Rows', metaProperty: 'MetaData', totalProperty: 'Result.TotalRows', successProperty: 'Success', messageProperty: 'Message'}, writer: {type: 'json', root: 'customAppointmentStatuses', allowSingle: false, encode: false}}}, 0, 0, 0, 0, 0, 0, [CalendarPreferences.store, 'CustomAppointmentStatusStore'], 0));
;

(Ext.cmd.derive('CalendarPreferences.store.CustomFieldAppointmentStore', Ext.data.Store, {model: 'Sdc.model.CustomFieldAppointment', proxy: {type: 'ajax', api: {create: pageUrl + '/CreateCustomFieldAppointments', read: pageUrl + '/GetCustomFieldAppointments', update: pageUrl + '/PutCustomFieldAppointments', destroy: pageUrl + '/DeleteCustomFieldAppointments'}, headers: {'Content-type': 'application/json; charset=utf-8'}, reader: {type: 'json', root: 'Result.Rows', metaProperty: 'MetaData', totalProperty: 'Result.TotalRows', successProperty: 'Success', messageProperty: 'Message'}, writer: {type: 'json', root: 'customFieldAppointments', allowSingle: false, encode: false}}}, 0, 0, 0, 0, 0, 0, [CalendarPreferences.store, 'CustomFieldAppointmentStore'], 0));
;

(Ext.cmd.derive('CalendarPreferences.view.ActiveGrid', Ext.grid.Panel, {initComponent: function() {
  var me = this;
  var config = {title: Titles.activePreferences, id: ID.activeGrid, store: Ext.create('CalendarPreferences.store.CustomFieldAppointmentStore'), columns: [{header: 'Name', dataIndex: 'FieldName', flex: 1}], multiSelect: true, allowCopy: true, viewConfig: {copy: true, plugins: {ptype: 'gridviewdragdrop', ddGroup: 'ddSkillGroup'}, listeners: {drop: function(node, data, dropRec, dropPosition) {
  var records = data.records;
  for (var i = 0; i < records.length; i++) 
    {
      records[i].set('Active', false);
    }
  me.store.each(function(record) {
  var position = me.store.findBy(function(recordt, id) {
  if (!recordt.get('Active') && (recordt.get('CustomFieldAppointmentID') == record.get('CustomFieldAppointmentID'))) 
  {
    return recordt;
  }
}, me, 0);
  record.set('Position', (position != -1) ? position : me.store.indexOf(record));
});
  for (var i = 0; i < records.length; i++) 
    {
      records[i].set('Active', true);
    }
  me.store.sync({callback: function() {
  me.store.load(function() {
  me.mainContainer.getInActiveGrid().store.load();
});
}});
}}}};
  Ext.apply(me, config);
  me.callParent(arguments);
}}, 0, ["activegrid"], ["container", "activegrid", "component", "grid", "gridpanel", "box", "panel", "tablepanel"], {"container": true, "activegrid": true, "component": true, "grid": true, "gridpanel": true, "box": true, "panel": true, "tablepanel": true}, ["widget.activegrid"], 0, [CalendarPreferences.view, 'ActiveGrid'], 0));
;

(Ext.cmd.derive('CalendarPreferences.view.InactiveGrid', Ext.grid.Panel, {initComponent: function() {
  var me = this;
  var config = {title: Titles.inactivePreferences, id: ID.inactiveGrid, store: Ext.create('CalendarPreferences.store.CustomFieldAppointmentStore'), columns: [{header: 'Name', dataIndex: 'FieldName', flex: 1}], multiSelect: true, allowCopy: true, viewConfig: {copy: true, plugins: {ptype: 'gridviewdragdrop', ddGroup: 'ddSkillGroup'}, listeners: {drop: function(node, data, dropRec, dropPosition) {
  var records = data.records;
  for (var i = 0; i < records.length; i++) 
    {
      records[i].set('Active', true);
    }
  me.store.each(function(record) {
  var position = me.store.findBy(function(recordt, id) {
  if (recordt.get('Active') && (recordt.get('CustomFieldAppointmentID') == record.get('CustomFieldAppointmentID'))) 
  {
    return recordt;
  }
}, me, 0);
  record.set('Position', (position != -1) ? position : me.store.indexOf(record));
});
  for (var i = 0; i < records.length; i++) 
    {
      records[i].set('Active', false);
    }
  me.store.sync({callback: function() {
  me.store.load(function() {
  me.mainContainer.getActiveGrid().store.load();
});
}});
}}}};
  Ext.apply(me, config);
  me.callParent(arguments);
  me.store.proxy.extraParams.isActive = false;
  me.store.load();
}}, 0, ["inactivegrid"], ["container", "component", "grid", "gridpanel", "box", "panel", "tablepanel", "inactivegrid"], {"container": true, "component": true, "grid": true, "gridpanel": true, "box": true, "panel": true, "tablepanel": true, "inactivegrid": true}, ["widget.inactivegrid"], 0, [CalendarPreferences.view, 'InactiveGrid'], 0));
;

(Ext.cmd.derive('CalendarPreferences.view.PreviewPreferences', Ext.panel.Panel, {globalFields: null, globalColor: {color: '#EBB6BF', textColor: '#B1505A'}, initComponent: function() {
  var me = this;
  var config = {title: Titles.previewPreferences, id: ID.previewPreferences, border: true, eventTpl: ['<tpl for=".">', '<div unselectable="on" id="{id}" style="right:{right}px;left:{left}px;top:{top}px;height:{height}px;width:{width}px;{style}" class="sch-event ' + Ext.baseCSSPrefix + 'unselectable {internalCls} {cls}">', '<div unselectable="on" class="sch-event-inner {iconCls}">', '{body}', '</div>', '</div>', '</tpl>'], dataTpl: Ext.XTemplate.from('bodyTemplate-event').compile()};
  Ext.apply(me, config);
  me.callParent(arguments);
}, beforeRender: function() {
  var me = this;
  me.callParent(arguments);
  var store = me.mainContainer.getActiveGrid().store;
  if (store) 
  {
    store.proxy.extraParams.isActive = true;
    store.on('load', function() {
  var activeObjects = [];
  me.mainContainer.getActiveGrid().store.each(function(record) {
  activeObjects.push(record);
}, this);
  me.reloadPreview(activeObjects, null, null);
});
    store.load();
  }
}, reloadPreview: function(fields, color, textColor) {
  var me = this;
  var tpl = new Ext.XTemplate(me.eventTpl).compile();
  if (fields) 
  {
    me.globalFields = fields;
  }
  if (color) 
  {
    me.globalColor.color = color;
    me.globalColor.textColor = textColor;
  }
  var params = {appointmentName: Titles.appointment, records: me.globalFields};
  renderData = {};
  renderData.id = ID.appointmentPreview;
  renderData.right = 0;
  renderData.left = 0;
  renderData.top = 0;
  renderData.height = 220;
  renderData.width = 185;
  renderData.style = me.getAppointmentStyle(me.globalColor.color, me.globalColor.textColor);
  renderData.internalCls = 'sch-event x-unselectable sch-event-resizable-true invalid sch-event-selected';
  renderData.cls = null;
  renderData.iconCls = null;
  renderData.body = me.dataTpl.apply(params);
  renderData.event = params;
  tpl.overwrite(me.body, renderData);
}, setAppointmentColor: function(color, textColor) {
  var me = this;
  me.reloadPreview(null, color, textColor);
}, getAppointmentStyle: function(color, textColor) {
  var me = this;
  var a = me.hexToRgb(color.substring(1, 7));
  var b = me.hexToRgb(textColor.substring(1, 7));
  var style = 'background: rgba({0}, {1}, {2}, 0.75) !important;' + 'background-color: rgba({0}, {1}, {2}, 0.75) !important;' + 'border-color : #ffffff !important;' + 'color: rgba({3}, {4}, {5}, 1) !important;';
  return Ext.String.format(style, a[0], a[1], a[2], b[0], b[1], b[2]);
}}, 0, ["previewpreferences"], ["container", "component", "box", "panel", "previewpreferences"], {"container": true, "component": true, "box": true, "panel": true, "previewpreferences": true}, ["widget.previewpreferences"], [[Sdc.util.AbstractColor.prototype.mixinId || Sdc.util.AbstractColor.$className, Sdc.util.AbstractColor]], [CalendarPreferences.view, 'PreviewPreferences'], 0));
;

(Ext.cmd.derive('CalendarPreferences.view.StatusGrid', Ext.grid.Panel, {initComponent: function() {
  var me = this;
  me.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {clicksToEdit: 1});
  var config = {title: Titles.statusPreferences, store: Ext.create('CalendarPreferences.store.CustomAppointmentStatusStore'), plugins: [me.cellEditing], columns: [{text: 'Status', dataIndex: 'FieldName', flex: 5}, {text: 'Background Color', dataIndex: 'BackgroundColor', flex: 4, align: 'center', editor: {xtype: 'ux.colorpickerfield', allowBlank: false, width: 100, selectOnFocus: false, editable: false, listeners: {select: function(picker, value) {
  var view = me.getView();
  var record = view.getRecord(view.getSelectedNodes()[0]);
  me.mainContainer.getPreviewColorPreference().setAppointmentColor(value, record.get('TextColor'));
}, blur: function(picker, The, eOpts) {
  if (picker.getValue() && picker.getValue().lenght == 6) 
  {
    picker.setValue('#' + picker.getValue());
  }
}}}, renderer: function(value) {
  return Ext.String.format('<div style="background-color:{0};width:50px;height:10px;' + 'display:inline-block;margin:0 5px 0 5px;border:solid;' + 'border-color:gray;border-width:1px;"></div>', value);
}}, {text: 'Text Color', dataIndex: 'TextColor', flex: 4, align: 'center', editor: {xtype: 'ux.colorpickerfield', allowBlank: false, width: 100, selectOnFocus: false, editable: false, listeners: {select: function(picker, value) {
  var view = me.getView();
  var record = view.getRecord(view.getSelectedNodes()[0]);
  me.mainContainer.getPreviewColorPreference().setAppointmentColor(record.get('BackgroundColor'), value);
}, change: function(picker, newValue, oldValue, eOpts) {
  if (newValue && newValue.length == 6 && newValue[0] != '#') 
  {
    picker.setValue('#' + newValue);
  }
}}}, renderer: function(value) {
  return Ext.String.format('<div style="background-color:{0};width:50px;height:10px;' + 'display:inline-block;margin:0 5px 0 5px;border:solid;' + 'border-color:gray;border-width:1px;"></div>', value);
}}, {text: 'Hide', dataIndex: 'HideStatus', xtype: 'disablecheckcolumn', flex: 3, renderer: function(value, meta, record) {
  var cssPrefix = Ext.baseCSSPrefix, cls = [cssPrefix + 'grid-checkcolumn'], disable = true;
  switch (record.get('FieldName').toLowerCase()) {
    case AppointmentStatusName.confirmed:
      disable = true;
      break;
    case AppointmentStatusName.validated:
      disable = true;
      break;
    default:
      disable = false;
      break;
  }
  if (disable) 
  {
    meta.tdCls += ' ' + this.disabledCls;
  }
  if (value) 
  {
    cls.push(cssPrefix + 'grid-checkcolumn-checked');
  }
  return '<img class="' + cls.join(' ') + '" src="' + Ext.BLANK_IMAGE_URL + '"/>';
}}], listeners: {select: function(gridView, record, index, eOpts) {
  var me = this;
  me.mainContainer.getPreviewColorPreference().setAppointmentColor(record.get('BackgroundColor'), record.get('TextColor'));
}}};
  Ext.apply(me, config);
  me.callParent(arguments);
  me.store.addListener('load', function() {
  me.getSelectionModel().select(me.store.first());
}, me);
  me.store.load();
}}, 0, ["statusgrid"], ["container", "component", "grid", "gridpanel", "statusgrid", "box", "panel", "tablepanel"], {"container": true, "component": true, "grid": true, "gridpanel": true, "statusgrid": true, "box": true, "panel": true, "tablepanel": true}, ["widget.statusgrid"], 0, [CalendarPreferences.view, 'StatusGrid'], 0));
;

Ext.Loader.setConfig({disableCaching: true, enabled: true});
Ext.application({name: 'CalendarPreferences', controllers: ['Main'], autoCreateViewport: false, launch: function() {
  var me = this;
  var container = new CalendarPreferences.view.MainContainer({renderTo: 'scheduler-container'});
}});

// @tag full-page
// @require C:\Projects\ACCode\WebSites\Pure\PX.Objects.FS\js\Shared\lib\plugins\array.js
// @require C:\Projects\ACCode\WebSites\Pure\PX.Objects.FS\js\Shared\lib\plugins\boxselect.js
// @require C:\Projects\ACCode\WebSites\Pure\PX.Objects.FS\js\Shared\lib\plugins\dateformat.js
// @require C:\Projects\ACCode\WebSites\Pure\PX.Objects.FS\js\Shared\lib\plugins\duration.js
// @require C:\Projects\ACCode\WebSites\Pure\PX.Objects.FS\js\Shared\lib\plugins\headerResizer.js
// @require C:\Projects\ACCode\WebSites\Pure\PX.Objects.FS\js\Calendars\CalendarPreferences\app.js

